<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网络知识</title>
    <url>/wang-luo-zhi-shi.html</url>
    <content><![CDATA[<h4 id="OSI-七层网络模型"><a href="#OSI-七层网络模型" class="headerlink" title="OSI 七层网络模型"></a>OSI 七层网络模型</h4><ol>
<li>应用层： 为用户进程提供网络服务</li>
<li>表示层：负责数据的转化，数据的压缩/解压，数据的加密/解密等</li>
<li>会话层：负责会话的建立，管理，销毁等服务</li>
<li>传输层：基于TCP/UDP进行 端口对端口的传输</li>
<li>IP层：数据打包成IP数据报，在路由器/交换机上传输</li>
<li>数据链路层: </li>
<li>物理层：</li>
</ol>
<h4 id="TCP-IP-网络模型"><a href="#TCP-IP-网络模型" class="headerlink" title="TCP/IP 网络模型"></a>TCP/IP 网络模型</h4><ol>
<li>应用层</li>
<li>传输层</li>
<li>IP层</li>
<li>数据链路层</li>
</ol>
<h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><h4 id="HTTPDNS优化"><a href="#HTTPDNS优化" class="headerlink" title="HTTPDNS优化"></a>HTTPDNS优化</h4><h3 id="HTTP-的版本区别"><a href="#HTTP-的版本区别" class="headerlink" title="HTTP 的版本区别"></a>HTTP 的版本区别</h3><h5 id="HTTP1-0与-HTTP1-1"><a href="#HTTP1-0与-HTTP1-1" class="headerlink" title="HTTP1.0与 HTTP1.1"></a>HTTP1.0与 HTTP1.1</h5><ol>
<li>缓存优化</li>
<li>网络带宽及网络连接都优化</li>
<li>host请求头添加</li>
<li>支持长连接（串行单线程处理请求，可以同时发起多个请求，但必须等待前一个请求处理完，才会处理新的请求，否则只能被阻塞）</li>
</ol>
<h5 id="HTTP1-1与HTTP2-0"><a href="#HTTP1-1与HTTP2-0" class="headerlink" title="HTTP1.1与HTTP2.0"></a>HTTP1.1与HTTP2.0</h5><ol>
<li>新的二进制文件</li>
<li>多路复用（多个请求可以在一个连接上并行执行，某个请求耗时严重，不会影响到其他连接的正常执行）<ol>
<li>做到了延迟的优化，TCP连接是慢启动，因此突发性和短时性的http连接不高效，通过复用连接可以更有效的使用TCP</li>
</ol>
</li>
<li>Header压缩 （一个页面有100个资源要加载，而每次请求都有1kb的消息头，则至少要消耗100kb获取请求头，http2.0，维护了一个字典，用以差量更新http头部）</li>
<li>服务端推送（服务端会主动把客户端所需要的资源一起发给客户端）</li>
</ol>
<h3 id="TCP-与UDP"><a href="#TCP-与UDP" class="headerlink" title="TCP 与UDP"></a>TCP 与UDP</h3><p>TCP 是面向连接的，可靠，慢，占用头部字节20多</p>
<p>UDP是无连接的，尽最大交付，快，占用头部字节少8</p>
<h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><h4 id="TCP与UDP比较"><a href="#TCP与UDP比较" class="headerlink" title="TCP与UDP比较"></a>TCP与UDP比较</h4>]]></content>
  </entry>
  <entry>
    <title>Algorithm 系列</title>
    <url>/algorithm-xi-lie.html</url>
    <content><![CDATA[<h3 id="算法的学习"><a href="#算法的学习" class="headerlink" title="算法的学习"></a>算法的学习</h3><h4 id><a href="#" class="headerlink" title></a><a href="/shi-me-shi-suan-fa.html" title="什么是算法">什么是算法</a></h4><h4 id="-1"><a href="#-1" class="headerlink" title></a><a href="/suan-fa-mian-shi-zhun-bei.html" title="算法面试准备">算法面试准备</a></h4><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><p><a href="https://github.com/ZhengYangxin/LeetCode" target="_blank" rel="noopener">自己的LeetCode代码库</a></p>
<p><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">比较好的算法总结</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode，算法数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系列</title>
    <url>/android-xi-lie.html</url>
    <content><![CDATA[<h3 id><a href="#" class="headerlink" title></a><a href="/protocol-buffer-shi-yong-he-yuan-li.html" title="protocol buffer 使用和原理">protocol buffer 使用和原理</a></h3>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>protocol buffer 使用和原理</title>
    <url>/protocol-buffer-shi-yong-he-yuan-li.html</url>
    <content><![CDATA[<h3 id="Protocol-Buffer-介绍"><a href="#Protocol-Buffer-介绍" class="headerlink" title="Protocol Buffer 介绍"></a>Protocol Buffer 介绍</h3><p>Protocol Buffer 是一种轻便高效的结构化数据格式，可以用于结构化数据的序列号，适合做数据存储和RPC数据交换格式，他是平台无关，语言无关，可扩展的序列号结构数据格式</p>
<h4 id="结构化数据格式"><a href="#结构化数据格式" class="headerlink" title="结构化数据格式"></a>结构化数据格式</h4><ol>
<li>XML, 通过标签定义的</li>
<li>JSON，通过键值对定义的</li>
<li>DB，数据库</li>
</ol>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ol>
<li>Serilizable</li>
<li>Parseable</li>
</ol>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol>
<li>RPC数据交换格式 即网络通讯</li>
<li>数据存储</li>
</ol>
<h4 id="跨平台，语言"><a href="#跨平台，语言" class="headerlink" title="跨平台，语言"></a>跨平台，语言</h4><p>如json，不限操作平台和编程语言同可以使用json</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>序列化后的体积相比json和xml很小，适合网络传输  40M的json数据  17M Protobuffer</li>
<li>支持跨平台，多语言</li>
<li>消息格式升级和兼容性不错</li>
<li>序列化反序列化快   40M的json数据  10s, Protobuffer 0.8s</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Android studio 环境配置</p>
<h4 id="配置应用build"><a href="#配置应用build" class="headerlink" title="配置应用build"></a>配置应用build</h4><pre><code>buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.1.0&#39;
        classpath &#39;com.google.protobuf:protobuf-gradle-plugin:0.8.10&#39;
    }
}</code></pre><h4 id="配置module-build-gradle"><a href="#配置module-build-gradle" class="headerlink" title="配置module build.gradle"></a>配置module build.gradle</h4><pre><code>apply plugin: &#39;com.android.application&#39;
apply plugin: &#39;com.google.protobuf&#39;
protobuf {
    protoc {
        artifact = &#39;com.google.protobuf:protoc:3.8.0&#39;
    }
    generateProtoTasks {
        all().each { task -&gt;
            task.builtins {
                java {
                    option &quot;lite&quot;
                }
            }
        }
    }
}

dependencies {
    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    implementation &#39;com.google.protobuf:protobuf-javalite:3.9.1&#39;
    ...
}
</code></pre><h4 id="构建消息"><a href="#构建消息" class="headerlink" title="构建消息"></a>构建消息</h4><p>消息由至少一个字段组合而成：字段 = 字段修饰符 + 字段类型 + 字段名 + 标识符<br>标识符TAG：每个字段的唯一标识数字，用于说明二进制文件的对应关系，不能修改，</p>
<pre><code>syntax = &quot;proto3&quot;;

//option java_package = &quot;www.dcf.com.vo&quot;;
package tutorial;

option java_package = &quot;com.zyx.proto&quot;;
option java_outer_classname = &quot;TestProto&quot;;

message test {
     int32     id = 1;  // ID
     string    str = 2;  // str
     int32     opt = 3;  //optional field
}
</code></pre><h4 id="Studio-自动生成代码"><a href="#Studio-自动生成代码" class="headerlink" title="Studio 自动生成代码"></a>Studio 自动生成代码</h4><p>通过Android Studio build，Protobuf插件会帮助我们自动生成TestProto类，类结构如下</p>
<p><img src="/Users/zhengyangxin/Documents/Blog/zhengyangxin.github.io/source/images/proto_generate_code.png" alt></p>
<p>Protobuf帮助我们自动生成了testOrBuilder接口，主要定义了个字段的get，set方法，并生成了test类，核心逻辑，通过writeTo（CodedOutputStream）接口序列化到CodedOutputStream，通过parseFrom(InputStream) 接口从InputStream中反序列化</p>
<p><img src="/Users/zhengyangxin/Documents/Blog/zhengyangxin.github.io/source/images/protobuffer_struct.png" alt></p>
<h3 id="ProtoBuffer-原理"><a href="#ProtoBuffer-原理" class="headerlink" title="ProtoBuffer 原理"></a>ProtoBuffer 原理</h3><p>ProtoBuffer不管在时间还是空间上更加高效，是怎么做到的？</p>
<p>消息经过ProtoBuffer序列化后会成为二进制数据流，通过key-Value组成方式写入到二进制数据流。</p>
<h4 id="编码机制"><a href="#编码机制" class="headerlink" title="编码机制"></a>编码机制</h4><h5 id="Base-128-Varints"><a href="#Base-128-Varints" class="headerlink" title="Base 128 Varints"></a>Base 128 Varints</h5><p>是一种可变字节序列化整形的方法</p>
<ol>
<li>每个byte的最高位是标志位(msb), 如果是1，则表示后面还有byte，否则为结束byte</li>
<li>每个byte的低7位用来存储数值的位</li>
<li>Varints方法用Litte-Endian(小端)字节序列</li>
</ol>
<h4 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h4><h5 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h5><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Meaning</th>
<th align="center">Used For</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">Varint</td>
<td align="center">int32,int64,uinit32,uint64,sint32,sint64,bool,enum</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">64-bit</td>
<td align="center">fixed64,sfixed64,double</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Length-delimited</td>
<td align="center">string,bytes,embedded messages</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">32-bit</td>
<td align="center">fixed32,sfixed32,float</td>
</tr>
</tbody></table>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>key的具体值为   (field_number &lt;&lt; 3) | wire_type，</p>
<p>以上面的例子来说，如字段id定义：</p>
<pre><code> int32 id = 2; // 150</code></pre><p>在序列化时，并不会把字段id写进二进制流中，而是把<code>field_number=2</code>通过上述<code>Key</code>的定义计算后写进二进制流中，这就是Protobuf可读性差的原因，也是其高效的主要原因。</p>
<pre><code>key = (field_number &lt;&lt; 3) | wire_type = 2 &lt;&lt; 3 | 0 = 10000 |0 = 16  = 0x10
value 150 二进制位1001 0110  
最高位 为msb，将它分为一个一组
1 0010110 进行补齐 0000001 0010110
小端序存储则为0010110  0000001
补齐 表示为msb   10010110 00000001 = 0x96  0x01
则最后的存储为 10 96 01

如果value 300 二进制为 100101100
最高位为msb， 进行7位一组分组
10  0101100  进行补齐0000010 0101100
小端序存储 10101100 00000010  = 0xac 0x2
则最后存储为 10 ac 02</code></pre><p>key的范围：wire_type只有六种类型，用3bit表示，在一个byte里，去掉mbs，以及3bit的wire_type,只剩下4bit来表示field_number,因此一个Byte里，field_number只能表达0-15，超过15个需要多个byte表示</p>
<h5 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h5><p>所谓ZigZag编码即将负数转换成正数，而所有正数都乘2，如0编码成0，-1编码成1，1编码成2，-2编码成3，以此类推，因而它对负数的编码依然保持比较高的效率。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>Varint适用于表达比较小的整形，当数字很大时，采用定长编码类型(64bit,32bit)</li>
<li>不利于表达负数，负数采用补码表示，会占用更多字节，确定出现负数用sint32,sint64,他会采用ZigZig编码将负数映射成整数，之后再使用Varint编码</li>
</ul>
<p>Length-delimited</p>
<ul>
<li><p>Length-delimited编码格式会将数据的length也编码进最终的数据，编码格式有string，bytes，自定义消息</p>
</li>
<li><p>在消息中将str = “testing”, </p>
<p>序列化的打印结果 为</p>
<pre><code> private void test() {
        TestProto.test.Builder test = TestProto.test.newBuilder();
        TestProto.test test1 = test.setStr(&quot;testing&quot;).build();
        // 序列化
        byte[] bytes = test1.toByteArray();

        for (byte aByte : bytes) {
            System.out.print(aByte +&quot; &quot;);
        }
}
// 18 7 116 101 115 116 105 110 103
str 的field_number = 2; str = &quot;testing&quot;
key = (field &lt;&lt; 3) | wire_type = 2 &lt;&lt; 3 | 2 = 10000 | 10 = (十进制) 18 = (16进制)0x12
7 为 value的长度testing长度为7
然后计算value的每个字母 t 在ASCII中的 十进制数是 116， e 为101， s为115 以此类推
发现每个byte存储的是计算后的10进制数字，和网上说16进制 byte存储方式不一致 12 07 74 65 73 74 69 6e 67
现在按照16进制存储计算
key = 12 已经确定
t 的二进制为 0111 0100 16 进制为74
e 则为65 ..
所以string的转换方式是 key的16进制 + 字符串长度16进制 + 字符串的每个字母的16进制</code></pre><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>通过原理破解，在通过观察源码Protobuffer的序列化和反序列化同时通过几个位运算实现的，所以他的效率高，体积小</p>
</li>
</ul>
<h4 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h4><ul>
<li>尽量不要修改tag</li>
<li>字段数量不要超过16个，否则会采用2个字节编码, (1个字节最大值为128， key的计算会通过field_number &lt;&lt; 3 | wire_type, 当field_number 为16时刚好使用了1个字节计算，否则就需要两个字节计算)</li>
<li>如果确定使用负数，采用sint32/sint64</li>
</ul>
<h3 id="FastJson对比"><a href="#FastJson对比" class="headerlink" title="FastJson对比"></a>FastJson对比</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>数据存储</tag>
        <tag>Protocol Buff</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter之性能测试和理论</title>
    <url>/flutter-zhi-xing-neng-ce-shi-he-li-lun.html</url>
    <content><![CDATA[<h4 id="Flutter的渲染阶段"><a href="#Flutter的渲染阶段" class="headerlink" title="Flutter的渲染阶段"></a>Flutter的渲染阶段</h4><p><strong>VSync-&gt;Animation-&gt;Build-&gt;Layout-&gt;Paint-&gt;Display List(GPU)</strong></p>
<ul>
<li>Build ： Widget，Element树</li>
<li>Layout，Paint： RenderObject树的创建</li>
<li>Display List(GPU)，是对Layer图层的创建</li>
</ul>
<h4 id="检查Flutter的渲染"><a href="#检查Flutter的渲染" class="headerlink" title="检查Flutter的渲染"></a>检查Flutter的渲染</h4><p>Debug模式和最终的生产模式，有很大的性能特点，所以在做真实的测量之前都用Profile模式</p>
<ul>
<li>Debug模式</li>
<li>Profile模式</li>
</ul>
<h4 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h4><p>它不是一个顶层Api，并且充分利用了组合的性质，所以他的公共方法比Android的View少</p>
<ul>
<li>是Flutter的UI单位，有很长的生命周期和状态</li>
<li>主要方法<ul>
<li>createRenderObject、updateRenderObject</li>
<li>performLayout</li>
<li>paint</li>
</ul>
</li>
</ul>
<h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><ul>
<li>ComponentElement，主要是做组合的，不直接参与布局绘制<ul>
<li>StatelessElement</li>
<li>StatefulElement</li>
</ul>
</li>
<li>RenderObjectElement，会对RenderObject树上的RenderObject做连接</li>
</ul>
<h4 id="同类型更新"><a href="#同类型更新" class="headerlink" title="同类型更新"></a>同类型更新</h4><p>修改某个Text的值</p>
<ul>
<li>Build<ul>
<li>在Flutter中Widget树是不可改变的，这也包括树节点之间的父子关系</li>
<li>在开始build时，会创造一个新的树</li>
<li>遍历Element，通过Element.updateChild(),观察子节点，若子节点类型发生改变，则会扔掉老节点，创造一个新的节点</li>
<li>更新过程中，若Element是Component则build即可，若是RenderObjectElement则会updateRenderObject</li>
<li>若内容发生改变会进行标脏处理</li>
</ul>
</li>
</ul>
<h4 id="Buid性能测试工具"><a href="#Buid性能测试工具" class="headerlink" title="Buid性能测试工具"></a>Buid性能测试工具</h4><ul>
<li>观望台，TimeLine，类似安卓的systrace,设置debugProfileBuildsEnable = true,检查build过程的性能损耗</li>
<li>遍历的触发 <ul>
<li>setState方法</li>
<li>依赖了InHeritedWidget,当InHeritedWidget发生改变会影响其他</li>
<li>热重载，所有节点都会被更新</li>
</ul>
</li>
<li>提高build效率<ul>
<li>通过Extra单独的Widget，减少遍历的节点</li>
<li>停止遍历</li>
</ul>
</li>
</ul>
<h4 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h4><p>在工程完成后会对RenderObject的某些节点进行标脏，让他重新绘制。<br>debugProfileBuildsEnabled = true;<br>debugProfilePaintsEnabled = true;<br>debugPaintLayerBordersEnabled = true;</p>
<ul>
<li>如何知道多少其他节点需要跟被标脏的树一起被更新呢？<ul>
<li>基于图层树Layer</li>
<li>更新指定图层</li>
</ul>
</li>
<li>Layer种类<ul>
<li>PictureLayer</li>
<li>ContainerLayer:主要用于做PictureLayer的连接</li>
</ul>
</li>
</ul>
<p>yum -y install wget<br>wget -N –no-check-certificate <a href="https://softs.fun/Bash/ssr.sh" target="_blank" rel="noopener">https://softs.fun/Bash/ssr.sh</a> &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter之平台集成</title>
    <url>/flutter-zhi-ping-tai-ji-cheng.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter之手势</title>
    <url>/flutter-zhi-shou-shi.html</url>
    <content><![CDATA[<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>描述屏幕上由触摸板，鼠标，指示笔等触发的指针的位置和移动</p>
<h4 id="指针事件"><a href="#指针事件" class="headerlink" title="指针事件"></a>指针事件</h4><ul>
<li>PointerDownEvent：指针在特定位置与屏幕接触</li>
<li>PointerMoveEvent：指针从屏幕的一个尾椎移动到另一个位置</li>
<li>PointerUpEvent：指针与屏幕停止接触</li>
<li>PointerCancelEvent：指针的输入已经不在指向此应用</li>
</ul>
<h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><pre><code>const Listener({
    Key key,
    this.onPointerDown,
    this.onPointerMove,
    // We have to ignore the lint rule here in order to use deprecated
    // parameters and keep backward compatibility.
    // TODO(tongmu): After it goes stable, remove these 3 parameters from Listener
    // and Listener should no longer need an intermediate class _PointerListener.
    // https://github.com/flutter/flutter/issues/36085
    @Deprecated(
      &#39;Use MouseRegion.onEnter instead. See MouseRegion.opaque for behavioral difference. &#39;
      &#39;This feature was deprecated after v1.10.14.&#39;
    )
    this.onPointerEnter, // ignore: deprecated_member_use_from_same_package
    @Deprecated(
      &#39;Use MouseRegion.onExit instead. See MouseRegion.opaque for behavioral difference. &#39;
      &#39;This feature was deprecated after v1.10.14.&#39;
    )
    this.onPointerExit, // ignore: deprecated_member_use_from_same_package
    @Deprecated(
      &#39;Use MouseRegion.onHover instead. See MouseRegion.opaque for behavioral difference. &#39;
      &#39;This feature was deprecated after v1.10.14.&#39;
    )
    this.onPointerHover, // ignore: deprecated_member_use_from_same_package
    this.onPointerUp,
    this.onPointerCancel,
    this.onPointerSignal,
    this.behavior = HitTestBehavior.deferToChild,
    Widget child,
  })</code></pre><h4 id="HitTestBehavior"><a href="#HitTestBehavior" class="headerlink" title="HitTestBehavior"></a>HitTestBehavior</h4><ul>
<li><p>translucent：层叠布局时，可以使布局都收到事件</p>
</li>
<li><p>opaque: 布局透明也可以收到事件</p>
</li>
<li><p>deferToChild：当布局透明时收不到事件</p>
<pre><code>enum HitTestBehavior {
/// Targets that defer to their children receive events within their bounds
/// only if one of their children is hit by the hit test.
deferToChild, // 子组件会一个接一个的进行命中测试，如果子组件收到，那父组件也能收到该事件

/// Opaque targets can be hit by hit tests, causing them to both receive
/// events within their bounds and prevent targets visually behind them from
/// also receiving events.
opaque, // 在命中测试中，将当前组件当成不透明处理

/// Translucent targets both receive events within their bounds and permit
/// targets visually behind them to also receive events.
translucent, // 当点击组件透明区域时，可以对自身边界内及底部可视区域，都进行命中测试
}</code></pre></li>
</ul>
<h4 id="忽略指针事件"><a href="#忽略指针事件" class="headerlink" title="忽略指针事件"></a>忽略指针事件</h4><ul>
<li>IgnorePointer：阻止子树接受指针事件，本身不会参与命中测试</li>
<li>AbsorbPointer：阻止子树接受指针事件，本身参与命中测试</li>
</ul>
<h3 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h3><p>Gesture代表的是语义操作（比如点击，拖动，缩放），通过一系列单独的指针事件组成，甚至是一系列指针组成。Gesture可以分发多种事件，对应着指针的生命周期（比如开始拖动，拖动更新，结束拖动）</p>
<h4 id="手势类别"><a href="#手势类别" class="headerlink" title="手势类别"></a>手势类别</h4><ul>
<li>GestureDetector：用于手势识别的功能性组件，可以识别各种手势，是指针事件的语义分装，内部使用了一个或者多个GestureRecognizer</li>
<li>GestureRecognizer：通过Listener将原始指针事件转化为语义手势</li>
</ul>
<h4 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h4><ul>
<li>点击：onTapDown，onTapUp，onTap，onTapCancel</li>
<li>双击：onDoubleTap</li>
<li>长按：onLongPress</li>
<li>纵向拖动：onVerticalDragStart，onVerticalDragUpdate，onVerticalDragEnd</li>
<li>横向拖动：onHorizontalDragStart，onHorizontalDragUpdate，onHorizontalDragEnd</li>
<li>移动：onPanStart,onPanUpdate,onPanEnd</li>
<li>移动和横向，纵向拖动互斥</li>
</ul>
<h4 id="手势消歧处理"><a href="#手势消歧处理" class="headerlink" title="手势消歧处理"></a>手势消歧处理</h4><ul>
<li>在屏幕的指定位置上，可能有多个手势捕捉器。所有的手势捕捉器监听了指针输入流事件并判断出特定的手势</li>
<li>在任何时候，识别器都可以宣告失败并离开竞技场。如果竞技场中只有一个识别器，那么这个识别器就是胜者。</li>
<li>在任何时候，任何识别器都可以宣告胜利，这将导致这个识别器胜出，其他识别器失败</li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter之动画</title>
    <url>/flutter-zhi-dong-hua.html</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>Animation：Flutter动画库中的核心类，插入用于指导动画的值</li>
<li>AnimationController:管理Animation</li>
<li>CurvedAnimation:定义动画的曲线</li>
<li>Tween:为动画对象插入一个范围值</li>
</ul>
<h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><ul>
<li>提供了每一帧动画变化的监听事件和移除事件，VoidCallback<ul>
<li>addListener</li>
<li>removeListener</li>
</ul>
</li>
<li>提供了动画状态的监听和移除事件，AnimationStatusListener<ul>
<li>addStatusListener</li>
<li>removeStatusListener</li>
</ul>
</li>
<li>动画的四种状态<ul>
<li>dismiss，在动画开始时停止</li>
<li>forward，动画从开始向结束运行</li>
<li>reverse，动画从结束向开始运行</li>
<li>completed，动画在结束时运行完成</li>
</ul>
</li>
<li>获取动画的状态</li>
<li>泛型参数为范围值，一般是double类型</li>
</ul>
<h4 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h4><ul>
<li>继承自Animation，是一个特殊的Animation，当硬件准备新帧时，它都会生成一个新值</li>
<li>需要一个vsync参数，vsync的存在防止后台动画消耗不必要的资源<pre><code>AnimationController({
  double value,
  this.duration, // 动画时长
  this.reverseDuration,
  this.debugLabel, 
  this.lowerBound = 0.0,  // 最小值
  this.upperBound = 1.0, // 最大值
  this.animationBehavior = AnimationBehavior.normal,
  @required TickerProvider vsync,  // 每一帧同步时的回调
})</code></pre></li>
</ul>
<h4 id="CurvedAnimation"><a href="#CurvedAnimation" class="headerlink" title="CurvedAnimation"></a>CurvedAnimation</h4><p>怎么运动，运动的过程，动画运行的曲线，可以继承Curve,重写transformInternal</p>
<ul>
<li>Curve曲线分类<ul>
<li>linear:匀速的</li>
<li>decelerate：匀减速</li>
<li>ease：开始加速后面减速</li>
<li>easeIn：开始慢后面快</li>
<li>easeOut：开始快，后面慢</li>
<li>easeInOut：开始慢，先加速，后减速</li>
</ul>
</li>
</ul>
<h4 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h4><p>可以自定义移动的类型，如移动像素等</p>
<ul>
<li>配置动画插入不同的范围和数据类型</li>
</ul>
<h4 id="AnimatedBuilder"><a href="#AnimatedBuilder" class="headerlink" title="AnimatedBuilder"></a>AnimatedBuilder</h4><p>动画的构建器</p>
<pre><code>const AnimatedBuilder({
    Key key,
    @required Listenable animation, // 具体动画
    @required this.builder, // 实现动画的对象
    this.child,
  })</code></pre><h4 id="路由切换动画"><a href="#路由切换动画" class="headerlink" title="路由切换动画"></a>路由切换动画</h4><ul>
<li>Android提供默认的MaterialPageRoute</li>
<li>IOS提供默认的CupertionPageRoute</li>
<li>自定义实现采用PageRouteBuilder<pre><code>Navigator.push(context, PageRouteBuilder(pageBuilder: (context, animation, econdaryAnimation){
return FadeTransition(opacity: animation, child: SyncAnim(),);
}));</code></pre></li>
</ul>
<h4 id="Hero动画"><a href="#Hero动画" class="headerlink" title="Hero动画"></a>Hero动画</h4><p>指在页面之间飞行的Widget，相当于转场动画，Hero在动画切换的时候，有一个共享的Widget可以在新旧路由之间切换</p>
<ul>
<li>InkWell:水波纹效果的widget</li>
<li>将需要共享的元素放入Hero Widget中</li>
<li>需要指定相同的tag<pre><code>InkWell(
          child: Hero(tag: &quot;avator&quot;, child: ClipOval(
            child: Image.network(&quot;http://yangxin.online/images/head.jpeg&quot;, width: 50, height: 50 , ),
          )),
          onTap: (){
            Navigator.of(context).push(MaterialPageRoute(builder: (context){
              return Scaffold(
                body: Center(
                  child: Hero(tag: &quot;avator&quot;, child: Image.network(&quot;http://yangxin.online/images/head.jpeg&quot;, width: 300, height: 300 , ),
                ),
              ));
            }));
          },
        )</code></pre></li>
</ul>
<h4 id="交织动画"><a href="#交织动画" class="headerlink" title="交织动画"></a>交织动画</h4><p>设计复杂动画，动画序列，重叠动画</p>
<ul>
<li><p>使用多个动画对象</p>
</li>
<li><p>一个AnimationControl控制所有的动画</p>
</li>
<li><p>每个动画对象指定间隔时间</p>
<pre><code>class Stagger extends StatelessWidget {
final AnimationController controller;

final Animation&lt;double&gt; opacity, width, height;

final Animation&lt;EdgeInsets&gt; padding;

final Animation&lt;BorderRadius&gt; borderRadius;

final Animation&lt;Color&gt; color;

Stagger({Key key, this.controller})
    : opacity = Tween(begin: 0.0, end: 1.0).animate(CurvedAnimation(
          parent: controller,
          curve: Interval(0.0, 0.1000, curve: Curves.linear))),
      width = Tween(begin: 50.0, end: 150.0).animate(CurvedAnimation(
          parent: controller,
          curve: Interval(0.125, 0.250, curve: Curves.linear))),
      height = Tween(begin: 50.0, end: 150.0).animate(CurvedAnimation(
          parent: controller,
          curve: Interval(0.250, 0.375, curve: Curves.linear))),
      padding = EdgeInsetsTween(
              begin: EdgeInsets.only(bottom: 10),
              end: EdgeInsets.only(bottom: 50))
          .animate(CurvedAnimation(
              parent: controller,
              curve: Interval(0.250, 0.375, curve: Curves.linear))),
      borderRadius = BorderRadiusTween(
              begin: BorderRadius.circular(5), end: BorderRadius.circular(15))
          .animate(CurvedAnimation(
              parent: controller,
              curve: Interval(0.375, 0.500, curve: Curves.linear))),
      color = ColorTween(begin: Colors.blue, end: Colors.red).animate(
          CurvedAnimation(
              parent: controller,
              curve: Interval(0.500, 0.750, curve: Curves.linear))),
      super(key: key);

@override
Widget build(BuildContext context) {
  return AnimatedBuilder(
    animation: controller,
    builder: (context, child) {
      return Container(
        padding: padding.value,
        alignment: Alignment.bottomCenter,
        child: Opacity(
          opacity: opacity.value,
          child: Container(
            width: width.value,
            height: height.value,
            decoration: BoxDecoration(
                color: color.value,
                border: Border.all(color: Colors.blue, width: 3),
                borderRadius: borderRadius.value),
          ),
        ),
      );
    },
  );
}
}
</code></pre></li>
</ul>
<p>class StaggerF extends StatefulWidget {<br>  @override<br>  State<statefulwidget> createState() {<br>    // TODO: implement createState<br>    return StaggerS();<br>  }<br>}</statefulwidget></p>
<p>class StaggerS extends State<staggerf> with TickerProviderStateMixin {<br>  AnimationController _controller;</staggerf></p>
<p>  _play() async {<br>    await _controller.forward().orCancel;<br>    await _controller.reverse().orCancel;<br>  }</p>
<p>  @override<br>  void initState() {<br>    super.initState();<br>    _controller =<br>        AnimationController(duration: Duration(seconds: 10), vsync: this);<br>    _controller.addStatusListener((status) {<br>      switch (status) {<br>        case AnimationStatus.dismissed:<br>          _controller.forward();<br>          break;<br>        case AnimationStatus.completed:<br>          _controller.reverse();<br>          break;<br>        case AnimationStatus.forward:<br>        case AnimationStatus.reverse:<br>          break;<br>      }<br>    });<br>  }</p>
<p>  @override<br>  Widget build(BuildContext context) {<br>    // TODO: implement build<br>    return Scaffold(<br>      body: GestureDetector(<br>        onTap: () {<br>          _play();<br>        },<br>        child: Center(<br>          child: Container(<br>            width: 300,<br>            height: 300,<br>            color: Colors.yellow,<br>            child: Stagger(<br>              controller: _controller,<br>            ),<br>          ),<br>        ),<br>      ),<br>    );<br>  }<br>}</p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter之路由</title>
    <url>/flutter-zhi-lu-you.html</url>
    <content><![CDATA[<h3 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h3><p>在Flutter中，屏于页面都叫做路由。路由管理，就是管理页面之间如何跳转，在Flutter中维护一个路由栈，路由入栈操作对应着就是打开一个新页面，路由出栈操作就是对应页面的关闭操作</p>
<ul>
<li>Navigator.push()跳转到第二个页面</li>
<li>Navigator.pop()退回到第一个页面<pre><code>Navigator.push(context, MaterialPageRoute(builder: (context) {
  return SecondRoute2(&quot;hello word&quot;);
}));
</code></pre></li>
</ul>
<p>Navigator.pop(context);</p>
<pre><code>
#### 路由传值
* Navigator.push()返回Flutter对象，用以接收新路由出栈时的返回数据
* Navigator.pop()将栈顶路由出栈，参数Result为页面关闭时返回给上一个页面的数据</code></pre><p> Scaffold(<br>      appBar: AppBar(<br>        title: Text(“SendRoute route”),<br>      ),<br>      body: Center(<br>        child: Column(<br>          children: <widget>[<br>            Text(arg),<br>            RaisedButton(<br>              child: Text(<br>                “go back”,<br>              ),<br>              onPressed: () {<br>                Navigator.pop(context, “hello world”);<br>              },<br>            ),<br>          ],<br>        ),<br>      ),<br>    );</widget></p>
<pre><code>
#### 命名路由
* 注册路由表
* Navigator.pushNamed()跳转到第二个界面。
* Navigator.pop()回退到第一个路由</code></pre><p>class MyApp2 extends StatelessWidget{<br>  @override<br>  Widget build(BuildContext context) {<br>    // TODO: implement build<br>    return MaterialApp(<br>      title: ‘Flutter Demo’,<br>      theme: ThemeData(<br>        primarySwatch: Colors.blue,<br>      ),<br>      routes: {<br>        ‘/‘: (context) =&gt; FirstRoute(),<br>        ‘/second_route’: (context) =&gt; SecondRoute()<br>      },<br>      initialRoute: ‘/‘,<br>    );<br>  }<br>}</p>
<p>// 跳转<br>Navigator.pushNamed(context, ‘/second_route’, arguments: ‘卡啦啦啦’);</p>
<p>// 获取命名跳转的传值<br>final String arg = ModalRoute.of(context).settings.arguments;</p>
<p>// 优先级最低路由列表<br>onGenerateRoute: (settings) {<br>        if(settings.name == ‘/second_route4’){<br>          var arg = settings.arguments;<br>          return MaterialPageRoute(builder: (context) =&gt; SecondRoute4(arg), settings: settings);<br>        }<br>      },</p>
<pre><code>
#### 路由动画
* MaterialPageRoute：继承自PageRoute，是MaterIAL组件库提供的组件，它可以针对不同的平台，实现与平台页面切换动画一致的路由切换动画
* PageRouteBuilder</code></pre><p>  Navigator.push(context, PageRouteBuilder(<br>    transitionDuration: Duration(milliseconds: 800),<br>    pageBuilder: (BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation){<br>      return FadeTransition(opacity: animation, child: SecondRoute5(),);<br>    }<br>  ));</double></double></p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter之列表控件</title>
    <url>/flutter-zhi-lie-biao-kong-jian.html</url>
    <content><![CDATA[<h4 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h4><ul>
<li><p>少量数据</p>
<pre><code>ListView({
  Key key,
  Axis scrollDirection = Axis.vertical, // 滚动方向
  bool reverse = false, // 是否反向展示数据
  ScrollController controller,
  bool primary,
  ScrollPhysics physics, // 物理滚动，默认根据不同平台采用不同对象
  bool shrinkWrap = false,
  EdgeInsetsGeometry padding,
  this.itemExtent, // item 有效范围
  bool addAutomaticKeepAlives = true, // 自动保存视图缓存
  bool addRepaintBoundaries = true, // 添加重绘边界
  bool addSemanticIndexes = true,
  double cacheExtent,
  List&lt;Widget&gt; children = const &lt;Widget&gt;[],
  int semanticChildCount,
  DragStartBehavior dragStartBehavior = DragStartBehavior.start,
})</code></pre></li>
<li><p>长列表数据</p>
<ul>
<li>itemBuilder:它是列表项的的构造器，返回值是一个Wideget，当列表滚动到具体的index时，会调用改构造器构建列表</li>
<li>itemCount：列表项的数量，数量为null，则为无限列表<pre><code>ListView.builder({
Key key,
Axis scrollDirection = Axis.vertical,
bool reverse = false,
ScrollController controller,
bool primary,
ScrollPhysics physics,
bool shrinkWrap = false,
EdgeInsetsGeometry padding,
this.itemExtent,
@required IndexedWidgetBuilder itemBuilder,
int itemCount,
bool addAutomaticKeepAlives = true,
bool addRepaintBoundaries = true,
bool addSemanticIndexes = true,
double cacheExtent,
int semanticChildCount,
DragStartBehavior dragStartBehavior = DragStartBehavior.start,
})</code></pre></li>
</ul>
</li>
<li><p>分割组件生成器</p>
<pre><code>ListView.separated({
  Key key,
  Axis scrollDirection = Axis.vertical,
  bool reverse = false,
  ScrollController controller,
  bool primary,
  ScrollPhysics physics,
  bool shrinkWrap = false,
  EdgeInsetsGeometry padding,
  @required IndexedWidgetBuilder itemBuilder,
  @required IndexedWidgetBuilder separatorBuilder,
  @required int itemCount,
  bool addAutomaticKeepAlives = true,
  bool addRepaintBoundaries = true,
  bool addSemanticIndexes = true,
  double cacheExtent,
})</code></pre></li>
</ul>
<h4 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h4><pre><code>GridView({
    Key key,
    Axis scrollDirection = Axis.vertical,
    bool reverse = false,
    ScrollController controller,
    bool primary,
    ScrollPhysics physics,
    bool shrinkWrap = false,
    EdgeInsetsGeometry padding,
    @required this.gridDelegate,  // 表格处理类，SliverGridDelegateWithFixedCrossAxisCount，SliverGridDelegateWithMaxCrossAxisExtent
    bool addAutomaticKeepAlives = true,
    bool addRepaintBoundaries = true,
    bool addSemanticIndexes = true,
    double cacheExtent,
    List&lt;Widget&gt; children = const &lt;Widget&gt;[],
    int semanticChildCount,
  })</code></pre>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter之布局组件</title>
    <url>/flutter-zhi-bu-ju-zu-jian.html</url>
    <content><![CDATA[<h3 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h3><p>线性布局，指的是沿水平或者垂直方向排布子组件。Flutter中通过Row和Column来实现线性布局。</p>
<ul>
<li>主轴和纵轴的区分，依赖于布局方向<ul>
<li>布局是水平方向，主轴就是水平方向(Main Axis)</li>
<li>反之，主轴就是竖直方向</li>
</ul>
</li>
</ul>
<h4 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h4><pre><code>  Row({
    Key key,
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,  // 子组件在水平方向上的对齐方式
    MainAxisSize mainAxisSize = MainAxisSize.max,  // 主轴占用的空间
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, //纵轴方向上的对齐方式
    TextDirection textDirection,  // 文字方向
    VerticalDirection verticalDirection = VerticalDirection.down, // 表示row纵轴的对齐方式,down:自上而下，up:自下而上
    TextBaseline textBaseline,
    List&lt;Widget&gt; children = const &lt;Widget&gt;[],
  })</code></pre><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h3><p>弹性布局允许子组件按照一定比例来分配父容器空间。Flutter中的弹性布局主要通过Flex和Expanded来配合实现</p>
<h4 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h4><p>Flex组件可以沿着水平或者垂直方向排列子组件</p>
<pre><code>Flex({
    Key key,
    @required this.direction,
    this.mainAxisAlignment = MainAxisAlignment.start,
    this.mainAxisSize = MainAxisSize.max,
    this.crossAxisAlignment = CrossAxisAlignment.center,
    this.textDirection,
    this.verticalDirection = VerticalDirection.down,
    this.textBaseline,
    List&lt;Widget&gt; children = const &lt;Widget&gt;[],
  })</code></pre><h4 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h4><p>可以按照比例”扩伸”，Row、Column和Flex子组件所占空间</p>
<pre><code>const Expanded({
    Key key,
    int flex = 1,
    @required Widget child,
  }) </code></pre><h3 id="层叠布局"><a href="#层叠布局" class="headerlink" title="层叠布局"></a>层叠布局</h3><p>层叠布局能够将子控件层叠排列。Flutter中Stack允许子控件堆叠，而positioned用于根据Stack的四个角来确定子组件的位置</p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><pre><code>  Stack({
    Key key,
    this.alignment = AlignmentDirectional.topStart, // 对齐方式
    this.textDirection,
    this.fit = StackFit.loose, // 如何占满Stack
    this.overflow = Overflow.clip, // 超出部分的显示
    List&lt;Widget&gt; children = const &lt;Widget&gt;[],
  })</code></pre><h4 id="Positioned"><a href="#Positioned" class="headerlink" title="Positioned"></a>Positioned</h4><p>分别表示离Stack的 上下左右的的间距， 以及指定元素的大小</p>
<pre><code>const Positioned({
    Key key,
    this.left,
    this.top,
    this.right,
    this.bottom,
    this.width,
    this.height,
    @required Widget child,
  })</code></pre>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter之基础组件</title>
    <url>/flutter-zhi-ji-chu-zu-jian.html</url>
    <content><![CDATA[<h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><h4 id="什么是widget"><a href="#什么是widget" class="headerlink" title="什么是widget"></a>什么是widget</h4><p>一切皆是widget，是flutter应用用户界面的基本构建单元，每个widget都与最终的用户界面有密切相关</p>
<ul>
<li>抽象类继承了可诊断树(DiagnosticableTree)</li>
<li>一个常量构造函数，可选参数key</li>
<li>抽象方法createElement</li>
<li>静态方法canUpdate，通过runtimeType和key判断</li>
</ul>
<h4 id="一个widget的定义如下"><a href="#一个widget的定义如下" class="headerlink" title="一个widget的定义如下"></a>一个widget的定义如下</h4><ul>
<li>一个结构元素(按钮，菜单)</li>
<li>一个风格元素(字体，配色方案等)</li>
<li>布局(padding)</li>
<li>等等</li>
</ul>
<h4 id="widget的分类"><a href="#widget的分类" class="headerlink" title="widget的分类"></a>widget的分类</h4><p>主要需要了解的是StatelessWidget和StatefullWidget</p>
<ul>
<li>StatelessWidget:无状态的，AssetImage,Text…</li>
<li>StatefulWidget:有状态的，Scrollable,Animatable..</li>
<li>Widget的介绍<ul>
<li>用于描述Element的配置</li>
<li>Widge他作为用户界面的一部分是不会改变的，被加载进Element(控制底层的渲染树)</li>
<li>Widget本身不包含状态或者可变数据，通过StatefulWidget.createState可以关联一个State</li>
<li>一个Widget可以被多次插入视图树中，并被加载进Element中</li>
<li>变量key和runtimeType用来判断Widget是否改变，是则重新加载</li>
</ul>
</li>
<li>构建 widget 的过程并不耗费资源，因为 Wiget 只是用来保存属性的容器。</li>
<li>无法获取Widget在屏幕上的位置和大小，因为Widget就是一张蓝图，他只是描述了底层渲染对象应该具有的属性</li>
</ul>
<h4 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h4><ul>
<li>继承自Widget的抽象类</li>
<li>重写了createElement方法名创建了StatelessElement对象</li>
<li>一个build方法，创建一个Widget</li>
<li>内部没有保存状态，UI界面创建后不会发生改变</li>
</ul>
<h4 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h4><ul>
<li>继承自Widget的抽象类</li>
<li>重写了createElement方法名创建了StatefulElement对象</li>
<li>一个createState方法，创建一个State</li>
<li>内部保存状态，调用setState方法，变更UI</li>
</ul>
<h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><ul>
<li>泛型抽象类 T extend StatefulWidget</li>
<li>State的流程<ul>
<li>launch-&gt;initState-&gt;didChangeDependencies-&gt;build-&gt;deactive-&gt;dispose-&gt;destroy</li>
<li>didUpdateWidget-&gt;build</li>
<li>initState：被插入到Widget树中被调用一次</li>
<li>didChangeDependencies:当state的依赖对象发生变化时调用</li>
<li>build:构建Widget时调用</li>
<li>didUpdateWidget:Widget重新构建时调用</li>
<li>deactive:当state对象被从树中移除调用</li>
<li>dispose:当state对象从树中被永久移除时调用，一般在此回调时释放资源</li>
</ul>
</li>
</ul>
<h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><ul>
<li>Element是控件树上的实例</li>
<li>Element 通过 mount 方法插入到 Element Tree 中，创建了RenderObject对象</li>
<li></li>
</ul>
<h4 id="树-Widget-Tree-Element-Tree-RenderObject-Tree"><a href="#树-Widget-Tree-Element-Tree-RenderObject-Tree" class="headerlink" title="树 Widget Tree, Element Tree ,RenderObject Tree"></a>树 Widget Tree, Element Tree ,RenderObject Tree</h4><ul>
<li>Widget Tree -(createElement)&gt; Element Tree -(createRenderObject)&gt; RenderObject Tree</li>
<li>Widget是为了描述Element需要的配置，负责创建Element,决定Element是否需要被更新</li>
<li>Element表示Widget配置树的特定位置的一个实例，同时持有Widget和RenderObject，负责管理Widget的配置和RenderObject的渲染。Widget发生改变，didUpdateWidget-&gt;build不会重建E，Element，只会更新</li>
<li>RenderObject表示渲染树的一个对象，负责真正的渲染工作，比如测量大小，位置绘制等都是由RendeObject完成</li>
</ul>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><ul>
<li>使用Key可以控制框架在Widget重建时与哪些其他Widget进行匹配</li>
<li>包含有LocalKey和globalKey<ul>
<li>LocalKey：ObjectKey，UniqueKey，ValueKey(PageStrageKey)</li>
<li>GlobalKey:LabeledGlobalKey,GlobalObjectKey</li>
</ul>
</li>
</ul>
<h3 id="MaterialApp"><a href="#MaterialApp" class="headerlink" title="MaterialApp"></a>MaterialApp</h3><p>Material应用是以MaterialApp Widget开始，主要封装了应用程序实现Material Design所需要的配置</p>
<ul>
<li>构造函数<ul>
<li>路由</li>
<li>主题</li>
<li>本地化</li>
<li>性能监控，调试</li>
</ul>
</li>
</ul>
<h4 id="Scaffold（脚手架）"><a href="#Scaffold（脚手架）" class="headerlink" title="Scaffold（脚手架）"></a>Scaffold（脚手架）</h4><p>在构造函数中，可以看出有App头布局，body内容,抽屉栏等元素控件，与原生Android有相似</p>
<pre><code>const Scaffold({
    Key key,
    this.appBar,
    this.body,
    this.floatingActionButton,
    this.floatingActionButtonLocation,
    this.floatingActionButtonAnimator,
    this.persistentFooterButtons,
    this.drawer,
    this.endDrawer,
    this.bottomNavigationBar,
    this.bottomSheet,
    this.backgroundColor,
    this.resizeToAvoidBottomPadding,
    this.resizeToAvoidBottomInset,
    this.primary = true,
    this.drawerDragStartBehavior = DragStartBehavior.start,
    this.extendBody = false,
    this.extendBodyBehindAppBar = false,
    this.drawerScrimColor,
    this.drawerEdgeDragWidth,
  })</code></pre><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><pre><code>const Text(
    this.data, { // 必要参数
    Key key,
    this.style,  // 文字样式
    this.strutStyle,
    this.textAlign, // 文字居中
    this.textDirection,
    this.locale,
    this.softWrap,
    this.overflow,
    this.textScaleFactor,
    this.maxLines,  // 最初
    this.semanticsLabel,
    this.textWidthBasis,
  })</code></pre><h4 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h4><p>表单操作，输入用户名密码</p>
<pre><code>const TextField({
    Key key,
    this.controller,
    this.focusNode,  // 焦点
    this.decoration = const InputDecoration(), // 设置输入样式
    TextInputType keyboardType,
    this.textInputAction,
    this.textCapitalization = TextCapitalization.none,
    this.style,
    this.strutStyle,
    this.textAlign = TextAlign.start,
    this.textAlignVertical,
    this.textDirection,
    this.readOnly = false,
    ToolbarOptions toolbarOptions,
    this.showCursor,
    this.autofocus = false,
    this.obscureText = false,  // 密码输入
    this.autocorrect = true,
    this.enableSuggestions = true,
    this.maxLines = 1,
    this.minLines,
    this.expands = false,
    this.maxLength,
    this.maxLengthEnforced = true,
    this.onChanged,
    this.onEditingComplete,
    this.onSubmitted,
    this.inputFormatters,  // 输入限制，手机号，数字 11位等
    this.enabled,
    this.cursorWidth = 2.0,
    this.cursorRadius,
    this.cursorColor,
    this.keyboardAppearance,
    this.scrollPadding = const EdgeInsets.all(20.0),
    this.dragStartBehavior = DragStartBehavior.start,
    this.enableInteractiveSelection = true,
    this.onTap,
    this.buildCounter,
    this.scrollController,
    this.scrollPhysics,
  }) </code></pre><h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><ul>
<li>AssetsImage:需要配置pubspec.yaml</li>
</ul>
<h4 id="BoxFit"><a href="#BoxFit" class="headerlink" title="BoxFit"></a>BoxFit</h4><p>图片的拉伸，填充控制</p>
<h4 id="Icon"><a href="#Icon" class="headerlink" title="Icon"></a>Icon</h4><pre><code>  const Icon(
    this.icon, {  // 设置Icons.add 系统提供
    Key key,
    this.size,
    this.color,
    this.semanticLabel,
    this.textDirection,
  })</code></pre>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>dart基本语法</title>
    <url>/dart-ji-ben-yu-fa.html</url>
    <content><![CDATA[<h3 id="Dart的开发环境安装"><a href="#Dart的开发环境安装" class="headerlink" title="Dart的开发环境安装"></a>Dart的开发环境安装</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li>Dart可以用来开发移动应用，web应用，开发命令行应用和服务端应用，主要有以下IDE可供选择</li>
<li>VS Code:在其中安装Dart插件进行开发</li>
<li>Android Studio：主要用于移动开发</li>
<li>Web Storm,IntelliJ, DartPad在线运行</li>
</ol>
<h4 id="Dart-SDK概要"><a href="#Dart-SDK概要" class="headerlink" title="Dart SDK概要"></a>Dart SDK概要</h4><ol>
<li>Dart SDK包含开发web，命令行和服务端应用所需要的库和命令行工具。如果是需要开发移动应用，只需要安装flutter即可</li>
</ol>
<h4 id="Dart-SDK安装（homebrew）"><a href="#Dart-SDK安装（homebrew）" class="headerlink" title="Dart SDK安装（homebrew）"></a>Dart SDK安装（homebrew）</h4><ol>
<li>install<pre><code>brew tap dart-lang/dart
brew install dart</code></pre></li>
</ol>
<h4 id="Dart-SDK升级"><a href="#Dart-SDK升级" class="headerlink" title="Dart SDK升级"></a>Dart SDK升级</h4><ol>
<li>update<pre><code>brew upgrade dart</code></pre></li>
<li>检查是否安装成功<pre><code>dart --version</code></pre></li>
</ol>
<h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><pre><code>vi .bash_profile

// click e 进入编辑模式
export Path=${PATH}:dart的安装目录</code></pre><h4 id="VS-Code的开发环境"><a href="#VS-Code的开发环境" class="headerlink" title="VS Code的开发环境"></a>VS Code的开发环境</h4><ol>
<li>VS Code的下载进行安装</li>
<li>Dart的环境配置,在VS extesion中搜索并下载dart插件</li>
</ol>
<h4 id="DartPad-在线运行"><a href="#DartPad-在线运行" class="headerlink" title="DartPad 在线运行"></a>DartPad 在线运行</h4><ol>
<li>打开dartpad.cn可以直接运行代码，但是如果有外部包导入，则需要VS Code</li>
</ol>
<h3 id="Dart基本概念"><a href="#Dart基本概念" class="headerlink" title="Dart基本概念"></a>Dart基本概念</h3><h4 id="样例程序"><a href="#样例程序" class="headerlink" title="样例程序"></a>样例程序</h4><pre><code>// 定义一个函数
printInteger(int aNumber){
  print(&#39;The number is $aNumber&#39;);
}

// Dart 程序从 main()函数开始执行
void main(){
  var number = 42; // 声明并初始化一个变量
  printInteger(number); // 调用一个函数
}</code></pre><ol>
<li>// 表示注释</li>
<li>int 表示数据类型</li>
<li>main 顶级函数，应用程序的入口</li>
<li>var 用于定义变量，可以不指定变量类型</li>
</ol>
<h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><ol>
<li>一切皆对象：所有变量引用的都是对象，数字，函数，null都是对象，都继承字Object类</li>
<li>Dart声明变量类型可选：Dart可以进行类型推断，dynamic可以声明一个不确定的类型</li>
<li>Dart支持泛型：List<int>或者List<dynaamic>(由任何类型对象组成的列表)</dynaamic></int></li>
<li>Dart支持顶级函数，支持属于类或者对象的函数，支持嵌套函数：main</li>
<li>Dart支持顶级变量，支持属于类或者对象的变量</li>
<li>标识符下划线开头表示库内私有：_number,_name()</li>
<li>标识符字母，数字，下划线，由字母或者下划线开头</li>
<li>Dart表达式有值，语句没有值</li>
<li>Dart工具可以显示警告和错误两种类型</li>
</ol>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>分为1，2，3</p>
<ul>
<li>1表示上下文关键字，在特定的场合才有用</li>
<li>2表示内置关键符</li>
<li>3是1.0之后支持异步的关键字</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ol>
<li>变量仅存储对象的引用</li>
<li>变量声明的时候可以不指定类型</li>
<li>未初始化的变量内容都为null</li>
<li>可以使用关键字final或者const修饰变量 final只能赋值一次，const为编译时常量，顶层的final变量或者类的final变量在其第一次使用的时候初始化</li>
</ol>
<h3 id="Dart内置类型"><a href="#Dart内置类型" class="headerlink" title="Dart内置类型"></a>Dart内置类型</h3><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><ul>
<li>长度不超过64位，具体取值范围依赖于不同的平台。在DartVM上其取值位于-2^63至2^63-1.编译吃JavaScript的Dart使用JavaScript数字，范围是-2^53~2^53-1之间</li>
</ul>
<h4 id="double"><a href="#double" class="headerlink" title="double"></a>double</h4><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li><p>Dart字符串是UTF-16编码的字符序列。可以使用单引号或者双引号创建字符串</p>
</li>
<li><p>可以使用+运算拼接字符串</p>
</li>
<li><p>使用三个单引号或者三个双引号穿件多行字符串</p>
</li>
<li><p>字符串前加上r作为前缀创建“raw”字符串（不会被做任何处理）</p>
<pre><code>
var s1 = &quot;dsadsa&quot;;
var s2 = &#39;dadasd&#39;;

var s3 = &#39;dasda\&#39;&#39;;

var s4 = &quot;ab&quot; + &quot;cd&quot;;

var s5 = &quot;dsad&quot;&quot;dasda&quot;;

var s6 =&#39;&#39;&#39;
dasfsa
dsadas
&#39;&#39;&#39;;

var s8 = &quot;dasdas is $a&quot;;

const s10 = &quot;a const&quot;;</code></pre></li>
</ul>
<h4 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h4><ul>
<li>bool关键字表示布尔类型，布尔类型只有true和false，是编译时常量</li>
<li>Dart的类型安全不允许使用1,0做代码判断</li>
</ul>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><ul>
<li><p>Dart中数组由List对象表示的</p>
</li>
<li><p>下标从0开始</p>
</li>
<li><p>List list = List();//固定长度为数组，无参表示可变长度</p>
<pre><code>var list = [1,2,3];
List list1 = new List();
List list2 = List();
list2.addAll(list);

var temp = list2[0];

var list3 = [0, ...list2];

var list4 = [0, ...?list3];

const list5 = [0,1,2]; 

// list5[1] = 1; //  不能修改</code></pre></li>
</ul>
<h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><ul>
<li><p>Dart中使用sets表示元素无序，唯一的值</p>
</li>
<li><p>支持Set字面量以及Set类型两种形式的set</p>
</li>
<li><p>Set字面量是在Dart2.2中加入的</p>
<pre><code>var set1 = {&#39;1&#39;};
var set2 = &lt;int&gt;{}; // 空的set， 不指定类型可用&lt;dynamic&gt;{}
Set&lt;int&gt; set3 = Set();

const set4 = {&#39;a&#39;};a</code></pre></li>
</ul>
<h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><ul>
<li><p>Dart中的Map通过map字面量和map类型来实现</p>
</li>
<li><p>每个键只能出现一次，但是值可能出现重复</p>
<pre><code>var map = {1:&quot;a&quot;, 2:&quot;b&quot;};
Map map1 = Map();

Map&lt;int, String&gt; map2 = Map();

map2[0]; //0 是可以不是下标

final  map3 = const {1:&quot;a&quot;, 2:&quot;b&quot;};</code></pre></li>
</ul>
<h4 id="Runes"><a href="#Runes" class="headerlink" title="Runes"></a>Runes</h4><ul>
<li>dart使用Runes来标识UTF-32编码的字符串</li>
<li>String类中的codeUniteAt和codeUnite属性返回16位代码单元。Runes属性可以获取字符串的Runes</li>
</ul>
<h4 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h4><ul>
<li>Symbols表示Dart中声明的操作符或者标识符，该类型的对象几乎不会被使用到</li>
<li>可以使用在标识符前面加#来获取Symbols</li>
<li>Symbols字面量是编译时的常量</li>
</ul>
<h3 id="Dart方法"><a href="#Dart方法" class="headerlink" title="Dart方法"></a>Dart方法</h3><p> Dart是一种真正的面向对象的语言，所以函数也是对象并且类型为Function，这意味着函数可以被赋值给变量或者作为其他函数的参数。可以像调用函数一样调用Dart类的实例</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>函数可以有两张形式的参数；必要参数和可选参数</li>
<li>必要参数定义在参数列表的前面</li>
<li>可选参数定义在必要参数的后面</li>
<li>可选参数<ul>
<li>可选参数分为命名参数和位置参数</li>
<li>可选参数列表中任选其一使用，不能混用</li>
</ul>
</li>
</ul>
<pre><code>int a(int a, int b,{int c, int d = 0, int f}){
  return a+b;
}

void main(){
  int c = a(2,3, c:4, d: 6);
}
// 使用参数名:参数值，的形式来指定命名参数
// 使用大括号的来指定命名参数
// 可以提供默认值
// @required注解来标识一个命名参数是必须的


int a(int a, int b,[int c, int d = 0, int f]){
  return a+b;
}
// 使用中括号将一系列参数包裹起来作为位置参数
// 可以使用=为函数的位置参数设置默认值，默认值必须是常量默认是null
</code></pre><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main()函数"></a>main()函数</h4><ul>
<li>每个Dart程序都必须有一个main()顶级函数作为程序入口</li>
</ul>
<h4 id="函数作为一级对象"><a href="#函数作为一级对象" class="headerlink" title="函数作为一级对象"></a>函数作为一级对象</h4><ul>
<li>可以将函数作为参数传递给另一个函数</li>
<li>可以将函数赋值给另一个变量</li>
</ul>
<pre><code>var f=  printE;
  var a = (e) =&gt; &quot;dsada &quot;; // 胖箭头语法

  var b = (e){
    return &quot;xxx&quot;;
  };
</code></pre><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul>
<li>没有名字的函数<pre><code>([[类型] 参数[,..]]){
  函数体;
}</code></pre></li>
</ul>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><ul>
<li>变量的作用于在写代码的时候就确定了</li>
<li>大括号内定义的变量只能在大括号内使用</li>
</ul>
<h4 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h4><ul>
<li>闭包即一个函数对象，即使函数对象的调用在它原始作用于范围之外，依然可以访问在它词法作用域内的变量</li>
</ul>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>所有函数都有返回值</li>
<li>没哟显示返回语句的函数，默认返回 return null</li>
</ul>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><ul>
<li>if else</li>
<li>三目运算 a == null? “guest”: a;</li>
<li>a ?? “guest”</li>
</ul>
<h4 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h4><pre><code>  var listaa =[&#39;a&#39;, &#39;q&#39;, &#39;f&#39;];

  for (var item in listaa) {

  }

  for (var i = 0; i &lt; listaa.length; i++) {

  }

  listaa.forEach((f){

  });</code></pre><h4 id="while-do-while"><a href="#while-do-while" class="headerlink" title="while /do while"></a>while /do while</h4><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><h4 id="break-continue"><a href="#break-continue" class="headerlink" title="break continue"></a>break continue</h4><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>Dart能够Throw和catch异常，</li>
<li>Dart中的所有异常为非检查异常，方法不一定声明他们所抛出的异常，并且你也不需要捕获异常</li>
<li>Dart提供了Exception和Error类型，以及一些子类，也可以实现自己的异常类型</li>
</ul>
<h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><pre><code>throw FormatException(&quot;Excepted at least 1 selection&quot;);

// 任意类型的异常对象
throw &quot;out of IIams&quot;;</code></pre><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><pre><code>try {

} on XXXException {

} on Exception catch(e) {

} catch(e, s) {

} finally {

}</code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Dart是一个面向对象的编程语言，同时支持基于mixin的继承机制。每个对象都是一个类的实例，所有的累都继承Object。基于Mixin的继承意味着每个类都只有一个超类，一个类的代码可以在其他多个类继承<br>中重复使用</p>
<h4 id="使用类的成员"><a href="#使用类的成员" class="headerlink" title="使用类的成员"></a>使用类的成员</h4><ul>
<li>对象的成员由函数和数据（即方法和实例变量）组成，使用(.)来访问对象的实例变量或者方法</li>
</ul>
<h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><ul>
<li>可以使用构造函数来创建一个对象。构造函数的命名方式可以为类名或者类名.标识符的形式</li>
</ul>
<pre><code>  var p = Point();
  var p2 = Point.fromJson({&#39;x&#39;: 1, &#39;y&#39;: 2});
  p.x = 3; // 使用x的setter方法</code></pre><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><pre><code>class Point{
  int x; //声明变量x并初始化为null
  int y;
  num z = 0; //声明变量z并初始化为0
}

void main(){
  var p = Point();
  // var p2 = Point.fromJson({&#39;x&#39;: 1, &#39;y&#39;: 2});

  p.x = 3; // 使用x的setter方法

  assert(p.x == 3);// 使用x的getter方法
  assert(p.y == null); //默认值为null
}</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li><p>声明一个与类名一样的函数，即可声明一个构造函数</p>
</li>
<li><p>对于大多数编程语言来说在构造函数中为变量赋值的的过程都类似，而Dart则提供了一种特殊的语法糖简化该步骤</p>
<pre><code>class Point{
int x; //声明变量x并初始化为null
int y;
num z = 0; //声明变量z并初始化为0

// Point(int x, int y){
//   this.x = x;
//   this.y = y;
// }

// this.x,this.y, Dart特殊的语法糖构造函数赋值
Point(this.x, this.y);
}</code></pre></li>
<li><p>默认构造函数：如果没有声明构造函数，Dart会自动生成一个无参的构造函数，并且该构造函数会自动调用其父类的无参构造函数</p>
</li>
<li><p>构造函数不会被继承：子类不会继承父类的构造函数</p>
</li>
<li><p>命名式构造函数：可以为一个类声明多个命名式的构造函数来表达更明确的意图</p>
<pre><code>class Point{
int x; //声明变量x并初始化为null
int y;
num z = 0; //声明变量z并初始化为0

// 命名式构造函数
Point.origin(){
  this.x = 0;
  this.y = 0;
}
}</code></pre></li>
<li><p>重定向构造函数:有时候类中的构造函数会调用类中其他的构造函数，该重定向构造函数没有函数体，只需要在函数签名后面使用（:）指定需要重定向到的其他构造函数既可以</p>
<pre><code>// 委托实现给主构造函数
Point.alongXAxis(int x):this(x, 0);</code></pre></li>
<li><p>常量构造函数：如果类生成的对象都是不变的，那么可以在生成这些对象时就将其变为编译时常量，你可以在类的构造函数前加上 const 关键字并确保所有实例均为final来实现该功能</p>
<pre><code>class ImmutablePoint{
static final ImmutablePoint point = const ImmutablePoint(0, 0);
final int x, y;
const ImmutablePoint(this.x, this.y);
}</code></pre></li>
<li><p>工厂构造函数: 使用factory关键字表示类的构造函数将会令该构造函数变为工厂构造函数，这将意味着使用该构造函数构造类的实例时并非总是先返回新的实例对象</p>
<pre><code>class Logger {
final String name;

static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};
factory Logger(String name){
  return _cache.putIfAbsent(name, () =&gt; Logger._internal(name));
}

static Logger _internal(String name){
  return Logger(name);
}
}</code></pre></li>
</ul>
<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><ul>
<li>在构造函数体执行之前初始化实例变量<pre><code>Point.fromJson(Map&lt;String, int&gt; json){
  x = json[&#39;x&#39;];
  y = json[&#39;y&#39;];
  print(&quot;fromJson(): ($x, $y)&quot; );
}</code></pre></li>
</ul>
<h4 id="调用父类构造函数"><a href="#调用父类构造函数" class="headerlink" title="调用父类构造函数"></a>调用父类构造函数</h4><ul>
<li>构造函数调用顺序<ul>
<li>初始化列表</li>
<li>父类的无参构造函数</li>
<li>当前类的构造函数</li>
</ul>
</li>
<li>如果父类无无参构造函数，那么子类必须调用父类的其中一个构造函数，为子类的构造函数指定父类的构造函数只需要在构造函数体前使用(:)指定</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>实例方法：实例方法可以访问实例的变量和this</li>
<li>getter和setter的方法</li>
<li>抽象方法：定义一个借口方法而不去做具体的实现让实现他的类去实现该方法，抽象方法只能存在与抽象类中</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>使用关键字abstract标识的类让类成为抽象类，抽象类将无法被实例化。抽象类常用于声明接口方法，有时候也会有具体的实现方法</li>
<li>抽象类尝尝会包含抽象方法</li>
</ul>
<h4 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h4><ul>
<li>继承 extend</li>
<li>子类可以重写父类的实例方法，getter,setter方法</li>
</ul>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>是一种特殊的类型，用于存储一些固定数量的常量</p>
<ul>
<li>使用关键字 enum</li>
<li>每一个枚举值都有一个名为index成员变量的getter方法</li>
<li>使用枚举类的values方法获取一个包含所有枚举值的列表</li>
<li>switch中使用枚举</li>
</ul>
<h4 id="使用mixin为类添加功能"><a href="#使用mixin为类添加功能" class="headerlink" title="使用mixin为类添加功能"></a>使用mixin为类添加功能</h4><p>mixin是一种在多继承中复用某各类中代码的方法模式</p>
<ul>
<li>定义一个类继承自Object并且不为该类定义构造函数，这个类就是Mixin类，通过关键字mixin替换class让其成为一个单纯的Mixin类</li>
<li>使用with关键字并在其后面跟上Mixin类的名字来使用Mixin模式</li>
</ul>
<h4 id="静态变量和方法"><a href="#静态变量和方法" class="headerlink" title="静态变量和方法"></a>静态变量和方法</h4><p>static 关键字修饰</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="为什么使用功能泛型"><a href="#为什么使用功能泛型" class="headerlink" title="为什么使用功能泛型"></a>为什么使用功能泛型</h4><ul>
<li>正确使用泛型可以生成更好的代码</li>
<li>使用泛型减少重复代码</li>
<li>构造方法时也可以使用泛型，在类名后用尖括号&lt;..&gt;将一个或多个类型包裹<pre><code>var nameSet = Set&lt;String&gt;.from(names);
var views = Map&lt;int, View&gt;();</code></pre></li>
<li>Dart的泛型类型是固化的，这意味着即便在运行时也会保持类的信息（java中的泛型是类型擦拭的）</li>
</ul>
<h4 id="限制参数化类型"><a href="#限制参数化类型" class="headerlink" title="限制参数化类型"></a>限制参数化类型</h4><ul>
<li>使用extends关键字限制</li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编程入门</title>
    <url>/java-bian-cheng-ru-men.html</url>
    <content><![CDATA[<h5 id="认识Java"><a href="#认识Java" class="headerlink" title="认识Java"></a>认识Java</h5><ol>
<li>Java的起源是SUM公司开发的，后来被oracle收购</li>
<li>Java的开发开发有三种<ul>
<li>JAVA SE 桌面应用开发</li>
<li>JAVA ME 嵌入是开发 </li>
<li>JAVA EE 企业平台开发，即互联网平台开发</li>
</ul>
</li>
</ol>
<h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ol>
<li>Java是半开源的项目，可以接触底层代码</li>
<li>Java是一种编程语言，面向对象的编程思想并且一直在拓展扩充</li>
<li>提供有方便的内存回收机制</li>
<li>避免了复杂的指针问题，使用更加简单的引用来代替指针</li>
<li>Java是支持多线程开发的语言，使得在单位时间内的提升了处理能力</li>
<li>Java提供了高效的网络处理能力，基于NIO实现了更加高效的网络传输能力</li>
<li>Java具有良好的可移植性</li>
<li>足够简单</li>
</ol>
<h4 id="Java的可移植性"><a href="#Java的可移植性" class="headerlink" title="Java的可移植性"></a>Java的可移植性</h4><p>在于同一个程序可以在不同的操作系统中执行部署，减少开发难度。依赖于Java虚拟机JVM，不同操作系统拥有不同版本的JVM，实现了移植性。</p>
<h5 id="Java程序运行机制"><a href="#Java程序运行机制" class="headerlink" title="Java程序运行机制"></a>Java程序运行机制</h5><ul>
<li>编译型，解释型。Java是两种高级编程语言的结合，先编译成.class文件，再解释成计算机识别的机器指令</li>
<li>编译命令：Javac.exe</li>
<li>解释命令：Java.exe</li>
<li>Java程序的组成：Java源文件，字节码文件，机器码指令</li>
</ul>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul>
<li>一台模拟的计算机，可以读取并处理经编译过的与平台无关的字节码class文件</li>
<li>java编译器针对JVM产生class文件，因此独立于平台</li>
<li>Java解释器负责将JVM的代码在特定的平台上运行</li>
</ul>
<h4 id="JDK的介绍"><a href="#JDK的介绍" class="headerlink" title="JDK的介绍"></a>JDK的介绍</h4><p>是Java的开发工具包,主要版本迭代，其中JRE是运行环境，只提供解释功能不提供程序的开发功能</p>
<ul>
<li>1995.05.23，JDK1.0发布， 1996年提供对外</li>
<li>1998.12.04 JDK1.2，更名为Java2</li>
<li>2005.05.23 十周年大会，JDK1.5 ，带来了新特性，决定了未来10的核心技术</li>
<li>2014 JDK1.8，支持了Lambda，可以函数式编程</li>
<li>2017 JDK1.9,提高了1.8稳定性</li>
<li>2018 JDK1.10,属于1.9的稳定版</li>
</ul>
<h4 id="JDK的安装与配置"><a href="#JDK的安装与配置" class="headerlink" title="JDK的安装与配置"></a>JDK的安装与配置</h4><h4 id="Java编程起步"><a href="#Java编程起步" class="headerlink" title="Java编程起步"></a>Java编程起步</h4><p>创建HelloWorld.java文件，编写源文件，编写输出HelloWord的程序。Java程序是需要经过两次处理之后才能正常执行的</p>
<ul>
<li>对源代码进行编译：Javac xxx/HelloWord.java，会出现一个HelloWord.class的字节码文件，利用JVM进行编译，编译出一套与平台无关的字节码文件(*.class)</li>
<li>在JVM上进行程序的解释执行Java xxx/HelloWord。解释的就是字节码文件，字节码文件的后缀是不需要编写的</li>
<li>类的定义有两种形式，public class 类名， class 类名。第一种文件名必须与类名一致，第二种可以不一致，生成的*.class文件名与类名一致。一般情况是一个class并且以public修饰，类名是驼峰式</li>
<li>main方法，程序运行入口主方法</li>
</ul>
<h4 id="ClASSPATH环境属性"><a href="#ClASSPATH环境属性" class="headerlink" title="ClASSPATH环境属性"></a>ClASSPATH环境属性</h4><ul>
<li>PATH: 是操作系统提供的路径配置，定义所有可执行程序的路径</li>
<li>CLASSPATH: 是JRE提供的，用于定义Java程序解释时类加载路径，默认是源文件的目录</li>
</ul>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>单行注释 //</li>
<li>多行注释 /* …. */</li>
<li>文档注释 /** …. */</li>
</ul>
<h4 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h4><ul>
<li>Java语言中有不同的结构：类，方法，变量结构等，对于结构的说明实际上就是标识符，是有命名规则的。</li>
<li>关键字，是系统对于一些结构的的描述处理，有着特殊含义，public static final 等等</li>
</ul>
<h4 id="Java数据类型简介"><a href="#Java数据类型简介" class="headerlink" title="Java数据类型简介"></a>Java数据类型简介</h4><ul>
<li>数据分类：基本数据类型(数字单元)分三大类，数值型，浮点型，字符型，引用数据类型(内存关系的使用)分数组，类，接口<table>
<thead>
<tr>
<th>类型</th>
<th>包括</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>基本数据类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>整型</td>
<td>byte,short,int,long</td>
<td>0</td>
</tr>
<tr>
<td>浮点型</td>
<td>float，double</td>
<td>0.0</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolea</td>
<td>false</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>引用类型</td>
<td>数组，类，接口</td>
<td>null</td>
</tr>
</tbody></table>
</li>
<li>使用原则： 如果是描述数字首选int,double；如果要进行数据传输或者文字编码选择byte(二进制处理)；处理中文char;描述内存或者文件大小，表的主键列long</li>
<li>内存溢出：如果数值的操作超出了数值类型的范围就会陷入循环的现象，通过使用范围更大的数值类型解决</li>
<li>浮点型数据，都是有小数点的。float 变量相乘会出现多出4位小数的历史bug</li>
<li>整形数据进行相除，会得到整数部分，10/2 = 2,  除非进行转型</li>
<li>字符类型char和整形int可以相互转换, 可以获取char字符在系统中的编码。大写字母 A(65)<del>Z(90)，小写字母a(97)</del>z(112),大小写之间相差32位，数字范围‘0’(48)~’9’(57)</li>
<li>java可以保存中文是因为Java使用的是Unicode 16进制的编码</li>
<li>布尔类型，只有true和false</li>
<li>字符串。在Java中范围大的数据类型与范围小的数据类型操作，所有小的数据类型会自动转型为数据范围大的数据类型</li>
</ul>
<h4 id="运算符简介"><a href="#运算符简介" class="headerlink" title="运算符简介"></a>运算符简介</h4><ul>
<li>数学运算符： 加减乘除</li>
<li>关系运算符：大小的比较，基本数据类型之间支持自动转型，字符类型可以转成int</li>
<li>逻辑运算符：三目(赋值)运算</li>
<li>位运算：二进制数的计算处理，(&amp;与) (|或者) (^异或) (~反码)<ul>
<li>&amp; | 在进行逻辑运算的时候所有的条件都会执行</li>
<li>&amp;&amp; || 若干个条件判断的时候，前面的返回来false 或者 true，后面的条件判断就不再执行</li>
</ul>
</li>
</ul>
<h4 id="IF分支结构"><a href="#IF分支结构" class="headerlink" title="IF分支结构"></a>IF分支结构</h4><p>针对关系表达式进行判断处理的的分支操作，关键字为if,else,,在多条件else if判断时需写上else</p>
<h4 id="switch分支语句"><a href="#switch分支语句" class="headerlink" title="switch分支语句"></a>switch分支语句</h4><p>是一个开关语句，它主要根据内容进行判断,支持String.注意添加break关键字，否则会继续执行。注意添加default关键字</p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for(定义循环的初始化数值；循环判断；修改循环数值){<br>    循环执行；<br>}</p>
<ul>
<li>在明确循环次数的情况下优先选择for循环</li>
<li>在不知道循环次数，但知道循坏条件下选择while</li>
</ul>
<h4 id="循坏控制"><a href="#循坏控制" class="headerlink" title="循坏控制"></a>循坏控制</h4><p>break：退出整个循坏的结构<br>continue： 在当前的语句之后中的代码不在执行，而直接执行后续的判断处理</p>
<h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><ul>
<li>方法的命名规则</li>
<li>是一段可以被重复调用的代码块</li>
</ul>
<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>当方法名相同的时候，参数类型或者个数不同的时候就称为方法的重载。</p>
<ul>
<li>同一个方法名称，可以根据我们调用时传递的参数类型及个数实现不同方法体的调用</li>
<li>方法的重载建议其返回值相同</li>
</ul>
<h4 id="方法的递归调用"><a href="#方法的递归调用" class="headerlink" title="方法的递归调用"></a>方法的递归调用</h4><ul>
<li>方法递归调用的结束条件</li>
<li>每次调用的过程中一定要修改传递的参数条件</li>
<li>递归操作虽然可以简化的调用，但是在实际开发中很少出现。容易栈溢出</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面向对象编程</title>
    <url>/java-mian-xiang-dui-xiang-bian-cheng.html</url>
    <content><![CDATA[<h4 id="面向对象的简介"><a href="#面向对象的简介" class="headerlink" title="面向对象的简介"></a>面向对象的简介</h4><ul>
<li>面向对象是以标准的模块化设计，并且可以重用特征，</li>
<li>面向过程对于一个问题的解决方案不会考虑重用的设计</li>
<li>面向对象设计的三大特征<ul>
<li>封装性：内部的操作对外部而言不可见，限制访问的安全</li>
<li>继承性：在已有结构的的基础上进行功能的扩充</li>
<li>多态性：在继承性的基础上扩充而来的概念，指的是类型的转换处理</li>
</ul>
</li>
<li>面向对象的开发步骤<ul>
<li>OOA：面向对象分析</li>
<li>OOD: 面向对象的设计</li>
<li>OOP: 面向对象的编程</li>
</ul>
</li>
</ul>
<h4 id="类与对象的简介"><a href="#类与对象的简介" class="headerlink" title="类与对象的简介"></a>类与对象的简介</h4><ul>
<li>类是对某一类事物的共性的抽象概念，而对象描述的是一个具体的产物</li>
<li>类的组成<ul>
<li>成员属性：年龄，名字等</li>
<li>操作方法：定义对象具有的处理行为</li>
</ul>
</li>
</ul>
<h4 id="类与对象的定义"><a href="#类与对象的定义" class="headerlink" title="类与对象的定义"></a>类与对象的定义</h4><ul>
<li>类是一个独立的结构体，所以需要使用class来进行定义，主要由方法和属性所组成</li>
<li>产生对象步骤<ul>
<li>声明对象</li>
<li>实例化对象</li>
</ul>
</li>
</ul>
<h4 id="对象内存分析"><a href="#对象内存分析" class="headerlink" title="对象内存分析"></a>对象内存分析</h4><p>Person per = new Person();</p>
<ul>
<li>堆内存：保存的是对象实例的具体信息，在程序中堆内存的开辟是通过new完成的</li>
<li>栈内存：保存的是一块堆内存的地址。通过地址找到堆内存，而后找到对象信息</li>
<li>所有的对象在调用属性和方法之前必须进行实例化，否则无法使用报空指针NullPointException</li>
</ul>
<h4 id="对象引用分析"><a href="#对象引用分析" class="headerlink" title="对象引用分析"></a>对象引用分析</h4><ul>
<li>类是引用数据类型</li>
<li>存在引用传递，当两个引用变量指向同一个对象实例时，修改会对两个变量都生效</li>
</ul>
<h4 id="引用与垃圾产生分析"><a href="#引用与垃圾产生分析" class="headerlink" title="引用与垃圾产生分析"></a>引用与垃圾产生分析</h4><ul>
<li>垃圾的产生是没有任何栈内存所指向的堆内存空间</li>
<li>一个栈内存只能保存一个堆内存的的地址数据，如果发生修改，则原保存的地址数据将彻底消失</li>
</ul>
<h4 id="成员属性的封装"><a href="#成员属性的封装" class="headerlink" title="成员属性的封装"></a>成员属性的封装</h4><p>对属性进行private的私有使用保护，不被外部程序随意修改数据</p>
<h4 id="构造方法和匿名对象"><a href="#构造方法和匿名对象" class="headerlink" title="构造方法和匿名对象"></a>构造方法和匿名对象</h4><ul>
<li>构造方法名称必须与类名称保持一致</li>
<li>构造方法不允许设置任何返回值类型，无返回值</li>
<li>构造方法在使用new关键字自动调用</li>
<li>一个类至少存在有一个构造函数，永恒存在</li>
<li>区分普通方法，两者对的调用时机不同</li>
<li>匿名对象没有引用，调用结束就会进行回收</li>
</ul>
<h4 id="this关键字调用本类属性"><a href="#this关键字调用本类属性" class="headerlink" title="this关键字调用本类属性"></a>this关键字调用本类属性</h4><ul>
<li>当前类中的属性：this.属性</li>
<li>当前类的构造方法，普通方法</li>
<li>描述当前对象</li>
</ul>
<h4 id="this调用方法"><a href="#this调用方法" class="headerlink" title="this调用方法"></a>this调用方法</h4><ul>
<li>构造方法在new实例化对象的时候调用</li>
<li>普通方法在实例化对象后才可以调用</li>
<li>评价一个代码的好坏<ul>
<li>代码结构可以重用，提供的是一个中间独立的支持</li>
<li>我们的目标是没有重复</li>
</ul>
</li>
<li>this()必须放在首行，必须保留程序出口避免死循环</li>
</ul>
<h4 id="声明static属性"><a href="#声明static属性" class="headerlink" title="声明static属性"></a>声明static属性</h4><ul>
<li>定义公共属性，通过类去修改属性值</li>
<li>static 属性值虽然定义在类中，但是其并不受类实例对象的控制</li>
<li>在进行类设计首选非static属性（95%），而考虑到公共属性则考虑</li>
</ul>
<h4 id="声明static的方法"><a href="#声明static的方法" class="headerlink" title="声明static的方法"></a>声明static的方法</h4><ul>
<li>通过类名调用</li>
<li>不能加this</li>
<li>static 方法只允许调用static属性和方法</li>
<li>非static方法允许调用static属性和方法</li>
<li>所有的static属性和方法都可以在没有实例化对象的前提下使用，而非static则必须实例化后使用</li>
</ul>
<h4 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h4><ul>
<li>定义在方法中的代码块</li>
<li>可以对方法进行一些结构的拆分，以防止相同变量名称所带来的的影响</li>
</ul>
<h4 id="构造块"><a href="#构造块" class="headerlink" title="构造块"></a>构造块</h4><p>构造块会有限于构造方法执行，并且每次实例化的时候都会调用构造块的代码</p>
<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>主要指通过static关键字定义的代码块</p>
<ul>
<li>静态代码块优先于构造代码块，并且不管有多少个实例对象，都只会执行一次。</li>
<li>父类的代码块优先子类执行</li>
</ul>
<h4 id="数组的基本定义"><a href="#数组的基本定义" class="headerlink" title="数组的基本定义"></a>数组的基本定义</h4><ul>
<li>大量引用类型数据的创建</li>
<li>数组的动态初始化，元素默认值为数据类型的默认值</li>
<li>数组的静态初始化</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系列</title>
    <url>/chong-xue-java.html</url>
    <content><![CDATA[<h2 id="阿里云Java学习路线"><a href="#阿里云Java学习路线" class="headerlink" title="阿里云Java学习路线"></a><a href="https://developer.aliyun.com/learning/roadmap/java?source=5176.11533457&userCode=r3yteowb&type=copy&spm=5176.12901015.0.i12901015.510b525c9IzVPf" target="_blank" rel="noopener">阿里云Java学习路线</a></h2><h3 id><a href="#" class="headerlink" title></a><a href="/java-bian-cheng-ru-men.html" title="Java编程入门">Java编程入门</a></h3><p>主要讲解JavaSE的发展历史，JDK开发环境的搭建，CLASSPATH属性作用，Java程序基本结构、基本数据类型的划分及使用、程序结构、方法的定义与使用。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a><a href="/java-mian-xiang-dui-xiang-bian-cheng.html" title="Java面向对象编程">Java面向对象编程</a></h3><p>面向对象是Java语言之中最为重要的特征，也是进一步学习Java的重要知识体系。在本课程之中将为读者详细的讲解面向对象的定义、类与对象的组成、内存分析、封装性、继承性、多态性等概念的全面分析</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 面向切面编程详解</title>
    <url>/android-mian-xiang-qie-mian-bian-cheng-xiang-jie.html</url>
    <content><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ol>
<li>什么是AOP（WHAT）</li>
<li>AOP的使用 (HOW)</li>
<li>比较主流AOP方案的优缺点 (WHY)</li>
<li>基于AOP实现的业务开源库 (WHERE)</li>
</ol>
<h3 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h3><h4 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h4><ul>
<li>AOP与OOP一样，是一种程序设计的思想：面向切面编程(Aspect Oritented Programming)，而非技术手段。思想的实现方式是一种技术，即通过预编译方式和运行期动态代理的方式实现程序功能的统一维护</li>
<li>AOP是OOP的延续，是软件开发中的热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，提高开发效率。</li>
</ul>
<h4 id="什么是OOP"><a href="#什么是OOP" class="headerlink" title="什么是OOP"></a>什么是OOP</h4><ul>
<li>OOP机面向对象编程(Object Oriented Programming)，被理解为是一种将程序分解为封装数据及相关操作的对象的编程思想。它有三大特性：多态，继承，封装。其中封装指：隐藏对象的属性和实现细节，仅对外公开访问方法，控制在程序中属性的读和写的级别，以获得更加清晰高效的逻辑单元划分。这个程序的六大设计原则中的单一职责原则一致：一个类只负责一件事。</li>
<li>因此针对上面的封装特性，他存在一个问题：当存在关注点聚焦的场景时，他无法很好的解决，因为一个关注点是面向所有而不是一个单一的类，不受类的边界的约束,因此它只能分散到各个类,方法中去。这样的好处是降低了类的复杂性，提高了程序的可维护性，但同时他也使代码变得啰嗦了，例如添加方法的调用日志，那就必须为所有的需要日志的方法添加调用日志的方法。</li>
</ul>
<h4 id="AOP和OOP的关系"><a href="#AOP和OOP的关系" class="headerlink" title="AOP和OOP的关系"></a>AOP和OOP的关系</h4><ul>
<li>面对上述聚焦某个点的问题，AOP可以理解为是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或者阶段，以获得逻辑过程中各个部分之间低耦合性隔离效果。这两种思想在目标上有本质上的差异，但两者不是对立的，AOP是为了弥补OOP的不足。</li>
<li>OOP解决了竖向的问题，AOP则解决了横向的问题，有了AOP对程序的监控将更加简单清晰</li>
</ul>
<h4 id="使用的业务场景"><a href="#使用的业务场景" class="headerlink" title="使用的业务场景"></a>使用的业务场景</h4><p>日志记录，性能统计，安全控制，事务处理，异常处理等等</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="/images/20171016213933903.png" alt></p>
<a id="more"></a>
<p>现在实现上图的业务，1.为所有的方法做参数校验，2.添加前置日志，后置日志。</p>
<ul>
<li><p>按照传统OOP实现，我们会定义一个参数校验的类Preconditions，及参数校验方法checkNotEmpty</p>
<pre><code>public final class Preconditions {
  public static &lt;T&gt; T checkNotEmpty(T instance, String name) {
      if (isEmpty(instance)) {
          throw new NullPointerException(name + &quot;不能为空&quot;);
      }
      return instance;
  }

  private static boolean isEmpty(Object obj) {
      if (obj == null) {
          return true;
      }
      if (obj instanceof String &amp;&amp; obj.toString().length() == 0) {
          return true;
      }
      //  .......
      return false;
  }
}</code></pre><p>  同样我们会定义日志记录的工具类LogDAO及写入日志方法addOpLog。这时候我们就需要找出需要需要校验参数和添加日志的方法进行一一添加。</p>
</li>
<li><p>而按照AOP的实现方式，是把这些横跨并嵌入众多模块的类方法集中起来，放到一个统一的地方来控制和管理，而我们只需要在这个唯一的地方进行参数的校验和日志的添加即可。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>OOP</th>
<th>AOP</th>
</tr>
</thead>
<tbody><tr>
<td>方法参数校验</td>
<td>所有功能模块单独添加</td>
<td>能够将同一个关注点聚焦在一处解决</td>
</tr>
<tr>
<td>增加日志</td>
<td>所有功能模块单独添加</td>
<td>能够将同一个关注点聚焦在一处解决</td>
</tr>
<tr>
<td>修改日志</td>
<td>功能代码分散，不方便调试</td>
<td>能够实现一处修改，处处生效</td>
</tr>
</tbody></table>
<h3 id="实现方式及使用"><a href="#实现方式及使用" class="headerlink" title="实现方式及使用"></a>实现方式及使用</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h4 id="APT（Annotation-Processing-Tool）"><a href="#APT（Annotation-Processing-Tool）" class="headerlink" title="APT（Annotation Processing Tool）"></a>APT（Annotation Processing Tool）</h4><p>是一种编译器注解技术。他通过定义注解和处理器来实现编译期生成代码的功能，并且将生成的代码和源代码一起编译成.class文件。通过APT技术我们可以将横切关注点封装到注解处理器中，从而实现横向切面和业务主体的分离。</p>
<h5 id="在使用APT之前我们需要了解他的一些相关知识"><a href="#在使用APT之前我们需要了解他的一些相关知识" class="headerlink" title="在使用APT之前我们需要了解他的一些相关知识"></a>在使用APT之前我们需要了解他的一些相关知识</h5><ol>
<li><p>Element<br>Element是一种在编译期间描述.java文件静态结构的一种类型，它可能表示一个package，一个class，一个filed，一个method。Element的比较应该使用equals，因为编译器间同一个Element可能会用两个对象表示.<br><img src="/images/169dd37cf73b8b6c.png" alt><br>我们通过Element便可以获取所有需要的类结构中的所有信息，十分有用的方法：</p>
<pre><code>public interface Element extends AnnotatedConstruct {
 //获取父Element
 Element getEnclosingElement();
 //获取子Element的集合
 List&lt;? extends Element&gt; getEnclosedElements();
 // 获取语言定义的类型
 TypeMirror asType()
}</code></pre></li>
<li><p>TypeMirror<br>Element中有个asType()方法用来返回TypeMirror。TypeMirror表示java编程语言中的类型，这些类型包括基本类型，声明类型(类、接口)，数组类型，类型变量和null类型。还可以表示通配符类型参数，executable的签名和返回类型，以及对应于包和关键字的void的伪类型。我们一般用TypeMirror于类型判断。如下Activity的类型判断：</p>
<pre><code>public interface TypeMirror extends javax.lang.model.AnnotatedConstruct {
 // 可获取获取类型，如boolean， byte，short，int等等
 TypeKind getKind();
}s
/**
* 类型相关工具类
*/
private Types typeUtils;
/**
* 元素相关的工具类
*/
private Elements elementUtils;
private static final String ACTIVITY_TYPE = &quot;android.app.Activity&quot;;
private boolean isSubActivity(Element element){
 //获取当前元素的TypeMirror
 TypeMirror elementTypeMirror = element.asType();
 //通过工具类Elements获取Activity的Element，并转换为TypeMirror
 TypeMirror viewTypeMirror = elementUtils.getTypeElement(ACTIVITY_TYPE).asType();
 //用工具类typeUtils判断两者间的关系
 return typeUtils.isSubtype(elementTypeMirror,viewTypeMirror)
}</code></pre></li>
<li><p>Types, typeUtil是类型相关的工具类，主要用于与TypeMirror结合使用，常用方法有</p>
<pre><code>public interface Types {
 // 将类型转化为对应的程序元素
 Element asElement(TypeMirror t);
 // 比较类型是否相同
 boolean isSameType(TypeMirror t1, TypeMirror t2);
 // t1是否是t2子类型
 boolean isSubtype(TypeMirror t1, TypeMirror t2);
 // t1是否是t2的父类型
 boolean isAssignable(TypeMirror t1, TypeMirror t2);
 // t1是否包含t的类型，，如t1是一个类元素的typeMirror,他的内部元素包含属性，方法等
 boolean contains(TypeMirror t1, TypeMirror t2);
 // .....
}</code></pre></li>
<li><p>Elements, elementUtil是元素相关的工具类，常用方法有</p>
<pre><code>public interface Elements {
 // 通过全限定名，获取包元素
 PackageElement getPackageElement(CharSequence name);

 // 通过全限定名，获取类元素
 TypeElement getTypeElement(CharSequence name);

 //  获取包元素
 PackageElement getPackageOf(Element type);

 // 获取类元素的所有成员元素
 List&lt;? extends Element&gt; getAllMembers(TypeElement type);

 // ......
}</code></pre></li>
<li><p>具体实战可以参考ButterKnife、Dagger、ARouter、EventBus3、DataBinding、AndroidAnnotation，框架的实现方式可以分几步</p>
<ul>
<li>自己定义代码结构</li>
<li>通过apt生成代码</li>
<li>定义Manager管理器进行初始化，传入目标对象进行逻辑代码的初始化</li>
</ul>
</li>
<li><p>demo参考,其中代码生的比较繁琐，基于字符拼接容易错，推荐使用Square的<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet</a>库，提供了非常友好的api</p>
<pre><code>自动生成xxx$$Proxy.java文件
public class MainActivity$$Proxy {
 public static Class&lt;?&gt; findTargetClass(String path) {
     if (path.equals(&quot;ddasdas&quot;)) {
         return MainActivity.class;
     }
     return null;
 }
}
//代码生成器
public class ParamaterCheckApt extends AbstractProcessor {

 // 操作Element工具类 (类、函数、属性都是Element)
 private Elements elementUtils;

 // type(类信息)工具类，包含用于操作TypeMirror的工具方法
 private Types typeUtils;

 // Messager用来报告错误，警告和其他提示信息
 private Messager messager;

 // 文件生成器 类/资源，Filter用来创建新的源文件，class文件以及辅助文件
 private Filer filer;

 // 该方法主要用于一些初始化的操作，通过该方法的参数ProcessingEnvironment可以获取一些列有用的工具类
 @Override
 public synchronized void init(ProcessingEnvironment processingEnvironment) {
     super.init(processingEnvironment);
     S// ....
 }

 /**
  * 相当于main函数，开始处理注解
  * 注解处理器的核心方法，处理具体的注解，生成Java文件
  * @param annotations 使用了支持处理注解的节点集合
  * @param roundEnv 当前或是之前的运行环境,可以通过该对象查找找到的注解。
  * @return true 表示后续处理器不会再处理（已经处理完成）
  */
 @Override
 public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
     if (annotations.isEmpty()) {
         return false;
     }
     Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(Arouter.class);
     for (Element element : elements) {
         // 通过类节点获取包节点
         String packageName = elementUtils.getPackageOf(element).getQualifiedName().toString();
         // 获取简单类名
         String className = element.getSimpleName().toString();
         messager.printMessage(Diagnostic.Kind.NOTE, &quot;被注解的类有：&quot; + className);
         String finalClassName = className + &quot;$$Proxy&quot;;
         try {
             JavaFileObject sourceFile = filer.createSourceFile(packageName + &quot;.&quot; + finalClassName);
             // 定义Writer对象，开启写入
             Writer writer = sourceFile.openWriter();
             // 设置包名
             writer.write(&quot;package &quot; + packageName + &quot;;\n&quot;);

             writer.write(&quot;public class &quot; + finalClassName + &quot; {\n&quot;);

             writer.write(&quot;public static Class&lt;?&gt; findTargetClass(String path) {\n&quot;);

             // 获取类之上@ARouter注解的path值
             Arouter aRouter = element.getAnnotation(Arouter.class);

             writer.write(&quot;if (path.equals(\&quot;&quot; + aRouter.path() + &quot;\&quot;)) {\n&quot;);

             writer.write(&quot;return &quot; + className + &quot;.class;\n}\n&quot;);

             writer.write(&quot;return null;\n&quot;);

             writer.write(&quot;}\n}&quot;);

             // 最后结束别忘了
             writer.close();
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
     return false;
 }
}</code></pre></li>
<li><p>生成的代码可以在project/项目(app)/build/generated/source/apt/ 下面可以找到</p>
</li>
</ol>
<h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><ul>
<li>是一种编译器，它在Java编译器的基础上增加了关键字的识别和编译方法，因此AspectJ可以织入Java代码。他还提供了AspectJ程序，在编译期间将开发者编写的AspectJ程序织入到目标程序中。它的核心是ajc(aspectjtools编译器)和weaver(织入器aspectjweaver)。</li>
<li>aspectjtools编译器是基于java编译器之上的，可以编译.aj文件，在java编译器之上加了关键字和方法，因此也可以编译java代码</li>
<li>weaver织入器：为了在java编译器上使用AspectJ而不依赖于AJC编译器，AspectJ5出现了@AspectJ，使用注解的方式去编写AspectJ代码，可以在任何java编译器上使用。在代码编译期间扫描目标程序，根据切点(PointCut)匹配，将开发者编写的Aspect程序编织到目标程序的.class文件中，对目标程序作了重构（重构的单位是JoinPoint），目的就是建立目标程序的与Aspect程序的连接（获取执行对象，方法，参数等上下文），从而达到Aop的目的</li>
</ul>
<h5 id="Aspect的一些术语"><a href="#Aspect的一些术语" class="headerlink" title="Aspect的一些术语"></a>Aspect的一些术语</h5><ol>
<li><p>切面(Aspectj): 即一个关注点的模块化，这个关注点可能横跨多个对象，其实就是公共功能的实现。如日志切面，权限切面，事物切面等。</p>
</li>
<li><p>通知（Advice）：是切面的具体实现。以目标方法为参照点，根据放置的位置不同，可以分为：</p>
<ul>
<li>前置通知(before)</li>
<li>后置通知(after)</li>
<li>异常通知(AfterThrowing)</li>
<li>最终通知(AfterReturning)</li>
<li>环绕通知(Around)</li>
</ul>
</li>
<li><p>在实际应用中通常是切面类中的一个方法，具体哪个则取决于配置。</p>
<ul>
<li>切入点（PointCut）： 用于定义通知应该切入到那些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配依赖于切入点的正则表达式定义。连接点JointPoint：就是程序在运行过程中能够切入到切面的地点。列如： 方法调用，异常抛出修改字段等。</li>
<li>目标对象（Target Object）：包含连接点的对象，也被称作被通知或者被代理的对象，这些对象只剩下干干净净的核心业务逻辑代码，所有共有功能的代码等则是等待Aop的切入</li>
<li>AOP代理（AOP Proxy）：将通知应用到目标对象之后动态的创建对象。代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能</li>
<li>织入(Weaving): 将切面应用到目标对象从而创建一个新的代理对象的过程，这个过程可以发生在编译期，类装载期及运行期，不同的时期有着不同的条件。如AspectJ则需要一种支持AOP的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；发生在运行期，则可直接通过java语言的反射机制与动态代理机制来实现</li>
</ul>
</li>
<li><p>AspectJ中的Join Point</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Join Points</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>method call</td>
<td>函数调用</td>
<td>比如Log.e()调用的地方是一个joinPoint</td>
</tr>
<tr>
<td>method execution</td>
<td>函数执行</td>
<td>比如Log.e()的内部执行，是一出joinPoint</td>
</tr>
<tr>
<td>constructor call</td>
<td>构造函数的调用</td>
<td>s 和method call 类似</td>
</tr>
<tr>
<td>constructor execution</td>
<td>构造函数的执行</td>
<td>和method execution类似</td>
</tr>
<tr>
<td>field get</td>
<td>获取某个变量</td>
<td>比如读取DemoActivity.debug成员</td>
</tr>
<tr>
<td>field set</td>
<td>设置某变量</td>
<td>比如设置DemoActivity.debug变量</td>
</tr>
<tr>
<td>preinitialization</td>
<td>Object 在构造函数中做一些工作</td>
<td>很少使用</td>
</tr>
<tr>
<td>initialization</td>
<td>Object在构造函数中做得工作</td>
<td>很少使用</td>
</tr>
<tr>
<td>static initialization</td>
<td>类初始化</td>
<td>比如类的static{}</td>
</tr>
<tr>
<td>handler</td>
<td>异常处理</td>
<td>比如try catch（xxx）中，对应catch内的执行</td>
</tr>
<tr>
<td>advice execution</td>
<td>AspectJ的内容</td>
<td>…</td>
</tr>
</tbody></table>
<ol start="5">
<li>PointCut基于正则表达式@注解 访问权限 返回值的类型 包名.函数名(参数),call(public  *  <em>.println(..))<br>是匹配一个方法，第一个</em>表示方法的返回值，第二个*表示方法的包名，(..)表示方法的参数的样子，..代表任意个数，任意类型的参数</li>
</ol>
<ul>
<li>*表示任何数量的字符，除了(.)</li>
<li>..表示任何数量的字符包括任何数量的(.)</li>
<li>+描述指定类型的任何子类或者子接口</li>
<li>同java一样，提供了一元和二元的条件表达操作符。<br>s一元操作符：!<br>二元操作符：||和&amp;&amp;</li>
<li>参考<a href="https://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="noopener">深入理解Android之Aop</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习</title>
    <url>/shu-ju-ku-xue-xi.html</url>
    <content><![CDATA[<h3 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h3><ol>
<li>第一：原子性， 即不可拆分</li>
<li>第二：唯一性， id</li>
<li>第三：避免冗余性</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp的学习</title>
    <url>/okhttp-de-xue-xi.html</url>
    <content><![CDATA[<h3 id="学习大纲"><a href="#学习大纲" class="headerlink" title="学习大纲"></a>学习大纲</h3><ol>
<li>OSI七层模型介绍，TCP/IP模型介绍，Http协议的格式介绍</li>
<li>OkHttp主线流程的源码阅读</li>
<li>OkHttp源码阅读之线程池详解</li>
<li>OkHttp责任链模式/建造者模式</li>
<li>OkHttp整体框架</li>
<li>OkHttp之Socket的请求与实现</li>
</ol>
<h3 id="1-网路模型"><a href="#1-网路模型" class="headerlink" title="1. 网路模型"></a>1. 网路模型</h3><ol>
<li>OSI七层模型，数据封装，解封装的过程</li>
<li>TCP/IP模型， 应用层，传输层，网络层， 主机到网络层</li>
<li>Http1.0, 请求响应后会马上断开；Http1.1,添加了keepAlive的长连接保持</li>
<li>get请求，请求行，请求属性集；post请求，请求行，请求属性集，请求体长度，请求体类型</li>
</ol>
<h3 id="2-OkHttp主流程源码阅读"><a href="#2-OkHttp主流程源码阅读" class="headerlink" title="2. OkHttp主流程源码阅读"></a>2. OkHttp主流程源码阅读</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>1. 创建OkHttpClient的实例对象client
2. 创建请求对象Request的实例对象request
3. 通过client.newCall(request)获取到请求对象call
4. 通过请求对象call进行同步call.execute()请求或者call.enqueue(new CallBack())的异步请求</code></pre><h4 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h4><pre><code>1. 通过构建者设计模式，创建出OkHttpClient的实例
2. 同样通过构建者设计模式，创建出Request的实例
3. client.newCall(request)内部通过Call的实现类RealCall，返回call的对象
4. 进行异步请求call.enqueue(new CallBack())不能重复请求，会调用分发器dispatcher.enqueue(new AsyncCall(responseCallback))
5. 在dispatcher中定义了双端的runningAsyncCalls和readyAsyncCalls及限制了同时访问同一个服务器为最大5个
6. 通过线程池调用executor.execute(asyncCall), asyncCall实现了Runnable
7. AsyncCall内部执行耗时execute方法，会调用责任链获得响应response
8. 成功与失败的回调，并且进行错误责任的划分</code></pre><h3 id="3-OkHttp源码阅读之线程池详解"><a href="#3-OkHttp源码阅读之线程池详解" class="headerlink" title="3. OkHttp源码阅读之线程池详解"></a>3. OkHttp源码阅读之线程池详解</h3><pre><code>public synchronized ExecutorService executorService() {
    if (executorService == null) {
      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
          new SynchronousQueue&lt;&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));
    }
    return executorService;
  }</code></pre><ol>
<li>OkHttp中使用的线程池，采用了缓存方案。线程任务60s内执行完毕，则会复用线程。自定义线程工厂</li>
<li>守护线程的设置</li>
</ol>
<h3 id="4-OkHttp责任链模式-建造者模式"><a href="#4-OkHttp责任链模式-建造者模式" class="headerlink" title="4. OkHttp责任链模式/建造者模式"></a>4. OkHttp责任链模式/建造者模式</h3><p>责任链模式关键是，拦截器集合，拦截器的一个管理类，index+1<br>建造者模式关键是构建对象</p>
<h3 id="OkHttp整体框架"><a href="#OkHttp整体框架" class="headerlink" title="OkHttp整体框架"></a>OkHttp整体框架</h3><ol>
<li>http的默认端口是80， https是443</li>
<li>callServerIntercept 建立连接，会做连接池的复用</li>
<li>网络层是在路由器之间的传输ip数据包，数据链路层是交换机间的传输是帧，最后是物理机的比特流的传输</li>
<li>OkHttp封装了Socket,对socket进行了复用，缓存机制</li>
<li>连接池的设计，定义了一个线程池和一个清理连接对象的线程，通过连接对象的空闲时间和允许的最大空闲时间来回收连接池</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>组件化总结</title>
    <url>/zu-jian-hua-zong-jie.html</url>
    <content><![CDATA[<h4 id="library和phone的区别"><a href="#library和phone的区别" class="headerlink" title="library和phone的区别"></a>library和phone的区别</h4><ol>
<li>library 是集成化，phone是组件化</li>
<li>library中是apply plugin: ‘com.android.android’，且没有applicationId，phone是apply plugin: ‘com.android.application’，有applicationId</li>
<li>library不能单独运行和单独打包，phone可以</li>
</ol>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li>定义config.gradle,统一配置信息及，定义是否为isRelease开关(是否为发布版本)</li>
<li>在每个模块里做isRelease判断，是否是library，修改组件和集成库的区别</li>
<li>组件时debug代码的配置</li>
</ol>
<h4 id="组件化开发规范"><a href="#组件化开发规范" class="headerlink" title="组件化开发规范"></a>组件化开发规范</h4><p>组件前缀</p>
<h4 id="module之间的交互"><a href="#module之间的交互" class="headerlink" title="module之间的交互"></a>module之间的交互</h4><ol>
<li>EventBus 必须一对一，若一对多将混乱不堪难以维护</li>
<li>反射  维护成本高，容易出现高版本@hide限制</li>
<li>隐式意图，需要维护manifest</li>
<li>BroadcastReceiver ，7.0后需要动态注册，需求方发送广播</li>
<li>类加载，需要准确的全类名，维护成本高容易出错</li>
</ol>
<h4 id="注解处理器的APT的应用"><a href="#注解处理器的APT的应用" class="headerlink" title="注解处理器的APT的应用"></a>注解处理器的APT的应用</h4><ol>
<li>简单来说是一种按一定规则，自动生成代码的工具</li>
<li>需要了解他的程序元素Element包括：PackageElement包元素，TypeElement类或接口元素，VariableElement属性字段参数元素，ExecutableElement方法(包括构造，静态方法)元素</li>
<li>Android studio 及 gradle的 版本兼容 1.as3.3.2 gradle 4.10.1(临界版本)  2. as3.4.1 gradle5.1.1(向下兼容)</li>
<li>定义需扫描的注解类</li>
<li>创建注解处理器@AutoService(Processor.class)，指定支持的注解，编译的java版本及注解处理器接受内容的参数</li>
<li>通过获取节点，定义包名及新的class名称，通过filter创建一个JavaFileObject对象</li>
<li>获取JavaFileObject的Write对象，进行一行一行的写入文件</li>
</ol>
<h4 id="JavaPoet的应用"><a href="#JavaPoet的应用" class="headerlink" title="JavaPoet的应用"></a>JavaPoet的应用</h4><p>JavaPoet是square推出的开源的java代码自动生成框架，提供javaApi生成Java文件</p>
<ol>
<li>MethodSpec生成方法</li>
<li>TypeSpec生成类或者接口class</li>
<li>JavaFile创建java文件</li>
<li>Element的子类，包括TypeElement, PackageElement等等表示程序可操作的元素，包括类，方法，属性，包等</li>
<li>TypeMirror,获取类的所有信息，可以判断子类关系</li>
</ol>
<h4 id="Arouter的源碼分析"><a href="#Arouter的源碼分析" class="headerlink" title="Arouter的源碼分析"></a>Arouter的源碼分析</h4><h5 id="1-初始化過程ARouter-init-gt-Arouter-init-gt-LogisticsCenter-init"><a href="#1-初始化過程ARouter-init-gt-Arouter-init-gt-LogisticsCenter-init" class="headerlink" title="1. 初始化過程ARouter.init -&gt; Arouter.init -&gt; LogisticsCenter.init()"></a>1. 初始化過程ARouter.init -&gt; <em>Arouter.init -&gt; LogisticsCenter.init()</em></h5><pre><code>* 在该方法中会进行APT生成文件的dex文件的扫码，加载所有的class文件，保存到routerMap对像并保存到sp中（第一次启动比较慢），同时开启了线程池每个dex的加载都会创建一个线程，最后放入缓存对象Warehouse的map中
* 在 LogisticsCenter.init() -&gt; _Arouter.afterInit()内部会创建拦截器对象interceptorService</code></pre><h4 id="路由的设计及应用"><a href="#路由的设计及应用" class="headerlink" title="路由的设计及应用"></a>路由的设计及应用</h4><p>参考Arouter</p>
<ol>
<li>组件间的跳转</li>
<li>组件间的值传递</li>
<li>获取其他组件的资源及实习方法</li>
<li>对未安装组件的拦截</li>
</ol>
<h4 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h4><p>存在问题</p>
<ol>
<li>各模块的service耦合度高</li>
<li>模块间的跳转都类名</li>
<li>数据的传输是调用方法的</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder的学习</title>
    <url>/binder-de-xue-xi.html</url>
    <content><![CDATA[<h3 id="进程通讯的方式"><a href="#进程通讯的方式" class="headerlink" title="进程通讯的方式"></a>进程通讯的方式</h3><ol>
<li>管道，耗性能</li>
<li>共享内存，多进程访问，管理混乱</li>
<li>Socket适用于网络通讯，进程通讯不适用</li>
</ol>
<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><ol>
<li>binder机制为每个进程都分配了UID和PID来作为鉴别身份的标识，安全性</li>
<li>对数据只进行了一次拷贝，通过驱动的内核空间拷贝数据，不需要额外的同步处理</li>
<li>使用简单C/S架构，实现面向对象的调用方式即在使用binder时，就和调用1个本地对象实例一样</li>
</ol>
<h4 id="Binder的四个重要角色"><a href="#Binder的四个重要角色" class="headerlink" title="Binder的四个重要角色"></a>Binder的四个重要角色</h4><ol>
<li>server</li>
<li>Client</li>
<li>ServiceMannager</li>
<li>Binder驱动(存在线程池 16个)，具体实现通过内存映射，内部调用了mmap()函数<br>前三者在用户空间，Binder驱动在内核空间</li>
</ol>
<h4 id="AIDL接口定义语言"><a href="#AIDL接口定义语言" class="headerlink" title="AIDL接口定义语言"></a>AIDL接口定义语言</h4><p>是对Binder通讯的封装<br>IBinder代表有能力进行快进程的能力<br>IIterface 拥有了Binder机制的能力，只有一个asBinder的方法<br>Binder<br>Stub 本地对象</p>
<h4 id="Binder的源码分析"><a href="#Binder的源码分析" class="headerlink" title="Binder的源码分析"></a>Binder的源码分析</h4><ol>
<li>打开binder设备<pre><code>frameworks /native /cmds /servicemanager /service_manager.c
driver = &quot;/dev/binder&quot;;  //返回文件描述符</code></pre></li>
<li>buffer的创建(用于进程间数据传递)<pre><code>bs = binder_open(driver, 128*1024); binder，创建128k的那内存映射</code></pre></li>
<li>开辟内存呢映射128k<pre><code>frameworks /native /cmds /servicemanager /binder.c
bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);
mmap()命令
device /google /cuttlefish_kernel /4.4-x86_64 /System.map
在系统启动的时候开辟了内存映射</code></pre></li>
<li>serviceManager的启动<pre><code>system /core /rootdir /init.rc
start servicemanager
在系统启动的时候做了启动服务</code></pre></li>
<li>打包Parcel,数据写入binder驱动，copy_from_user<pre><code>打包Parcel
frameworks native libs binder IServiceManager.cpp
addService
</code></pre></li>
</ol>
<p>数据写入binder驱动<br>frameworks native libs binder IPCThreadState.cpp<br>writeTransactionData</p>
<pre><code>6. 服务注册，添加到链表SVClist中
7. 定义主线程中的线程池
8. 循环从mIn和mOut中读和写数据请求，发到binder设备中

### 三方登录实例
A应用client端，B应用为Server端。A调用B进行登录。两应用aidl文件的包名必须一致
#### A应用
1. 创建ILoginInterface.aidl</code></pre><p>// ILoginInterface.aidl<br>package com.netease.binder;</p>
<p>// Declare any non-default types here with import statements</p>
<p>interface ILoginInterface {</p>
<pre><code>// 登录
void login();

// 登录返回
void loginCallback(boolean loginStatus, String loginUser);</code></pre><p>}</p>
<pre><code>2. 在A应用中建立Binder连接,记得销毁</code></pre><p>public void initBindService() {<br>        Intent intent = new Intent();<br>        // 设置Server应用Action<br>        intent.setAction(“BinderB_Action”);<br>        // 设置Server应用包名（5.1+要求）<br>        intent.setPackage(“com.netease.binder.b”);<br>        // 开始绑定服务<br>        bindService(intent, conn, BIND_AUTO_CREATE);<br>        // 标识跨进程绑定<br>        isStartRemote = true;<br>    }</p>
<pre><code>// 服务连接
private ServiceConnection conn = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        iLogin = ILoginInterface.Stub.asInterface(service);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {

    }
};</code></pre><pre><code>3. 因为需要接受B进程返回的数据，需要同样创建一个服务，</code></pre><p>package com.netease.binder.a.service;</p>
<p>import android.app.Service;<br>import android.content.Intent;<br>import android.os.IBinder;<br>import android.os.RemoteException;<br>import android.util.Log;</p>
<p>import com.netease.binder.ILoginInterface;</p>
<p>public class MyService extends Service {</p>
<pre><code>@Override
public IBinder onBind(Intent intent) {

    return new ILoginInterface.Stub() {
        @Override
        public void login() throws RemoteException {
        }

        @Override
        public void loginCallback(boolean loginStatus, String loginUser) throws RemoteException {
            Log.e(&quot;netease &gt;&gt;&gt; &quot;, &quot;loginStatus: &quot; + loginStatus + &quot; / loginUser: &quot; + loginUser);
        }
    };
}</code></pre><p>}</p>
<pre><code>#### B应用
1. 创建ILoginInterface.aidl
2. 创建对应的service服务</code></pre><p>public class MyService extends Service {</p>
<pre><code>@Override
public IBinder onBind(Intent intent) {

    return new ILoginInterface.Stub() {
        @Override
        public void login() throws RemoteException {
            Log.e(&quot;netease &gt;&gt;&gt; &quot;, &quot;BinderB_MyService&quot;);
            // 单项通信有问题，真实项目双向通信，双服务绑定
            serviceStartActivity();
        }

        @Override
        public void loginCallback(boolean loginStatus, String loginUser) throws RemoteException {
        }
    };
}

/**
 * 在Service启动Activity，需要配置：.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 */
private void serviceStartActivity() {
    Intent intent = new Intent(this, MainActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivity(intent);
}</code></pre><p>}</p>
<pre><code>3. 在AndroidManifest配置文件中注册服务</code></pre><!--
                 代表在应用程序里，当需要该service时，会自动创建新的进程。
                 android:process=":remote"

                 是否可以被系统实例化
                 android:enabled="true"

                 代表是否能被其他应用隐式调用
                 android:exported="true"
        -->
<pre><code>    &lt;service
        android:name=&quot;.service.MyService&quot;
        android:enabled=&quot;true&quot;
        android:exported=&quot;true&quot;
        android:process=&quot;:remote_service&quot;&gt;

        &lt;intent-filter&gt;
            &lt;!-- 激活 MyService 唯一name，不能重名--&gt;
            &lt;action android:name=&quot;BinderB_Action&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/service&gt;</code></pre><pre><code>4. 当A请求登录时，会唤起B应用打开登录界面，当输入完登录信息后需要将登录结果返回给A应用，因此同样需要A应用有一个跨进程服务接受B进程的登录结果，所以同样在B中创建Ade服务连接</code></pre><p>public void initBindService() {<br>        Intent intent = new Intent();<br>        // 设置Server应用Action<br>        intent.setAction(“BinderA_Action”);<br>        // 设置Server应用包名（5.1+要求）<br>        intent.setPackage(“com.netease.binder.a”);<br>        // 开始绑定服务<br>        bindService(intent, conn, BIND_AUTO_CREATE);<br>        // 标识跨进程绑定<br>        isStartRemote = true;<br>    }</p>
<pre><code>// 服务连接
private ServiceConnection conn = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        iLogin = ILoginInterface.Stub.asInterface(service);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {

    }
};</code></pre><p>```</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler解析</title>
    <url>/handler-jie-xi.html</url>
    <content><![CDATA[<h4 id="Handler的几个问题"><a href="#Handler的几个问题" class="headerlink" title="Handler的几个问题"></a>Handler的几个问题</h4><ol>
<li>Handler内存泄漏的测试<br>在消息未发送之前，将activity销毁，需要remove消息及将handler赋值为null</li>
<li>为什么不能在子线程创建Handler<br>在子线程中直接new Handler，会获取当前线程的Looper，但我们并没有穿件Looper</li>
<li>textView.setText()只能在主线程执行？<br>是的，因为setText()会刷新界面，调用requestLayout及invalidate，内部会做是否为主线程的检查</li>
<li>new Handler()两种写法有什么区别？<br>直接new Handler 重写他的handlerMessage()方法不推荐，通过new Handler(new Handler.CallBack)是推荐做法 CallBack接口的handlerMessage方法应返回为true</li>
<li>ThreadLocal用法和原理<br>ThreadLocal 内部是一个Map对象，保存着key和value，可以为当前的线程，value为线程保存的值</li>
</ol>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ol>
<li>从应用的创建：ActivityThread.main() -&gt; Looper.preMainLooper-&gt; 这时候ThreadLocal.get() = null -&gt;会创建主线程的Looper对象及唯一关联的MessageQueue</li>
<li>当在主线程中new Handler()时 -&gt; 内部回调Looper.myLooper获取到主线程的Looper-&gt; 将looper的messagequeue赋值给Handler的变量 -&gt; 当handler调用sendMessage -&gt; queue.enqueueMessage()</li>
<li>在ActivityThread.main() -&gt; 会调用Looper.loop()方法 -&gt; 从消息队列中获取消息 -&gt;</li>
<li>调用message.target.dispachMessage -&gt; target即Handler，则会调用handler中的dispatch方法 -&gt; 最终掉用handler的handlerMessage方法</li>
</ol>
<h4 id="解决几个问题"><a href="#解决几个问题" class="headerlink" title="解决几个问题"></a>解决几个问题</h4><ol>
<li>为什么主线程用Looper死循环不会引发ANR异常<br>因为Looper.next开启死循环的时候，一旦需要等待时或者还没有执行到执行的时候，会调用NDK里的JNI方法，释放当前的时间片，这样就不会引发ANR异常</li>
<li>为什么Handler构造方法里面的Looper不是直接new？<br>因为直接new出来不一定能保证唯一，只有用Looper.prepare才能保证唯一性</li>
<li>MessageQueue为什么要放在Looper的私有构造方法里初始化<br>因为一个线程只能由一个Looper，所以在构造方法里初始化也就能保证MessageQueue的唯一性</li>
<li>主线程里的Looper.prepare/Looper.loop,是一直在无限循环里面的吗<br>是的</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Android架构MVX</title>
    <url>/android-jia-gou-mvx.html</url>
    <content><![CDATA[<h3 id="MVC架构设计"><a href="#MVC架构设计" class="headerlink" title="MVC架构设计"></a>MVC架构设计</h3><h4 id="流程关系"><a href="#流程关系" class="headerlink" title="流程关系"></a>流程关系</h4><ol>
<li>View接受用户交互事件</li>
<li>View将用户的操作，交给Controller</li>
<li>Controller完成具体业务逻辑</li>
<li>得到封装好的Model,再进行View的更新</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Controller是作为媒介，处于Model和View之前，Model和View之间有紧密的联系，耦合性强<br>Controller做的事情过多，违反了面向对象的单一职责原则 </p>
<h3 id="MVP架构设计"><a href="#MVP架构设计" class="headerlink" title="MVP架构设计"></a>MVP架构设计</h3><h4 id="流程关系-1"><a href="#流程关系-1" class="headerlink" title="流程关系"></a>流程关系</h4><ol>
<li>View接受用户交互事件</li>
<li>View把用户的操作交给了Presenter</li>
<li>presenter控制Model进行业务逻辑的处理</li>
<li>presenter处理完毕后，数据封装进Model</li>
<li>presenter收到通知后，再更新数据</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>双向通信方式</p>
<ol>
<li>View层与Model层完全解耦</li>
<li>所有的逻辑都交给Presenter处理</li>
<li>MVP分层较为严谨</li>
</ol>
<h4 id="MVVM架构设计"><a href="#MVVM架构设计" class="headerlink" title="MVVM架构设计"></a>MVVM架构设计</h4><h4 id="流程关系-2"><a href="#流程关系-2" class="headerlink" title="流程关系"></a>流程关系</h4><ol>
<li>View接受用户数据</li>
<li>View把用户的操作交给了ViewModel</li>
<li>ViewModel控制Model进行业务处理</li>
<li>ViewModel处理完毕后，数据封装进Model，刷新View</li>
</ol>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>降低耦合度：一个ViewModel层可以绑定不同的View层，当Model变化时View可以不变</li>
<li>可以把一些视图逻辑放在ViewModel层中，让很多View可以重用这些视图逻辑</li>
</ol>
<h4 id="dataBinding的使用"><a href="#dataBinding的使用" class="headerlink" title="dataBinding的使用"></a>dataBinding的使用</h4><p>1.gradle文件添加，支持</p>
<pre><code>// 添加DataBinding依赖
    dataBinding{
        enabled = true
    }</code></pre><ol start="2">
<li>布局文件中，添加最外层layout根布局<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;/layout&gt;</code></pre></li>
<li>添加定义data标签，定义数据及数据来源<pre><code>&lt;!-- 定义该View（布局）需要绑定的数据来源 --&gt;
 &lt;data&gt;
     &lt;variable
             name=&quot;user&quot;
             type=&quot;com.zyx.cherish.mvp.bean.UserInfo&quot; /&gt;
 &lt;/data&gt;</code></pre></li>
<li>在正常布局中用data中定义的name去使用“@=”是为了实现双向绑定（v -&gt; model）<pre><code>&lt;EditText
             android:layout_width=&quot;wrap_content&quot;
             android:layout_height=&quot;wrap_content&quot;
             android:text=&quot;@={user.name}&quot; /&gt;</code></pre></li>
<li>build之后在activity中通过DatabindinngUtils绑定类与布局,然后就可以设置数据<pre><code>ActivityLoginLayoutBinding viewDataBinding = DataBindingUtil.setContentView(this, R.layout.activity_login_layout);
</code></pre></li>
</ol>
<p>viewDataBinding.setUser(userInfo);</p>
<pre><code>#### 源码分析
**内存消耗的缺点**
1. 会生成大量的object的对象，用到了数组保存数组
2. 每个View会监听数据变化，创建了线程
3. 在刷新时会轮训发送handler消息
在定义布局后通过rebuild，会生成额外的文件，这个是系统通过APT生成的
主要有
1. activity_login_layout-layout.xml 配置文件，可以让dataBing方便查找View
2. activity_login_layout 为每个View添加了Tag如binding_1
3. DataBinderMapperImpl 这个是具体实现绑定类
4. 在DataBindingUtil.setContentView(this, R.layout.activity_login_layout)后会对布局中的控件进行绑定
5. 线程 mRebindRunnable  控件会对M数据修改做监听，来更新V的数据
6. InverseBindingListener 控件自身数据修改即V数据修改，会更新M的数据</code></pre>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title>切面编程</title>
    <url>/qie-mian-bian-cheng.html</url>
    <content><![CDATA[<h4 id="AspectJ-的几个注意"><a href="#AspectJ-的几个注意" class="headerlink" title="AspectJ 的几个注意"></a>AspectJ 的几个注意</h4><ol>
<li>as3.0.1 gradle4.4-all  需要r17(NDK)</li>
<li>as3.2.1 gradle4.6-all</li>
<li>as3.4.0 gradle5.1.1-all 存在过时的api</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>Aspectj</tag>
      </tags>
  </entry>
  <entry>
    <title>几个问题</title>
    <url>/ji-ge-wen-ti.html</url>
    <content><![CDATA[<h4 id="1-fragment的切换有多少种方式，有区别吗"><a href="#1-fragment的切换有多少种方式，有区别吗" class="headerlink" title="1. fragment的切换有多少种方式，有区别吗"></a>1. fragment的切换有多少种方式，有区别吗</h4><ol>
<li>add/remove，replace（remove后add，只有一个），hide/show(较耗性能), attach/detach(不会回收fragment,但会回收里面的View)</li>
<li>只要我们创建了activity一定要在manifest中声明吗<h4 id="3-activity有几种启动模式，各自的使用场景"><a href="#3-activity有几种启动模式，各自的使用场景" class="headerlink" title="3. activity有几种启动模式，各自的使用场景"></a>3. activity有几种启动模式，各自的使用场景</h4></li>
<li>共有四种启动模式</li>
<li>应用的首页，通常是singleTask <h4 id="4-实际开发中文件命名有何规范"><a href="#4-实际开发中文件命名有何规范" class="headerlink" title="4.实际开发中文件命名有何规范"></a>4.实际开发中文件命名有何规范</h4></li>
<li>java文件以系统名结尾，XXXActivity,XXXFragment,XXXApplication</li>
<li>布局名以系统名+业务名+类型， activity_home_layout ,Layout布局文件</li>
<li>类或者方法添加注释<h4 id="5-如何封装框架"><a href="#5-如何封装框架" class="headerlink" title="5. 如何封装框架"></a>5. 如何封装框架</h4></li>
<li>从调用时可变参数的封装</li>
<li>核心部分不变参数及通用方法的设计</li>
<li>回调函数处理，异常处理，线程切换，数据转化的通用设计<h4 id="6-Charles的使用"><a href="#6-Charles的使用" class="headerlink" title="6.Charles的使用"></a>6.Charles的使用</h4></li>
<li>请求拦截，查看请求及响应信息</li>
<li>请求地址的映射(Map),主要用于接口调试</li>
<li>请求参数设置，模拟慢网，超时等情况</li>
<li><h4 id="7-如何有序地做内存分析与优化"><a href="#7-如何有序地做内存分析与优化" class="headerlink" title="7. 如何有序地做内存分析与优化"></a>7. 如何有序地做内存分析与优化</h4><a href="https://juejin.im/post/5b1b5e29f265da6e01174b84" target="_blank" rel="noopener">https://juejin.im/post/5b1b5e29f265da6e01174b84</a><h4 id="8-启动优化"><a href="#8-启动优化" class="headerlink" title="8. 启动优化"></a>8. 启动优化</h4><a href="https://juejin.im/post/5d95f4a4f265da5b8f10714b" target="_blank" rel="noopener">https://juejin.im/post/5d95f4a4f265da5b8f10714b</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Material Design</title>
    <url>/material-design.html</url>
    <content><![CDATA[<h3 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a>Material Design</h3><p>它是一种Google官方推荐的设计规范。正如Android的碎片化，基于Android系统自研发的，拥有独特的交互和视觉效果的手机品牌在国内也是层出不穷，如小米的MIUI，魅族的flyme，锤子的Smartisan等等，这种开发被叫做ROM开发。对于App应用，按照安卓最新的MaterialDesign规范来进行单独的安卓版界面设计，这个是最花时间的，但是是最规范的</p>
<h4 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h4><ol>
<li>FloatActionBar</li>
<li>bottomBar</li>
<li>topBar</li>
<li>Bottom navigation</li>
<li>Navigation drawer</li>
<li>Snackbars<br>…等等</li>
</ol>
<h3 id="CoordinatorLayout的原理"><a href="#CoordinatorLayout的原理" class="headerlink" title="CoordinatorLayout的原理"></a>CoordinatorLayout的原理</h3><p>依赖于NestedScroll的实现，CoordinatorLayout必须实现NestedScrollingParent,滚动对象如RecycleView必须实现NestedScrollingChild，</p>
<h4 id="CardView的原理"><a href="#CardView的原理" class="headerlink" title="CardView的原理"></a>CardView的原理</h4>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Android屏幕适配</title>
    <url>/android-ping-mu-gua-pei.html</url>
    <content><![CDATA[<h3 id="Android的碎片化"><a href="#Android的碎片化" class="headerlink" title="Android的碎片化"></a>Android的碎片化</h3><p>android的碎片化严重，屏幕尺寸不同，分辨率密度，决定了做适配的重要性</p>
<h4 id="常见方式"><a href="#常见方式" class="headerlink" title="常见方式"></a>常见方式</h4><ol>
<li>避免写死控件，使用wrap_content,match_parent</li>
<li>LinearLayout线性布局：权重</li>
<li>RelativeLayout绝对布局</li>
<li>ContrainLayout 约束布局</li>
<li>Percent-support-lib 百分比布局</li>
</ol>
<h4 id="图片资源释放"><a href="#图片资源释放" class="headerlink" title="图片资源释放"></a>图片资源释放</h4><ol>
<li>.9图片或者SVG实现缩放</li>
<li>备用位图匹配不同的分辨率</li>
</ol>
<h4 id="用户流程匹配"><a href="#用户流程匹配" class="headerlink" title="用户流程匹配"></a>用户流程匹配</h4><ol>
<li>根据业务逻辑不同执行不同的跳转</li>
<li>根据别名展示不同的界面</li>
</ol>
<h4 id="限定符适配"><a href="#限定符适配" class="headerlink" title="限定符适配"></a>限定符适配</h4><ol>
<li>分辨率</li>
<li>尺寸</li>
<li>最小屏</li>
<li>横竖屏</li>
</ol>
<h4 id="刘海屏的适配"><a href="#刘海屏的适配" class="headerlink" title="刘海屏的适配"></a>刘海屏的适配</h4><ol>
<li>Android 9.0官方适配</li>
<li>华为，OPPO，vivo </li>
</ol>
<h3 id="适配方式"><a href="#适配方式" class="headerlink" title="适配方式"></a>适配方式</h3><h4 id="限定符适配-1"><a href="#限定符适配-1" class="headerlink" title="限定符适配"></a>限定符适配</h4><p><strong>优点</strong></p>
<ol>
<li>使用简单，无需开发者手动指定</li>
<li>Google推荐使用方式，有系统自行判断</li>
<li>适配通过不同的xml实现，无需代码加逻辑</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>增加APK大小，适配机型越多，xml越多</li>
<li>适配所以，大概增加近3m</li>
<li>不能适配奇葩机型，如手表<h4 id="百分比适配"><a href="#百分比适配" class="headerlink" title="百分比适配"></a>百分比适配</h4></li>
</ol>
<p><strong>优点</strong></p>
<ol>
<li>通过百分比定义宽高，比较方便</li>
<li>彻底抛弃px,dp</li>
<li>开发量小</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>自定义不支持</li>
<li>对代码侵入强<h4 id="修改系统density-densityScale-densityDpi"><a href="#修改系统density-densityScale-densityDpi" class="headerlink" title="修改系统density, densityScale, densityDpi"></a>修改系统density, densityScale, densityDpi</h4><h4 id="代码动态适配"><a href="#代码动态适配" class="headerlink" title="代码动态适配"></a>代码动态适配</h4></li>
</ol>
<h3 id="网易云音乐歌单页面"><a href="#网易云音乐歌单页面" class="headerlink" title="网易云音乐歌单页面"></a>网易云音乐歌单页面</h3><h4 id="Toolbar的使用"><a href="#Toolbar的使用" class="headerlink" title="Toolbar的使用"></a>Toolbar的使用</h4><ol>
<li>4.4之前是使用ActionBar，之后推荐使用Toolbar</li>
<li>Toolbar不符合设计要求，通过反射修改子元素的属性(left,pading等)<h4 id="沉浸式设计"><a href="#沉浸式设计" class="headerlink" title="沉浸式设计"></a>沉浸式设计</h4></li>
<li>沉浸式与非沉浸式的区别是状态栏是否透明，是否与App主题是否一致.<br>通过属性，开启沉浸式后状态栏就会变成浮动的，导致Toolbar向上移动<pre><code>     &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;
     &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;</code></pre>通过代码控制，同样会导致Toolbar向上移动，内容延伸进状态栏</li>
<li>通过自定义设置一个透明的statusBarView，用于定义statusBar的颜色</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>“Android”</category>
      </categories>
      <tags>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title>属性动画</title>
    <url>/shu-xing-dong-hua.html</url>
    <content><![CDATA[<h4 id="动画的种类"><a href="#动画的种类" class="headerlink" title="动画的种类"></a>动画的种类</h4><ol>
<li>平移</li>
<li>透明</li>
<li>旋转</li>
<li>缩放</li>
<li>帧动画</li>
</ol>
<h4 id="动画的设计考虑"><a href="#动画的设计考虑" class="headerlink" title="动画的设计考虑"></a>动画的设计考虑</h4><ol>
<li>面向用户为开发者，因此API尽量简单</li>
<li>一个View有多个动画，但同时只能由一个运行</li>
<li>动画执行不能依赖于自身for循环</li>
<li>如何让动画动起来</li>
</ol>
<h4 id="动画任务"><a href="#动画任务" class="headerlink" title="动画任务"></a>动画任务</h4><ol>
<li>控件</li>
<li>时长</li>
<li>起始值</li>
<li>差值器  </li>
</ol>
<h4 id="在属性动画初始化的的过程中"><a href="#在属性动画初始化的的过程中" class="headerlink" title="在属性动画初始化的的过程中"></a>在属性动画初始化的的过程中</h4><ol>
<li>创建ObjectAnimator对象，保存控件及属性名，</li>
<li>设置关键帧的值，创建PropertyValueHolder, 通过KeyframeSet的ofInt方法将动画分解成不同的关键帧</li>
<li>创建关键帧，Keyframe保存了关键帧的mFraction比例，值没Value及值类型mValueType</li>
<li>估值器的设置，是用来计算关键帧之间具体的值，</li>
<li>差值器的设置是修改某个时间点动画的百分比</li>
</ol>
<h4 id="自定义控件开发思路"><a href="#自定义控件开发思路" class="headerlink" title="自定义控件开发思路"></a>自定义控件开发思路</h4><ol>
<li>观察有哪些动画</li>
<li>哪些元素比较特别，后面有没有可能变更需求</li>
<li>看是否有事件交互</li>
<li>如何设置自定义控件较为合理</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>属性动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Android事件分发源码分析</title>
    <url>/android-shi-jian-fen-fa-yuan-ma-fen-xi.html</url>
    <content><![CDATA[<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="事件分发的类型"><a href="#事件分发的类型" class="headerlink" title="事件分发的类型"></a>事件分发的类型</h4><p>down，move， up，cancel</p>
<h4 id="事件分发序列"><a href="#事件分发序列" class="headerlink" title="事件分发序列"></a>事件分发序列</h4><p>down -&gt; up<br>down -&gt; move -&gt; up</p>
<h4 id="事件分发的对象"><a href="#事件分发的对象" class="headerlink" title="事件分发的对象"></a>事件分发的对象</h4><p>Activity  ViewGroup  View</p>
<h4 id="事件分发的方法"><a href="#事件分发的方法" class="headerlink" title="事件分发的方法"></a>事件分发的方法</h4><p>dispatchTouchEvent()<br>onInterceptTouchEvent()<br>onTouchEvent()</p>
<h4 id="Activity的事件分发"><a href="#Activity的事件分发" class="headerlink" title="Activity的事件分发"></a>Activity的事件分发</h4><ol>
<li>dispatchTouchEvent</li>
<li>PhoneWindow.superDispatchTouchEvent()</li>
<li>DecorView.superDispatchTouchEvent</li>
<li>ViewGroup.dispatchTouchEvent<br>事件由Activity到了ViewGroup，如果View没有消费掉，会调用Activity的onTouchEvent</li>
</ol>
<h4 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h4><ol>
<li>事件从Down开始，接收到Down事件时会做取消并清除touch事件，置空mFistTouchTarget对象，清空Touch标记位</li>
<li>是否拦截判断(除Down时间以外），通过onIntercept，子类可以通过修改requestDisallowInteceptTouchEvent使父容器不拦截事件.默认都会走onInterceptTouchEvent方法，默认返回false</li>
<li>会调用dispatchTranseformdTouchEvent方法,内部会调用子类的dispatchTouchEvent方法或者父类的dispatchTouchEvent的方法</li>
</ol>
<h4 id="View中的事件处理"><a href="#View中的事件处理" class="headerlink" title="View中的事件处理"></a>View中的事件处理</h4><ol>
<li>事件传递到中，会先发判断TouchListener,如果设置了TouchListener,根据回调方法onTouch方法的返回值，做响应处理，若返回true则进行第二步，否则第三步</li>
<li>onTouch中返回true，则意味着事件被消费，onTouchEvent的方法将不再执行，事件结束</li>
<li>onTouch中返回false,则意味着事件没有消费，将继续执行onTouchEvent方法</li>
<li>onTouchEvent会更具事件类型执行不同的逻辑</li>
<li>当事件时down时，会判断是否设置了longClick事件，设置了则会更具到up的时长和longClick方法的返回值去决定是否执行onClickListener方法，修改OnLongClickListener方法的返回值可以使两个方法都执行</li>
</ol>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><h4 id="架构设计思想的需求点"><a href="#架构设计思想的需求点" class="headerlink" title="架构设计思想的需求点"></a>架构设计思想的需求点</h4><ol>
<li>每个界面上的元素都需要有事件响应，那意味着事件的核心处理类不能太多</li>
<li>事件传递的工作不能丢给开发者，只暴露接口</li>
<li>每个控件都可以接受事件和消费事件，如果控件消费了，你那后续事件就交给这个事件了</li>
<li>如何查找会消费事件的控件</li>
<li>如何更具坐标查找该控件的范围</li>
<li>每次发生事件，都需要遍历每个子元素吗？</li>
</ol>
<h5 id="为什么所有的控件都继承字View"><a href="#为什么所有的控件都继承字View" class="headerlink" title="为什么所有的控件都继承字View"></a>为什么所有的控件都继承字View</h5><p>View是事件处理和传递的抽象类，还包括绘制，测量其他代码</p>
<h4 id="事件分发的思考"><a href="#事件分发的思考" class="headerlink" title="事件分发的思考"></a>事件分发的思考</h4><ol>
<li>容器包含很多子控件</li>
<li>子控件和容器都能消费事件</li>
<li>子控件不能进行分发给其他子控件</li>
<li>分发功能只能由容器分发给子控件</li>
</ol>
<h4 id="如何快速查找能响应的控件"><a href="#如何快速查找能响应的控件" class="headerlink" title="如何快速查找能响应的控件"></a>如何快速查找能响应的控件</h4><p>TouchTarget消费对象的缓存队列的设计，利用链表及缓存池，通过链表操作达到复用的效果<br>obtain()方法，内部操作加锁，判断静态变量recycleBin缓存对象TouchTarget是否为空，不为空则取出第一个，否则new出一个TouchTarget.当一系列事件消费完后 ，释放这个对象加入缓存</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码分析及架构</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义UI之Canvas</title>
    <url>/zi-ding-yi-ui-zhi-canvas.html</url>
    <content><![CDATA[<h4 id="Canvas绘制几何图形，文本，位图等"><a href="#Canvas绘制几何图形，文本，位图等" class="headerlink" title="Canvas绘制几何图形，文本，位图等"></a>Canvas绘制几何图形，文本，位图等</h4><ol>
<li>drawBitmap() 在指定坐标绘制位图</li>
<li>drawLine()根据起始点绘制连线</li>
<li>drawPath()根据给定的路径，绘制连线</li>
<li>drawPoint()根据给定的坐标，绘制点</li>
<li>drawText()根据给定的坐标和文本绘制文字<br>…..</li>
</ol>
<h4 id="位置，形状变化等"><a href="#位置，形状变化等" class="headerlink" title="位置，形状变化等"></a>位置，形状变化等</h4><ol>
<li>void translate(float x, float y) 平移操作</li>
<li>void scale() 缩放</li>
<li>void rotate() 旋转</li>
<li>void skew() 倾斜</li>
<li>void clipXXX()剪切</li>
<li>void clipOutXXX()反向剪切</li>
<li>setMatrix(Matrix matrix) 通过matrix实现以上效果</li>
</ol>
<h4 id="Canvas的状态保存"><a href="#Canvas的状态保存" class="headerlink" title="Canvas的状态保存"></a>Canvas的状态保存</h4><p>Canvas内部维护着状态栈，通过save和restore保存恢复<br>离屏绘制saveLayer</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>插件化学习</title>
    <url>/cha-jian-hua-xue-xi.html</url>
    <content><![CDATA[<h4 id="插件化的目的"><a href="#插件化的目的" class="headerlink" title="插件化的目的"></a>插件化的目的</h4><ol>
<li><p>自解耦</p>
</li>
<li><p>免安装</p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>插件化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义UI之Paint</title>
    <url>/zi-ding-yi-ui.html</url>
    <content><![CDATA[<h4 id="Paint画笔"><a href="#Paint画笔" class="headerlink" title="Paint画笔"></a>Paint画笔</h4><p>画笔的实现内部都是调用native方法的，画笔的基础Api</p>
<ol>
<li>setColor(Color.RED)</li>
<li>setARGB(),setAlpha  设置颜色及透明度</li>
<li>setAntiAlias(true) 抗锯齿</li>
<li>setStyle() Paint.Style.STROKE/FILL/FILL_AND_STROKE  描边，填充效果</li>
<li>setStrokeWidth() 描边宽度</li>
<li>setStrokeCap() Paint.Cap.BUTT/ROUND/SQUARE  线尾部形状 默认BUTT,round圆角效果，方形</li>
<li>setStrokeJoin() 拐角效果，MITER/ROUND/BEVEL 默认MITER尖角，圆角，折角</li>
<li>setShader(Shader shader) 设置环形渲染器</li>
<li>setXfermode() 设置图层混合模式</li>
<li>setColorFilter()设置颜色过滤器</li>
<li>setFilterBitmap(true) 设置双线性过滤，使图片更加平滑</li>
<li>setMaskFilter() 设置画笔的遮罩滤镜</li>
<li>setTextScalX(2) 设置缩放文本倍数</li>
<li>setTextSize(38) 设置文本字体大小</li>
<li>setTextAlign() 对齐方式</li>
<li>setUnderLineText(true) 设置下划线</li>
<li>getTextBounds(str, 0, str.length(), rect) 测量文本大小，将文本大小信息存放在rect中</li>
<li>measureText(str) 测量文本的宽</li>
<li>getFontMetrics()获取字体度量对象, 变量包括ascent,descent,top,bottom,leading ,字体的高度为descent - ascennt, leading为行间距是当前字的ascent - 上一个字的descent</li>
</ol>
<h4 id="setShader-Shader-shader-设置环形渲染器-着色器"><a href="#setShader-Shader-shader-设置环形渲染器-着色器" class="headerlink" title="setShader(Shader shader) 设置环形渲染器(着色器)"></a>setShader(Shader shader) 设置环形渲染器(着色器)</h4><ol>
<li>LinearGradient 线性渲染</li>
<li>RadilGradient 环形渲染</li>
<li>SweepGradient 扫描渲染</li>
<li>BitmapGradient 位图渲染</li>
</ol>
<h5 id="TileMode-平铺模式"><a href="#TileMode-平铺模式" class="headerlink" title="TileMode 平铺模式"></a>TileMode 平铺模式</h5><ol>
<li>CLAMP 超出后 以最后像素拉升填充  </li>
<li>REPEAT 超出后重复平铺</li>
<li>MIRROR 镜像填充</li>
</ol>
<h4 id="组合渲染器，图层混合模式Xfermode"><a href="#组合渲染器，图层混合模式Xfermode" class="headerlink" title="组合渲染器，图层混合模式Xfermode"></a>组合渲染器，图层混合模式Xfermode</h4><p><strong>PortorDuff.Mode</strong></p>
<ol>
<li>使用场景<ul>
<li>ComposeShader 组合渲染器</li>
<li>Paint.setXfermode()</li>
<li>porterDuffColorFilter 颜色过滤器</li>
</ul>
</li>
<li>使用注意<ul>
<li>静止硬件加速，14之后图层混合不支持硬件加速，但系统是默认打开的setLayerType(View.LAYER_SOFTWARE, null)</li>
<li>离屏绘制，去除背景等其他干扰,保证xfermode不会出现错误结果saveLayer  ,restoreToCount,<h4 id="setColorFilter"><a href="#setColorFilter" class="headerlink" title="setColorFilter"></a>setColorFilter</h4></li>
</ul>
</li>
</ol>
<p><strong>LightColorFilter</strong><br>颜色过滤器，可以过滤掉指定颜色<br><strong>PorterDuffFilter</strong><br>颜色和其他的图层混合<br><strong>颜色矩阵ColorMatrixColorFilter</strong><br>通过修改颜色矩阵Matrix数组中的值</p>
<h4 id="画笔滤镜总结"><a href="#画笔滤镜总结" class="headerlink" title="画笔滤镜总结"></a>画笔滤镜总结</h4><ol>
<li>简单的模拟光照效果，可以使用LightColorFilter</li>
<li>图像与颜色的，图层混合的实现，PorterDuffColorFilter</li>
<li>颜色数组及颜色举证实现滤镜效果</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义UI</tag>
        <tag>shader</tag>
        <tag>colorFilter</tag>
        <tag>xfermode</tag>
      </tags>
  </entry>
  <entry>
    <title>PPT 制作学习</title>
    <url>/ppt-zhi-zuo-xue-xi.html</url>
    <content><![CDATA[<h5 id="PPT的学习记录"><a href="#PPT的学习记录" class="headerlink" title="PPT的学习记录"></a>PPT的学习记录</h5><h4 id="PPT学习之剪切"><a href="#PPT学习之剪切" class="headerlink" title="PPT学习之剪切"></a>PPT学习之剪切</h4><p>通过剪切可以得到一组图片，作为PPT的背景样式即板式，做到风格统一</p>
<h4 id="PPT之基本四步骤"><a href="#PPT之基本四步骤" class="headerlink" title="PPT之基本四步骤"></a>PPT之基本四步骤</h4><ol>
<li>字体统一</li>
<li>突出标题</li>
<li>颜色取巧</li>
<li>配图</li>
</ol>
<h4 id="PPT之四大技能"><a href="#PPT之四大技能" class="headerlink" title="PPT之四大技能"></a>PPT之四大技能</h4><ol>
<li>复制</li>
<li>清除格式</li>
<li>更改图片</li>
<li>PPT草稿</li>
</ol>
<h4 id="PPT之人物图片处理"><a href="#PPT之人物图片处理" class="headerlink" title="PPT之人物图片处理"></a>PPT之人物图片处理</h4><ol>
<li>聚焦脸部</li>
<li>圆形剪裁</li>
<li>图片装饰</li>
<li>去掉颜色</li>
</ol>
<h4 id="PPT之风格迥异的处理"><a href="#PPT之风格迥异的处理" class="headerlink" title="PPT之风格迥异的处理"></a>PPT之风格迥异的处理</h4><ol>
<li>调节大小，基准线</li>
<li>等比裁剪</li>
<li>横向分布</li>
<li>更换背景</li>
</ol>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>PPT制作</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidUI 加载和绘制流程</title>
    <url>/androidui-jia-zai-he-hui-zhi-liu-cheng.html</url>
    <content><![CDATA[<h3 id="源码总结"><a href="#源码总结" class="headerlink" title="源码总结"></a>源码总结</h3><h4 id="View是如何被添加到屏幕窗口上去的"><a href="#View是如何被添加到屏幕窗口上去的" class="headerlink" title="View是如何被添加到屏幕窗口上去的"></a>View是如何被添加到屏幕窗口上去的</h4><ol>
<li>在Activity的onCreate方法中调用setContentView将我们的布局传入</li>
<li>内部调用了Window的唯一实例对象PhoneWindow的setContentView方法</li>
<li>内部创建了顶层布局容器DecorView</li>
<li>在DecorView中加载了基础布局ViewGroup(主题布局)，</li>
<li>将我们的布局添加到基础布局的FrameLayout中 </li>
</ol>
<h4 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h4><ol>
<li>绘制入口<ul>
<li>ActivityThread.handlerResumeActivity</li>
<li>WindowManagerImpl.addView(decorView, layoutParams)</li>
<li>WindowManagerGlobal.addView()</li>
</ul>
</li>
<li>绘制的类及方法<ul>
<li>ViewRootImpl.addView(decorView, layoutParams, parentView)</li>
<li>ViewRootImpl.requestLayout()-&gt;scheduleTraversals()-&gt;doTraversals()-&gt;performTraversals()</li>
</ul>
</li>
<li>绘制流程的三大步骤<ul>
<li>ViewRootImpl.performMeasure()</li>
<li>ViewRootImpl.performLayout()</li>
<li>ViewRootImpl.performDraw</li>
</ul>
</li>
<li>绘制中的测量<ul>
<li>MeasureSpec的确定及计算: 顶层DecoView和其他View</li>
<li>DecorView通过窗口大小和DecoView本身大小确定</li>
<li>其他View通过父View的MeasureSpec和本身的大小确定</li>
</ul>
</li>
<li>绘制中的布局<ul>
<li>view.layout的方法确定自身的位置</li>
<li>若是ViewGroup类型，需要调用onLayout的方法确定子View的位置</li>
</ul>
</li>
<li>绘制中的绘制<ul>
<li>绘制背景drawableBackground</li>
<li>绘制自己onDraw</li>
<li>绘制子View  dispatchDraw</li>
<li>绘制前景，滚动条装等饰</li>
</ul>
</li>
</ol>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>onMeasure -&gt; onLayout(ViewGroup要实现) -&gt; onDraw(可选，系统控件不用实现)</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidUI</tag>
      </tags>
  </entry>
  <entry>
    <title>插件化</title>
    <url>/cha-jian-hua.html</url>
    <content><![CDATA[<h3 id="VirtualAPK"><a href="#VirtualAPK" class="headerlink" title="VirtualAPK"></a>VirtualAPK</h3><p>是滴滴开源的插件化项目，实现动态加载和运行apk的功能。<br>支持任何class的加载，资源的加载及四大组件<br><img src="https://github.com/didi/VirtualAPK/raw/master/imgs/va.png" alt="架构图"><br>android 插件化框架VitualAPK解析</p>
]]></content>
  </entry>
  <entry>
    <title>阿里镜像</title>
    <url>/a-li-jing-xiang.html</url>
    <content><![CDATA[<h3 id="阿里镜像"><a href="#阿里镜像" class="headerlink" title="阿里镜像"></a>阿里镜像</h3><pre><code>buildscript {
    ext.kotlin_version = &#39;1.2.71&#39;
    repositories {
        // 以下四行代码为阿里gradle 源
        maven{ url &#39;https://maven.aliyun.com/repository/google&#39;}
        maven{ url &#39;https://maven.aliyun.com/repository/gradle-plugin&#39;}
        maven{ url &#39;https://maven.aliyun.com/repository/public&#39;}
        maven{ url &#39;https://maven.aliyun.com/repository/jcenter&#39;}
        google()
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.2.0&#39;
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}

allprojects {
    repositories {
        // 所有的model 都优先使用阿里源
        maven{ url &#39;https://maven.aliyun.com/repository/google&#39;}
        maven{ url &#39;https://maven.aliyun.com/repository/gradle-plugin&#39;}
        maven{ url &#39;https://maven.aliyun.com/repository/public&#39;}
        maven{ url &#39;https://maven.aliyun.com/repository/jcenter&#39;}
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}</code></pre>]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>阿里</tag>
      </tags>
  </entry>
  <entry>
    <title>8月25日</title>
    <url>/8-yue-25-ri.html</url>
    <content><![CDATA[<h4 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h4><ol>
<li>事件分发的对象是MotionEvent,通过触摸屏幕和点击按键产生</li>
<li>事件分发的组件包括Activity，ViewGroup，View以及硬件驱动。</li>
<li>事件传递的方法，Native通过监听，读取dev/input/eventX文件产生新事件，发送给Java层。经过上面提到的组件，主要通过dispatchTouchEvent(),onInterceptTouchEvent(),onTouchEvent()三个方法传递，拦截和消费</li>
<li>Activity和View没有OnInterceptTouchEvent方法，无需拦截事件</li>
<li>在调用子View的dispatchTouchEvent时会判断是否设置了onTouchListener，会回调onTouch方法，返回true则为已经消费了,就不会调用onTouchEvent()的方法及内部的OnClick()方法</li>
<li>处理滑动冲突的方式1.外部拦截：由重写父View在onInterceptTouchEvent()根据业务来判断move事件是否要拦截事件，down和up事件不拦截。2. 内部拦截，父View除了down事件都拦截，然后由子View通过requesDisallowInterceptTouchEvent()来控制父类是否要拦截，或者交给子View处理 </li>
</ol>
]]></content>
      <tags>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title>8月21日</title>
    <url>/8-yue-21-ri.html</url>
    <content><![CDATA[<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>模板方法模式：在模板类中定义算法或任务执行的流程框架，将一些具体步骤延迟到子类中去实现。即可定义出不同的表现类。</p>
<h4 id="项目实例"><a href="#项目实例" class="headerlink" title="项目实例"></a>项目实例</h4><p>在项目中订单类型往往很多，订单的处理方式也是别有不同。现在介绍一个用户扫码点餐后，收银接受订单消息的处理流程。首先看一下流程</p>
<ol>
<li>用户下单：下单来源：支付宝，微信，口碑等，订单类型：堂食，自提，外卖</li>
<li>服务端收到下单请求，定义与之对应的消息推送给收银机</li>
<li>商户在收银机上收到下单消息，进行处理</li>
<li>服务端收到收银的处理结果，推送消息给用户</li>
<li>用户收到消息<br>上面流程在自动审核消息里就是一个通用的过程，因此可以多这个过程制定一个步骤，具体实现由开发者定义。</li>
</ol>
<p>整个流程中收银机处理的就是订单消息。由于订单的来源及订单类型的多种多样，也就意味着存在两方面的不同。1. 订单数据：基础数据+扩展数据 2.业务处理不同，不同的订单类型需要有不同的UI透出和额外的特殊操作。因此我们可以定义一个基础的UI操作类，定义出，获取订单数据，填充数据等</p>
]]></content>
  </entry>
  <entry>
    <title>8月20号</title>
    <url>/8-yue-20-hao.html</url>
    <content><![CDATA[<h4 id="四大引用"><a href="#四大引用" class="headerlink" title="四大引用"></a>四大引用</h4><p>垃圾回收机制在回收对象的时候，会判断是否有引用指向对象</p>
<ol>
<li>强引用</li>
</ol>
<ul>
<li>程序中大部分的对象都是强引用，如果一个对象具有一个强引用指向它，那垃圾回收器是不会回收他的，在内存不足的情况，系统宁愿报outOfMemery也不会回收这些对象</li>
</ul>
<ol start="2">
<li>软引用</li>
</ol>
<ul>
<li>如果一个对象只具有软引用，那内存充足的情况是不会被回收的，但在系统内存不足的情况，垃圾回收器还是会回收的。在未被回收之前，程序能正常使用该对象。软引用和一个引用队列管理，若软应用被回收，就会将软应用加入的引用队列中</li>
</ul>
<ol start="3">
<li>弱引用<br>弱引用和软引用的区别在于，只具有弱引用的对象具有更短的生命周期，当垃圾回收器扫描到弱引用对象时，就会回收掉该对象。无论内存是否充足。回收后同样会将该引用加入到相关联的引用队列中</li>
<li>虚引用</li>
</ol>
<ul>
<li>虚引用顾名思义就是形同虚设，对对象的生命周期毫无影响。一个对象被虚引用指引，就和没有引用一下。会被回收。与软引用和虚引用的区别在于：他必须和引用队列联合使用。唯一目的就是对象被回收的时候收到一个系统通知</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>8月16日</title>
    <url>/8-yue-16-ri.html</url>
    <content><![CDATA[<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ol>
<li>HashMap是线程不安全的</li>
<li>允许key和value为null</li>
<li>不保证存储的有序性</li>
<li>影响HashMap性能的两个变量，init capacity(16)和loadFactor(0.75),load链表长度，减少Hash</li>
<li>faile-fast机制，不允许迭代遍历时remove，add</li>
<li>1.7和1.8jdk版本的数据存储结构.Entry,数组+链表。Node，数组+链表/红黑树</li>
<li>扩容大小2倍，容量为2次幂，方便获取捅数组位置提高效率</li>
<li>HashSet基于HashMap实现，value为object对象</li>
</ol>
<h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><ol>
<li>线程安全，synchronize修饰方法</li>
<li>key，value不为null</li>
<li>不保证有序性</li>
<li>initcapcity(11) loadFactor 0.75</li>
<li>扩容大小2倍+1，容量为奇数或者素数，使哈希更加均匀</li>
</ol>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ol>
<li>并发容器，多线程下更加高效</li>
<li>key或者value不为null</li>
<li>cas无所操作。inittable初始化.SIZECTl，synchronnize</li>
<li>扩容，rehash</li>
</ol>
]]></content>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>8月14日</title>
    <url>/8-yue-14-ri.html</url>
    <content><![CDATA[<h3 id="Android中使用ProtoBuf"><a href="#Android中使用ProtoBuf" class="headerlink" title="Android中使用ProtoBuf"></a>Android中使用ProtoBuf</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Protobuf是一种Google开发的一种格式，这种格式与开发语言无关，与运行平台无关，用于序列化数据结构，并且很容易扩展，可用于通讯协议和数据存储等，类似于XML，json，但是序列化，反序列化，和数据的大小都远远高于其他数据结构。因为他会将具备可读性的key值的信息都进行过滤，转化更加精简的数据。</p>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ol>
<li>数据更加精简</li>
<li>数据大小是json数据的3~10倍</li>
<li>压缩性能是可以提升20~100倍</li>
<li>数据歧义少</li>
<li>代码自动生成<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5>数据大小的减少是。对key值的特殊定义，及数据都转成了16进制。<br>性能的提升，主要针对整形，浮点型的优化处理。字符型相对提升</li>
</ol>
]]></content>
      <tags>
        <tag>Protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>8月13日</title>
    <url>/8-yue-13-ri.html</url>
    <content><![CDATA[<h3 id="Android打包流程"><a href="#Android打包流程" class="headerlink" title="Android打包流程"></a>Android打包流程</h3><p>打包流程包括包含四步骤</p>
<ol>
<li>通过aapt工具打包res资源文件，生成R.java,resources.arsc和res文件</li>
<li>处理.aidl文件，生成对应的java接口文件</li>
<li>通过java compiler编译R.java, java接口文件，java源文件，生成.class文件</li>
<li>通过dex命令，将.class文件和第三方库的.class文件处理称classes.dex</li>
<li>通过apkbuilder工具，将Dex文件，res资源合并成一个APK</li>
<li>通过jarsinger工具，为APK进行签名</li>
<li>通过zipalign工具进行apk的对齐优化</li>
</ol>
<h3 id="自定义Gradle插件"><a href="#自定义Gradle插件" class="headerlink" title="自定义Gradle插件"></a>自定义Gradle插件</h3><ol>
<li>创建一个module，无论phone还是Android Library，因为后面会删掉大部分文件</li>
<li>删除module下的文件及文件夹，只保留空的src/main目录及build.gradle文件</li>
<li>创建groovy文件夹，定义包名。如java项目一样</li>
<li>创建一个类MyPlugin.groovy</li>
<li>在build.build中加入groovy引用和用于上传的maven的引用<pre><code>apply plugin: &#39;groovy&#39;
apply plugin: &#39;maven&#39;
</code></pre></li>
</ol>
<p>dependencies {<br>    //gradle sdk<br>    compile gradleApi()<br>    //groovy sdk<br>    compile localGroovy()<br>}</p>
<p>repositories {<br>    mavenCentral()<br>}<br>group = ‘com.zyx.plugin’<br>version = ‘1.0.0’</p>
<p>uploadArchives {<br>    repositories {<br>        mavenDeployer {<br>            //提交到远程服务器：<br>            // repository(url: “<a href="http://www.xxx.com/repos&quot;" target="_blank" rel="noopener">http://www.xxx.com/repos&quot;</a>) {<br>            //    authentication(userName: “admin”, password: “admin”)<br>            // }<br>            //本地的Maven地址设置为D:/repos<br>            repository(url: uri(‘/Users/zhengyangxin/StudioProjects/myProject/LibraryCollection/pluginrepos’))<br>        }<br>    }</p>
<p>}</p>
<pre><code>6. 插件已经编好，接着需要告诉gradle我们定义了哪个插件，需要创建文件src/main/resources/META-INF/gradle-plugins/XXXX.properties, 这里的XXXX就是外部module引用的名称，在这里我们定义为com.zyx.plugin.properties</code></pre><p>apply plugin: ‘com.zyx.plugin’</p>
<pre><code>7. 然后在XXXX.properties指明我们定义的插件</code></pre><p>implementation-class=com.hc.plugin.MyPlugin</p>
<pre><code>8. 最后可以进行打包一个plugin在本地，通过定义的uploadArchives Task
9. 在需要的modlue中引用自定义的plugin</code></pre><p>apply plugin: ‘com.zyx.plugin’</p>
<p>buildscript {<br>    repositories {<br>        maven {//本地Maven仓库地址<br>            url uri(‘/Users/zhengyangxin/StudioProjects/myProject/LibraryCollection/pluginrepos’)<br>        }<br>    }<br>    dependencies {<br>        //格式为–&gt;group:module:version<br>        classpath ‘com.zyx.plugin:plugin:1.0.0’<br>    }<br>}</p>
<pre><code></code></pre>]]></content>
  </entry>
  <entry>
    <title>8月8日</title>
    <url>/8-yue-8-ri.html</url>
    <content><![CDATA[<h3 id="Android开源框架-Aoppermission"><a href="#Android开源框架-Aoppermission" class="headerlink" title="Android开源框架 Aoppermission"></a>Android开源框架 Aoppermission</h3><p>Aoppermission是基于Aspect实现。实现过程及原理分析。Android的常用Aop有两种方式1.通过JNI Hook，2.静态织入</p>
<h4 id="Acpect基础知识"><a href="#Acpect基础知识" class="headerlink" title="Acpect基础知识"></a>Acpect基础知识</h4><ol>
<li>注解@Aspect，申明切面标记类</li>
<li>@Pointcut, 定义切点，标记方法</li>
<li>@Befeore 前置通知，切点前执行</li>
<li>@Around 围绕切点执行</li>
<li>@after 后置通知，切点后执行</li>
<li>@AfterReturening,返回返回值，切点返回值</li>
<li>@AfterThrowing ，异常通知，切点抛出异常</li>
<li>首先需要依赖com.hujiang.aspectjx:gradle-android-plugin-aspectjx，配置好了所需的环境</li>
<li>通过定义注解，包括NeedPermission,PermissionCanceled,PermissionDenied，三个注解对应这申请权限的三种情况。通过源码看他们的作用域都是Method，保留时间都是一直到运行时期，那就意味着，我们可以通过反射的技术实现想做的，而本项目也恰恰是基于反射和Aspect实现</li>
</ol>
<h4 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h4><p>纵向关系OOP，横向关系AOP</p>
<ol>
<li>OOP是面向对象编程，按照单一职责原则会将会定义一个个类，每个类只负责一个责任。当我们要使用这个时会引用他，使他分散在个个模块，到处都有。如日志，埋点等。从对象组织角度来讲，采用的分类方式是类似生物学的方式，以继承为主线</li>
<li>AOP是面向切面编程，我们从横向的的角度去观察这些对象，无需到处调用。这些需要打印日志的地方就是一个切点，AOp会在适当的时机打印<br>OOP是将问题划分到某个单个模块里去，而AOP是将把涉及到众多模块的某一类问题进行统一管理。AOP是将这些功能集中起来放到一个地方进行管理。是与业务逻辑进行隔离解耦</li>
</ol>
<h4 id="实现特定方法的前后执行"><a href="#实现特定方法的前后执行" class="headerlink" title="实现特定方法的前后执行"></a>实现特定方法的前后执行</h4><ol>
<li>硬编码，在执行方法前添加额外的执行方法</li>
<li>静态织入，通过AspectJ，通过扫描文件分析代码，找到切点JoinPoint，通过自动生成代码获取方法的各种信息，</li>
<li>JDK动态代理是对接口的代理，CGLib是对类的代理，把被代理的对象的class加载起来修改字节码，修改其字节码生成一个继承被代理对象的子类.通过子类增强功能</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>8月7日</title>
    <url>/8-yue-7-ri.html</url>
    <content><![CDATA[<h4 id="Android中AOP应用"><a href="#Android中AOP应用" class="headerlink" title="Android中AOP应用"></a>Android中AOP应用</h4><p>在Android开发中，有很多知名的开源框架在使用AOP思想。例如ButterKnife,Retrofit,Hugo等。AOP可以做性能检测和埋点技术也有很多</p>
<ol>
<li>性能检测和优化，360的ArgusAPM,滴滴的booster，Hugo</li>
<li>埋点技术，逻辑思维的DDAuto Tracker, 网易的HubbleData</li>
<li>通过AOP技术，还可以在我们向服务器请求数据时，会显示一个Loding，结果返回后隐藏它，可以通过AOP技术将Loading动作与业务主体分离</li>
<li>Android的权限管理Aopermission</li>
</ol>
]]></content>
      <categories>
        <category>“日记”</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>8月6日</title>
    <url>/8-yue-6-ri.html</url>
    <content><![CDATA[<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>UML是一种可视化的面向对象的建模语言,可以用来描述系统的静态结构和动态行为。用得最多的是类图，时序图，用例图。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>类图中类是对象的集合，用来描述类的对象结构类及与类,系统之间的交互关系</p>
<ol>
<li>泛化关系(表现为is a)：实线加指向父类或接口的空心箭头,包括类与类的继承，接口与接口的继承，类对接口的实现.</li>
<li>实现抽象：虚线+指向抽象的类的空心箭头</li>
<li>聚合关系：不是强依赖关系，用实线+空心菱形箭头指向依赖对象，公司和员工的关系</li>
<li>组合关系：强依赖关系(共存),用实线+实心菱形箭头指向依赖对象，公司和部门的关系，同时创建，同生命周期</li>
<li>依赖关系：通过入参依赖，用虚线+实心箭头，体现为局部变量，方法参数或者静态调用方法</li>
<li>关联关系(has a)：一个类知道另一个类的属性和方法，是另一个类的全局变量<a id="more"></a>

</li>
</ol>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p>用来显示对象之间的交互关系的图，涉及到角色,生命线，控制焦点和消息等元素<br>消息可以分为：同步消息，异步消息，返回消息，自关联消息</p>
<h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><p>用来描述角色和系统之间的关系，角色与系统交互及系统反应，包括扩展关系和包含关系</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP面向切面编程。程序设计原则中的单一职责原则，要求我们一个类只负责一个任务，那就意味着一个程序将会有很多类，负责不同能功能。好处是解耦了，但同时如果需要对类的方法进行埋点统一配置等，将会异常繁琐。而AOP就是为了解决这个问题.</p>
<h4 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h4><p>贯穿多个模块的非主体业务功能，如日志功能</p>
<h4 id="AOP的几种实现方式"><a href="#AOP的几种实现方式" class="headerlink" title="AOP的几种实现方式"></a>AOP的几种实现方式</h4><ol>
<li>动态代理</li>
<li>APT是一种编译期注解处理技术。通过注解和处理来实现编译期生成代码,和源代码一起编译成class文件。将拓展的关注点代码放入注解处理器中</li>
<li>AspectJ<br>是一种编译器。java编译器基础上加了关键字识别和编译方法，可以编写Aspect程序植入目标程序，拓展程序功能。</li>
<li>Transform + Javassist/ASM<br>Transform是Android Gradle提供的，可以操作字节码的一种方式。源码-.class-.dex。在.class转变为.dex过程会经历一系列的Transform处理。Javassist/ASM是操作.class字节码</li>
</ol>
<p><a href="https://juejin.im/post/5d0a0dfce51d45775d516f94" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>8月4日</title>
    <url>/8-yue-4-ri.html</url>
    <content><![CDATA[<h3 id="阿里开源项目启动框架Alpha"><a href="#阿里开源项目启动框架Alpha" class="headerlink" title="阿里开源项目启动框架Alpha"></a>阿里开源项目启动框架Alpha</h3><p>前面已经介绍了它的原理是基于PERT技术实现的。将一个项目过程以任务单元合理的安排资源，有些任务存在依赖关系所以执行顺序是定死的，但有些任务可以是脱离顺序，可以从关键任务路径中拎出来并行，从而一个项目的耗时及资源占比最大的任务即关键任务路径，在保证项目质量的前提下，可以对关键任务路径上的任务进行优化，也可以从次要任务优化，使关键任务资源充足，达到优化整体项目的效果。下面介绍关键代码类及点</p>
<h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>任务即项目的执行单元，任务包含的元素</p>
<ol>
<li>任务的状态：空闲(idle)，正在执行(runing)，结束(finish)，等待(wait)</li>
<li>任务优先级：线程是有限的，对于同一时机的任务，其执行顺序也是有先后顺序的</li>
<li>任务执行所在线程的优先级，对于优先级高的可以分配到更多的cpu时间</li>
<li>任务执行的线程：1.线程池子线程；2.主线程</li>
<li>任务名和任务的监听器对象集合</li>
<li>任务的关联关系：1.前驱任务集合，2.后继任务集合。执行顺序</li>
<li>当然可以添加监控器，监控任务的执行情况（任务耗时）<a id="more"></a>

</li>
</ol>
<h4 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h4><p>项目即由多个任务组成的集合体，它本身也是一个任务，但有其特殊的属性和方法定义</p>
<ol>
<li>定义了项目的生命周期，ProjectStart(),TaskFinish(),ProjectFinish()。项目的开始，项目中某任务的结束，项目的结束</li>
<li>定义开始和结束任务，两个任务是从图的执行角度来讲是唯一的起始和结束点，可以有效衡量一个图的开始和结束，并且方便将图插入另一个图中.startTask, finishTask</li>
<li>项目名称及生命周期监听集合 </li>
<li>添加监控器，及项目执行性能统计</li>
</ol>
<h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><ol>
<li>初始化Project对象，定义startTask，finishTask，定义回调事件</li>
<li>添加任务，建立任务间的顺序关系</li>
<li>添加任务会与startTask与finishTask构成环形的有向图，每个任务会记录它的前驱任务集合和后继任务集合。当且仅当前驱任务执行完毕才会执行它自己，然后是后继任务，也就意味着，finnishTask只会在所有任务执行结束调用，最后的最后回调project的finish</li>
</ol>
<h4 id="项目意义"><a href="#项目意义" class="headerlink" title="项目意义"></a>项目意义</h4><p>在项目中的实践，</p>
<ol>
<li>可以应用于应用启动流程,在应用启动时会初始化很多任务，如数<br>据库，Tinker，图片库，缓存数据等等，这些任务或许可以同步执行<br>，但有些必须顺序执行。通过PERT技术恰恰能解释并优化这个过程</li>
<li>图片上传任务，数据上传等。数据多可以通过并发上传额方式充分利用cpu</li>
</ol>
<p><a href="https://github.com/alibaba/alpha" target="_blank" rel="noopener">项目地址</a></p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>Alpha</tag>
        <tag>启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>8月3日</title>
    <url>/8-yue-3-ri.html</url>
    <content><![CDATA[<h3 id="Https的用途和工作模式"><a href="#Https的用途和工作模式" class="headerlink" title="Https的用途和工作模式"></a>Https的用途和工作模式</h3><p>用Http协议看新闻没什么问题，但换到严肃的场景中就存在安全风向了，如支付，使用普通的Http协议就会被黑客盯上。通过拦截请求假装自己是服务器，让你输入密码等。解决这种问题的思路是对数据加密，加密方式分两种：</p>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>在对称加密中，加密解密都使用相同的秘钥，因此秘钥的保密工作需要做好，只能给使用的人知道,存在问题</p>
<ul>
<li>秘钥的约定时机，秘钥通过互联网传输一样会被黑客截获</li>
</ul>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>加密和解密使用的秘钥不相同。分公钥和私钥，且公钥加密只能私钥解密，反之亦然。对称加密会存在秘钥约定十几的问题，所以需要非对称加密介入。将非对称加密的公钥公开，私钥自己保留。同样存在问题</p>
<ul>
<li>服务器的回复数据，黑客可以通过公钥解密，且黑客也可以模拟发送请求，所以一对公钥私钥不够，客户端同样需要有自己的公钥和私钥，并且客户端的公钥给服务端<a id="more"></a>

</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>对称加密的算法比分对称加密的算法效率高性能也好，大多数场景都是用对称加密</p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>非对称加密也存在同样的问题，如何将不对称的公钥给对方。一种是放在公网地址上，让对方下载；二是建立链接的时候传给对方。存在问题：</p>
<ul>
<li>如何鉴别别人发给你的公钥是对的，而不是冒充的<br>通过权威机构(CA)部门的证书，证书里面包括公钥还要发布者的信息及发布机构，证书有效期等，如身份证一样的存在。证书的签名算法即ＣＡ的私钥,给公司的公钥加密。所有用户在网站上得到的是一个证书，你只要得到ＣＡ的公钥去解密签名就能得到公司的公钥了。关于ＣＡ公钥的可靠性，则需要更加权威的机构证实。</li>
</ul>
<h4 id="Https的工作模式"><a href="#Https的工作模式" class="headerlink" title="Https的工作模式"></a>Https的工作模式</h4><p>非对称加密性能不及对称加密，通过非对称加密只对对称加密的秘钥进行加密码，而真正通讯的传输数据则通过对称加密的秘钥进行加解密。过程<br><img width="200" src="/images/lADPDgQ9q4pv-gfNBLbNAuA_736_1206.jpg"></p>
<ol>
<li>客户端发送Client Hello 到服务器,会以明文传输TLS版本信息，加密套件候选列表，压缩算法列表等信息，还有一个随机数，在协商对称秘钥的时候使用</li>
<li>服务器返回Server Hello消息，告诉客户端服务器所选的协议版本，加密套件和压缩算法等，还有一个随机数，用于后续秘钥协商</li>
<li>服务器发送证书</li>
<li>客户端从CA仓库里的公钥去解密证书，成功则可信任获得了服务器的公钥。最后客户端产生一个随机数，用服务器公钥加密发送给服务端</li>
<li>客户端接收到Client Key Exchange,通过私钥解密。最后协商出对称加密的秘钥为客户端的随机数+服务端的随机数+Pre-master产生与客户端相同的对称秘钥</li>
<li>客户端和服务端通过协商的对称秘钥进行通讯</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>对称加密的效率比非对称加密高，但无法解决了秘钥传输的问题。非对称加密可以解决这个问题，但是效率不高</li>
<li>非对称加密需要通过证书合权威机构来验证公钥的合法性</li>
<li>Https是综合了对称加密合非对称加密算法的Http协议，既保证传输安全，有保证了传输效</li>
</ul>
<h3 id="阿里开源项目Alpha启动框架"><a href="#阿里开源项目Alpha启动框架" class="headerlink" title="阿里开源项目Alpha启动框架"></a>阿里开源项目Alpha启动框架</h3><p>是一个基于PERT图构建的异步启动框架，使用简单，高效。<br>在应用启动的时候，我们通常会做很多工作需要，为了提高启动速度，我们尽可能的让这些工作并发进行。但这些工作可能存在前后依赖关系，所以我们需要想办法保证执行顺序的正确性。</p>
<h4 id="PERT"><a href="#PERT" class="headerlink" title="PERT"></a>PERT</h4><p>即计划评审技术，利用网络分析制定计划以及对计划予以评价的技术。它能调整计划的各道工序，合理安排资源，加速计划进度.</p>
<h5 id="四个概念"><a href="#四个概念" class="headerlink" title="四个概念"></a>四个概念</h5><ol>
<li>事件：表示主要活动结束的哪一点</li>
<li>活动：表示从一个事件到另一个事件之间的过程</li>
<li>松弛事件：不影响完工前提下可能被推迟完成的最大时间</li>
<li>关键路线：是PERT中花费时间最长的事件和活动序列</li>
</ol>
<h5 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h5><ol>
<li>构建一个清晰精确的事件活动网络，其中包括时间和资源</li>
<li>对时间活动进行逻辑排序以确定关键路线</li>
<li>确定“不确定性”</li>
<li>计算关键路线和宽裕时间</li>
</ol>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol>
<li>标识出项目的关键路径，以明确项目活动的重点</li>
<li>对关键步骤进行资源调度及优化</li>
<li>资源发生矛盾时，通过调度非关键路径资源，保证项目进度</li>
<li>通过PERT网络分析法可大大缩短项目完成的时间</li>
</ol>
<h4 id="在軟件设计的应用"><a href="#在軟件设计的应用" class="headerlink" title="在軟件设计的应用"></a>在軟件设计的应用</h4><ol>
<li>软件的模块化，不同业务线并行开发</li>
<li>应用插件化，使宿主与插件分开编译，提高编译速度</li>
</ol>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>Https</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle学习</title>
    <url>/gradle-xue-xi.html</url>
    <content><![CDATA[<h4 id="什么是Gradle"><a href="#什么是Gradle" class="headerlink" title="什么是Gradle"></a>什么是Gradle</h4><p>Gradle是一个开源的，非常灵活的自动化构建工具，具有以下几大特点：</p>
<ol>
<li>高性能:只执行定义的任务，可以复用任务的输入输出，避免不必要的执行</li>
<li>基于JVM:可以利用java，Kotlin,Groovy等编译器支持的语言</li>
<li>定制了基础框架，便于构建</li>
<li>扩展性：可以自定义任务</li>
<li>编辑器的支持</li>
</ol>
<h4 id="设计Gradle插件"><a href="#设计Gradle插件" class="headerlink" title="设计Gradle插件"></a>设计Gradle插件</h4><h5 id="1-总体架构"><a href="#1-总体架构" class="headerlink" title="1. 总体架构"></a>1. 总体架构</h5><ol>
<li>提取可用的逻辑编写成二进制插件</li>
<li>插件对性能的影响</li>
<li>定制规范，减少配置</li>
<li>将功能与规范隔离</li>
</ol>
<h5 id="2-技术"><a href="#2-技术" class="headerlink" title="2. 技术"></a>2. 技术</h5><ol>
<li>使用静态语言编写插件</li>
<li>尽量通过Gradle内部的ApI实现插件</li>
<li>3 减少外部依赖</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>OkHttp</title>
    <url>/okhttp.html</url>
    <content><![CDATA[<h4 id="一-曾经的网络框架"><a href="#一-曾经的网络框架" class="headerlink" title="一. 曾经的网络框架"></a>一. 曾经的网络框架</h4><h5 id="Android的网络框架有四种"><a href="#Android的网络框架有四种" class="headerlink" title="Android的网络框架有四种"></a>Android的网络框架有四种</h5><ol>
<li>HttpClient ： 2.2版本以下存在bug，所以2.3之后建议使用HttpUrlConnection</li>
<li>HttpUrlConnection 2.3+， 官方推荐</li>
<li>Volley，谷歌开发，简单的网络任务框架，底层兼容2.3以前版本使用了HttpClient，2.3+使用的是HttpUrlConnection，功能拓展性弱</li>
<li>Okhttp，从Android4.4开始HttpURLConnection的底层实现采用的是okHttp.</li>
</ol>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><img src="/image/compare.png" alt><br>通过上面的比较，在Android发展的每个阶段，他们有各自存在的意义，只是时过境迁，被种种原因被替换或者废弃。<br>这个过程是一个框架发展的过程，从重量级繁杂且难以维护，到轻量级易扩展，到过度版本新老版本的兼容，最后取长补短完善自己的网络框架。<br>化繁为简，然后又能包容万象的过程</p>
<h5 id="网络框架应该有的功能"><a href="#网络框架应该有的功能" class="headerlink" title="网络框架应该有的功能"></a>网络框架应该有的功能</h5><ol>
<li>自定义请求的Header</li>
<li>GET，POST</li>
<li>支持文件上传下载</li>
<li>图片加载</li>
<li>支持多任务网络请求操作</li>
<li>支持缓存</li>
<li>支持回调</li>
<li>支持session</li>
<li>…..</li>
</ol>
<h4 id="二-OkHttp简介"><a href="#二-OkHttp简介" class="headerlink" title="二. OkHttp简介"></a>二. OkHttp简介</h4><p>一张图了解OkHttp的整个过程<br><img src="/images/OkHttp.jpg" alt><br>在OkHttp中真正核心的东西是Interceptor，他不仅负责拦截请求进行额外的处理(入cookie)，实际上他还会把实际的网络请求，缓存，透明压缩等功能都统一起来，每一个功能都只是一个Interceptor，它们在连接成一个Interceptor.Chain,环环相扣最终完成一次网络请求，从getResponseWithInterceptorChain函数中我们可以看到Interceptor.Chain的分布情况依次是：</p>
<ol>
<li>在配置OkHttpClinet时设置的interceptors</li>
<li>负责失败重试和重定向的RetryAndFollowUpInterceptor</li>
<li>负责把用户构造的请求转化为发送到服务器的请求，把服务器返回的响应转化为用户友好的响应BridgeInterceptor</li>
<li>负责读取缓存直接返回，更新缓存的CacheInterceptor</li>
<li>负责和服务器建立连接的ConnectInterceptor</li>
<li>配置OkHttpClient时设置的NetworkInterceptor</li>
<li>负责向服务器发送请求数据，从服务器读取响应数据的CallServerInterceptor</li>
</ol>
<p>在这里位置决定了功能，最后一个一定是CallServerInterceptor，其他的在这之前。责任链模式在Interceptor中得到了很好的实践。对于request变成response对象，每个interceptor都能完成这件事，也由各自的inteceptor决定是否要交给下个interceptor。</p>
<h4 id="三-Interceptor分析"><a href="#三-Interceptor分析" class="headerlink" title="三. Interceptor分析"></a>三. Interceptor分析</h4><p>首先看分析ConnectInterceptor和CallServerInterceptor，这两个interceptor实现了和服务器进行通信的核心</p>
<h5 id="1-ConnectInterceptor建立连接"><a href="#1-ConnectInterceptor建立连接" class="headerlink" title="1. ConnectInterceptor建立连接"></a>1. ConnectInterceptor建立连接</h5><pre><code>/** Opens a connection to the target server and proceeds to the next interceptor. */

  @Override 
  public Response intercept(Chain chain) throws IOException {
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    Request request = realChain.request();
    Transmitter transmitter = realChain.transmitter();

    // We need the network to satisfy this request. Possibly for validating a conditional GET.
    boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);
    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);

    return realChain.proceed(request, transmitter, exchange);
  }</code></pre><p>通过创建一个Exchange对象，他将在后面使用。他的内部是对http，https请求的实现，内部都是利用Okio对Socket的读写操作进行了封装.在内部是对java.io和java.nio进行了封装，内部创建了一个主要的RealConnectionn对象，利用RealConnectionn进行读写</p>
<h5 id="2-CallServerInterceptor-发送和接受数据"><a href="#2-CallServerInterceptor-发送和接受数据" class="headerlink" title="2. CallServerInterceptor 发送和接受数据"></a>2. CallServerInterceptor 发送和接受数据</h5><p>主要过程：</p>
<ol>
<li>向服务器发送request header</li>
<li>如果有request body,就向服务器发送</li>
<li>读取response header, 构造response 对象</li>
<li>如果有response body,则创建一个带body的response对象</li>
</ol>
<h5 id="3-CacheIntercepter-缓存"><a href="#3-CacheIntercepter-缓存" class="headerlink" title="3. CacheIntercepter 缓存"></a>3. CacheIntercepter 缓存</h5><p>在建立连接，和服务器通讯之前就是CacheIntercepter，我们需要检查响应是否已经本地缓存了，如果缓存了则直接返回，否则进行后面的流程，并把返回的数据写入缓存</p>
<ol>
<li>获取本地缓存cacheCandidate</li>
<li>如果本地缓存可用则直接返回CacheCandidate，从而打断interceptor链</li>
<li>走剩下的interceptor获取nnetworkResponse</li>
<li>networkResponse、cacheResponse构造新的response</li>
<li>根据新的response里的header定制缓存策略，存入缓存中（method 为get）</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>创建一个单例的OkHttpClient，创建请求对象request，初始化请求方式，请求url，请求header，请求body，然后通过client的newcall（request）构建真正的请求对象realcall。有realcall的execute方法和qnqueue方法区分是同步请求还是异步请求，异步请求依赖线程池dispatcher，最终会调用getResponseWithInterceptorsChain方法返回返回response。内部通过这种拦截器对request请求数据和response响应数据进行处理，每个拦截器直接通过realinterceptchain对象的process连接起来（责任链模式）</p>
]]></content>
      <tags>
        <tag>网络，Okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>二维火火种培训</title>
    <url>/er-wei-huo-huo-chong-pei-xun.html</url>
    <content><![CDATA[<p>毕业在即，我也在二维火实习了近半年时间，随着对产品和公司的了解我决定将继续留在公司学习，想在未来的某一天看着自己参与或者做的项目投入市场，得到大家的认可。</p>
<h3 id="火种培训"><a href="#火种培训" class="headerlink" title="火种培训"></a>火种培训</h3><p>火种：二维火的种子（实习生），年轻，活力。星星之火可以燎原。</p>
<h3 id="第一天-2018-6-20"><a href="#第一天-2018-6-20" class="headerlink" title="第一天 2018/6/20"></a>第一天 2018/6/20</h3><ul>
<li>红烧肉：产品研发负责人《开篇介绍》<br>给我们介绍了公司的使命，愿景，价值观等。聊了聊公司的发展历程以及在公司多年来的经历，给了我们一些切身的建议：每个月看书，写日记 todolist等</li>
<li>人参果：产品委员会主席《公司产品介绍》<br>细致的讲述了公司的价值观：正直善良，敬畏之心，天道酬情！<br>讲述了公司在10几年间，产品的迭代更替以及公司的主要产品线（排队，扫码点餐，厨房KDS，收银，供应链，掌柜等等）<a id="more"></a>

</li>
</ul>
<h3 id="第二天-2018-6-21"><a href="#第二天-2018-6-21" class="headerlink" title="第二天 2018/6/21"></a>第二天 2018/6/21</h3><ul>
<li>生抽：交易架构师《高并发下的变成》<br>介绍了Java并发编程的基础，以及交易订单的一些具体场景，如何避免并发导致的数据同步问题。还介绍了锁的应用等等</li>
<li>小米：项目管理主管《流程规范&amp;项目管理》<br>详细介绍了项目的具体含义：一群人为达到某一目标而做某一件事。<br>告诉我们项目即输入物-〉输出物<br>项目的整个流程等</li>
</ul>
<h3 id="第三天-2018-6-22"><a href="#第三天-2018-6-22" class="headerlink" title="第三天 2018/6/22"></a>第三天 2018/6/22</h3><ul>
<li>四季豆：共享业务总监《二维火服务端技术架构》<br>介绍了千亿级别服务架构的演变过程，从一个点子，几个人快速的做了一个东西推向市场，产品使用量上升，服务器资源有限，添加服务器，负载均衡，缓存设计，业务模块拆封等等</li>
<li>马宝：供应链客户经理《客户端架构》<br>介绍了Android的一些历史及在二维火中的一些具体应用，同时分享了很多有趣的程序员日常。最后一句，8小时的生存，other 生活！</li>
</ul>
<p>上了7天请假两天参加毕业典礼</p>
<p>pm开放平台项目</p>
<h3 id="确定项目角色，流程角色及职责"><a href="#确定项目角色，流程角色及职责" class="headerlink" title="确定项目角色，流程角色及职责"></a>确定项目角色，流程角色及职责</h3><ol>
<li><p>项目经理：简称PM，项目中职责为主导项目全体成员按照项目计划执行，完成项目目标，管控项目的全过程；善于风险识别及跟踪问题解决。更侧重于项目过程中的沟通协作，会议组织，里程碑进度把控，组织过程资产归档，对外汇报等工作。</p>
</li>
<li><p>需求经理：简称DM，负责收集各类需求，整理分析后列入禅道的需求池，对接PD推动需求的实现。</p>
</li>
<li><p>产品经理：简称PD，细化需求制作市场需求文档（简称MRD）；明确项目需求范围边界值，编写产品说明书（简称PRD），协同交互，视觉完善PRD正式版。跟踪产品验收。 立项初始，判定此项目是否为重点业务型项目。</p>
</li>
<li><p>视觉设计师：简称UI，实现PD的页面需求，将其可视化。视觉稿需通过视觉评审。协同PD确认最终界面符合视觉设计稿。 </p>
</li>
<li><p>技术经理：简称TM，项目中职责为担任技术总负责，把控项目整体技术方案可行；重点跟进架构设计阶段，开发阶段及发布阶段的具体执行。更侧重于项目过程中的任务计划评估，技术难题解决，代码质量把控，发布管理跟踪等工作。</p>
</li>
<li><p>开发人员：客户端及服务端的代码实现者。完成编码后的自测，联调，根据冒烟用例进行冒烟测试。</p>
</li>
<li><p>测试人员：质量的把关者。需要根据测试用例，担当内部测试，接口测试、预发后测试，线上回归测试等。</p>
</li>
<li><p>配置管理员：简称SCM，进行版本控制，协助完成项目环境配置。</p>
</li>
<li><p>运维人员：简称SA，提供项目环境（开发、测试环境），评审发布计划，协助发布等。</p>
</li>
<li><p>数据库管理员：简称DBA，主要负责产品研发中心所有数据库的运营和维护，评审SQL等。</p>
</li>
<li><p>业务线技术TL：各业务线技术负责人。主要负责立项时候判定项目是否重点技术项目。</p>
</li>
<li><p>架构委员会：由高级架构师，核心应用owner们及业务线技术负责人组成的技术架构组织。如有技术型项目启动时，负责判定项目是否为重点技术型项目。</p>
</li>
<li><p>产品架构委员会：简称PDM，在项目执行过程中主要负责参与二维火核心产品业务的MRD&amp;PRD评审，以及上线后产品目标的验收。</p>
</li>
</ol>
<h3 id="立项会"><a href="#立项会" class="headerlink" title="立项会"></a>立项会</h3><p>产品组织，项目经理结果通知</p>
]]></content>
      <categories>
        <category>二维火</category>
      </categories>
      <tags>
        <tag>JOb</tag>
        <tag>二维火</tag>
      </tags>
  </entry>
  <entry>
    <title>Android IPC</title>
    <url>/android-ipc.html</url>
    <content><![CDATA[<h3 id="Android跨进程通讯的几种方式"><a href="#Android跨进程通讯的几种方式" class="headerlink" title="Android跨进程通讯的几种方式"></a>Android跨进程通讯的几种方式</h3><h4 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h4><p>  Bundle实现了Parcelable，方便在进程中传输数据。主要在activity、service、receiver中Intent中应用，</p>
<h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>Android基于Linux，对文件的读写没有限制。存在的问题就是并发读写的问题<br>sp存在缓存策略，内存中存在备份，导致多进程不可靠</p>
<h4 id="使用messenger信使"><a href="#使用messenger信使" class="headerlink" title="使用messenger信使"></a>使用messenger信使</h4><ol>
<li>Messenger可以在不同的进程中传递Message对象，轻松实现数据的跨进程通讯。</li>
<li>它的底层实现是AIDl，内部一次只做一次处理，因此服务端不用考虑线程同步的问题</li>
<li>缺点是只能用来简单的信息传递，并发请求不大合适且无法不支持跨进程的方法的调用<br><img src="http://opd2n5pxb.bkt.clouddn.com/Messenger%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Alt text" title="Messenger 工作原理图"></li>
</ol>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>进程通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJava的使用及源码分析</title>
    <url>/rxjava-de-shi-yong-ji-yuan-ma-fen-xi.html</url>
    <content><![CDATA[<h3 id="基于Rxjava-2-1-10版本源码分析"><a href="#基于Rxjava-2-1-10版本源码分析" class="headerlink" title="基于Rxjava-2.1.10版本源码分析"></a>基于Rxjava-2.1.10版本源码分析</h3><p>从开源文档范例开始分析</p>
<h4 id="范例一-Flowable-just输出HelloWord"><a href="#范例一-Flowable-just输出HelloWord" class="headerlink" title="范例一.Flowable.just输出HelloWord"></a>范例一.Flowable.just输出HelloWord</h4><pre><code>Flowable.just(&quot;Hello world&quot;).subscribe(new Consumer&lt;String&gt;() {
    @Override
    public void accept(String s) throws Exception {

    }
});</code></pre><p>1.从just方法开始,首先可以看到三个注解方法</p>
<pre><code>@CheckReturnValue  //检查返回值
@BackpressureSupport(BackpressureKind.FULL)  //支持的背压方式
@SchedulerSupport(SchedulerSupport.NONE) //调度方式,即处理事件的方式IO数据流，新开一个线程等。
public static &lt;T&gt; Flowable&lt;T&gt; just(T item) { //方法参数是个泛型，
    ObjectHelper.requireNonNull(item, &quot;item is null&quot;);
    //返回值是个Flowable对象
    return RxJavaPlugins.onAssembly(new FlowableJust&lt;T&gt;(item)); 
}</code></pre><a id="more"></a>
<p>2.方法第一行是判空操作在很多地方都使用到了，查看方法不为空则返回原对象，否则，抛出异常NullPointerException</p>
<pre><code>public static &lt;T&gt; T requireNonNull(T object, String message) {
        if (object == null) {
            throw new NullPointerException(message);
        }
        return object;
    }</code></pre><p>3.方法第三行中的看new FlowableJust<t>(item)创建的实例对象</t></p>
<pre><code>public final class FlowableJust&lt;T&gt; extends Flowable&lt;T&gt; implements ScalarCallable&lt;T&gt; {
    private final T value; //final变量，赋值后不能改变
    public FlowableJust(final T value) {
        this.value = value;
    }
    //重写了Flowable的subscribeActual方法，传入了观察者与发射内容构造一个订阅对象
    //由观察者去订阅这个对象
    @Override
    protected void subscribeActual(Subscriber&lt;? super T&gt; s) {
        s.onSubscribe(new ScalarSubscription&lt;T&gt;(s, value));
    }

    @Override
    public T call() {
        return value;
    }
}</code></pre><p>4.然后看RxJavaPlugins.onAssembly()方法</p>
<pre><code>@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    @NonNull
    public static &lt;T&gt; Flowable&lt;T&gt; onAssembly(@NonNull Flowable&lt;T&gt; source) {
        //在这里钩子函数为null，即直接返回source
        Function&lt;? super Flowable, ? extends Flowable&gt; f = onFlowableAssembly;
        if (f != null) {
            return apply(f, source);
        }
        return source;
    }</code></pre><p>5.所以Flowable.just(“Hello world”)只是生成了一个Flowable对象。接着看subscribe()方法。实现了Consumer接口</p>
<pre><code>public interface Consumer&lt;T&gt; {
    /**
     * 回调函数accept去消费这个传入值，
     * Consume the given value.
     * @param t the value
     * @throws Exception on error
     */
    void accept(T t) throws Exception;
}</code></pre><p>6.接着看subscribe()方法</p>
<pre><code>@CheckReturnValue
@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
@SchedulerSupport(SchedulerSupport.NONE)
public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) {
    //onNext即要去消费的接口对象
    //其他传入参数为默认的onError，onComplete接口回调，和最大数量的订阅对象
    return subscribe(onNext, Functions.ON_ERROR_MISSING,
            Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);
}</code></pre><p>7.然后去看第二个subscribe()内部方法</p>
<pre><code>@CheckReturnValue
@BackpressureSupport(BackpressureKind.SPECIAL)
@SchedulerSupport(SchedulerSupport.NONE)
public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,
        Action onComplete, Consumer&lt;? super Subscription&gt; onSubscribe) {
    ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);
    ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);
    ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);
    ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);

    //上面一系列的判空操作之后，将传入参数组合成一个LambdaSubscriber
    LambdaSubscriber&lt;T&gt; ls = new LambdaSubscriber&lt;T&gt;(onNext, onError, onComplete, onSubscribe);

    //调用了第三个subscribe方法
    subscribe(ls);

    return ls;
}</code></pre><p>8、先来看一下LambdaSubscriber对象，除了对传入参数赋值之外，内部重写了熟悉的onSubscribe、onNext()、onError()、onComplete()三个方法。从6.可以看出在这四个方法中除了onNext()是我们传入的，其他都是框架默认的。源码过长，不copy了。<br>9.接着继续看第三个subscribe(ls)方法</p>
<pre><code>@BackpressureSupport(BackpressureKind.SPECIAL)
@SchedulerSupport(SchedulerSupport.NONE)
@Beta
public final void subscribe(FlowableSubscriber&lt;? super T&gt; s) {
    ObjectHelper.requireNonNull(s, &quot;s is null&quot;);
    try {
        // 传入当前要观察的对象和处理方法对象构建了一个观察者对象
        Subscriber&lt;? super T&gt; z = RxJavaPlugins.onSubscribe(this, s);

        ObjectHelper.requireNonNull(z, &quot;Plugin returned null Subscriber&quot;);

        //在这传入一个观察者对象
        subscribeActual(z);
    } catch (NullPointerException e) { // NOPMD
        throw e;
    } catch (Throwable e) {
        Exceptions.throwIfFatal(e);
        // can&#39;t call onError because no way to know if a Subscription has been set or not
        // can&#39;t call onSubscribe because the call might have set a Subscription already
        RxJavaPlugins.onError(e);

        NullPointerException npe = new NullPointerException(&quot;Actually not, but can&#39;t throw other exceptions due to RS&quot;);
        npe.initCause(e);
        throw npe;
    }
}</code></pre><p>10.接着看subscribeActual(),似曾相识在3.中FlowableJust重写了父类的subscribeActual()方法，所以最后有回来了</p>
<pre><code>@Override
protected void subscribeActual(Subscriber&lt;? super T&gt; s) {
    //1.传入观察者对象和要发射的值创建了一个标量的订阅对象
    //2.观察者对象订阅了这个标量的订阅对象
    s.onSubscribe(new ScalarSubscription&lt;T&gt;(s, value));
}</code></pre><p>11.先看ScalarSubscription方法，可以看到当调用了request(n)的方法时onNext方法就会被调用,</p>
<pre><code>public ScalarSubscription(Subscriber&lt;? super T&gt; subscriber, T value) {
    this.subscriber = subscriber;
    this.value = value;
}

@Override
public void request(long n) {
    if (!SubscriptionHelper.validate(n)) {
        return;
    }
    if (compareAndSet(NO_REQUEST, REQUESTED)) {
        Subscriber&lt;? super T&gt; s = subscriber;
        //这里就是LambdaSubscriber中的onNext，也是我们传入的onNext会去回调的地方
        s.onNext(value);
        if (get() != CANCELLED) {
            s.onComplete();
        }
    }

}</code></pre><p>12.所以我们要看request()在哪里调用，接着看继续看s.onSubscribe()方法，它就是LambdaSubscriber中的onSubscribe()方法</p>
<pre><code>@Override
public void onSubscribe(Subscription s) {
    if (SubscriptionHelper.setOnce(this, s)) {
        try {
            //onSubscribe对象是在3.中传入的FlowableInternalHelper.RequestMax.INSTANCE，并调用了accept方法
            onSubscribe.accept(this);
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            s.cancel();
            onError(ex);
        }
    }
}</code></pre><p>13.接着继续看FlowableInternalHelper.RequestMax.INSTANCE。</p>
<pre><code>public enum RequestMax implements Consumer&lt;Subscription&gt; {
    //枚举法创建的单例
    INSTANCE;
    @Override
    public void accept(Subscription t) throws Exception {
        //可以看到在这里调用了request方法
        t.request(Long.MAX_VALUE);
    }
}</code></pre><p>14.接着可以回到11.ScalarSubscription类中，在request方法中就调用了LambdaSubscriber的onNext*()方法并传入了value值<br>15.接着再去看LambdaSubscriber类中的onNext方法</p>
<pre><code>@Override
    public void onNext(T t) {
        if (!isDisposed()) {
            try {
                //在这里回调了我们当初我们传入的实现对象onNext的accept方法，
                onNext.accept(t);
            } catch (Throwable e) {
                Exceptions.throwIfFatal(e);
                get().cancel();
                onError(e);
            }
        }
    }</code></pre><p>16.走完onNext方法后，继续看11.它会继续走s.onComplete()方法，这个方法也是默认的Functions.EMPTY_ACTION</p>
<pre><code>static final class EmptyAction implements Action {
        @Override
        public void run() { 
            //空方法
        }

        @Override
        public String toString() {
            return &quot;EmptyAction&quot;;
        }
    }</code></pre><p>17.至于onError方法会14.在onNext()发生异常时去调用，且在这里也是默认传入的Functions.ON_ERROR_MISSING</p>
<pre><code>static final class OnErrorMissingConsumer implements Consumer&lt;Throwable&gt; {
    @Override
    public void accept(Throwable error) {
        RxJavaPlugins.onError(new OnErrorNotImplementedException(error));
    }
}</code></pre><h4 id="最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext-进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式"><a href="#最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext-进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式" class="headerlink" title="最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext()进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式"></a>最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext()进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式</h4>]]></content>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射那些事</title>
    <url>/java-fan-she-na-xie-shi.html</url>
    <content><![CDATA[<h2 id="反射机制的定义"><a href="#反射机制的定义" class="headerlink" title="反射机制的定义"></a>反射机制的定义</h2><p>在运行状态期间，能过动态的知道一个类的属性和方法，能够动态的调用一个对象的属性和方法的功能。</p>
<h2 id="反射机制的功能"><a href="#反射机制的功能" class="headerlink" title="反射机制的功能"></a>反射机制的功能</h2><p>在运行期间</p>
<ol>
<li>判断任意一个对象所属的类</li>
<li>构建任意一个类的对象</li>
<li>判断任意一个类的属性和方法</li>
<li>调用任意一个对象的方法</li>
<li>生成动态代理<a id="more"></a>
<h2 id="反射机制的应用场景"><a href="#反射机制的应用场景" class="headerlink" title="反射机制的应用场景"></a>反射机制的应用场景</h2></li>
<li>逆向代码，反编译</li>
<li>与注解相结合的框架，retrofit</li>
<li>单纯的反射机制框架，EventBus</li>
<li>动态生成类框架，Gson</li>
</ol>
<h2 id="通过反射获取类信息"><a href="#通过反射获取类信息" class="headerlink" title="通过反射获取类信息"></a>通过反射获取类信息</h2><p>每个类被加载后，系统会为该类生成一个对应的Class对象，通过该Class对象就可以访问JVM中的这个类</p>
<h4 id="在JAVA程序中获得Class对象通常有三种方法"><a href="#在JAVA程序中获得Class对象通常有三种方法" class="headerlink" title="在JAVA程序中获得Class对象通常有三种方法"></a>在JAVA程序中获得Class对象通常有三种方法</h4><ol>
<li>使用Class类的forName()静态方法,传入全限定名</li>
<li>调用某个类的class属性 </li>
<li>通过对象getClass()获取Class对象<br>```</li>
<li>Classs  class = Class.forName(com.zyx.Person);</li>
<li>Class calss = Person.class;</li>
<li>Person person = new Person();<br>Class class = person.getClass();<br>```<h4 id="获取class对象的属性、方法、构造函数"><a href="#获取class对象的属性、方法、构造函数" class="headerlink" title="获取class对象的属性、方法、构造函数"></a>获取class对象的属性、方法、构造函数</h4></li>
<li>获取class对象的属性<pre><code>Field[] allFields = class.getDeclaredFileds();// 获取所有声明的属性
Filed[] publicFileds = calss.getFields[]; //获取所有public属性
Field ageField = class.getDeclaredFiled(&quot;age&quot;);// 获取指定声明的属性
Filed desFiled = calss.getField(&quot;age&quot;); //获取指定public属性</code></pre></li>
<li>获取class对象的方法<pre><code>Method[] methods = class.getDeclaredMethods();// 获取所有声明的方法
Method[] publicFileds = calss.getMethods[]; //获取所有public方法，
Method[] publicFileds = calss.getMethods[]; //获取所有public方法，带指定形参列表的方法
Method method= class.getDeclaredMethods(&quot;info&quot;,String.class);// 获取指定声明的方法，
Method infoMethod = calss.getMethod(&quot;info&quot;,String.class); //获取指定public方法,带指定形参列表的方法</code></pre></li>
<li>获取class对象的构造函数<pre><code>Constructor</code></pre><h4 id="通过Java反射生成并操作对象"><a href="#通过Java反射生成并操作对象" class="headerlink" title="通过Java反射生成并操作对象"></a>通过Java反射生成并操作对象</h4></li>
</ol>
<p><strong>生成实例</strong></p>
<ol>
<li>使用Class对象的newInstance()方法来创建Class对象对应的实例，但对应类必须有默认的构造函数</li>
<li>先使用Class的对象获取指定的Constructor对象，在调用Constructor对象的newInstance()方法</li>
</ol>
<p><strong>调用方法</strong></p>
<ol>
<li>通过Class对象的getMethods()或者getMethod()获得指定方法，返回Method对象或者数组。</li>
<li>通过Method对象中的invoke()方法。第一个参数传调用该方法的对象，第二个参数传对应该方法的参数。<pre><code>Object obj = class.newInstance();
Method methdo = calss.getDeclareMethod(&quot;setAge&quot;, int.calss);
method.invoke(obj, 28); //会检查调用权限</code></pre></li>
</ol>
<p><strong>访问成员变量赋值</strong></p>
<pre><code>Object obj = class.newInstance();
Field field = class.getField(&quot;age&quot;);
field.setInt(obj, 28);
int age = field.getInt(obj);</code></pre><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>给某个类提供一个代理对象，并由代理对象控制对原对象的访问，即客户不直接操控原对象，而是通过代理对象操控原对象</p>
<h4 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h4><ol>
<li>静态代理，在编译时就实现好了，会生成对应的Class实际文件</li>
<li>动态代理，在运行时生成，在运行时生成类字节码被加载到JVM中</li>
</ol>
<h4 id="代理模式的思路"><a href="#代理模式的思路" class="headerlink" title="代理模式的思路"></a>代理模式的思路</h4><ol>
<li>代理对象和目标对象均实现同一个行为接口</li>
<li>代理对象和目标对象分别实现具体接口逻辑</li>
<li>在代理对像的构造函数中实例化一个目标对象</li>
<li>在代理对象中调用目标对象的行为接口</li>
<li>客户端想要调用目标对象的行为接口只能通过代理对象来操作</li>
</ol>
<h4 id="Java反射机制和动态代理"><a href="#Java反射机制和动态代理" class="headerlink" title="Java反射机制和动态代理"></a>Java反射机制和动态代理</h4><p><strong>动态代理介绍</strong></p>
<ol>
<li>运行时生成代理类，并将代理类的字节码载入当前代理的ClassLoader</li>
<li>不需要多些多写一个与目标类相同的代理类</li>
<li>可以在运行时定制代理类的执行逻辑</li>
</ol>
<p><strong>涉及的类</strong></p>
<ol>
<li>java.lang.reflect.Proxy,生成代理类的主类，通过Proxy生成的代理类都继承Proxy。Proxy提供了创建动态代理类和代理对象的方法，是所有动态代理类的父类。</li>
<li>java.lang.reflect.InvacationHandle 调用处理器，当调用动态代理的方法时会直接转到InvocationHandle的invoke()方法</li>
</ol>
<h4 id="泛型与Class"><a href="#泛型与Class" class="headerlink" title="泛型与Class"></a>泛型与Class</h4><p>避免强制转换<br>泛型参数化类型 getGenericType();<br>普通类型 getType()</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>【反射机制】</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型那些事</title>
    <url>/fan-xing-na-xie-shi.html</url>
    <content><![CDATA[<h2 id="泛型的目的"><a href="#泛型的目的" class="headerlink" title="泛型的目的"></a>泛型的目的</h2><p>语法糖即糖衣语法，这种语法对语言并没有影响，只是方便了程序员的使用。主要包括：泛型，变长参数，条件编译，自动拆装箱，内部类等。虚拟机并不支持这种语法，在编译期就会被还原为基础语法结构，这个过程被称为解语法糖。<br>泛型的目的：通过泛型使得在编译期间完成类型转换工作，避免运行时强制类型转换而出现ClassCastException，类型转换异常</p>
<a id="more"></a>
<h2 id="泛型初窥"><a href="#泛型初窥" class="headerlink" title="泛型初窥"></a>泛型初窥</h2><p>JDK1.5之后添加<br>泛型的好处</p>
<ol>
<li>类型安全，将类型检测挪到了编译期。</li>
<li>消除了代码中许多的强制类型转换，增强了代码的可读性</li>
<li>为较大的优化带来了可能<h2 id="泛型使用"><a href="#泛型使用" class="headerlink" title="泛型使用"></a>泛型使用</h2>泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当做类型使用<br>方法声明定义的形参只能在该方法里使用<br>修饰符&lt;T,S&gt; 返回值类型 方法名（形参列表）{<br> 方法体<br>}<h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2></li>
<li>任意通配符：？匹配任意的类型，用作读取不能添加</li>
<li>上限通配符：使用extends关键字指定这个类型必须是继承某个类，或者是实现某个接口（子类或者本身）</li>
<li>下限通配符：使用super关键字指定这个类型必须是某个类的父类，或者是某个接口的父类</li>
</ol>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>作用于编译期间，所以运行期间泛型信息是被擦除的，编译后的Class不包含泛型信息。静态方法，静态初始化或者静态变量声明和初始化不允许使用类型形参。也不能使用instance of运算符</p>
]]></content>
      <categories>
        <category>“JAVA”</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类分析理解</title>
    <url>/java-ji-he-lei-fen-xi-li-jie.html</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/csdn_terence/article/details/78379878" title="Optional title" target="_blank" rel="noopener">Java集合面试总结</a></p>
<h2 id="Collecton-和-Map"><a href="#Collecton-和-Map" class="headerlink" title="Collecton 和 Map"></a>Collecton 和 Map</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>包括 Set List Queue</p>
<a id="more"></a>
<h4 id="主要分析"><a href="#主要分析" class="headerlink" title="主要分析"></a>主要分析</h4><ol>
<li><p>ArrayList</p>
<ul>
<li>动态数组</li>
<li>capacity 扩容机制  1.5倍， 初始 java1.8 : 10 ;android 21 :12</li>
<li>内部元素变动 System.copyarray();</li>
<li>线程不安全</li>
</ul>
</li>
<li><p>LinkList<br>双向链表<br>Node()函数，该函数以O(1/2)的性能去获取一个节点<br>链表操作<br>线程不安全</p>
</li>
<li><p><a href="http://www.importnew.com/20386.html" title="Optional title" target="_blank" rel="noopener">HashMap</a></p>
<ul>
<li>hash()方法 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) able的长度都是2的幂，因此index仅与hash值的低n位有关 [计算方式](<a href="http://blog.csdn.net/fan2012huan/article/details/51097331&quot;Optional" target="_blank" rel="noopener">http://blog.csdn.net/fan2012huan/article/details/51097331&quot;Optional</a> title”)</li>
<li>tableSizeFor() 找到大于等于initialCapacity的最小的2的幂</li>
<li>Node[] tab哈希桶数组.哈希冲突，开放地址和链地址法</li>
<li>根据key获取哈希桶数组索引位置</li>
<li>tab 长度为2的幂次</li>
<li>threshold 所能容纳的key-value对极限</li>
<li>Map m = Collections.synchronizeMap(hashMap)实现同步</li>
<li>初始 capacity 16 loadFactor 0.75</li>
</ul>
</li>
<li><p><a href="http://www.iqiyi.com/v_19rro6v558.html?vfm=m_312_shsp" title="Optional title" target="_blank" rel="noopener">TreeMap</a></p>
<ul>
<li>红黑树的定义，节点非红即黑，根节点为黑色，不能连续的红色，任意节点到末端的路径黑色个数相同</li>
<li>红黑树的平衡调整，颜色和结构</li>
<li>继承了SortMap ，put()函数会做比较</li>
<li>寻找后继节点，中序遍历</li>
</ul>
</li>
<li><p>LinkHashMap</p>
</li>
</ol>
<ul>
<li>与HashMap类似，不过保证了put顺序</li>
<li>主要实现了afterNodeAccess(),afterNodeInsert(),afterNoderemoval三个方法</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>android 线程那些事</title>
    <url>/android-xian-cheng-tong-bu.html</url>
    <content><![CDATA[<h3 id="线程和线程安全"><a href="#线程和线程安全" class="headerlink" title="线程和线程安全"></a>线程和线程安全</h3><h4 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h4><ol>
<li>线程为进程的一个实体</li>
<li>轻量级进程</li>
<li>是CPU调度和分配的基本单位</li>
<li>可与同一进程内的线程共享进程内的全部资源</li>
<li>android 进程通过fork创建，线程通过pthread.creat创建</li>
</ol>
<h4 id="并发的优势促使多线程的出现"><a href="#并发的优势促使多线程的出现" class="headerlink" title="并发的优势促使多线程的出现"></a>并发的优势促使多线程的出现</h4><ol>
<li>资源利用率 ，提高</li>
<li>公平性，共享资源</li>
<li>便利性，多任务并发执行比单任务更容易执行</li>
</ol>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多线程的引入意味着引入了线程安全。当单线程能正确运行的代码，在多线程访问的情况下，不管线程以何种顺序访问，并不添加同步代码都能正确表现行为，则称它为线程安全的</p>
<h3 id="并发的三大要素"><a href="#并发的三大要素" class="headerlink" title="并发的三大要素"></a>并发的三大要素</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指的是一个或者多个不能再被分割的操作<br>value = 1; //院子操作<br>value++; //复合操作</p>
<h4 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h4><p>指多进程访问共享资源，不做同步</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>当一个线程对某个变量做出修改时，其他线程可以立刻读取修改后的值</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ol>
<li>是一种稍弱的同步机制，用来确保变量更新操作同步到其他线程，虚拟机不会指令重排</li>
<li>锁与volatile不同，锁具有两个特性：互斥性和可见性</li>
</ol>
<h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><h4 id="Sychronized关键字"><a href="#Sychronized关键字" class="headerlink" title="Sychronized关键字"></a>Sychronized关键字</h4><p>可作用于class和java对象</p>
<h4 id="锁的原理"><a href="#锁的原理" class="headerlink" title="锁的原理"></a>锁的原理</h4><ol>
<li>锁实现了内存可见性和操作原子性</li>
<li>释放锁时，该线程的本地内存中的共享变量会被刷新到内存中</li>
<li>锁不会被继承</li>
<li>同步代码块是使用monitorenter和monitorexit指令实现的，同步方法是通过ACC_SYNCHRONIZED标识符实现</li>
</ol>
<h4 id="锁的使用原则"><a href="#锁的使用原则" class="headerlink" title="锁的使用原则"></a>锁的使用原则</h4><ol>
<li>可能被多个线程同时访问的可变变量，在访问它时都需要持有一个锁，变量由这个锁保护</li>
<li>每个可变变量都只有一个锁来保护，知道锁的范围</li>
<li>当锁作用于多个变量时，对每个变量的操作都应该由同一个恶锁保护</li>
<li>在Android中，工作线程尽量不要和UI线程做同步</li>
</ol>
<h4 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h4><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h4 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h4><p>reentrantLock<br>semaphore<br>countDownLatch<br>CyclicBarrier<br>FutureTask</p>
<h3 id="原子变量和非阻塞算法"><a href="#原子变量和非阻塞算法" class="headerlink" title="原子变量和非阻塞算法"></a>原子变量和非阻塞算法</h3><p>Atomic<br>cas非阻塞算法<br>性能比较</p>
<p><a href="https://segmentfault.com/l/1500000012849264/play" target="_blank" rel="noopener">https://segmentfault.com/l/1500000012849264/play</a></p>
]]></content>
  </entry>
  <entry>
    <title>Bit Manipulation</title>
    <url>/bit-manipulation.html</url>
    <content><![CDATA[<h3 id="Bit-Manipulation-位运算-："><a href="#Bit-Manipulation-位运算-：" class="headerlink" title="Bit Manipulation(位运算)："></a>Bit Manipulation(位运算)：</h3><p>一共五种运算：与，或，异或，左移，右移。</p>
<h4 id="常用技巧："><a href="#常用技巧：" class="headerlink" title="常用技巧："></a>常用技巧：</h4><p>（1） n &amp; （n-1）能够消灭n中最低位中的1。<br>（2） 右移：除以2， 左移：乘以2。<br>（3） 异或性质：交换律，0^a=a, a^a=0;<br>（3） 将常用字符、数字等均转为按位运算，可以节约空间。</p>
<a id="more"></a>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="Number-of-1-Bits"><a href="#Number-of-1-Bits" class="headerlink" title="Number of 1 Bits"></a><a href="https://leetcode.com/problems/number-of-1-bits/description/" title="Optional title" target="_blank" rel="noopener">Number of 1 Bits</a></h4><p>使用右移。<br>使用n&amp;(n-1)可以消灭一个1的性质来求解。</p>
<pre><code>public static int hammingWeight(int n) {
    int cnt = 0;
    while (n &gt; 0) {
        cnt += (n &amp; 1);
        n &gt;&gt;= 1;
    }
    return cnt;
}</code></pre><h4 id="Missing-Number"><a href="#Missing-Number" class="headerlink" title="Missing Number"></a><a href="https://leetcode.com/problems/missing-number/description/" title="Optional title" target="_blank" rel="noopener">Missing Number</a></h4><p>这道题给我们n个数字，是0到n之间的数但是有一个数字去掉了，让我们寻找这个数字，要求线性的时间复杂度和常数级的空间复杂度。<br><strong>解法一:</strong>最直观的一个方法是用等差数列的求和公式求出0到n之间所有的数字之和，然后再遍历数组算出给定数字的累积和，然后做减法，差值就是丢失的那个数字</p>
<pre><code>public static int missingNumber(int[] nums) {
    int sum = 0;
    int n = nums.length;
    for(int i =0; i&lt; n; i++){
        sum += nums[i];
    }
    return (int)(0.5 * n * (n + 1) - sum);
}</code></pre><p><strong>解法二：</strong>，使用位操作Bit Manipulation来解的，用到了异或操作的特性。思路是既然0到n之间少了一个数，我们将这个少了一个数的数组合0到n之间完整的数组异或一下，那么相同的数字都变为0了，剩下的就是少了的那个数字了</p>
<pre><code>public static int missingNumber1(int[] nums) {
    int res = 0;
    for (int i = 0; i &lt; nums.length; ++i) {
        int midres = (i + 1) ^ nums[i];
        res ^= midres;
    }
    return res;
}</code></pre><p><strong>解法三：</strong>这道题还可以用二分查找法来做，我们首先要对数组排序，然后我们用二分查找法算出中间元素的下标，然后用元素值和下标值之间做对比，如果元素值大于下标值，则说明缺失的数字在左边，作为读者的你可能会提出，排序的时间复杂度都不止O(n)，何必要多此一举用二分查找，还不如用上面两种方法呢。对，你说的没错，但是在面试的时候，有可能人家给你的数组就是排好序的，那么此时用二分查找法肯定要优于上面两种方法，所以这种方法最好也要掌握以下</p>
<pre><code>public static int missingNumber2(int[] nums) {
    if(nums == null || nums.length ==0)
        return -1;
    int low = 0;
    int high = nums.length - 1;
    while (low &lt;= high){
        int mid = low + (high - low)/2;
        if(nums[mid] &gt; mid){
            high = mid -1;
        }else {
            low = mid + 1;
        }
    }
    return low;
}</code></pre><h4 id="Power-of-Two"><a href="#Power-of-Two" class="headerlink" title="Power of Two"></a><a href="https://leetcode.com/problems/power-of-two/description/" title="Optional title" target="_blank" rel="noopener">Power of Two</a></h4><p>使用n&amp;(n-1）=0来判断。<br>注意0和负数的情况。<br>这道题让我们判断一个数是否为2的次方数，而且要求时间和空间复杂度都为常数<br><strong>解法一：</strong>那么我们很容易看出来2的次方数都只有一个1，剩下的都是0，所以我们的解题思路就有了，我们只要每次判断最低位是否为1，然后向右移位，最后统计1的个数即可判断是否是2的次方数</p>
<pre><code>public static boolean isPowerOfTwo(int n) {
    int cnt = 0;
    while (n &gt; 0) {
        cnt += (n &amp; 1);
        n &gt;&gt;= 1;
    }
    return cnt == 1;
}</code></pre><p><strong>解法二：</strong>这道题还有一个技巧，如果一个数是2的次方数的话，根据上面分析，那么它的二进数必然是最高位为1，其它都为0，那么如果此时我们减1的话，则最高位会降一位，其余为0的位现在都为变为1，那么我们把两数相与，就会得到0，用这个性质也能来解题。</p>
<pre><code>public static boolean isPowerOfTwo2(int n){
    int result = n &amp; (n - 1);
    if(n &gt; 0 &amp;&amp; result == 0){
        return true;
    }else {
        return false;
    }
}</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>自建梯子，畅行无阻</title>
    <url>/vpn.html</url>
    <content><![CDATA[<p><a href="https://github.com/codeyu/BTGFW" title="Optional title" target="_blank" rel="noopener">自建梯子教程</a><br><a href="https://github.com/XX-net/XX-Net/issues/6506#issuecomment-336799889" title="Optional title" target="_blank" rel="noopener">自己搭建ss/ssr服务器教程（适合初学者）</a></p>
<p>###【一键部署ssr代码】<br>yum -y install wget<br>wget -N –no-check-certificate <a href="https://softs.fun/Bash/ssr.sh" target="_blank" rel="noopener">https://softs.fun/Bash/ssr.sh</a> &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</p>
<p>备用地址<br>yum -y install wget<br>wget -N –no-check-certificate <a href="https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh</a> &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</p>
<a id="more"></a>
<p>参数配置<br>远程端口<br>密码<br>加密方式 aes-256-cfb<br>协议 auth_chain_a<br>混淆方式 plain</p>
<p>###【谷歌BBR加速教程】</p>
<p>yum -y install wget</p>
<p>wget –no-check-certificate <a href="https://github.com/teddysun/across/raw/master/bbr.sh" target="_blank" rel="noopener">https://github.com/teddysun/across/raw/master/bbr.sh</a></p>
<p>chmod +x bbr.sh</p>
<p>./bbr.sh</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Largest Rectangle in Histogram and Maximal Rectangle</title>
    <url>/largest-rectangle-in-histogram.html</url>
    <content><![CDATA[<p>题目链接：<br><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" title="Optional title" target="_blank" rel="noopener">Largest Rectangle in Histogram</a><br><a href="https://leetcode.com/problems/maximal-rectangle/description/" title="Optional title" target="_blank" rel="noopener">Maximal Rectangle</a></p>
<a id="more"></a>
<p>Largest Rectangle in Histogram 这道题算是比较难的一道题，最简单的做法就是对于任意一个bar，向左向右遍历，知道高度小于该bar。这时候计算该区域的面积。对于每一个bar，我们都做如上处理，最后得到最大值。当然这样的做法是O(n2)，过不了大数据集合测试。</p>
<p>从上面我们直到，对于任意一个bar n，我们得到的包含该bar n的矩形区域里面bar n是最小的。我们使用ln和rn来表示bar n向左及向右第一个小于bar n的bar的索引位置。<br>譬如题目中bar 2的高度是5,它的ln为1，rn为4.包含bar的矩形区域面积为（4-1-1）*5=10</p>
<p>我们可以从左往右遍历所有的bar，并将其push到一个stack中，如果dangqianbar的高度小于栈顶bar，我们pop出栈顶bar，同时以该bar计算举行面积。纳闷我们如何知道该bar的ln和rn呢？rn铁定就是当前遍历到的bar的索引，而ln则是当前栈顶bar的索引，因为此时栈顶bar的高度一定小于pop出来的bar的高度。</p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>因为要找三个元素，所以时间复杂度为O(n)，空间复杂度为O(1)</p>
<h4 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h4><pre><code>public static int largestRectangleArea(int[] height ){
    int maxArea  = 0;
    Stack&lt;Integer&gt; s = new Stack&lt;&gt;();
    int i = 0;
    while (i &lt;= height.length){
        int h = (i == height.length ? 0 : height[i]);
        if(s.isEmpty() ||  h &gt;= height[s.peek()]){
            s.push(i);
            i++;
        }else {
            int t = s.pop();
            maxArea = Math.max(maxArea, height[t] * (s.isEmpty() ? i : i - s.peek() - 1));
        }
    }
    return maxArea;
}</code></pre><p>Maximal Rectangle此题是之前那道的 Largest Rectangle in Histogram直方图中最大的矩形 的扩展，这道题的二维矩阵每一层向上都可以看做一个直方图，输入矩阵有多少行，就可以形成多少个直方图，对每个直方图都调用 Largest Rectangle in Histogram 直方图中最大的矩形 中的方法，就可以得到最大的矩形面积。那么这道题唯一要做的就是将每一层构成直方图，由于题目限定了输入矩阵的字符只有 ‘0’ 和 ‘1’ 两种，所以处理起来也相对简单。方法是，对于每一个点，如果是‘0’，则赋0，如果是 ‘1’，就赋之前的height值加上1。具体参见代码如下：</p>
<h4 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h4><pre><code>public static int maximalRectangle(char[][] matrix) {
    if(matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return 0;

    int[] height = new int[matrix[0].length];
    for(int i = 0; i &lt; matrix[0].length; i ++){
        if(matrix[0][i] == &#39;1&#39;) height[i] = 1;
    }
    int result = largestRectangleArea(height);
    for(int i = 1; i &lt; matrix.length; i ++){
        resetHeight(matrix, height, i);
        result = Math.max(result, largestRectangleArea(height));
    }
    return result;
}

private static void resetHeight(char[][] matrix, int[] height, int idx){
    for(int i = 0; i &lt; matrix[0].length; i ++){
        if(matrix[idx][i] == &#39;1&#39;) height[i] += 1;
        else height[i] = 0;
    }
}

public static int largestRectangleArea(int[] height ){
    int maxArea  = 0;
    Stack&lt;Integer&gt; s = new Stack&lt;&gt;();
    int i = 0;
    while (i &lt;= height.length){
        int h = (i == height.length ? 0 : height[i]);
        if(s.isEmpty() ||  h &gt;= height[s.peek()]){
            s.push(i);
            i++;
        }else {
            int t = s.pop();
            maxArea = Math.max(maxArea, height[t] * (s.isEmpty() ? i : i - s.peek() - 1));
        }
    }
    return maxArea;
}</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>需常记心头</title>
    <url>/xu-chang-ji-xin-tou.html</url>
    <content><![CDATA[<p>在二维火工作收集的经典语句！</p>
<a id="more"></a>
<p><strong>不要起个大早，赶个晚集</strong><br>无法快速落地的“点子”都属于“忽悠”。趋势、潮流瞬息万变，竞争对手如狼似虎。再好的点子，如果只是挂在嘴上，不执行、不落实，等于把机会拱手送给别人。</p>
<p><strong>清空自己</strong><br>用户都很懒，并且时间宝贵，面对陌生的功能需要快速做出决定。所以在设计每一个细节时，尽量清空自己，忘掉身份，忘掉流程，让自己变成一个小白。最终呈现给用户的内容才是浅显易懂的。</p>
<p><strong>不要被用户牵着鼻子走</strong><br>与用户聊需求时，要挖掘其背后真实的目的。用户不会替我们考虑灵活性、普遍性、规范性。个性化的需求如何落实到通用的产品中区，需要思考，不能被用户带到沟里去。</p>
<p><strong>切记习以为常</strong><br>习惯一个人，习惯一件事，会让自己变得麻木，忽视其中存在的问题。我们的产品对大部分用户来说是陌生的，用户可能会卡在一些我们倒背如流的节点上，设计和使用自己的产品时需要保持敏感</p>
<p><strong>定期回顾</strong><br>行业在发展，技术在进步，客户的认知在变化，我们自己也在成长。长时间不用的东西，定期去回顾，会发现很多问题。有些功能用的很少，可能设计过时了，或者流程出问题了。</p>
<p><strong>产品能解决的事不要靠人去解决</strong><br>“这个功能给店家培训一下就好”，这句话是不负责任的，一个功能点做一次培训，一家店做一次培训，一千个功能点和十万店家需要多少人去培训多少次？人力成本的投入是巨大的，要用好的设计去引导用户，而不是靠人力去解决问题。</p>
]]></content>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Find Mininum in Rotated Sorted Array I and II</title>
    <url>/find-mininum-in-rotated-sorted-array.html</url>
    <content><![CDATA[<p>题目链接:<br><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" title="Optional title" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array</a><br><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/" title="Optional title" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array II</a></p>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>Find the minimum element.<br><strong>I和II的区别在于是否有重复元素</strong></p>
<a id="more"></a>

<h4 id="题目的要求"><a href="#题目的要求" class="headerlink" title="题目的要求"></a>题目的要求</h4><ol>
<li>一个升序的数组且无重复元素</li>
<li>在处理数组前进行部分反转</li>
<li>找出最小元素</li>
</ol>
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><ol>
<li>寻找最小值，我们可以用二分查找法来做</li>
<li>在一个区间的A，如果A[start] &lt; A[end]，那么该区间一定是有序的</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>假设一个轮转的排序数组arr，我们首先获取中间元素的值，arr[mid], mid = start + (end - start)/2.因为没有重复数组，那么就有两种情况。</p>
<ol>
<li>arr[mid] &gt; arr[start], 那么最小值一定在右半区间，eg:{4,5,6,7,0,1,2} 中间数为7.7&gt;4,最小元素一定在{7,0,1,2}</li>
<li>arr[mid] &lt; arr[start], 那么最小值一定在左半区间,eg:{7,0,1,2,3,4,5,6}中间数为2,2&lt;7，最小元素一定在{7,0,1,2}</li>
<li>处理重复元素，当arr[mid] == arr[start], 跳过start++.</li>
</ol>
<h4 id="边界值"><a href="#边界值" class="headerlink" title="边界值"></a>边界值</h4><ol>
<li>输入数组arr == null, arr.length == 0 ,return 0</li>
<li>arr.length == 1, return arr[0]</li>
<li>输入数组arr为有序数组，return arr[start];</li>
</ol>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间复杂度为O(logn)，空间复杂度为O(N)</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>public static int findMin(int[] arr){
    if(arr == null || arr.length == 0)
        return 0;
    if(arr.length == 1)
        return arr[0];

    int start = 0;
    int end = arr.length -1;

    while (start &lt; end){
        if(arr[start] &lt; arr[end]){
            return arr[start];
        }
        int min = start + (end - start)/2; It can avoid overflow.
        if(arr[start] &lt; arr[min]){
            start = min;
        }else if(arr[start] &lt; arr[min]){
            end = min;
        }else{
            start++; //处理重复元素
        }
    }
    return arr[start] &lt; arr[end] ? arr[start] : arr[end];
}</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>3Sum</title>
    <url>/3sum.html</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/3sum/discuss/" title="Optional title" target="_blank" rel="noopener">3Sum</a><br>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>Note: The solution set must not contain duplicate triplets.</p>
<pre><code>For example, given array S = [-1, 0, 1, 2, -1, -4],
A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]</code></pre><a id="more"></a>
<h4 id="题目的两点要求："><a href="#题目的两点要求：" class="headerlink" title="题目的两点要求："></a>题目的两点要求：</h4><ol>
<li>每个答案组里面的三个数字是要从小到大排列起来的</li>
<li>每个答案不可以和其他的答案相同</li>
</ol>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><ol>
<li>每个答案数组triplet中的元素是要求升序排列的</li>
<li>不能包含重复的答案数组</li>
</ol>
<h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><ol>
<li>因为要求每个答案数组中的元素都是升序排列的，所以开头我们要对数组进行排序</li>
<li>因为不能包含重复的答案数组，我们要在代码里做去重操作</li>
<li>归根结底是Two pointers的想法，定位其中两个指针，根据和的大小移动另外一个</li>
</ol>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>因为要找三个元素，所以时间复杂度为O(n2)，空间复杂度为O(1)</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    if(nums.length &lt; 3)
        return result;
    Arrays.sort(nums);
    int i = 0;
    while (i &lt; nums.length -2){
        if(nums[i] &gt; 0)
            return result;
        int j = i + 1;
        int k = nums.length - 1;

        while (j &lt; k){
            int sum = nums[i] + nums[j] + nums[k];
            if(sum == 0)
                result.add(Arrays.asList(nums[i], nums[j], nums[k]));
            if(sum &lt;= 0)
                while (nums[j] == nums[++j] &amp;&amp; j &lt; k);
            if(sum &gt;= 0)
                while (nums[k] == nums[--k] &amp;&amp; j &lt; k);
        }
        while (nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2);
    }
    return result;
}</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>20171117picture</title>
    <url>/20171117picture.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hexo优化参考</title>
    <url>/20171117hexo.html</url>
    <content><![CDATA[<p><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" title="Optional title" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></p>
<p><a href="https://ehlxr.me/2016/08/30/%E4%BD%BF%E7%94%A8Hexo%E5%9F%BA%E4%BA%8EGitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/" title="Optional title" target="_blank" rel="noopener">使用Hexo基于GitHub Pages搭建个人博客</a></p>
<p><a href="http://www.aisun.org/2017/09/hexo+next+gitment/" title="Optional title" target="_blank" rel="noopener">为 hexo NexT 添加 Gitment 评论插件</a>(Next 5.1.3已集成)</p>
<p><a href="http://tc9011.com/2016/12/24/hexo%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E3%80%81high%E4%B8%80%E4%B8%8B%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91/" title="Optional title" target="_blank" rel="noopener">hexo添加音乐、high一下及一些坑</a></p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读 一本书</title>
    <url>/20171117read.html</url>
    <content><![CDATA[<p><strong>想做一个会阅读的人！</strong><br>阅读的目的可以从三方面理解：<br>1.获取资讯，2.为了娱乐，3.增进阅读的理解力。<br><em>会读书的人都是主动的阅读，为了提高阅读的理解力。</em></p>
<a id="more"></a>

<h2 id="阅读的三个阶段："><a href="#阅读的三个阶段：" class="headerlink" title="阅读的三个阶段："></a>阅读的三个阶段：</h2><ul>
<li>基础阅读：掌握基础的字面上的意思</li>
<li>分析阅读：对书进行剖析，与作者深度沟通交流</li>
<li>主题阅读：同一主题书籍的相互对比，提炼。</li>
</ul>
<h3 id="分析阅读有："><a href="#分析阅读有：" class="headerlink" title="分析阅读有："></a>分析阅读有：</h3><h4 id="第一阶段：找出一本书在谈些什么的规则"><a href="#第一阶段：找出一本书在谈些什么的规则" class="headerlink" title="第一阶段：找出一本书在谈些什么的规则"></a>第一阶段：找出一本书在谈些什么的规则</h4><ul>
<li>了解这本书的种类和主题，并分类</li>
<li>能用简短的语句概括这本书的主要内容</li>
<li>按照书的特定顺序和重要内容，罗列书的大纲，并罗列重要部分的摘要</li>
<li>确定作者想要解决的问题</li>
</ul>
<h4 id="第二阶段：诊释一本书的内容规则"><a href="#第二阶段：诊释一本书的内容规则" class="headerlink" title="第二阶段：诊释一本书的内容规则"></a>第二阶段：诊释一本书的内容规则</h4><ul>
<li>找出关键字，与作者达成共识</li>
<li>理解关键字所在的句子，明确主题</li>
<li>分析重要句字所在的重要段落，知道作者重要的论述是什么。</li>
<li>确定作者已经解决了哪些问题，还有哪些是没解决的。判断哪些是作者已知的未解决问题</li>
</ul>
<h4 id="第三阶段：像是沟通知识一样的评论一本书的规则"><a href="#第三阶段：像是沟通知识一样的评论一本书的规则" class="headerlink" title="第三阶段：像是沟通知识一样的评论一本书的规则"></a>第三阶段：像是沟通知识一样的评论一本书的规则</h4><ul>
<li>在了解整本书的大纲并能诠释这本书前，不能轻易批评</li>
<li>避免争强好胜盲目反对</li>
<li>批评之前要证明自己分清了知识与个人观点的不同<h5 id="常见评判标准"><a href="#常见评判标准" class="headerlink" title="常见评判标准"></a>常见评判标准</h5></li>
</ul>
<ol>
<li>作者知识不足</li>
<li>作者知识错误</li>
<li>作者逻辑错误</li>
<li>作者分析不全</li>
</ol>
<h2 id="把书本内容变成自己的知识和能力（实用性阅读指南）"><a href="#把书本内容变成自己的知识和能力（实用性阅读指南）" class="headerlink" title="把书本内容变成自己的知识和能力（实用性阅读指南）"></a>把书本内容变成自己的知识和能力（实用性阅读指南）</h2><p>大严峻之认为：<strong>一本书的重要内容只占整本书的20%，这20%最重要的又仅有4%。</strong></p>
<h3 id="带着目标主动阅读，找重点"><a href="#带着目标主动阅读，找重点" class="headerlink" title="带着目标主动阅读，找重点"></a>带着目标主动阅读，找重点</h3><ul>
<li>想想你希望通过这本书获得什么</li>
<li>用二八法则关注书中20%最重要的知识<h3 id="做好读书笔记，尤其是思维导图"><a href="#做好读书笔记，尤其是思维导图" class="headerlink" title="做好读书笔记，尤其是思维导图"></a>做好读书笔记，尤其是思维导图</h3></li>
<li>笔记不是做单纯的摘录，而是提炼书本内容，并形成自己的理解，通过笔记完成信息到知识的转换，实现输出</li>
<li>将我们头脑中正在思考的内容，以可视化的图形呈现出来的思考工具<br><img src="http://opd2n5pxb.bkt.clouddn.com/read1.jpg" alt="实用性阅读指南思维导图" title="Optional title"></li>
</ul>
<h3 id="付诸行动，将学到的知识转化为能力"><a href="#付诸行动，将学到的知识转化为能力" class="headerlink" title="付诸行动，将学到的知识转化为能力"></a>付诸行动，将学到的知识转化为能力</h3><ul>
<li>设立具体的、可达到的行动目标</li>
<li>思考现状和目标的差距</li>
<li>将目标进一步具体化，细化到每一天之行，确定行动的优先顺序</li>
</ul>
<h2 id="如何在三年内有效地打造自己的专业能力-高效能阅读"><a href="#如何在三年内有效地打造自己的专业能力-高效能阅读" class="headerlink" title="如何在三年内有效地打造自己的专业能力(高效能阅读)"></a>如何在三年内有效地打造自己的专业能力(高效能阅读)</h2><h3 id="下定决心锁定一个主题"><a href="#下定决心锁定一个主题" class="headerlink" title="下定决心锁定一个主题"></a>下定决心锁定一个主题</h3><ul>
<li>请下定决心，锁定一个主题。只有骨气勇气锁定一个主题，就能形成思考的轴。有了这个轴，所有的信息都会随之而来。</li>
<li>读书要 <strong>先专后博</strong> ，深入思考一件事的时候，是不得不同时思考其他很多事。这是因为，人的生活本来就是综合性、整体性的。</li>
</ul>
<h3 id="把读书的七成投资在垂直型阅读上"><a href="#把读书的七成投资在垂直型阅读上" class="headerlink" title="把读书的七成投资在垂直型阅读上"></a>把读书的七成投资在垂直型阅读上</h3><p>投资基础 <strong>“70:20:10模式”</strong>，读书要7成投资在垂直型阅读，2成阅读支持现有业务或新业务的书，1成是阅读未知领域。</p>
<h3 id="观察业务能力强的前辈的书架"><a href="#观察业务能力强的前辈的书架" class="headerlink" title="观察业务能力强的前辈的书架"></a>观察业务能力强的前辈的书架</h3><p>观察或让前辈推荐他们认为好的书</p>
<h3 id="对业界关键人物进行定点观测"><a href="#对业界关键人物进行定点观测" class="headerlink" title="对业界关键人物进行定点观测"></a>对业界关键人物进行定点观测</h3><p>常常了解最新业界消息</p>
<p><strong>未完待续<del>~</del></strong></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Merge Sorted Array</title>
    <url>/20171116.html</url>
    <content><![CDATA[<p>题目链接:<a href="https://leetcode.com/problems/merge-sorted-array/description/" title="Optional title" target="_blank" rel="noopener">Merge Sorted Array</a><br>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.<br>由题意得：<br>1.A和B两个数组都是有序的数组，大小分别为m和n<br>2.合并两数组在A数组中，A数组容量足够大。<br>思路分析：如果暴力解法即(无脑解法)，遍历A数组和B数组每个元素比较，若A[i] &lt; B[j]，则继续比较下一个B元素，否则将A数组i及之后的元素往后移动以为。这种解法想想就不可能。换一种思路两数组都反向递减遍历。两数组总长度index = m+n-1, 遍历若A[i] &lt; B[j]，则A[index] = A[j] j–,否则A[index] = B[i] i–,index–。代码如下：</p>
<pre><code>public static int[] megerArray(int[] A, int m, int[] B, int n){
    int aCount = m-1, bCount = n-1, index = m+n-1;
    while (index &gt;= 0){
        if(aCount&gt;=0 &amp;&amp; bCount&gt;=0){
            if(A[aCount] &gt; B[bCount]){
                A[index] = A[aCount];
                aCount--;
            }else {
                A[index] = A[bCount];
                bCount--;
            }
        }else if(aCount &gt;= 0){
            A[index] = A[aCount];
            aCount--;
        }else if(bCount &gt;=0){
            A[index] = A[bCount];
            bCount--;
        }
        index--;
    }
    return A;
}</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Pascal&#39;s Triangle II</title>
    <url>/pascal-s-triangle-ii.html</url>
    <content><![CDATA[<p>题目链接: <a href="https://leetcode.com/problems/pascals-triangle-ii/description/" title="Optional title" target="_blank" rel="noopener">Pascal’s Triangle II</a><br>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return [1,3,3,1].</p>
<p>Note:<br>Could you optimize your algorithm to use only O(k) extra space?</p>
<p>这道题跟Pascal’s Triangle很类似，只是这里只需要求出某一行的结果。Pascal’s Triangle中因为是求出全部结果，所以我们需要上一行的数据就很自然的可以去取。而这里我们只需要一行数据，就得考虑一下是不是能只用一行的空间来存储结果而不需要额外的来存储上一行呢？这里确实是可以实现的。对于每一行我们知道如果从前往后扫，第i个元素的值等于上一行的list[i]+list[i-1]，可以看到数据是往前看的，如果我们只用一行空间，那么需要的数据就会被覆盖掉。所以这里采取的方法是从后往前扫，这样每次需要的数据就是list[i]+list[i-1]，我们需要的数据不会被覆盖，因为需要的res[i]只在当前步用，下一步就不需要了。这个技巧在动态规划省空间时也经常使用，主要就是看我们需要的数据是原来的数据还是新的数据来决定我们遍历的方向。时间复杂度还是O(n^2)，而空间这里是O(k)来存储结果，仍然不需要额外空间。代码如下：</p>
<pre><code>public static List&lt;Integer&gt; getRow(int row){
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    if(row&lt;0)
        return list;
    list.add(1);
    for (int line = 1; line &lt; row; line++){
        for (int index = list.size() - 1; index &gt; 0; index --){
            list.set(index, list.get(index-1)+list.get(index));
        }
        list.add(1);
    }
    return list;
}</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Adroid studio常用技巧</title>
    <url>/adroid-studio-chang-yong-ji-qiao.html</url>
    <content><![CDATA[<p>Android studio 是Google官方定制的Android开发工具，俗话说工欲善其事必先利其器，充分利用开发工具不仅能大大提高工作效率，同时也是个人能力的一种体现。在此提供关键字和官方文档方便查阅和记忆</p>
<a id="more"></a>
<h4 id="1-Android-国际化多语言实现"><a href="#1-Android-国际化多语言实现" class="headerlink" title="1.Android 国际化多语言实现"></a>1.Android 国际化多语言实现</h4><p>Translations Editor 翻译编辑<br>preview中导航栏Language，设置及时显示语言<br><a href="https://developer.android.com/studio/write/translations-editor.html?hl=zh-cn" title="Optional title" target="_blank" rel="noopener">Localize the UI with Translations Editor</a></p>
<h4 id="2-最小化用户遇到“打开方式”对话框的概率"><a href="#2-最小化用户遇到“打开方式”对话框的概率" class="headerlink" title="2.最小化用户遇到“打开方式”对话框的概率"></a>2.最小化用户遇到“打开方式”对话框的概率</h4><p>Android App Links<br><a href="https://developer.android.com/studio/write/app-link-indexing.html?hl=zh-cn" title="Optional title" target="_blank" rel="noopener">Add Android App Links</a></p>
<h4 id="3-使用-Lint-改进代码"><a href="#3-使用-Lint-改进代码" class="headerlink" title="3.使用 Lint 改进代码"></a>3.使用 Lint 改进代码</h4><p>手动运行检查或从命令行运行 Lint<br><a href="https://developer.android.com/studio/write/lint.html?hl=zh-cn#config" title="Optional title" target="_blank" rel="noopener">使用 Lint 改进您的代码</a></p>
<h4 id="4-使用注解改进代码检查"><a href="#4-使用注解改进代码检查" class="headerlink" title="4.使用注解改进代码检查"></a>4.使用注解改进代码检查</h4><p>support-annotations依赖<br><a href="https://developer.android.com/studio/write/annotations.html?hl=zh-cn" title="Optional title" target="_blank" rel="noopener">使用注解改进代码检查</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Adroid studio</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Pascal&#39;s Triangle</title>
    <url>/pascal-s-triangle.html</url>
    <content><![CDATA[<p>题目链接:<a href="https://leetcode.com/problems/pascals-triangle/description/" title="Optional title" target="_blank" rel="noopener">Pascal’s Triangle</a></p>
<p>Given numRows, generate the first numRows of Pascal’s triangle.<br>For example, given numRows = 5,<br>Return</p>
<pre><code>[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]</code></pre><p>这道题比较简单，属于基础的数组操作。知道规律就好做了，它的规律如下：<br>1.每行的元素个数等于行数<br>2.每行的第一个元素和最后一个元素等于1<br>3.第三行起，每行除第一个和最后一个元素外之间的元素第i行第k个元素 = 行数i-1行第k个元素 + 行数i-1行第k-1元素<br>4.隐藏条件：当行数i和元素j的下表相等时 ，i行的第j个元素等于1<br>具体代码如下：</p>
<pre><code>//方法一
public static List&lt;List&lt;Integer&gt;&gt;  generate(int numRows){
    List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;&gt;();
    if(numRows &lt;= 0){
        return triangle;
    }

    for (int i = 0; i &lt; numRows; i++) {
        List&lt;Integer&gt; row = new ArrayList&lt;&gt;();
        for (int j = 0; j &lt; i+1; j++) {
            if(j ==0 || j == i){
                row.add(1);
            }else {
                row.add(triangle.get(i-1).get(j-1) + triangle.get(i-1).get(j));
            }
        }
        triangle.add(row);
    }
    return triangle;
}


//方法二
public static int[][]  pascal(int rowNums){
    if(rowNums&lt;=0)
        return new int[1][1];

    int[][] arr = new int[rowNums][];
    for (int i = 0; i &lt; rowNums; i++){
        arr[i] = new int[i+1];
        for (int j = 0; j &lt; i+1; j++){
            if(j == 0 || j == i){
                arr[i][j] = 1;
            }else {
                arr[i][j] = arr[i-1][j-1] + arr[i-1][j];
            }
        }
    }
    return arr;
}</code></pre><p>算法时间复杂度应该是O(1+2+3+…+n)=n(n-1)/2=O(n^2)，空间上只需要二维数组来存储结果，不需要额外空间。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Plus One</title>
    <url>/plus-one.html</url>
    <content><![CDATA[<p>题目链接 <a href="https://leetcode.com/problems/plus-one/description/" title="Optional title" target="_blank" rel="noopener">Plus One</a></p>
<p>Given a non-negative number represented as an array of digits, plus one to the number.<br>The digits are stored such that the most significant digit is at the head of the list.</p>
<p> 这道题很简单，就是考加法的进位运算问题对一个数组进行加一操作，具体思路：<br> 维护一个进位，对每一位进行加一，然后判断进位，如果有继续到下一位，否则就可以返回了，因为前面不需要计算了。有一个小细节就是如果到了最高位进位仍然存在，那么我们必须重新new一个数组，然后把第一个为赋成1（因为只是加一操作，其余位一定是0，否则不会进最高位）。代码如下：</p>
<pre><code> public static int[] plusOne(int[] digit){
        int one = 1;
        int sum = 0;
        for(int i = digit.length -1 ; i &gt;= 0; i--){
            sum = digit[i] + one;
            digit[i] = sum % 10;  //取余
            one = sum / 10;  //取整
            if(one == 0){ //无需进位，则返回即可
                return digit;
            }
        }
        int[] res = new int[digit.length + 1]; //当最高位仍需进位则重新new一个数组
        res[0] = 1;
        return res;
    }</code></pre><p> 因为只需要一次扫描，所以算法复杂度是O(n)，n是数组的长度。而空间上，一般情况是O(1)，但是如果数是全9，那么是最坏情况，需要O(n)的额外空间。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo，换电脑怎么更新博客</title>
    <url>/shi-yong-hexo-huan-dian-nao-zen-me-geng-xin-bo-ke.html</url>
    <content><![CDATA[<p>hexo官方给了一些迁移的方法，不过它上面介绍的方法都是把博客文章从hexo系统迁移到其他博客系统的方法。然而我们这里要讨论的是：</p>
<h4 id="当我们更换电脑的时候我们应该怎么办？"><a href="#当我们更换电脑的时候我们应该怎么办？" class="headerlink" title="当我们更换电脑的时候我们应该怎么办？"></a>当我们更换电脑的时候我们应该怎么办？</h4><p>所以默认你已经成功利用hexo和github发布博客，如果还没有，网上很多资料。</p>
<a id="more"></a>
<p>具体的思路是：在生成的已经推到github上的hexo静态代码出建立一个分支，利用这个分支来管理自己hexo的源文件。如果能在刚刚配置hexo的时候就想好以后的迁移的问题就太好了，可以省掉很多麻烦，可实际使用中，刚刚配置hexo的时候，好多人都是初学，不会想到以后的问题，我就是这样的。</p>
<h3 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h3><ol>
<li>克隆gitHub上面生成的静态文件到本地<pre><code>git clone git@github.com:ZhengYangxin/zhengyangxin.github.io.git</code></pre></li>
<li>把克隆到本地的文件除了git的文件都删掉，找不到git的文件的话就当删了吧。不要用hexo init初始化。</li>
<li>将之前使用hexo写博客时候的整个目录（所有文件）搬过来。把该忽略的文件忽略了<br>```<br>.DS_Store<br>Thumbs.db<br>db.json</li>
</ol>
<p>*.log</p>
<p>public/<br>.deploy*/<br>node_modules<br>##注意忽略node_modules,这个文件换一台电脑都需要用npm install 重新生成</p>
<pre><code>4. 创建一个叫hexo的分支</code></pre><p>git checkout -b hexo</p>
<pre><code>5. 提交复制过来的文件并推送至hexo分支</code></pre><p>git add –all<br>git commit -m “新建分支源文件”<br>git push –set-upstream origin hexo</p>
<pre><code>
到这里基本上就搞定了，以后再推就可以直接git push了，hexo的操作跟以前一样。
今后无论什么时候想要在其他电脑上面用hexo写博客，就先装好node然后直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。
</code></pre><p>git clone -b hexo <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ZhengYangxin/zhengyangxin.github.io.git</p>
<p>```</p>
<p>这样做完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。</p>
]]></content>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试准备</title>
    <url>/suan-fa-mian-shi-zhun-bei.html</url>
    <content><![CDATA[<h3 id="一道排序体题需要考与面试官沟通的点"><a href="#一道排序体题需要考与面试官沟通的点" class="headerlink" title="一道排序体题需要考与面试官沟通的点"></a>一道排序体题需要考与面试官沟通的点</h3><ul>
<li>有没有可能包含大量的重复元素</li>
<li>是否近乎有序</li>
<li>数据取值范围是否有限</li>
<li>是否需要稳定排序</li>
<li>是否用链式存储</li>
<li>数据大小足够装载内存里</li>
</ul>
<h3 id="算法面试优秀不意味技术面试优秀"><a href="#算法面试优秀不意味技术面试优秀" class="headerlink" title="算法面试优秀不意味技术面试优秀"></a>算法面试优秀不意味技术面试优秀</h3><ul>
<li>考虑项目经历和项目中遇到的实际问题</li>
<li>印象最深的bug</li>
<li>面向对象</li>
<li>设计模式</li>
<li>网络相关：安全相关、内存相关、并发相关</li>
<li>系统设计：scalability</li>
</ul>
<h3 id="技术面试优秀不意味着能够拿到Offer"><a href="#技术面试优秀不意味着能够拿到Offer" class="headerlink" title="技术面试优秀不意味着能够拿到Offer"></a>技术面试优秀不意味着能够拿到Offer</h3><p><strong>创建自己的项目</strong></p>
<ul>
<li>自己做小应用</li>
<li>自己解决小问题</li>
<li>“不是项目”的项目：书籍的整理</li>
<li>技术分享，blog、github </li>
</ul>
<p><strong>了解过去自身的思考行为方式</strong></p>
<ul>
<li>遇到最大的挑战</li>
<li>犯过的错误</li>
<li>遭遇的失败</li>
<li>最享受的工作内容</li>
<li>遇到冲突处理方式</li>
<li>做的最与众不同的事儿</li>
</ul>
<p><strong>准备好问面试官的问题</strong></p>
<ul>
<li>整个小组的大概运行模式是怎么样的</li>
<li>整个项目组的后续规划是如何</li>
<li>这个产品中某个问题的解决方案</li>
<li>为什么选择某些技术？标准？</li>
<li>对某技术很感性局，是否有机会深入</li>
</ul>
<h3 id="算法面试没这么难"><a href="#算法面试没这么难" class="headerlink" title="算法面试没这么难"></a>算法面试没这么难</h3><ul>
<li>没必要啃完《算法导论》</li>
<li>高级数据结构和算法面试提及概率很低（红黑树、计算几何、B-Tree、数论、斐波那契堆、FFT）</li>
</ul>
<h3 id="准备范围"><a href="#准备范围" class="headerlink" title="准备范围"></a>准备范围</h3><p>*<em>关注基础算法和数据结构，非“有意思”的题目<br>*</em></p>
<ul>
<li>各种排序算法</li>
<li>基础数据结构和算法实现：堆、二叉树、图…</li>
<li>基础数据结构使用：链表、栈、队列、哈希表、图、Trie…</li>
<li>基础算法：深度优先、广度优先、二分查找、递归…</li>
<li>基本算法思想：递归、分支、回溯搜索、贪心、动态规划…</li>
</ul>
<h3 id="解决算法问题的整体思路"><a href="#解决算法问题的整体思路" class="headerlink" title="解决算法问题的整体思路"></a>解决算法问题的整体思路</h3><ul>
<li>注意题目中的条件</li>
<li>当没有思路时（测试用例，暴力解法——&gt;优化）</li>
<li>优化算法（算法思路、数据结构、空间换时间、预处理数据、瓶颈除找解决方案）</li>
<li>实际编写问题，极端条件的判断（数组为空、字符串为空、数据为NULL），代码规范（变量名、模块化、复用性）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>git相关操作</title>
    <url>/git-xiang-guan-cao-zuo.html</url>
    <content><![CDATA[<h3 id="一-git关联本地与远程分支"><a href="#一-git关联本地与远程分支" class="headerlink" title="一. git关联本地与远程分支"></a>一. git关联本地与远程分支</h3><pre><code>$ git branch --set-upstream-to=origin/dev2.2 master
Branch master set up to track remote branch dev2.2 from origin.</code></pre><p>远程分支在前，本地分支在后。<br>关联之后就可以正常的pull代码了。</p>
<h3 id="二-查看所有分支（本地、远程）"><a href="#二-查看所有分支（本地、远程）" class="headerlink" title="二.查看所有分支（本地、远程）"></a>二.查看所有分支（本地、远程）</h3><pre><code>$ git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/dev
  remotes/origin/dev2.2
  remotes/origin/master</code></pre><h3 id="三-当前关联的远程分支"><a href="#三-当前关联的远程分支" class="headerlink" title="三.当前关联的远程分支"></a>三.当前关联的远程分支</h3><pre><code>$ git branch -vv
* master beb7725 [origin/dev2.2: behind 1] 首页本地记录上次关闭之前的状态</code></pre><h3 id="四-git-merge-和-git-merge-–no-ff"><a href="#四-git-merge-和-git-merge-–no-ff" class="headerlink" title="四.git merge 和 git merge –no-ff"></a>四.git merge 和 git merge –no-ff</h3><p><img src="http://img.blog.csdn.net/20150811134840627" alt="Alt text" title="Optional title"><br>根据这张图片可以看出<br>Git merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。<br>git merge 则不会显示 feature，只保留单条分支记录。</p>
<h3 id="五-merge-与-rebase-的区别"><a href="#五-merge-与-rebase-的区别" class="headerlink" title="五.merge 与 rebase 的区别"></a>五.merge 与 rebase 的区别</h3><p>1.Git merge 会生成一个新得合并节点，而rebase不会<br>比如：</p>
<pre><code>      D---E test
     /
A---B---C---F master</code></pre><p>使用merge合并, 为分支合并自动识别出最佳的同源合并点： git merge master</p>
<pre><code>      D--------E
     /          \
A---B---C---F----G   test, master</code></pre><p>操作会舍弃 master 分支上提取的 commit，同时不会像 merge 一样生成一个合并修改内容的 commit，相当于把 master 分支（当前所在分支）上的修改在 deve 分支（目标分支）上原样复制了一遍:git rebase test</p>
<pre><code>A---B---D---E---C&#39;---F&#39;   test, master</code></pre><p>使用git pull时默认是merge， 加 –rebase参数使其使用rebase方式</p>
<pre><code>git pull --rebase  </code></pre><p>2.rebase和merge的不同适用场景</p>
<p><strong>rebase场景：</strong>如果修改了某个公用代码的BUG，这个时候就应该是把所有的OEM版本分支rebase到这个修复BUG的分支上来，在rebase过程中，Git会要你手动解决代码上的冲突，你需要做的就是把修复BUG的代码放到目标分支代码里面去。rebase的结果是：所有的分支依然存在</p>
<p><strong>merge场景：</strong>因为成员的代码开发工作已经完成了，也不需要再保留这个分支了，所以我们可以把这个成员分支merge到主分支上，当然冲突在所难免，手工解决的工作肯定逃不掉，但是利大于弊不是吗。merge以后，分支就不存在了，但是在git的所有分支历史中还能看到身影。</p>
<p><strong>一般我们把别的分支合并到master时用merge，而把master合并到别的分支时会用到rebase的原因，这是因为master分支一般commit会比较频繁。</strong></p>
<p>所以每次下拉代码fetch之后用rebase的原因就是：<br>本地commit之后，fetch远端代码，此时，远端代码可能会被若干人修改会有若干个commit，而本地就一个commit，然后git rebase的时候，是默认rebase 远端代码，此时会将本地commit应用到远端代码，也就只需要解决一次冲突，并且rebase之后没有新的commit，很友好。但是，如果使用merge，则会产生新的commit。</p>
<h3 id="六-网上推荐的工作流一般是用fetch-rebase-相比pull-merge工作流更干净，不容易出错"><a href="#六-网上推荐的工作流一般是用fetch-rebase-相比pull-merge工作流更干净，不容易出错" class="headerlink" title="六.网上推荐的工作流一般是用fetch+rebase (相比pull+merge工作流更干净，不容易出错)"></a>六.网上推荐的工作流一般是用fetch+rebase (相比pull+merge工作流更干净，不容易出错)</h3><p><strong>比如dev是你的公共开发分支*</strong></p>
<p>git checkout dev  # 本地切到公共分支 </p>
<p>git pull              # 将本地的dev更新</p>
<p>git checkout -b bug_101026  # 新建一个主题分支（一个bug，一个功能什么的）<br>… # 改动.. commit.. 测试…</p>
<p>git fetch origin      # 更新upstream</p>
<p>git rebase origin/dev  # 将你的commits移到的末尾</p>
<p>git checkout dev  # 切换到公共分支</p>
<p>git pull              # 更新公共分支</p>
<p>git rebase bug_101026  # 将你的主题分支加到公共分支的末尾</p>
<p>git push               # 推送</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中方法调用参数传递的方式是传值，有且只有传值</title>
    <url>/java-zhong-fang-fa-diao-yong-can-shu-chuan-di-de-fang-shi-shi-chuan-zhi-you-qie-zhi-you-chuan-zhi.html</url>
    <content><![CDATA[<h4 id="Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does-Java-pass-by-refrence-or-pass-by-value）"><a href="#Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does-Java-pass-by-refrence-or-pass-by-value）" class="headerlink" title="Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does Java pass by refrence or pass by value）"></a>Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does Java pass by refrence or pass by value）</h4><p><strong>基本数据类型与引用数据类型</strong></p>
<ul>
<li><p>8种基本数据类型</p>
</li>
<li><p>引用数据类型：类、接口类型、数组类型、枚举类型、注解类型。</p>
</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li><p>基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。</p>
</li>
<li><p>引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。</p>
</li>
</ul>
<p>例如，有一个类Person,有属性name,age,带有参的构造方法，</p>
<p>Person p = new Person(“zhangsan”,20);</p>
<p><strong>在内存中的具体创建过程是：</strong></p>
<p>1.首先在栈内存中位其p分配一块空间;</p>
<p>2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值””，0；</p>
<p>3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作；</p>
<p>4.调用构造方法，为两个属性赋值为”Tom”,20；（注意这个时候p与Person对象之间还没有建立联系）；</p>
<p>5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。</p>
<h4 id="相关知识："><a href="#相关知识：" class="headerlink" title="相关知识："></a>相关知识：</h4><p>静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在整个程序的生命周期内都存在，由编译器在编译的时候分配。</p>
<p>堆区：  一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错</p>
<p>栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限</p>
<p>文字常量区： 常量字符串就是放在这里的。   程序结束后由系统释放。</p>
<p>程序代码区：存放函数体的二进制代码。</p>
<p><img src="http://images0.cnblogs.com/blog2015/751291/201507/051423530158394.png" alt="Alt text" title="Optional title"></p>
<p><strong>在Java中，所有的对象变量都是引用，Java通过引用来管理对象。然而在给方法传参时，Java并没有使用传引用的方式，而是采用了传值的方式。</strong><br>例如下面的badSwap()方法：</p>
<pre><code>public void badSwap(int var1, int var2)  
{  
  int temp = var1;  
  var1 = var2;  
  var2 = temp;  
}  </code></pre><p>当badSwap方法结束时，原有的var1和var2的值并不会发生变化。即使我们用其它Object类型来替代int，也不会有变化，因为Java在传递引用时也是采用传值的方式。（译者注：这里是关键，全文的核心是：1. Java中对象变量是引用 2. Java中方法是传值的 3. 传方法中参数时，传递的是引用的值）<br>代码：</p>
<pre><code>public void tricky(Point arg1, Point arg2)  
{  
  arg1.x = 100;  
  arg1.y = 100;  
  Point temp = arg1;  
  arg1 = arg2;  
  arg2 = temp;  
}  
public static void main(String [] args)  
{  
  Point pnt1 = new Point(0,0);  
  Point pnt2 = new Point(0,0);  
  System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y: &quot; +pnt1.y);   
  System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);  
  System.out.println(&quot; &quot;);  
  tricky(pnt1,pnt2);  
  System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y:&quot; + pnt1.y);   
  System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);    
}  </code></pre><p>执行main()的输出如下：</p>
<pre><code>X: 0 Y: 0  
X: 0 Y: 0  
X: 100 Y: 100  
X: 0 Y: 0  </code></pre><p>这个方法成功地改变了pnt1的值，但pnt1和pnt2的交换却失败了！这是Java参数传递机制里最让人迷惑的地方。在main()中，pnt1和pnt2是Point对象的引用，当将pnt1和pnt2传递给tricky()时，Java使用的正是传值的方式，将这两个引用的传给了﻿﻿arg1和arg2。也就是说arg1和arg2正是pnt1和pnt2的复制，他们所指向的对象是相同的。详情可见下面的图示：</p>
<div align="center">
![Alt text](http://images.techhive.com/images/idge/imported/article/jvw/2000/05/03-qa-0512-pass1-100158781-orig.gif "Optional title")
在作为参数传递后，对象至少有两个引用指向自己
</div>
在main()中，引用被复制并以传值的方式进行传递，对象本身并不会被传递。因此，tricky()方法中pnt1所指向的对象发生了变化。因为传递的是引用的复制，因此引用的交换既不能引起对象的交换，更不会使原始引用发生变化。如图2所示，tricky()交换了arg1与arg2，但不会影响pnt1和pnt2。因此若想交换原始引用pnt1和pnt2，那么不能通过调用方法的方式来实现。
<div align="center">
![Alt text](http://hi.csdn.net/attachment/201201/31/0_13279907114A2K.gif "Optional title")
在作为参数传递后，对象至少有两个引用指向自己
</div>

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结：####"></a>总结：####</h4><ol>
<li>Java中对象变量是引用 </li>
<li>Java中方法是传值的 </li>
<li>传方法中参数时，传递的是引用的值 </li>
</ol>
]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>try catch finally的执行顺序及数据处理情况</title>
    <url>/try-catch-finally-de-zhi-xing-shun-xu-ji-shu-ju-chu-li-qing-kuang.html</url>
    <content><![CDATA[<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol>
<li>不管有木有出现异常，finally块中的代码都会执行</li>
<li>当try或catch中有return时，finally仍然会执行</li>
<li>当try或catch中有return时,finally是在return前执行的（此时并没有返回运算后的结果，而是先把运算结果保存起来，而后再去执行finally，此如果finally若有rentrn，则程序结束，若无则操作后跳回try或catch继续执行）</li>
<li>finally中最好不要包含return，否则程序会提前推出，返回值不是catch或catch的值</li>
</ol>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>例1<pre><code>try{} catch(){}finally{} return;
显然程序按顺序执行。</code></pre></li>
<li>例2<pre><code>try{ return; }catch(){} finally{} return;
程序执行try块中return之前（包括return语句中的表达式运算）代码；
再执行finally块，最后执行try中return;
finally块之后的语句return，因为程序在try中已经return所以不再执行。</code></pre></li>
<li>例3<pre><code>try{ } catch(){return;} finally{} return;
程序先执行try，如果遇到异常执行catch块，
有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，
最后执行catch块中return. finally之后也就是4处的代码不再执行。
无异常：执行完try再finally再return.</code></pre></li>
<li>例4<pre><code>try{ return; }catch(){} finally{return;}
程序执行try块中return之前（包括return语句中的表达式运算）代码；
再执行finally块，因为finally块中有return所以提前退出。</code></pre></li>
<li>例5<pre><code>try{} catch(){return;}finally{return;}
程序执行catch块中return之前（包括return语句中的表达式运算）代码；
再执行finally块，因为finally块中有return所以提前退出。</code></pre></li>
<li>例6<pre><code>try{ return;}catch(){return;} finally{return;}
程序执行try块中return之前（包括return语句中的表达式运算）代码；
有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；
则再执行finally块，因为finally块中有return所以提前退出。
无异常：则再执行finally块，因为finally块中有return所以提前退出。</code></pre><h4 id="finally块中改变返回值的特殊情况"><a href="#finally块中改变返回值的特殊情况" class="headerlink" title="finally块中改变返回值的特殊情况####"></a>finally块中改变返回值的特殊情况####</h4></li>
</ul>
<p>这里涉及到java的引用传递和值传递，首先要明白java全部都是传值的。对于基本数据类型的值是存在栈中的，它是将数据完完整整的拷贝，生成一个新的变量值；对于引用类型的数据既对象它的数据存在于堆中，栈中保存的是指向数据的引用地址，它是将对象的引用地址值拷贝了，所以修改了对象内容，但地址值是不变的。<br>测试代码code1</p>
<pre><code>public class FinallyTest {
    public static void main(String[] args) {

        System.out.println(new FinallyTest().test());;
    }

    static int test()
    {
        int x = 1;
        try
        {
            x++;
            return x;
        }
        finally
        {
            ++x;
        }
    }
}</code></pre><p>输出2<br>测试代码code2</p>
<pre><code>
public class FinallyTest2  
{
    public static void Main(string[] args)  
       {  
         /*测试test1*/   
           List&lt;string&gt;relist=test1();  
           foreach (var item in relist)  
           {  
               Console.WriteLine(item);  
           }  
           Console.ReadLine();  
       }  
       private static List&lt;string&gt; test1()  
       {  
           List&lt;string&gt; strlist = new List&lt;string&gt;();  
           strlist.Add(&quot;zs&quot;);  
           strlist.Add(&quot;ls&quot;);  
           strlist.Add(&quot;ww&quot;);  
           strlist.Add(&quot;mz&quot;);  
           try  
           {  
               strlist.Add(&quot;wq&quot;);  
               return strlist;  
           }  
           finally  
           {  
               strlist.Add(&quot;yyy&quot;);  
           }  
       } 
}</code></pre><p>测试输出结果：<br>zs<br>ls<br>ww<br>mz<br>wq<br>yyy</p>
<p><strong>所以可得</strong><br>如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况：</p>
<p>1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。</p>
<p>2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</p>
<p><strong>最终结论：</strong><br>任何执行try或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。</p>
]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>面试基础（一）</title>
    <url>/mian-shi-ji-chu-yi.html</url>
    <content><![CDATA[<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><p>基本数据类型分为原始类型和包装类型，Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型(wrapper class)，int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<table>
<thead>
<tr>
<th>8种原始类型</th>
<th>容量</th>
<th>对应包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte(字节)</td>
<td>8 位</td>
<td>Byte</td>
</tr>
<tr>
<td>shot(短整型)</td>
<td>16位</td>
<td>Short</td>
</tr>
<tr>
<td>int(整型)</td>
<td>32 位</td>
<td>Integer</td>
</tr>
<tr>
<td>long(长整型)</td>
<td>64 位</td>
<td>Long</td>
</tr>
<tr>
<td>float(浮点型)</td>
<td>32 位</td>
<td>Float</td>
</tr>
<tr>
<td>double(双精度)</td>
<td>64 位</td>
<td>Double</td>
</tr>
<tr>
<td>char(字符型)</td>
<td>16 位</td>
<td>Character</td>
</tr>
<tr>
<td>boolean(布尔型)</td>
<td>1 位</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>注意几点：</p>
<p><strong>1、各数据类型按容量大小（表数范围大小）由小到大排列为：</strong></p>
<p>byte &lt;—— short, char  &lt;——int &lt;——long &lt;——float &lt;——double</p>
<p><strong>2、基本类型之间的转换原则：</strong></p>
<p>1）运算时，容量小的类型自动转换为容量大的类型；</p>
<p>2）容量大的类型转换为容量小的类型时，要加强制转换符，且精度可能丢失；</p>
<pre><code>如：float f = 1.2f;
int ff = (int) f;
System.out.println(ff);  1</code></pre><p>3）short，char之间不会互相转换（需要强制转换），byte、short、char并且三者在计算时首先转换为int类型；</p>
<p>4）实数常量默认为double类型， 整数常量默认为int类型；</p>
<p>*<em>3、包装类及String类都是定定义为public final class的，因此这几个都不能被继承；　　*</em></p>
<p><strong>4、原始类型是可以通过==直接判断是否相等的，而包装类型是类，通过==判断值是否相等是不对的，必须通过equals()函数</strong></p>
<p>*<em>下面的程序中，temp的最终值是什么？  *</em></p>
<pre><code>long temp=(int)3.9;   3

temp%=2;   1</code></pre><p>A .0</p>
<p>B .1</p>
<p>C .2</p>
<p>D .3</p>
<p>E .4</p>
<p><strong>short s1 = 1; s1 = s1 + 1;有什么错（错误）? short s1 = 1; s1 += 1;有什么错（正确）?</strong></p>
<p>*<em>下面哪个不是JAVA关键字 *</em></p>
<p>A  integer</p>
<p>B  double</p>
<p>C  float</p>
<p>D  default</p>
<p>###2.1.2 历年考题</p>
<p><strong>下面哪些不是java的简单数据类型?</strong> AC</p>
<p>A. short  B. Boolean  C. Double  D. float</p>
<p><strong>0.6332的数据类型是（）</strong>  A</p>
<p>A float     B double     C Float      D Double</p>
<p><strong>float f=3.4;是否正确?</strong>  错</p>
<p><strong>下面哪些类可以被继承</strong></p>
<p>下面哪些类可以被继承？  ABDE<br>Java.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader<br>A、Thread    B、Number    C、Double    D、Math    E、ClassLoader</p>
<p><strong>String 是最基本的数据类型吗?</strong>不是</p>
<p><strong>int和Integer有什么区别?</strong> 原始类型和封装类型，java5后自动拆箱和封箱机制</p>
<p><strong>5、请写出下面程序的运行结果：</strong>
　</p>
<pre><code>class AutoUnboxingTest {
    public static void main(String[] args) {
        Integer a = new Integer(3);
        Integer b = 3; // 将3自动装箱成Integer类型
        int c = 3;
        System.out.println(a == b); // false 两个引用没有引用同一对象
        System.out.println(a == c); // true a自动拆箱成int类型再和c比较
        System.out.println(b == c); // true b自动装箱然后自动拆箱成int类型再和c比较

    }
}</code></pre><h2 id="2-2-String、StringBuilder、StringBuffer"><a href="#2-2-String、StringBuilder、StringBuffer" class="headerlink" title="2.2 String、StringBuilder、StringBuffer"></a>2.2 String、StringBuilder、StringBuffer</h2><h3 id="2-2-1-String"><a href="#2-2-1-String" class="headerlink" title="2.2.1 String"></a>2.2.1 String</h3><p>字符串常量，不可更改，因为其内部定义的是一个final类型的数组来保存值的，如下：</p>
<pre><code>private final char value[];</code></pre><p>所以，当我们每次去“更改”String变量的值的时候（包括重新赋值或者使用String内部的一些方法），其实是重新新建了一个String对象（new String）来保存新的值，然后让我们的变量指向新的对象。因此，当我们需要频繁改变字符串的时候，使用String会带来较大的开销。</p>
<p>定义String的方法有两种：</p>
<p>（1）String str = “abc”;<br>（2）String str2 = new String(“def”);</p>
<p>第一种方式创建的String对象“abc”是存放在字符串常量池中，创建过程是，首先在字符串常量池中查找有没有”abc”对象，如果有则将str直接指向它，如果没有就在字符串常量池中创建出来“abc”，然后在将str指向它。当有另一个String变量被赋值为abc时，直接将字符串常量池中的地址给它。如下：</p>
<pre><code>String a = &quot;abc&quot;;  
String b = &quot;abc&quot;;  
System.out.println(a == b);    //打印 true </code></pre><p>也就是说通过第一种方式创建的字符串在字符串常量池中，是可共享的。同时，也是不可更改的，体现在：     </p>
<pre><code>String a = &quot;abc&quot;;  
String b = &quot;abc&quot;;  
b = b + &quot;def&quot;;  </code></pre><p>此时，字符串常量池中存在了两个对象“abc”和“abcdef”。</p>
<p>第二种创建方式其实分为两步： </p>
<pre><code>String s = &quot;def&quot;;      
String str2 = new String(s);  </code></pre><p>第一步就是上面的第一种情况；第二步在堆内存中new出一个String对象，将str2指向该堆内存地址，新new出的String对象内容，是在字符串常量池中找到的或创建出“def”对象，相当于此时存在两份“def”对象拷贝，一份存在字符串常量池中，一份被堆内存的String对象私有化管理着。所以使用String str2 = new String(“def”);这种方式创建对象，实际上创建了两个对象。</p>
<p>###2.2.2 StringBuffer(JDK 1.0) 和StringBuilder(JDK1.5)</p>
<p>StringBuffer和StringBuilder在功能上基本完全相同，它们都继承自AbstractStringBuilder，使用方法也都一样;可以对StringBuffer和StringBuilder对象进行改变，每次改变还是再原来的对象上发生的，不会重新new出新的StringBuffer或StringBuilder对象来。所以，当我们需要频繁修改字符串内容的时候，使用StringBuffer和StringBuilder是很好地选择。</p>
<p>StringBuffer和StringBuilder的最主要区别就是线程安全方面，由于在StringBuffer内大部分方法都添加了synchronized同步，所以StringBuffer是线程安全的，而StringBuilder不是线程安全的。因此，当我们处于多线程的环境下时，我们需要使用StringBuffer，如果我们的程序是线程安全的使用StringBuilder在性能上就会更优一点。</p>
<p>历年面试题：</p>
<p><strong>String与StringBuffer的区别：</strong></p>
<h2 id="2-3-关键字"><a href="#2-3-关键字" class="headerlink" title="2.3 关键字"></a>2.3 关键字</h2><h3 id="2-3-1-switch"><a href="#2-3-1-switch" class="headerlink" title="2.3.1 switch"></a>2.3.1 switch</h3><p><strong>1、switch中的参数类型</strong></p>
<p>在jdk1.7 之前switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。<br>在jdk1.7 及1.7以后，switch也支持了String类型，如下：</p>
<pre><code>String str = &quot;abc&quot;;  
switch (str) {  
case &quot;abc&quot;:  
    System.out.println(&quot;-----abc-----&quot;);  
    break;  
case &quot;aaa&quot;:  
    System.out.println(&quot;-----aaa-----&quot;);  
    break;  
} </code></pre><p>枚举类型</p>
<pre><code>enum ColorEnum {
    RED,
    GREEN,
    BLUE
}

public static void main(String[] args) {
    ColorEnum color = ColorEnum.BLUE;
    switch (color) {
        case RED:
            System.out.println(&quot;红色&quot;);
            break;
        case GREEN:
            System.out.println(&quot;绿色&quot;);
            break;
        case BLUE:
            System.out.println(&quot;蓝色&quot;);
            break;
    }
}</code></pre><p><strong>历年试题：</strong></p>
<p><strong>swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?</strong></p>
<h3 id="2-3-2-break-continue-goto"><a href="#2-3-2-break-continue-goto" class="headerlink" title="2.3.2 break,continue,goto"></a>2.3.2 break,continue,goto</h3><p>break的作用是跳出当前循环块（for、while、do while）或程序块（switch）。在循环块中的作用是跳出当前正在循环的循环体。在程序块中的作用是中断和下一个case条件的比较。</p>
<p>continue用于结束循环体中其后语句的执行，并跳回循环程序块的开头执行下一次循环，而不是离开循环体。</p>
<p>goto:goto是java中的保留字，现在没有在java中使用。 </p>
<p><strong>break,continue与标签</strong></p>
<p>“标签”是后面跟一个冒号的标识符，就象下面这样：<code>label1:</code></p>
<p>对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方——在<br>标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另<br>一个循环或者一个开关。这是由于 break 和 continue 关键字通常只中断当前循环，但若随同标签使用，它们<br>就会中断到存在标签的地方。如下所示：</p>
<pre><code>label1:
外部循环{
  内部循环 {
    //...
    break; //1
    //...
    continue; //2
    //...
    continue label1; //3
    //...
    break label1; //4
   }
}</code></pre><p>在条件 1 中，break 中断内部循环，并在外部循环结束。</p>
<p>在条件 2 中，continue 移回内部循环的起始处。</p>
<p>在条件 3 中，continue label1 却同时中断内部循环以及外部循环，并移至 label1 处。随后，它实际是继续<br>循环，但却从外部循环开始。</p>
<p>在条件 4 中，break label1 也会中断所有循环，并回到 label1 处，但并不重<br>新进入循环。也就是说，它实际是完全中止了两个循环。</p>
<p><strong>示例：</strong></p>
<pre><code>public static void main(String[] args) {
    outerCycle:
    for(int i = 0; i &lt; 10; i++){
        for(int j = 0; j &lt; 10; j++){
            if(j == 5){
                continue outerCycle;
            }
            System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;) &quot;);
        }
        System.out.println();
    }
}</code></pre><p>给外层循起始处加了标签（也就是说给外层循环起了个名字）“outerCycle”，在内层循环使用“continue outerCycle”时，就相当于在outerCycle这个循环中直接使用continue语句。</p>
<p>(0,0) (0,1) (0,2) (0,3) (0,4) (1,0) (1,1) (1,2) (1,3) (1,4) (2,0) (2,1) (2,2) (2,3) (2,4) (3,0) (3,1) (3,2) (3,3) (3,4) (4,0) (4,1) (4,2) (4,3) (4,4) (5,0) (5,1) (5,2) (5,3) (5,4) (6,0) (6,1) (6,2) (6,3) (6,4) (7,0) (7,1) (7,2) (7,3) (7,4) (8,0) (8,1) (8,2) (8,3) (8,4) (9,0) (9,1) (9,2) (9,3) (9,4)</p>
<pre><code>public static void main(String[] args) {
    outerCycle:
    for(int i = 0; i &lt; 10; i++){
        for(int j = 0; j &lt; 10; j++){
            if(j == 5){
                break outerCycle;
            }
            System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;) &quot;);
        }
        System.out.println();
    }
}</code></pre><p>运行结果</p>
<p>(0,0) (0,1) (0,2) (0,3) (0,4)</p>
<p><strong>历年试题：</strong></p>
<p>请写出下面程序的运行结果 ：</p>
<pre><code>public static void main(String[] args) {
    int i = 0;
    outer:
    // 第一个标签
    for (; true; ) {
        inner:
        //第二个标签
        for (; i &lt; 10; i++) {
            prt(&quot;i = &quot; + i);
            if (i == 2) {
                prt(&quot;continue&quot;);
                continue;
            }
            if (i == 3) {
                prt(&quot;break&quot;);
                i++; // 注意
                break;
            }
            if (i == 7) {
                prt(&quot;continue outer&quot;);
                i++; //注意
                continue outer;
            }
            if (i == 8) {
                prt(&quot;break outer&quot;);
                break outer;
            }
            for (int k = 0; k &lt; 5; k++) {
                if (k == 3) {
                    prt(&quot;continue inner&quot;);
                    continue inner;
                }
            }
        }
    }


}


static void prt(String s) {
    System.out.println(s);
}</code></pre><p>下面是输出结果：<br>i = 0<br>continue inner<br>i = 1<br>continue inner<br>i = 2<br>continue<br>i = 3<br>break<br>i = 4<br>continue inner<br>i = 5<br>continue inner<br>i = 6<br>continue inner<br>i = 7<br>continue outer<br>i = 8<br>break outer</p>
<p><strong>需要匹配后通过break关键字跳出程序块，不然继续向下执行</strong></p>
<p>下面的方法，当输入为2的时候返回值是多少?（）</p>
<pre><code>    public static int getValue(int i) {
        int result = 0;
        switch (i) {
        case 1:
            result = result + i;
        case 2:
            result = result + i * 2;
        case 3:
            result = result + i * 3;
        }
        return result;
    }</code></pre><p>A0                    B2                    C4                     D10</p>
<p><strong>break语句的描述中，正确的是( )</strong></p>
<p>A、只中断最内层的循环 </p>
<p>B、只中断最外层的循环 </p>
<p>C、借助于标号，可以实现任何外层循环中断</p>
<p>D、只中断某一层的循环</p>
<p>##2.4 值传递和引用传递</p>
<p>首先要说明的是java中是没有指针的，java中只存在值传递，只存在值传递！！！  然而我们经常看到对于对象（数组，类，接口）的传递似乎有点像引用传递，可以改变对象中某个属性的值。但是不要被这个假象所蒙蔽，实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以还是按值传递。</p>
<p>需要注意的是当传递的是数组名或对象实例的话，其实传递的都是地址拷贝</p>
<pre><code>public class Test3 {
    public static void change(int a){
        a=50;
    }
    public static void main(String[] args) {
        int a=10;
        System.out.println(a);  //10
        change(a);
        System.out.println(a);  //10
    }
}</code></pre><pre><code>public class Test3 {
    public static void change(int []a){
        a[0]=50;
    }
    public static void main(String[] args) {
        int []a={10,20};
        System.out.println(a[0]);  //10
        change(a);
        System.out.println(a[0]);  //50
    }
}</code></pre><pre><code>class Emp {
    public int age;
}
public class Test {
    public static void change(Emp emp)
    {
        emp.age = 50;
        emp = new Emp();//再创建一个对象
        emp.age=1000;
    }

    public static void main(String[] args) {
        Emp emp = new Emp();
        emp.age = 100;
        System.out.println(emp.age);  //100
        change(emp);
        System.out.println(emp.age);  //50
        System.out.println(emp.age);  //50
    }
}</code></pre><p><strong>历史考题</strong></p>
<p>指出下列程序运行的结果 （）</p>
<pre><code>public class Example {

    String str = new String(&quot;good&quot;);

    char[] ch = { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; };

    public static void main(String args[]) {

        Example ex = new Example();

        ex.change(ex.str, ex.ch);

        System.out.print(ex.str + &quot; and &quot;);  //good and gbc

        System.out.print(ex.ch);

    }

    public void change(String str, char ch[]) {

        str = &quot;test ok&quot;;

        ch[0] = &#39;g&#39;;

    }
}</code></pre><p>A、 good and abc</p>
<p>B、 good and gbc</p>
<p>C、 test ok and abc</p>
<p>D、 test ok and gbc </p>
<p>##2.5 数组</p>
<p><strong>声明数组的两种方式：</strong></p>
<p>int a[];<br>int []a;</p>
<p>通过上边的定义，我们只是得到了一个数组的引用。这时已经为引用分配了存储空间，但是还没有给数组对象本身分配任何空间。想要给数组对象分配存储空间，必须使用初始化表达式。</p>
<p><strong>初始化数组的方式：</strong></p>
<p>int a[] = new int[8]; //分配空间，赋值默认值<br>int a[] = {0,1,2,3};<br>int a[] = new int[]{0,1,2,3};</p>
<p><strong>默认初始化</strong></p>
<p>如果我们利用int a[] = new int[6]，为数组元素分配了空间，但没有初始化，Java会为他们分配默认值。如下表所示：</p>
<p>基本类型    默认值<br>boolean false<br>char       ‘/u0000’(null)<br>byte       (byte)0<br>short      (short)0<br>int         0<br>long       0L<br>float      0.0f<br>double     0.0d</p>
<p><strong>7.下面哪些语句能够正确地生成5个空字符串？</strong></p>
<p>A.String   a[]=new   String[5]；for(int   i=0;i&lt;5;a[i++]=””);     </p>
<p>B.String   a[]={“”，””，””，””，””}；     </p>
<p>C.String   a[5]；     </p>
<p>D.String[5] a；     </p>
<p>E.String   []a=new   String[5];for(int   i=0;i&lt;5;a[i++]=null);</p>
<p>*<em>5.下面哪个语句正确地声明一个整型的二维数组？ *</em></p>
<p>A. int   a[][] =   new   int[][]；     </p>
<p>B. int   a[10][10]   =   new   int[][]；     </p>
<p>C. int   a[][]   =   new   int[10][10]；     </p>
<p>D. int   [][]a   =   new   int[10][10]；     </p>
<p>E. int   []a[]   =   new   int[10][10]；</p>
<p>*<em>27.哪个语句创建了一个数组实例？ *</em></p>
<p>A. int[] ia = new int [15]; </p>
<p>B. float fa = new float [20]; </p>
<p>C. char[] ca = “Some String”; </p>
<p>D. int ia [][] = {4, 5, 6} {1, 2, 3};</p>
<p><strong>数组有没有length()这个方法? String有没有length()这个方法？</strong><br>没有，有</p>
<p><strong>请问下面程序在初始化后，a[0]和b[0]的值是多少？</strong></p>
<p>String []a = new String[10];  //null<br>int []b = new int[10];  //0</p>
<p><strong>下面程序的运行结果是：</strong></p>
<pre><code>int index=1; 
int foo[]=new int[3]; 
int bar=foo[index]; 
int baz=bar+index; </code></pre><p>A. baz has a value of 0<br>B. baz has value of 1<br>C. baz has value of 2<br>D. an exception is thrown<br>E. the code will not compile </p>
<p><strong>下面代码的运行结果为：（）</strong></p>
<pre><code>import java.io.*;

import java.util.*;
public class foo{

    public static void main (String[] args){

        String s;

        System.out.println(&quot;s=&quot; + s);

    }

}</code></pre><p>A 代码得到编译，并输出“s=”</p>
<p>B 代码得到编译，并输出“s=null”</p>
<p>C 由于String s没有初始化，代码不能编译通过</p>
<p>D 代码得到编译，但捕获到 NullPointException异常</p>
<p>##2.6  构造函数相关</p>
<p><strong>1、如果一个类中没有写任何的构造方法，JVM会生成一个默认的无参构造方法。</strong></p>
<p><strong>2、如果一个基类中写了有参构造函数，没有定义无参构造函数，基类是不会默认生成无参构造函数的。而且子类的构造函数中，如果没有显示通过super.调用基类构造函数，那么默认是调用父类的无参构造方法（即默认为super()，一般这句话省略了）。</strong></p>
<p>下面哪三个描述是正确的？  B、C、E</p>
<p>A. 默认构造器初始化方法变量</p>
<p>B. 默认构造器有和它所在类相同的访问修饰词.</p>
<p>C. 默认构造器调用其父类的无参构造器.</p>
<p>D. 如果一个类没有无参构造器,编译器会它创建一个默认构造器.</p>
<p>E. 只有当一个类没有任何构造器时，编译器会为它创建一个默认构造器</p>
<p>以下子类B的情形哪一个是可以通过编译的：</p>
<pre><code>public class A {  
    public A(String s){  }  
}  


public class B extends A {   
    String name = &quot;llyB&quot;;  
}  


public class B extends A {    
    String name = &quot;llyB&quot;;  
    public B(String s){}  
}  


public class B extends A {    
    String name = &quot;llyB&quot;;  
    public B(String s){  
        super(s);  
    }  
}   能</code></pre><p>所以，只要记住，在子类的构造方法中，只要里面没有显示的通过super去调用父类相应的构造方法，默认都是调用super()，即无参构造方法，因此要确保父类有相应的构造方法。</p>
<p><strong>3、Java创建对象的几种方式：</strong></p>
<p>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p>
<p>(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。</p>
<p>历年考题：不通过构造函数也能创建对象吗（A）</p>
<p>A 是     B 否</p>
<p>下列说法正确的有（c）</p>
<p>A． class中的constructor不可省略</p>
<p>B． constructor必须与class同名，但方法不能与class同名</p>
<p>C． constructor在一个对象被new时执行</p>
<p>D．一个class只能定义一个constructor</p>
<p><strong>4、构造函数调用顺序</strong></p>
<p>在Java中，子类的构造过程中必须调用其父类的构造函数，是因为有继承关系存在时，子类要把父类的内容继承下来。但如果父类有多个构造函数时，该如何选择调用呢？</p>
<p>第一个规则：子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，那么编译器会帮我们加上一个默认的构造方法（就是没有参数的构造方法），但是如果你自己写了构造方法，那么编译器就不会给你添加了，所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是如果在子类构造方法中我们并没有显示的调用基类的构造方法，如：super();  这样就会调用父类没有参数的构造方法。    </p>
<p>第二个规则：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数，此时无参的构造函数就不会被调用。</p>
<p>总之，一句话：子类没有显示调用父类构造函数，不管子类构造函数是否带参数都默认调用父类无参的构造函数，若父类没有则编译出错。</p>
<p>历年考题：下面是People和Child类的定义和构造方法，每个构造方法都输出编号。在执行new Child(“mike”)的时候都有哪些构造方法被顺序调用？请选择输出结果 ( )</p>
<pre><code>class People {
    String name;

    public People() {
        System.out.print(1);
    }

    public People(String name) {
        System.out.print(2);
        this.name = name;
    }
}

class Child extends People {
    People father;

    public Child(String name) {
        System.out.print(3);
        this.name = name;
        father = new People(name + &quot;:F&quot;);
    }

    public Child() {
        System.out.print(4);
    }

}</code></pre><p>A312              B 32               C 432              D 132</p>
<p><strong>5、override与Overloading</strong></p>
<p>Override（重写）:<br>    在子类中定义与父类具有完全相同的名称和参数的方法，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，是子类与父类之间多态性的一种体现。特点如下：<br>  （1）子类方法的访问权限只能比父类的更大，不能更小（可以相同）；<br>  （2）如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法；</p>
<p>Overload（重载）:<br>  同一个类中可以有多个名称相同的方法，但方法的参数个数和参数类型或者参数顺序不同；<br>    关于重载函数返回类型能否不一样，需分情况：<br>（1）如果几个Overloaded的方法的参数列表不一样（个数或类型），它们的返回者类型当然也可以不一样；<br>（2）两个方法的参数列表完全一样，则不能通过让其返回类型的不同来实现重载。<br>（3）不同的参数顺序也是可以实现重载的；<br>（4）构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载。  </p>
<h3 id="2-7-静态代码块执行顺序"><a href="#2-7-静态代码块执行顺序" class="headerlink" title="2.7 静态代码块执行顺序"></a>2.7 静态代码块执行顺序</h3><p>执行顺序：1.静态代码块 –&gt; 2.普通代码块 –&gt; 3.构造方法</p>
<p>需要明白的是，1是类级别的，2和3是实例级别的，所以在父子类关系中，上述的执行顺序为：</p>
<p>父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法；</p>
<p>也就是上到下（父类到子类）先走完 类级别的（静态的）–&gt; 再依次走完父类的所有实例级别代码 –&gt; 再走子类所有实例级别代码</p>
<p>历史题目：</p>
<p>如下代码的输出结果：</p>
<pre><code>public class HelloB extends HelloA {
     public HelloB() {
         System.out.println(&quot;-----------HelloB 构造方法------------&quot;);
     }

     {
         System.out.println(&quot;I’m B class&quot;);
     }

     static{
         System.out.println(&quot;static B&quot;);
     }
     public static void main(String[] args){
         new HelloB();
     }
}

class HelloA{
     public HelloA(){
         System.out.println(&quot;-----------HelloA 构造方法------------&quot;);
     }

     {
         System.out.println(&quot;I’m A class&quot;);
     }

     static{
         System.out.println(&quot;static A&quot;);
     }
}</code></pre><p>输出结果：<br>static A<br>static B<br>I’m A class<br>———–HelloA 构造方法————<br>I’m B class<br>———–HelloB 构造方法————</p>
<p><strong>下面程序的运行结果是什么（）</strong></p>
<pre><code>class HelloA {

    public HelloA() {
        System.out.println(&quot;HelloA&quot;);
    }

    { System.out.println(&quot;I&#39;m A class&quot;); }

    static { System.out.println(&quot;static A&quot;); }

}

public class HelloB extends HelloA {
    public HelloB() {
        System.out.println(&quot;HelloB&quot;);
    }

    { System.out.println(&quot;I&#39;m B class&quot;); }

    static { System.out.println(&quot;static B&quot;); }

    public static void main(String[] args) { 
　　　　 new HelloB(); 
　　 }

}</code></pre><p>答案：</p>
<pre><code>static A
static B
I&#39;m A class
HelloA
I&#39;m B class
HelloB</code></pre><h3 id="2-8-面向对象"><a href="#2-8-面向对象" class="headerlink" title="2.8 面向对象"></a>2.8 面向对象</h3><p>1、Java面向对象的基本思想之一是封装细节并且公开接口。Java语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为四种级别：</p>
<p>（1）public： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；</p>
<p>（2）protected： 用protected修饰的类、类属变量及方法，包内的任何类及包外那些继承了该类的子类才能访问（此处稍后解释），protected重点突出继承；</p>
<p>（3）default： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。default重点突出包；</p>
<p>（4）private： 用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。　</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同 包</th>
<th>子 类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>2、final修饰的类不能被继承，没有子类。</p>
<p>3、abstract修饰的类不能被实例化，必须被子类继承。类只要有一个抽象方法就必定是抽象类，但抽象类不一定要有抽象方法。声明方式必须是：<code>abstract void C();</code> 不能带我实现体大括号。</p>
<p>历史题目：</p>
<p><strong>1、如下代码：</strong></p>
<pre><code>class A {

A() { }

}

class B extends A {

}</code></pre><p>哪两个说明是正确的？   </p>
<p>A. B类的构造器应该是 public.</p>
<p>B. B类的构造器应该是没有参数</p>
<p>C. B类的构造器应该调用this().</p>
<p>D. B类的构造器应该调用super().</p>
<p><strong>是否可以继承String类?</strong></p>
<p>String类是final类故不可以继承。</p>
<p>*<em>以public修饰的类如：public class Car{…} 则Car( )  *</em></p>
<p>A、可被其它程序包中的类使用 B、仅能被本程序包中的类使用</p>
<p>C、不能被任意其它类使用 D、不能被其它类继承</p>
<h3 id="2-9-equals与-的区别"><a href="#2-9-equals与-的区别" class="headerlink" title="2.9 equals与==的区别"></a>2.9 equals与==的区别</h3><p><strong>（1）==是一个运算符，它比较的是值</strong></p>
<p>对于基本数据类型，直接比较其数据值是否相等。如果是不同的基本数据类型之间进行比较，则遵循基本数据类型间运算的转换原则。如下：</p>
<pre><code>if(12 == 12.0){  
    System.out.println(&quot;-----12 == 12.0-------&quot;);  
} </code></pre><p>此时打印了—–12 == 12.0——-，因为低一级的int类型的12自动转换为高一级的float类型</p>
<p>对于引用类型，==比较的还是值，只不过此时比较的是两个对象变量的内存地址。所以，用==来比较对象，实际上是判断这两个对象是否是同一个new出来的对象，或者是否是一个对象赋值给另一个对象的情况。如：</p>
<pre><code>String s1 = new String(&quot;abc&quot;);
String s2 = s1;//将s1对的内存地址赋给了s2，此时s1==s2返回true；</code></pre><p><strong>（2）equals</strong></p>
<p>equals方法是属于Object类的一个方法，其实现源码如下：</p>
<pre><code>public boolean equals(Object obj) {  
    return (this == obj);  
}  </code></pre><p>可以看到，其实equals方法里面用的还是==运算符，所以对于那些没有重写过Object类的equals方法来说，==和equals方法是等价的！</p>
<p>然而，很多类都自己去重写了equals方法，比如String类、所有基本数据类型的包装类等<br>String类的equals源码如下：</p>
<pre><code>public boolean equals(Object anObject) {  
    if (this == anObject) {  
        return true;  
    }  
    if (anObject instanceof String) {  
        String anotherString = (String) anObject;  
        int n = value.length;  
        if (n == anotherString.value.length) {  
            char v1[] = value;  
            char v2[] = anotherString.value;  
            int i = 0;  
            while (n-- != 0) {  
                if (v1[i] != v2[i])  
                        return false;  
                i++;  
            }  
            return true;  
        }  
    }  
    return false;  
}  </code></pre><p>首先判断是否是同一个new出来的对象，即判断内存地址是否相同；如果不同则判断对象中的内容是否相同。</p>
<p>Integer类的equals方法如下：</p>
<pre><code>public boolean equals(Object obj) {  
    if (obj instanceof Integer) {  
        return value == ((Integer)obj).intValue();  
    }  
    return false;  
}  </code></pre><p>直接转成判断值是否相等了。</p>
<p>因此，对于String类和所有基本数据类型的包装类来说，equals方法就是判断其内容是否相等。对于其他类来说，要具体看其是否重写了equals方法及具体业务实现。</p>
<p>另：对于基本数据类型来说，使用equals方法，需要用该基本类型对应的包装类，因为equals是针对对象来使用的！</p>
<p><strong>下面程序的运行结果是（）</strong></p>
<pre><code>String str1 = &quot;hello&quot;;
String str2 = &quot;he&quot; + new String(&quot;llo&quot;);
System.err.println(str1 == str2);</code></pre><p>##其它基础</p>
<p><strong>&amp;和&amp;&amp;的区别</strong></p>
<p>&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。</p>
<p>*<em>下面的语句会产生什么样的输出? *</em></p>
<p>System.out.println(4&amp;7);</p>
<p>A.4</p>
<p>B.5</p>
<p>C.6</p>
<p>D.7</p>
<p>E.0</p>
<p><strong>5、try、catch、finally执行顺序问题</strong></p>
<p><strong>14. 如下代码：</strong></p>
<pre><code>public class Foo {

public static void main(String[] args) {

try {

return;

} finally {

System.out.println( &quot;Finally&quot; );

}
}
}</code></pre><p>输出结果是什么?   A</p>
<p>A. Finally</p>
<p>B.编译失败</p>
<p>C. 代码正常运行但没有任何输出.</p>
<p>D. 运行时抛出异常</p>
<p>下面函数将返回？</p>
<pre><code>publicstaticintfunc (){
    try{
        return 1;
    }catch(Exception e){
        return 2;
    }finally{
        return 3;
    }
}</code></pre><p>A、1    B、2    C、3     D、编译错误</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构之线性表</title>
    <url>/shu-ju-jie-gou-zhi-xian-xing-biao.html</url>
    <content><![CDATA[<h4 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表"></a>什么是线性表</h4><p>线性表就是由n（n&gt;0）个数据元素a1,a2….组成的有限序列</p>
<ul>
<li>数据元素的个数为n，表长度，当n=0时为空表</li>
<li>一个线性表为非空表，既n&gt;0，则可以简单记为（a1,a2….,an)</li>
<li>数据元素ai表示了各个元素，在不同场合含义不同<br>逻辑结构特点</li>
<li>有且仅有一个开始结点a1,没有直接前驱结点,有且仅有一个后继结点a2</li>
<li>有且仅有一个终结点an,没有直接后继结点，有且仅有一个前驱结点an-1</li>
<li>其余内部结点ai（2&lt;=i&lt;=n-1）都有且仅有一个前驱结点和一个后继结点</li>
<li>同一个线性表，各个数据元素ai必须具有相同的数据类型</li>
</ul>
<h4 id="线性表的基本运算"><a href="#线性表的基本运算" class="headerlink" title="线性表的基本运算"></a>线性表的基本运算</h4><ol>
<li>初始化</li>
<li>计算表表长</li>
<li>获取结点</li>
<li>查找结点</li>
<li>插入结点</li>
<li>删除结点</li>
</ol>
<h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><ol>
<li>顺序表就是按照顺序存储方式存储的线性表，该线性表的结点按照逻辑次依次存放在计算机的一组连续的存储单元中</li>
<li>结点ai存储地址的LOC(ai)计算式：LOC(ai)=a1+(i-1)*c  (0&lt;=i&lt;=n)</li>
<li>重点<ul>
<li>插入结点：先判断结点数量是否已满，以及插入结点序号是否正确，满足，将顺序表的数据后移，同时插入节点，更新结点数量表长度</li>
<li>删除结点：先判断待删除结点序号是否正确，然后开始移动数据，并更新结点数量</li>
</ul>
</li>
<li>顺序表缺点<ul>
<li>在插入和删除节点的时候，往往需要移动大量的数据</li>
<li>如果表比较大，有时比较难分配足够的连续存储空间，往往导致内存分配失败，而无法存储</li>
</ul>
</li>
</ol>
<h4 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h4><ol>
<li>链表结构是一种动态存储分配的结构形式，可以根据需要动态申请内存单元</li>
<li>链表中每个结点都包含如下两部分<ul>
<li>数据部分，保存的是该节点的实际数据</li>
<li>地址部分，保存的是下一个节点的地址</li>
</ul>
</li>
<li>采用引用来指示下一个数据的地址，因此在链表结构中，逻辑上相邻的结点在内存中并不一定相邻，逻辑上相邻关系通过地址部分的引用变量来实现。</li>
<li>链表结构分类<ul>
<li>单链表</li>
<li>双链表:每个结点包含两个引用，一个指向下一个结点，一个指向上一个结点</li>
<li>单循环链表:在单链表中，将终端结点的引用域null改为指向表头结点或者开始结点</li>
<li>多重链的循环表：将表中结点链在多个环上</li>
</ul>
</li>
<li>重点<ul>
<li>追加结点</li>
<li>头引用head</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>数据结构（一）</title>
    <url>/shu-ju-jie-gou-yi.html</url>
    <content><![CDATA[<h4 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h4><ul>
<li>数据结构是数据对象、存在于该对象的实例以及组成实例的数据元素之间的关系，并且这种关系可以通过定义相关的函数来给出</li>
<li>数据结构是抽象数据类型ADT的物理实现</li>
<li>一个数据结构是由数据元素依据某种逻辑联系起来的，对数据元素之间逻辑关系的描述称为数据的逻辑结构。由于数据必须在计算机内存储，数据的存储结构是其在计算机内的表示，既数据的实现形式</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>数据（Data）：数据是信息的载体，其能够被计算机识别、存储和加工处理，是计算机程序加工的“原材料”。</li>
<li>数据元素：数据元素是数据的基本单位，其也称之为元素，结点、顶点、记录等。</li>
<li>数据项：一个元素可以由若干个数据项组成，数据项是具有独立含义的最小标识单位。数据项也可称之为字段、域、属性</li>
<li>数据结构：是指数据间的相互关系，也就是数据的组织形式。</li>
</ul>
<p>####数据结构的内容</p>
<ul>
<li>数据的逻辑结构</li>
<li>数据的存储结构</li>
<li>数据的运算（检索、插入、删除、更新、排序等） </li>
</ul>
<h4 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h4><ul>
<li>按逻辑结构分类<ol>
<li>线性结构<ul>
<li>线性结构是非空集</li>
<li>线性结构有且仅有一个开始结点和一个终端结点</li>
<li>线性结构所有结点最多只有一个直接前驱结点和一个直接后继结点 </li>
<li>线性表、栈、队列和串等</li>
</ul>
</li>
<li>非线性结构<ul>
<li>非线性结构是非空集</li>
<li>非线性结构的一个结点可能有多个直接前驱结点和多个直接后继结点</li>
<li>数组、广义表、树结构和图结构等</li>
</ul>
</li>
</ol>
</li>
<li>按存储结构分类<ol>
<li>顺序存储结构<ul>
<li>在一块连续的存储区域一个接着一个的存放数据</li>
<li>线性存储方式主要用于线性逻辑结构的数据存放</li>
</ul>
</li>
<li>链式存储结构<ul>
<li>不要求逻辑上相邻的结点物理位置上相邻，结点间的逻辑关系由附加的引用字段表示。一个结点的引用字段往往指向下一个结点的存放位置。</li>
<li>也称链式存储结构</li>
</ul>
</li>
<li>索引存储结构<ul>
<li>采用附加的索引表的方式来存储结点信息</li>
</ul>
</li>
<li>散列存储方式<ul>
<li>根据结点的关键字 直接计算出该结点的存储地址的一种存储方式</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h4><ol>
<li>数组<br>数组是一种聚合数据类型，是将具有相同类型的若干变量有序的组织在一起的计集合。</li>
<li>栈<br>栈是一种特殊的线性表，其只能在一个表的固定端进行数据节点的插入和删除操作。</li>
<li>队列<br>队列和栈类似也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，在表的另一端进行删除操作。</li>
<li>链表<br>链表是一种数据元素按照链式存储结构进行存储的数据结构。</li>
<li>树<br>树是典型的非线性结构，其中包括了n个结点的有穷集合。</li>
<li>图<br>图是另一种非线性结构</li>
<li>堆<br>堆是一种特殊的树形结构，我们一般讨论的是堆都是二叉树。</li>
<li>散列表<br>散列表源自于散列函数，结构中存在关键字和T相等的记录。</li>
</ol>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是算法</title>
    <url>/shi-me-shi-suan-fa.html</url>
    <content><![CDATA[<h4 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h4><ul>
<li>算法是模型分析的一组可行的、确定的和有穷的规则（广泛）</li>
<li>算法是解决实际问题的一种精确的描述方法</li>
<li>算法是对特定问题的求解步骤的一种精确描述方法</li>
</ul>
<h4 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h4><ul>
<li>有穷性：算法的指令或者执行步骤是有限的</li>
<li>确切的：算法的每一个指令和步骤都必须有明确的定义和描述</li>
<li>输入：一个算法应该有的输入条件，用于初始化</li>
<li>输出：一个算法应该有个名明确的结果输出</li>
<li>可行性：执行步骤的可行，且有可以在有限时间内完成</li>
</ul>
<h4 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h4><ul>
<li>按照应用来分类<ul>
<li>基础算法、数据结构、几何、加密、查询、排序等等 </li>
</ul>
</li>
<li>按照确定性来分类<ul>
<li>确定性算法：有限时间内完成，结果唯一</li>
<li>非确定性算法：有限时间内完成，结果往往不唯一</li>
</ul>
</li>
<li>按照算法思路<ul>
<li>递推、递归、穷举、贪婪、分治、动态规划、迭代等算法 </li>
</ul>
</li>
</ul>
<h4 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h4><ul>
<li>数据结构+算法+程序设计语言 = 程序</li>
<li>数据结构表示处理对象，算法是计算和处理的核心方法，程序设计语言是算法的实现方法。这几者综合便构成了一个程序</li>
</ul>
<h4 id="算法的表示"><a href="#算法的表示" class="headerlink" title="算法的表示"></a>算法的表示</h4><ul>
<li>自然语言表示</li>
<li>流程图</li>
<li>N-S图</li>
<li>伪代码表示</li>
</ul>
<h4 id="算法性能评价"><a href="#算法性能评价" class="headerlink" title="算法性能评价"></a>算法性能评价</h4><ul>
<li>时间复杂度：算法执行所消耗的时间，时间越短，性能越好,算法越好。<ul>
<li>与每条语句执行的数量有关</li>
<li>与问题的规模有关</li>
</ul>
</li>
<li>空间复杂度：算法执行所消耗的存储空间，消耗越小，算法越好。<ul>
<li>程序保存所需要的存储空间，程序的大小</li>
<li>程序执行过程中所需消耗的存储空间（变量等）</li>
</ul>
</li>
</ul>
<h4 id="算法实例"><a href="#算法实例" class="headerlink" title="算法实例"></a>算法实例</h4><p>一个班级学生档案集中查找某一个学生的档案<br>伪代码</p>
<pre><code>变量 x = 输入需要查找的数据
变量 arr = 随机生产数组数据
for 1到20{
    if(arr[i] ==){
    找到数据
    break;
    }
}
输出该数据的位置
程序结束</code></pre><p>Code</p>
<pre><code>public Class Test1{
    static int N = 20;
    public static void main(String args[]){
    int arr[] = new int[N];
    int x;
    int pos = -1;
    Random r= new Random();
    for(int i=0; i&lt;N; i++){
        arr[i] = r.nextInt(100);
    }
    System.out.println(&quot;生成随机数序列&quot;)
    for(int i=0; i&lt;N; i++){
        System.out.print(arr[i]+&quot; &quot;);
    }

    System.out.print(&quot;输入要查找的整数&quot;);
    Scanner input = new Scanner(System.in);
    x = input.getInt();
    for(int i=0; i&lt;N; i++){
        if(arr[i] == x){
            pos = i;
            break;
        }
    }

    if(f&lt;0){
        System.out.print(&quot;未找到数据&quot;);
    }else{
        System.out.print(x+&quot;数据位于&quot;+pos+&quot;位置，是数组的第&quot;+(pos+1)+&quot;个元素&quot;);
    }
    } 
}</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第三方登录的注意与坑</title>
    <url>/di-san-fang-deng-lu-de-zhu-yi-yu-keng.html</url>
    <content><![CDATA[<h3 id="三方登录实多平台快捷方现方式"><a href="#三方登录实多平台快捷方现方式" class="headerlink" title="三方登录实多平台快捷方现方式"></a>三方登录实多平台快捷方现方式</h3><p>Mob平台 集成开发 三方登录和分享<br>ShareSdk.xml 配置<br>AndroidManifest.xml 配置</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>微信平台<br>  包名千万不要写错<br>  数字签名 是MD5 非 SHA1(大部分平台都是SHA1)<br>  测试签名和发行签名区分或统一。</li>
<li>QQ 平台<br>  添加测试账号</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>数据传输加密——非对称加密算法RSA+对称算法AES</title>
    <url>/shu-ju-chuan-shu-jia-mi-fei-dui-cheng-jia-mi-suan-fa-rsa-dui-cheng-suan-fa-aes.html</url>
    <content><![CDATA[<h3 id="数据传输加密"><a href="#数据传输加密" class="headerlink" title="数据传输加密"></a>数据传输加密</h3><p>&emsp;&emsp;在开发应用过程中，客户端与服务端经常需要进行数据传输，涉及到重要隐私信息时，开发者自然会想到对其进行加密，即使传输过程中被“有心人”截取，也不会将信息泄露。对于加密算法，相信不少开发者也有所耳闻，比如MD5加密，Base64加密，DES加密，AES加密，RSA加密等等。在这里我主要向大家介绍一下我在开发过程中使用到的加密算法，RSA加密算法+AES加密算法。简单地介绍一下这两种算法吧。</p>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>&emsp;&emsp;之所以叫RSA算法，是因为算法的三位发明者RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准，主要的算法原理就不多加介绍，如果对此感兴趣的话，建议去百度一下RSA算法。需要了解的是RSA算法属于非对称加密算法，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。简单的说是“公钥加密，私钥解密；私钥加密，公钥解密”。</p>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p> &emsp;&emsp;高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p>
<h3 id="为什么要结合使用这两种算法"><a href="#为什么要结合使用这两种算法" class="headerlink" title="为什么要结合使用这两种算法"></a>为什么要结合使用这两种算法</h3><p>&emsp;&emsp;如果不清楚非对称算法和对称算法，也许你会问，为什么要结合使用这两种算法，单纯使用一种算法不行吗？这就要结合不同的场景和需求了。</p>
<p>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密的情况<br>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密，例如绑定银行卡的时候，需要传递用户的银行卡号，手机号等重要信息，客户端这边就需要对这些重要信息进行加密，使用RSA公钥加密，服务端使用RSA解密，然后返回一些普通信息，比如状态码code,提示信息msg,提示操作是成功还是失败。这种场景下，仅仅使用RSA加密是可以的。</p>
<p>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密的情况<br>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密,例如客户端登录的时候，传递用户名和密码等资料，需要进行加密，服务端验证登录信息后，返回令牌token需要进行加密，客户端解密后保存。此时就需要结合这两种算法了。至于整个流程是怎样的，在下面会慢慢通过例子向你介绍，因为如果一开始就这么多文字类的操作，可能会让读者感到一头雾水。</p>
<h3 id="使用RSA加密和解密"><a href="#使用RSA加密和解密" class="headerlink" title="使用RSA加密和解密"></a>使用RSA加密和解密</h3><p>产生公钥和私钥：产生RSA公钥和密钥的方法有很多，在这里我直接使用我封装好的方法产生，都最后我会将两个算法的工具类赠送给大家。</p>
<pre><code>/**
 * 生成公钥和私钥
 * 
 * @throws Exception
 * 
 */
public static void getKeys() throws Exception {
    KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);
    keyPairGen.initialize(1024);
    KeyPair keyPair = keyPairGen.generateKeyPair();
    RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
    RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();

    String publicKeyStr = getPublicKeyStr(publicKey);
    String privateKeyStr = getPrivateKeyStr(privateKey);

    System.out.println(&quot;公钥\r\n&quot; + publicKeyStr);
    System.out.println(&quot;私钥\r\n&quot; + privateKeyStr);
}

public static String getPrivateKeyStr(PrivateKey privateKey)
        throws Exception {
    return new String(Base64Utils.encode(privateKey.getEncoded()));
}

public static String getPublicKeyStr(PublicKey publicKey) throws Exception {
    return new String(Base64Utils.encode(publicKey.getEncoded()));
}</code></pre><p>公匙</p>
<pre><code>MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCRQZ5O/AOAjeYAaSFf6Rjhqovws78I716I9oGF7WxCIPmcaUa1YuyLOncCCuPsaw69+RMWjdbOBp8hd4PPM/d4mKTOVEYUE0SfxhhDTZaM5CzQEUXUyXy7icQTGR5wBjrbjU1yHCKOf5PJJZZQWB06husSFZ40TdL7FdlBpZ1u1QIDAQAB</code></pre><p>私钥</p>
<pre><code>MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJFBnk78A4CN5gBpIV/pGOGqi/CzvwjvXoj2gYXtbEIg+ZxpRrVi7Is6dwIK4+xrDr35ExaN1s4GnyF3g88z93iYpM5URhQTRJ/GGENNlozkLNARRdTJfLuJxBMZHnAGOtuNTXIcIo5/k8klllBYHTqG6xIVnjRN0vsV2UGlnW7VAgMBAAECgYBMoT9xD8aRNUrXgJ7YyFIWCzEUZN8tSYqn2tPt4ZkxMdA9UdS5sFx1/vv1meUwPjJiylnlliJyQlAFCdYBo7qzmib8+3Q8EU3MDP9bNlpxxC1go57/q/TbaymWyOk3pK2VXaX+8vQmllgRZMQRi2JFBHVoep1f1x7lSsf2TpipgQJBANJlO+UDmync9X/1YdrVaDOi4o7g3w9u1eVq9B01+WklAP3bvxIoBRI97HlDPKHx+CZXeODx1xj0xPOK3HUz5FECQQCwvdagPPtWHhHx0boPF/s4ZrTUIH04afuePUuwKTQQRijnl0eb2idBe0z2VAH1utPps/p4SpuT3HI3PJJ8MlVFAkAFypuXdj3zLQ3k89A5wd4Ybcdmv3HkbtyccBFALJgs+MPKOR5NVaSuF95GiD9HBe4awBWnu4B8Q2CYg54F6+PBAkBKNgvukGyARnQGc6eKOumTTxzSjSnHDElIsjgbqdFgm/UE+TJqMHmXNyyjqbaA9YeRc67R35HfzgpvQxHG8GN5AkEAxSKOlfACUCQ/CZJovETMmaUDas463hbrUznp71uRMk8RP7DY/lBnGGMeUeeZLIVK5X2Ngcp9nJQSKWCGtpnfLQ==</code></pre><p>&emsp;&emsp;很明显，公钥字符串长度比较短，私钥的比较长。生成完密钥后，公钥可以存放在客户端，即使被别人知道公钥，也是没有问题的；私钥则一定要保存在服务端。如果到时公司面临人事变动，避免私钥被离职人员泄露，可以重新生成公钥和密钥。</p>
<p>使用公钥加密，私钥解密<br><img src="http://i.imgur.com/EzSYTst.png" alt="Alt text" title="Optional title"><br>这里在客户端模拟加密的情况，对字符串”Beyond黄家驹”使用RSA加密，调用RSAUtils的encryptByPublicKey()方法，输出结果为：</p>
<pre><code>密文: BRFjf3tUqRqlwuP5JtzxZinf7lp+AHuHM9JSabM5BNFDxuUe9+uuO6RpCHVH5PibifqQHzGNsyZn1G9QcIENT9Tbm+PZwAbNUlMPZRDBU1FSnOtY8dBdeW/lJdnY9sJVwNvIBnOLQk66hxRh6R2149dwlgdsGUpWMOMBzcP3vsU=</code></pre><p>在服务端，可以使用RSAUtils的decryptByPrivateKey()方法进行解密，现在模拟服务端解密<br><img src="http://i.imgur.com/oNox5Ma.png" alt="Alt text" title="Optional title"><br>&emsp;&emsp;在这里虽然没有完全模拟数据传输过程，比如说客户端发起一个网络请求，传递参数给服务端，服务端接收参数并进行处理，也是为了让大家可以更加容易明白，所以这里只是进行简单的模拟。可以看到Android客户端端和Java服务端的RSA加密解密算法是可以互通的，原因是他们所使用到的base64加密类是一致的，所以才可以实现加密和解密的算法互通。<br><img src="http://i.imgur.com/lLgQbab.png" alt="Alt text" title="Optional title"><br><img src="http://i.imgur.com/lLgQbab.png" alt="Alt text" title="Optional title"><br>&emsp;&emsp;使用到的jar包都是javabase64-1.3.1.jar,相信不少人都知道，java中有自带的Base64算法类，但是安卓中却没有，之前出现的情况是，使用的Base64类不统一，比如在安卓客户端开发使用的Base64算法是使用第三方提供的jar包，而java服务端中使用的是JDK自带的Base64,导致从客户端传过来的密文，服务端解析出错。</p>
<p>&emsp;&emsp;上面的例子展示了客户端使用公钥加密，服务端使用私钥解密的过程。也许你会这么想，既然可以如此，那服务端那边信息也可以通过RSA加密后，传递加密信息过来，客户端进行解密。但是，这样做，显示是不安全的。原因是，由于客户端并没有保存私钥，只有公钥，只可以服务端进行私钥加密，客户端进行公钥解密，但由于公钥是公开，别人也可以获取到公钥，如果信息被他们截取，他们同样可以通过公钥进行解密，那么这样子加密，就毫无意义了，所以这个时候，就要结合对称算法，实现客户端与服务端之前的安全通信了。</p>
<p>使用AES加密解密<br>加密<br><img src="http://i.imgur.com/WgX5ss7.png" alt="Alt text" title="Optional title"><br>模拟客户端进行AES加密，我们通过调用AESUtils中的generateKey()方法，随机产生一个密钥，用于对数据进行加密。输出的结果为：</p>
<pre><code>密钥: 6446c69c0f914a57
密文: GECDQOsc22yV48hdJENTMg==</code></pre><p>解密<br>&emsp;&emsp;模拟服务端进行AES解密，由于AES属于对称算法，加密和解密需要使用同一把密钥，所以，服务端要解密传递过来的内容，就需要密钥 + 密文。这里模拟一下服务端解密。<br><img src="http://i.imgur.com/NXLPGwG.png" alt="Alt text" title="Optional title"><br>&emsp;&emsp;到这里也许你会问，客户端使用AES进行加密，服务端要进行解密的话，需要用到产生的密钥，那密钥必须从客户端传输到服务端，如果不对密钥进行加密，那加密就没有意义了。所以这里终于谈到了重点，RSA算法+AES算法结合使用。</p>
<p>RSA算法+AES算法的使用<br>&emsp;&emsp;举一个简单的例子来说明一下吧，例如实名认证功能，需要传递用户真实姓名和身份证号，对于这种重要信息，需要进行加密处理。</p>
<p>客户端使用RSA + AES对重要信息进行加密<br>客户端加密过程主要分为以下三个步骤：</p>
<ol>
<li><p>客户端随机产生AES的密钥；</p>
</li>
<li><p>对身份证信息（重要信息）进行AES加密；</p>
</li>
<li><p>通过使用RSA对AES密钥进行公钥加密。<br><img src="http://i.imgur.com/8c2YKWN.png" alt="Alt text" title="Optional title"></p>
</li>
</ol>
<p>&emsp;&emsp;这样在传输的过程中，即时加密后的AES密钥被别人截取，对其也无济于事，因为他并不知道RSA的私钥，无法解密得到原本的AES密钥，就无法解密用AES加密后的重要信息。</p>
<p>服务端使用RSA + AES对重要信息进行解密</p>
<p>服务端解密过程主要分为以下两个步骤：</p>
<ol>
<li><p>对加密后的AES密钥进行RSA私钥解密，拿到密钥原文；</p>
</li>
<li><p>对加密后的重要信息进行AES解密，拿到原始内容。<br><img src="http://i.imgur.com/kVrEvsu.png" alt="Alt text" title="Optional title"></p>
</li>
</ol>
<p>&emsp;&emsp;现实开发中，服务端有时也需要向客户端传递重要信息，比如登录的时候，返回token给客户端，作为令牌，这个令牌就需要进行加密，原理也是差不多的，比上面多一个步骤而已，就是将解密后的AES密钥，对将要传递给客户端的数据token进行AES加密，返回给客户端，由于客户端和服务端都已经拿到同一把AES钥匙，所以客户端可以解密服务端返回的加密后的数据。如果客户端想要将令牌进行保存，则需要使用自己定义的默认的AES密钥进行加密后保存，需要使用的时候传入默认密钥和密文，解密后得到原token。</p>
<p>&emsp;&emsp;上面提及到客户端加密，服务端返回数据不加密的情况，上面说到仅仅使用RSA是可以，但是还是建议同时使用这两种算法，即产生一个AES密钥，使用RSA对该密钥进行公钥加密，对重要信息进行AES加密，服务端通过RSA私钥解密拿到AES密钥，再对加密后的重要信息进行解密。如果仅仅使用RSA，服务端只通过RSA解密，这样会对于性能会有所影响，原因是RSA的解密耗时约等于AES解密耗时的100倍，所以如果每个重要信息都只通过RSA加密和解密，则会影响服务端系统的性能，所以建议两种算法一起使用。</p>
<p>同时还有相应的JS版RSA和AES算法，使用方式也差不多，在这里简单演示一下：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;RSA+AES.html&lt;/title&gt;

    &lt;meta name=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt;
    &lt;meta name=&quot;description&quot; content=&quot;this is my page&quot;&gt;
    &lt;meta name=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/rsa.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/aes.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var key = getKey();//随机产生AES密钥
        var encryptKey = RSA(key);//对AES密钥进行RSA加密
        console.log(&quot;encryptKey: &quot; + encryptKey);

        //测试AES加密和解密
        var cipherText = AESEnc(key,&quot;123456&quot;);
        var plainText = AESDec(key,cipherText);
        console.log(&quot;密文: &quot; + cipherText);
        console.log(&quot;明文: &quot; + plainText);
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    This is my HTML page. &lt;br&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>打开页面后，查看控制台输出：<br><img src="http://i.imgur.com/PyU0b3r.png" alt="Alt text" title="Optional title"><br>同时，模拟服务端解密，运行结果如下：<br><img src="http://i.imgur.com/3VrRv3d.png" alt="Alt text" title="Optional title"></p>
<p>需要注意的是:</p>
<p>1.RSAUtils中配置公钥和密钥，可以使用getKeys()方法产生。如果是客户端，则无须配置私钥，把没有私钥的RSAUtils放到客户端，因为仅需要用到公钥加密的方法。</p>
<p>2.AESUtils中配置偏移量IV_STRING；</p>
<p>3.rsa.js中最底部配置公钥，须和上面RSAUtils配置的公钥一致；</p>
<p>4.aes.js中的底部var iv = CryptoJS.enc.Utf8.parse(“16-Bytes–String”); //加密向量中，替换里面的字符串，加密向量须和<br>是上面的AESUtils中的偏移量一致。</p>
<p>各种语言的加密的处理方式有所差异，所以我们需要因地制宜。了解此加密的思想方法即可</p>
<ol>
<li><a href="http://blog.csdn.net/treesky/article/details/49422645" target="_blank" rel="noopener">php 和 java RSA 对称加密互通的问题</a></li>
<li><a href="http://www.cnblogs.com/yipu/articles/3871576.html" target="_blank" rel="noopener">php与java通用AES加密解密算法</a></li>
<li><a href="http://blog.csdn.net/pbm863521/article/details/54023009" target="_blank" rel="noopener">Android错误解决：java.lang.NoSuchMethodError: No static method encodeBase64String</a></li>
</ol>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全、Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio修改包名</title>
    <url>/android-studio-xiu-gai-bao-ming.html</url>
    <content><![CDATA[<h3 id="Android-Studio修改包名"><a href="#Android-Studio修改包名" class="headerlink" title="Android Studio修改包名"></a>Android Studio修改包名</h3><ol>
<li>修改包显示方式</li>
</ol>
<p><img src="http://img2.tuicool.com/BBBR3qN.png!web" alt="Alt text" title="修改包显示方式"></p>
<p>通过修改包显示方式，我们可以更方便的修改包名。</p>
<ol start="2">
<li>修改包名</li>
</ol>
<p><img src="http://www.itnose.net/img/20150709/10391686.png" alt="Alt text" title="修改包名"></p>
<ol start="3">
<li>改build.gradle(module：APP名字)文件中的 applicationId</li>
</ol>
<p><img src="http://www.itnose.net/img/20150709/10391688.png" alt="Alt text" title="改build.gradle("></p>
<ol start="4">
<li>clean和rebuild project</li>
</ol>
<p><img src="http://www.itnose.net/img/20150709/10391689.png" alt="Alt text" title="clean和rebuild project"></p>
<ol start="5">
<li>关闭android studio重启(可选)</li>
</ol>
<p>亲测有效，完美~</p>
<h3 id="简易操作，全局替换"><a href="#简易操作，全局替换" class="headerlink" title="简易操作，全局替换"></a>简易操作，全局替换</h3><p>ctr+shift+r</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>包名修改</tag>
      </tags>
  </entry>
  <entry>
    <title>事件传递机制</title>
    <url>/shi-jian-chuan-di-ji-zhi.html</url>
    <content><![CDATA[<h3 id="Touch事件传递机制"><a href="#Touch事件传递机制" class="headerlink" title="Touch事件传递机制"></a>Touch事件传递机制</h3><p>其中Activity和View控件（TextView）拥有分派和处理事件方法，View容器（LinearLayout）具有分派，拦截，处理事件方法。这里也有个比喻：领导都会把任务向下分派，一旦下面的人把事情做不好，就不会再把后续的任务交给下面的人来做了，只能自己亲自做，如果自己也做不了，就只能告诉上级不能完成任务，上级又会重复他的过程。另外，领导都有权利拦截任务，对下级隐瞒该任务，而直接自己去做，如果做不成，也只能向上级报告不能完成任务。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//分派事件</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>MotionEvent ev<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//拦截事件 </span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onInterceptTouchEvent</span><span class="token punctuation">(</span>MotionEvent ev<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//处理事件</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onTouchEvent</span><span class="token punctuation">(</span>MotionEvent event<span class="token punctuation">)</span></code></pre>
<p><img src="http://static.open-open.com/lib/uploadImg/20150128/20150128145842_296.png" alt="Alt text" title="Optional title"></p>
<p><img src="http://www.codeceo.com/wp-content/uploads/2015/01/touch-event-5.png" alt="Alt text" title="Optional title"></p>
<p>从上面两张事件传递图我们的出来一些结论：</p>
<ol>
<li><p>事件是先有dispatchTouchEvent分派给下一级</p>
</li>
<li><p>要经过onInterceptTouchEvent是否需要拦截，不拦截传递给下一级，最终传递给view控件，</p>
</li>
<li><p>onTouchEvent方法中，在处理事件中，如果返回True，则表示能处理，传递将会终止。反着，不能，如果不能的话，这会返回上一级的onTouchEvent方法中，如果还是false，会一直到到上一层的onTouchEvent方法中。</p>
</li>
</ol>
<p>好奇的我们会发现一个问题：图二中的黄色线，没有像红色线那样，先传递到最底层，然后再回滚回去，这是为什么呢？</p>
<p>答：就如我们故事中，他都知道了，底下人都不会去做了，那么他干嘛还分派给他呢，他就会自己做了，直接给onTouchEvent ，这就是事件传递中的“记忆”功能。我们是手指点击蓝色区域，Touch事件有两个，第一个ACTION_DOWN，第二个ACTION_UP，第一个 ACTION_DOWN事件向下传递到某View，它把事件继续传递交给它的子View，它会记录该事件是否被它下面的View给处理成功了，（怎么能知 道呢？如果该事件会再次被向上传递到我这里来由我的onTouchEvent来处理，那就说明下面的View都没能成功处理该事件）；当第二个 ACTION_UP事件向下传递到该View，该View的dispatchTouchEvent方法机会判断，若上次的事件由下面的view成功处理 了，那么这次的事件就继续交给下面的来处理，若上次的事件没有被下面的处理成功，那么这次的事件就不会向下传递了，该View直接调用自己的 onTouchEvent方法来处理该事件。</p>
<p>PS：关于这“记忆”功能的信息只在一系列事件完成之前有效，也就是从ACTION_DOWN事件开始，直到后续事件 ACTION_MOVE，ACTION_UP结束后，“记忆”的信息就会清除。也就是说如果某View处理ACTION_DOWN事件失败了 （onTouchEvent()返回false），那么后续的ACTION_MOVE,ACTION_UP等事件就不会再传递到该View了，由其父 View自己来处理。在下一次发生ACTION_DOWN事件的时候，还是会传递到该View的。</p>
<p>补充说明：</p>
<p>-》若在向下传递的过程中被拦截了，即onInterceptTouchEvent方法返回true，则事件将停止向下传递，直接由当前的onTouchEvent方法来处理，若处理成功则OK，若处理不成功，则事件会向上传递。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Teach you to recognize MVC, MVP and MVVM</title>
    <url>/teach-you-to-recognize-mvcmvpmvvm.html</url>
    <content><![CDATA[<h3 id="Teach-you-to-recognize-MVC-MVP-AND-MVVM"><a href="#Teach-you-to-recognize-MVC-MVP-AND-MVVM" class="headerlink" title="Teach you to recognize MVC, MVP AND MVVM"></a>Teach you to recognize MVC, MVP AND MVVM</h3><p>I believe we are no stranger to MVC, MVP and MVVM, as the three most familiar Android framework. Their applications can be very extensive, but for some novice, it can be difficult to distinguish between them three.</p>
<h3 id="Article-focus"><a href="#Article-focus" class="headerlink" title="Article focus:"></a>Article focus:</h3><ol>
<li>Learn and distinguish between MVC, MVP and MVVM.</li>
<li>Know how these three models in the use of Android.</li>
<li>Out of the DataBinding errors.</li>
<li>Understand the development model of MVP data binding.</li>
</ol>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC means Model View Controller, is the most common framework in the software architecture, simply through the control of controller to operate the modle layer of data, and return to view layer display.</p>
<p><img src="http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvc.png" alt="Alt text" title="Optional title"></p>
<p>Use the traditional MVC, which View, corresponding to a variety of layout files, but these layout files are not as powerful as the Web Side, can do very limited. Controller correspods to the Activity, but Activity has the function of operating UI. We in the actual project will hava a lot of UI operations, and also do a lot of View should be dong in the layer</p>
<p>MVC there is an important flaw, we look at the picture above, view layer and the model layer is mutual konw, which means that there is coupling between the two layers. The Coupling is very fatal for large program, beacuse it means that development, testing, maintenance need to spend a lot of energy.</p>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>MVP as MVC evolution, to solve a lot of MVC shortcommings. For Android, MVP model layer relative to the MVC is the same, but activity and fragment is no longer the controller layer, but the pure view layer.And all fordwarding of user events is handled by the presenter layer.<br><img src="http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvp.png" alt="Alt text" title="Optional title"></p>
<p>It can be seen from the figure that the most obvious difference is that the view and model layer are no longer mutual konw and complete descoupling. Instead of the precenter layer acts as bridge, the events used to manipulate the view layer are passed to the presenter layer, the presenter layer to mainpulate the model layer, and the data is returned to the view layer. the view layer and the model layer are completely unconnected throughout the process.</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM最早是由微软提出的<br><img src="http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvvm.png" alt="Alt text" title="Optional title"></p>
<p>From the figure to see that it is similiar to MVP, but the presenter layer<br>be replaced by ViewModel layer. And the view layer and the viewmodel are bound to each other, the means that when you update the data of the viewmodel layer, the view layer changes accordingly ui. </p>
<h3 id="Last-MVP-Databinding"><a href="#Last-MVP-Databinding" class="headerlink" title="Last: MVP + Databinding"></a>Last: MVP + Databinding</h3><p>We use the data binding framework to save similar findViewById and data binding time, and the use of presenter to separate the business logic and view layer.</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>模式、Android</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化之布局</title>
    <url>/xing-neng-you-hua-zhi-bu-ju.html</url>
    <content><![CDATA[<ol>
<li>性能优化之布局<br>重用<br>减少视图层级<br>需要时加载，懒加载布局<br>使用工具：Hierarchy View</li>
<li>Android 性能优化方法<br>使用Dalvik提供的 dalvik.system.VMRuntime类来设置最小堆内存为例:</li>
<li>bitmap 设置图片尺寸<br>避免 内存溢出 OutOfMemoryError的优化方法<br>options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一</li>
<li>Android 还有一些性能优化的方法：<br>首先内存方面，可以参考 Android堆内存也可自己定义大小 和 优化Dalvik虚拟机的堆内存分配<br>基础类型上，因为Java没有实际的指针，在敏感运算方面还是要借助NDK来完成。这点比较有意思的是Google 推出NDK可能是帮助游戏开发人员，比如OpenGL ES的支持有明显的改观，本地代码操作图形界面是很必要的。<br>图形对象优化，这里要说的是Android上的Bitmap对象销毁，可以借助recycle()方法显示让GC回收一个Bitmap对象，通常对一个不用的Bitmap可以使用下面的方式。</li>
<li><a href="http://mobile.51cto.com/abased-410791.htm" target="_blank" rel="noopener">从代码角度进行优化</a><br>静态变量引起内存泄露<br>使用Application的Context<br>及时关闭资源<br>使用Bitmap及时调用recycle()<br>对Adapter进行优化<br>代码“微优化”</li>
<li><a href="http://mobile.51cto.com/abased-410795.htm" target="_blank" rel="noopener">使用软引用和弱引用</a></li>
<li><a href="http://www.cnblogs.com/kest/p/5141817.html" target="_blank" rel="noopener">Android 中的Activity、Window、View之间的关系</a><br>Activity在onCreate时调用attach方法，在attach方法中会创建window对象。window对象创建时并没有创建 DocerView 对象。用户在Activity中调用setContentView,然后调用window的setContentView，这时会检查DecorView是否存在，如果不存在则创建DecorView对象，然后把用户自己的 View  添加到 DecorView 中。</li>
<li><a href="http://www.tuicool.com/articles/iIf6BbV" target="_blank" rel="noopener">Activity的几种LaunchMode及使用场景</a><br><a href="http://blog.csdn.net/linmiansheng/article/details/24297375" target="_blank" rel="noopener">Android关于Task的一些实践</a></li>
<li><a href="http://www.cnblogs.com/liqw/p/4175325.html" target="_blank" rel="noopener">Android 设计模式之MVC模式</a><br>MVC模式下，系统框架的类库被划分为3种：模型（Model）、视图（View）、控制器（Controller）。模型对象负责建立数据结构和相应的行为操作处理。视图对象负责在屏幕上渲染出相应的图形信息展示给用户看。控制器对象负责截获用户的按键和屏幕触摸等事件，协调Model对象和View对象。<br>　　用户与视图交互，视图接收并反馈用户的动作；视图把用户的请求传给相应的控制器，由控制器决定调用哪个模型，然后由模型调用相应的业务逻辑对用户请求进行加工处理，如果需要返回数据，模型会把相应的数据返回给控制器，由控制器调用相应的视图，最终由视图格式化和渲染返回的数据，对于返回的数据完全可以增加用户体验效果展现给用户。</li>
<li><a href="http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/" target="_blank" rel="noopener">教你认清MVC，MVP和MVVM</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0301/4018.html" target="_blank" rel="noopener">如何设计MVP中的Presentation层</a><br><a href="http://www.jianshu.com/p/ce1b447efc4f" target="_blank" rel="noopener">google 官方mvp实例的实践之mvp-databinding-Rxjava（一）</a></li>
<li><a href="https://jiangchunyu.github.io/2016/08/28/Netty-4-0%E5%9C%A8Android-%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/" target="_blank" rel="noopener">Netty 4.0在Android 上的使用，长连接断线自动重连</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>android系统架构(一)</title>
    <url>/android-xi-tong-jia-gou-yi.html</url>
    <content><![CDATA[<h3 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h3><p>&emsp;&emsp;由于在学习Android的时候并没有很系统地进行学习，知识点比较零碎，所以需要将自己的知识点进行系统的整理，那么首要的我需要将android的系统架构搞清楚，这样才能分清楚我所了解的知识点附属于哪个层面，是内核还是应用层，可以进行怎样的扩展，在哪些场景去运用。</p>
<h3 id="Android架构解析"><a href="#Android架构解析" class="headerlink" title="Android架构解析"></a>Android架构解析</h3><p><a href="http://mobile.51cto.com/android-235496.htm" target="_blank" rel="noopener">Google工程师多图详解Android系统架构</a><br><a href="https://my.oschina.net/fhd/blog/349830" target="_blank" rel="noopener">Android基础之Android系统架构</a><br><a href="https://zh.wikipedia.org/wiki/Android#Linux.E6.A0.B8.E5.BF.83" target="_blank" rel="noopener">Android维基百科</a><br><a href="http://tech.it168.com/a2011/0805/1228/000001228471.shtml" target="_blank" rel="noopener">Android对Linux内核的增强</a><br><a href="http://www.tuicool.com/articles/EN7nuiN" target="_blank" rel="noopener">Android系统架构详解(2)–Android Runtime</a></p>
<p>以上是我在这个课题下的一些参考博客或者网页链接。里面有对于android架构的一些较好的分析理解，接下来是阅读后自己的一些整理。</p>
<p>Android采用层次化系统架构，官方公布的标准架构如下图所示。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Android-System-Architecture.svg/1000px-Android-System-Architecture.svg.png" alt="Alt text" title="Optional title"></p>
<p>Android由底层往上分为4个主要功能层，分别是Linux内核层（Linux Kernel），系统运行时库层（Libraries和Android Runtime），应用程序架构层（Application Framework）和应用程序层（Applications）。</p>
<p>接下来对这几个层面进行逐个分析：</p>
<h4 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h4><p>&emsp;&emsp;Android以Linux操作系统内核为基础，借助Linux内核服务实现硬件设备驱动，进程和内存管理，网络协议栈，电源管理，无线通信等核心功能。Android4.0版本之前基于Linux2.6系列内核，4.0及之后的版本使用更新的Linux3.X内核，并且两个开源项目开始有了互通。Linux3.3内核中正式包括一些Android代码，可以直接引导进入Android。Linux3.4增添了电源管理等更多功能，以增加与Android的硬件兼容性，使Android在更多设备上得到支持。直到现在最新的android6.0仍然继续延用着linux3.4.0，而linux最新的版本已经到了4.3系列，那么为什么android没有继续去更新Linuxkernel的版本也是一个值得探讨的课题。 </p>
<p>&emsp;&emsp;Android内核 对Linux内核进行了增强，增加了一些面向移动计算的特有功能。例如，低内存管理器LMK（Low Memory Keller），匿名共享内存（Ashmem）,以及轻量级的进程间通信Binder机制等。这些内核的增强使Android在继承Linux内核安全机制的同时，进一步提升了内存管理，进程间通信等方面的安全性。</p>
<h4 id="硬件抽象层"><a href="#硬件抽象层" class="headerlink" title="硬件抽象层"></a>硬件抽象层</h4><p>&emsp;&emsp;内核驱动和用户软件之间还存在所谓的硬件抽象层（Hardware Abstract Layer,HAL），它是对硬件设备的具体实现加以抽象。HAL没有在Android官方系统架构图中标明，下图标出了硬件抽象层在android系统中的位置：</p>
<p><img src="http://static.oschina.net/uploads/space/2014/1128/125552_hnZu_168814.jpg" alt="Alt text" title="Optional title"></p>
<p>&emsp;&emsp;鉴于许多硬件设备厂商不希望公开其设备驱动的源代码，如果能将android的应用框架层与linux系统内核的设备驱动隔离，使应用程序框架的开发尽量独立于具体的驱动程序，则android将减少对Linux内核的依赖。HAL由此而生，它是对Linux内核驱动程序进行的封装，将硬件抽象化，屏蔽掉了底层的实现细节。HAL规定了一套应用层对硬件层读写和配置的统一接口，本质上就是将硬件的驱动分为用户空间和内核空间两个层面；Linux内核驱动程序运行于内核空间，硬件抽象层运行于用户空间。</p>
<h4 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h4><p>&emsp;&emsp;官方的系统架构图中，位于Linux内核层之上的系统运行库层是应用程序框架的支撑，为Android系统中的各个组件提供服务。系统运行库层由系统类库和Android运行时构成。</p>
<ul>
<li>系统类库<br>系统类库大部分由C/C++编写，所提供的功能通过Android应用程序框架为开发者所使用。例如SQlite,WebKit,SSL都在会在日常开发中有用到</li>
</ul>
<p><img src="http://images.51cto.com/files/uploadimg/20101129/1011272.png" alt="Alt text" title="Optional title"></p>
<ul>
<li>运行时<br>Android运行时包含核心库和Dalvik虚拟机两部分。<ul>
<li>核心库：核心库提供了Java5 se API的多数功能，并提供Android的核心API，如android.os，android.net，android.media等。</li>
<li>Dalvik虚拟机：Dalvik虚拟机是基于apache的java虚拟机，并被改进以适应低内存，低处理器速度的移动设备环境。Dalvik虚拟机依赖于Linux内核，实现进程隔离与线程调试管理，安全和异常管理，垃圾回收等重要功能。</li>
</ul>
</li>
</ul>
<p>Dalvik和标准Java虚拟机有以下主要区别：</p>
<ul>
<li>Dalvik基于寄存器，而JVM基于栈。一般认为，基于寄存器的实现虽然更多依赖于具体的CPU结构，硬件通用性稍差，但其使用等长指令，在效率速度上较传统JVM更有优势。</li>
<li>Dalvik经过优化，允许在有限的内存中同时高效地运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行，都拥有一个独立的Dalvik虚拟机实例。Android这种基于Linux的进程“沙箱”机制，是整个安全设计的基础之一。</li>
<li>Dalvik虚拟机从DEX（Dalvik Executable）格式的文件中读取指令与数据，进行解释运行。DEX文件由传统的，编译产生的CLASS文件，经dx工具软件处理后生成。</li>
<li>Dalvik的DEX文件还可以进一步优化，提高运行性能。通常，OEM的应用程序可以在系统编译后，直接生成优化文件（.ODEX）； 第三方的应用程序则可在运行时在缓存中优化与保存，优化后的格式为DEY（.dey文件）。</li>
</ul>
<p>&emsp;&emsp;这部分内容，即从android4.4开始就出现了ART（android runtime），但是这个ART并不是指这一节的主题，而是一种用来代替Dalvik的新型运行环境。当然在4.4的正式环境中用的还是Dalvik，真正开始用ART取代Dalvik是从android5.0开始的。（todo:针对这个改动，楼主会专门另开一个篇幅的文章去探究ART和Dalvik之间的区别）</p>
<p>另外这一节中有提到NDK,相信对于开发者而言SDK和NDK都是必要要接触和了解的东西，那么先从下图来看看sdk和ndk的关系。</p>
<p><img src="http://img.blog.csdn.net/20160107235017221" alt="Alt text" title="Optional title"></p>
<p>&emsp;&emsp;很显然地，ndk可以通过native code跨过使用dalvik runtime,直接调用到android内核资源，而sdk则需要在dalvik runtime环境下才能调用到内核资源。然而两者并不是各司其职，各不相关。android提供了JNI(Java native interface)使两者可以进行相互调用和通信。</p>
<h4 id="应用程序框架层"><a href="#应用程序框架层" class="headerlink" title="应用程序框架层"></a>应用程序框架层</h4><p>&emsp;&emsp;应用程序框架层提供开发Android应用程序所需的一系列类库，使开发人员可以进行快速的应用程序开发，方便重用组件，也可以通过继承实现个性化的扩展。</p>
<p><img src="http://images.51cto.com/files/uploadimg/20101129/1011271.png" alt="Alt text" title="Optional title"></p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>&emsp;&emsp;Android平台的应用层上包括各类与用户直接交互的应用程序，或由java语言编写的运行于后台的服务程序。例如，智能手机上实现的常见基本功能 程序，诸如SMS短信，电话拨号，图片浏览器，日历，游戏，地图，web浏览器等程序，以及开发人员开发的其他应用程序。</p>
<p>&emsp;&emsp;将android的基本架构进行了一个总体的分析和罗列，我们可以发现，平时开发中最常接触和用到的一定是application层，但是我们也不难发现，一些application层应用到的东西都能在系统层找到对应的踪迹，例如sqlite,webkit,甚至alarm。他们是怎么从底层到达application层供我们日常开发所用，这个也是需要去了解和研究的。本篇文章的目的在开篇已经阐述过，是为了能更好地将自己的知识对号入座，并且去补充一些自己在某些层面上缺乏的知识，最终可以将自己的知识形成一个整体的体系结构。</p>
]]></content>
  </entry>
  <entry>
    <title>Netty项目实践（一）</title>
    <url>/netty-xiang-mu-shi-jian-yi.html</url>
    <content><![CDATA[<h3 id="为什么要学"><a href="#为什么要学" class="headerlink" title="为什么要学"></a>为什么要学</h3><p>需要要做一个中间件，接受由硬件通过wifi和手机反复传递过来的数据（温湿度），然后再通过中间件将数据写入数据库。由于数据是时时接收的，所以用普通的http请求难以完全实现，所以考虑建立长链接实现功能。<br></p>
<h4 id="Netty的使用场景非常吻合："><a href="#Netty的使用场景非常吻合：" class="headerlink" title="Netty的使用场景非常吻合："></a>Netty的使用场景非常吻合：</h4><ul>
<li>构建高性能、低时延的各种Java中间件，例如MQ、分布式服务框架、ESB消息总线等，Netty主要作为基础通信框架提供高性能、低时延的通信服务；</li>
<li>公有或者私有协议栈的基础通信框架，例如可以基于Netty构建异步、高性能的WebSocket协议栈；</li>
<li>各领域应用，例如大数据、游戏等，Netty作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。<h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><a href="https://www.zhihu.com/question/24322387" target="_blank" rel="noopener">通俗地讲，Netty 能做什么？</a><br><a href="http://www.kuqin.com/shuoit/20150709/346994.html" target="_blank" rel="noopener">Netty那些不得不说的事</a>;<br><a href="http://www.infoq.com/cn/articles/netty-high-performance/" target="_blank" rel="noopener">Netty系列之Netty高性能之道</a><h3 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h3></li>
</ul>
<ol>
<li><p>创建Maven 项目BabyNetty</p>
<pre><code>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

 &lt;groupId&gt;com.zyx.baby&lt;/groupId&gt;
 &lt;artifactId&gt;BabyNetty&lt;/artifactId&gt;
 &lt;packaging&gt;pom&lt;/packaging&gt;
 &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code></pre><p>GroupID:是项目组织唯一的标识符，实际对应JAVA的包的结构，是main目录里java的目录结构。<br>ArtifactID:就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。</p>
</li>
<li><p>创建两个模块JavaClient，NettyCore<br>JavaClient:打算用于对服务器的一些数据请求<br>NettyCore：数据接收，分发处理</p>
</li>
<li><p>依赖jar和插件</p>
<pre><code>&lt;!--“打包“这个词听起来比较土，比较正式的说法应该是”构建项目软件包“，具体说就是将项目中的各种文件，
比如源代码、编译生成的字节码、配置文件、文档，按照规范的格式生成归档，最常见的当然就是JAR包和WAR包了，--&gt;
 &lt;build&gt;
     &lt;plugins&gt;
         &lt;plugin&gt;
             &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
             &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
             &lt;configuration&gt;
                 &lt;archive&gt;
                     &lt;manifest&gt;
                         &lt;addClasspath&gt;true&lt;/addClasspath&gt;
                         &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
                         &lt;mainClass&gt;org.origin.netty.Start&lt;/mainClass&gt;
                     &lt;/manifest&gt;
                 &lt;/archive&gt;
             &lt;/configuration&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
             &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
             &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
             &lt;executions&gt;
                 &lt;execution&gt;
                     &lt;id&gt;copy&lt;/id&gt;
                     &lt;phase&gt;package&lt;/phase&gt;
                     &lt;goals&gt;
                         &lt;goal&gt;copy-dependencies&lt;/goal&gt;
                     &lt;/goals&gt;
                     &lt;configuration&gt;
                         &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;
                     &lt;/configuration&gt;
                 &lt;/execution&gt;
             &lt;/executions&gt;
         &lt;/plugin&gt;
     &lt;/plugins&gt;
 &lt;/build&gt;
</code></pre></li>
</ol>
<dependencies>
        <!--是一个能够将Java bean/map/collection/Java array/xml转换成JSON并且反过来将JSON转换成java对象的类库-->
        <dependency>
            <groupid>net.sf.json-lib</groupid>
            <artifactid>json-lib</artifactid>
            <version>2.4</version>
            <classifier>jdk15</classifier>
        </dependency>
        <!--Netty包-->
        <dependency>
            <groupid>io.netty</groupid>
            <artifactid>netty-all</artifactid>
            <version>5.0.0.Alpha2</version>
        </dependency>
        <!--Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录-->
        <dependency>
            <groupid>log4j</groupid>
            <artifactid>log4j</artifactid>
            <version>1.2.17</version>
        </dependency>
</dependencies>
```
4. 配置Log4j日志组件
日志是应用软件中不可缺少的部分，Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录。在apache网站：jakarta.apache.org/log4j 可以免费下载到Log4j最新版本的软件包。
参考：[最详细的Log4j使用教程](http://www.codeceo.com/article/log4j-usage.html)
5. 核心NettyCore编写
    * 常量数据集定义
``` JAVA
package com.zyx.baby.domain;

<p>/**</p>
<ul>
<li><p>Created by 三金Sir on 2017/3/19.</p>
</li>
<li><p>/<br>public class Constant {</p>
<p>  public static final String ENCODING=”UTF-8”;</p>
</li>
</ul>
<pre><code>public static final String CLIENT_SERVER=&quot;JAVASERVER&quot;;
//not used
public static final String CLIENT_IOS_SECRET =&quot;BABY_IOS&quot;;
public static final String CLIENT_ANDROID_SECRET =&quot;BABY_ANDROID&quot;;
public static final String CLIENT_HARDWARE=&quot;BABY_HARDWARE&quot;;

public enum Type{
    SERVER_CONNECT(1000), //Java client connect
    LOGIN(2000),
    LOGINOUT(2001),
    RECONNECT(1020), // app client reconnect
    SUCCESS_AWARE(4000), // notify client the operation is apply successful.
    INTERNAL_ERROR(4001), // middleware error
    DATA_ERROR(4002); // json data parse error

    public int value;

    Type(int value){
        this.value = value;
    }

    public int value() {
        return value;
    }

    public static Type parse(int value){
        switch (value){
            case 1000:
                return SERVER_CONNECT;
            case 2000:
                return LOGIN;
            case 2001:
                return LOGINOUT;
            case 4000:
                return SUCCESS_AWARE;
            case 4001:
                return INTERNAL_ERROR;
            case 1020:
                return RECONNECT;
            default:
                return DATA_ERROR;
        }
    }

}</code></pre><p>}</p>
<pre><code>知识点 Java 枚举enum
        - 在实际编程中，往往存在着这样的“数据集”，它们的数值在程序中是稳定的，而且“数据集”中的元素是有限的。
        - 例如星期一到星期日七个数据元素组成了一周的“数据集”，春夏秋冬四个数据元素组成了四季的“数据集”。
        - 在Java中如何更好的使用这些“数据集”呢？因此枚举便派上了用场，以下代码详细介绍了枚举的用法。
        #### 参考 ：
    [Java 枚举enum 使用详解](http://blog.csdn.net/zcback1/article/details/51014229?locationNum=4&amp;fps=1).&lt;/br&gt;[java enum(枚举)使用详解 + 总结](http://blog.csdn.net/zhushuai1221/article/details/51775811?locationNum=7&amp;fps=1).
* 数据格式定义
``` JAVA
package com.zyx.baby.domain;

import io.netty.buffer.ByteBuf;
import net.sf.json.JSONObject;

import java.nio.charset.Charset;

/**
 * Created by 三金Sir on 2017/3/19.
 */
public class DataPacket {
    private Constant.Type type;
    // SERVER、BLUETOOTH、WIFI
    private String from = &quot;SERVER&quot;;
    private String to=&quot;&quot;;
    private String data = &quot;&quot;;

    public DataPacket(Constant.Type type,String data){
        this.type = type;
        this.from = &quot;SERVER&quot;;
        this.data = data;
    }

    public DataPacket(String to){
        this.type = Constant.Type.SUCCESS_AWARE;
        this.from = &quot;SERVER&quot;;
        this.to = to;
        this.data = &quot;&quot;;
    }

    public DataPacket(Constant.Type type,  String to, String data) {
        this.type = type;
        this.to = to;
        this.data = data;
    }

    public DataPacket(Constant.Type type, String from, String to, String data) {
        this.type = type;
        this.from = from;
        this.to = to;
        this.data = data;
    }

    // Getter&amp;Setter begin

    public Constant.Type getType() {
        return type;
    }

    public void setType(Constant.Type type) {
        this.type = type;
    }

    public String getFrom() {
        return from;
    }

    public void setFrom(String from) {
        this.from = from;
    }

    public String getTo() {
        return to;
    }

    public void setTo(String to) {
        this.to = to;
    }

    public String getData() {
        return data;
    }

    public void setData(String data) {
        this.data = data;
    }

    // Getter&amp;Setter end

    public static DataPacket parse(Object object){
        ByteBuf receive = (ByteBuf)object;
        JSONObject json=JSONObject.fromObject(receive.toString(Charset.forName(Constant.ENCODING)));
        receive.release();
        return new DataPacket(Constant.Type.parse(json.getInt(&quot;type&quot;)),json.getString(&quot;from&quot;),json.getString(&quot;to&quot;),json.getString(&quot;data&quot;));
    }

    @Override
    public String toString() {
        return &quot;{&quot; +
                &quot;\&quot;type\&quot;:&quot; + type.value() +
                &quot;, \&quot;from\&quot;:\&quot;&quot; + from + &#39;&quot;&#39; +
                &quot;, \&quot;to\&quot;:\&quot;&quot; + to + &#39;&quot;&#39; +
                &quot;, \&quot;data\&quot;:\&quot;&quot; + data + &#39;&quot;&#39; +
                &#39;}&#39;;
    }
}</code></pre><p>知识点：netty中ByteBuf部分<br><a href="http://www.tuicool.com/articles/FFb6Zr" target="_blank" rel="noopener">netty中ByteBuf部分的分析</a><br><a href="http://blog.csdn.net/alex_bean/article/details/51251015?locationNum=1&fps=1" target="_blank" rel="noopener">Netty之ByteBuf</a><br>[ Netty中的ByteBuf原理分析]<a href="http://blog.csdn.net/u012832964/article/details/50899511" target="_blank" rel="noopener">http://blog.csdn.net/u012832964/article/details/50899511</a></p>
<ul>
<li>配置拦截器，连接设备身份认证<br>  过程：<pre><code>  - verify = 设备标识字段+时间戳
  - MD5加密后与客户端发送code匹配
  - 成功,返回标识字段;否则null,Access denied</code></pre><pre class=" language-JAVA"><code class="language-JAVA">package com.zyx.baby.interceptor;

</code></pre>
</li>
</ul>
<p>import com.zyx.baby.domain.Constant;<br>import com.zyx.baby.domain.DataPacket;<br>import com.zyx.baby.utils.Util;<br>import io.netty.channel.ChannelHandlerContext;</p>
<p>import static org.apache.log4j.Logger.*;</p>
<p>/**</p>
<ul>
<li><p>连接设备拦截器</p>
</li>
<li><p>Created by 三金Sir on 2017/3/19.</p>
</li>
<li><p>/<br>public class Interceptor {<br>  private static final org.apache.log4j.Logger log = getLogger(Interceptor.class);</p>
<p>  public static String authIntercept(DataPacket pkt, ChannelHandlerContext ctx){</p>
<pre><code>  String secret = Constant.CLIENT_SERVER;
  try {
      String[] data = pkt.getData().split(&quot;&amp;&quot;);
      String code = data[0];
      String timestamp = data[1];

      String verify;
      if(pkt.getType() == Constant.Type.SERVER_CONNECT)
          verify = Constant.CLIENT_SERVER + timestamp;
      else
          verify = Constant.CLIENT_HARDWARE + timestamp;

      String validateCode = Util.md5(verify);

      boolean isLogin = pkt.getType() == Constant.Type.LOGIN || pkt.getType() == Constant.Type.RECONNECT;

      if(isLogin &amp;&amp; !code.equals(validateCode)){
          verify = Constant.CLIENT_HARDWARE + timestamp;
          validateCode = Util.md5(verify);
          secret = Constant.CLIENT_HARDWARE;
      }

      if(isLogin &amp;&amp; !code.equals(validateCode)){
          verify = Constant.CLIENT_ANDROID_SECRET + timestamp;
          validateCode = Util.md5(verify);
          secret = Constant.CLIENT_ANDROID_SECRET;
      }

      if(isLogin &amp;&amp; !code.equals(validateCode)){
          verify = Constant.CLIENT_IOS_SECRET + timestamp;
          validateCode = Util.md5(verify);
          secret = Constant.CLIENT_IOS_SECRET;
      }

      if (!code.equals(validateCode)) {</code></pre><p>//                SystemService.sendMessage(new DataPacket(Constant.Type.DATA_ERROR, “Access denied.”), ctx);</p>
<pre><code>          ctx.close();
          log.warn(&quot;[ socket interceptor ] Access denied.&quot;);
          return null;
      }

  } catch (Exception e) {
      e.printStackTrace();
      return null;
  }

  return secret;</code></pre><p>  }</p>
</li>
</ul>
<p>}</p>
<pre><code>未完待续~~~
</code></pre>]]></content>
      <categories>
        <category>项目实践</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Subline3下的两款Markdown插件</title>
    <url>/subline3-xia-de-liang-kuan-markdown-cha-jian.html</url>
    <content><![CDATA[<h3 id="MarkdownEditing"><a href="#MarkdownEditing" class="headerlink" title="MarkdownEditing"></a>MarkdownEditing</h3><h4 id="MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。"><a href="#MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。" class="headerlink" title="MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。"></a>MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。</h4><ol>
<li>安装插件<br>安装插件之前，我们需要首先安装一个Sublime 中最不可缺少的插件 Package Control, 以后我们安装和管理插件都需要这个插件的帮助。</li>
<li>安装”Package Control”<br>使用快捷键 “ ctrl + `” 打开Sublime的控制台 ,或者选择 View &gt; Show Console<br>在控制台的命令行输入框，把下面一段代码粘贴进去，回车 就可以完成Pacakge Control 的安装了。<pre><code>import urllib.request,os,hashlib; h = &#39;eb2297e1a458f27d836c04bb0cbaf282&#39; + &#39;d0e7a3098092775ccb37ca9d6b2e4b7d&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</code></pre></li>
<li>安装MarkdownEditing<br>Package Control 安装成功后我们就可以使用它方便的管理插件了，首先使用快捷键 ‘command + shift + p ‘ 进入到Sublime 命令面板，输入 “package install” 从列表中选择 “install Package” 然后回车。这时候Sublime开始请求远程插件仓库的索引，所以第一次使用可能会有一些小的延时。<br><img src="http://upload-images.jianshu.io/upload_images/222358-bee1d25963b27ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text" title="Optional title"><br>看到列表的更新之后输入 “markdown ed” 关键字，选择“MarkdownEditing” 回车。 插件安装完毕后需要重新启动Sublime插件才能生效。下面是我使用sublime编辑代码片断的显示效<br><img src="http://upload-images.jianshu.io/upload_images/222358-d8421f8682fdd2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text" title="Optional title"></li>
</ol>
<p>输入 “mdi + tab” 会自动插入下面的图片标记</p>
<pre><code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></pre><p>输入 “mdl + tab” 会自动生成下面的链接标记</p>
<pre><code>[](link)</code></pre><h3 id="Markdown-Preview-插件"><a href="#Markdown-Preview-插件" class="headerlink" title="Markdown Preview 插件"></a>Markdown Preview 插件</h3><h4 id="Mardown-Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。"><a href="#Mardown-Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。" class="headerlink" title="Mardown Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。"></a>Mardown Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。</h4><ol>
<li>安装<br>通过按组合键Ctrl+Shift+P或是点击Preference-&gt;Package Control调出命令面板，然后再输入 install，选择 Package Control: install package。<br><img src="http://img.blog.csdn.net/20160424184816763" alt="Alt text" title="Optional title"><br>在插件安装面板输入markdown找到Markdown Preview并点击安装即可。<br><img src="http://img.blog.csdn.net/20160424211042612" alt="Alt text" title="Optional title"></li>
<li>使用<br>通过按组合键Ctrl+Shift+P或是点击Preference-&gt;Package Control调出命令面板，输入mdp，下图中红框圈出的就是在浏览器中预览markdown文件。<br><img src="http://img.blog.csdn.net/20160424211409258" alt="Alt text" title="Optional title"><br>选中后，你将见到两个选项：GitHub和Mardown。GitHub选项意味着使用GitHub的在线API来解析.md文件。它的解析速度取决于你的联网速度。据称有每天60次访问的限制。[2]但能免费获得GFM格式的语法支持和EMOJI表情的支持。<br>另外一个常用功能是图中第五个，Export HTML in Sublime Text，即导出html文件到sublime text。</li>
<li>快捷键设置<br>Sublime Text支持自定义快捷键，markdown preview默认没有快捷键，我们可以自己为preview in browser设置快捷键。方法是在Preferences -&gt; Key Bindings User打开的文件的中括号中添加以下代码(可在Key Bindings Default找到格式)：</li>
</ol>
<pre><code>{ &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: {&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;}  }</code></pre><h6 id="这里："><a href="#这里：" class="headerlink" title="这里："></a>这里：</h6><p>“alt+m”可设置为自己喜欢的按键。<br>“parser”:”markdown”也可设置为”parser”:”github”，改为使用Github在线API解析markdown。</p>
]]></content>
      <categories>
        <category>辅助工具</category>
      </categories>
      <tags>
        <tag>Subline</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云Centos7搭建Git服务器仓库</title>
    <url>/a-li-yun-centos7-da-jian-git-fu-wu-qi-cang-ku.html</url>
    <content><![CDATA[<p>阿里云Centos7 搭建Git服务器仓库，记录过程</p>
<h2 id="1-首先需要安装Git，可以使用yum源在线安装："><a href="#1-首先需要安装Git，可以使用yum源在线安装：" class="headerlink" title="1.首先需要安装Git，可以使用yum源在线安装："></a>1.首先需要安装Git，可以使用yum源在线安装：</h2><pre><code>[root@localhost Desktop]# yum install -y git</code></pre><p><img src="http://img.blog.csdn.net/20170209181003136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="2-创建一个git用户，用来运行git服务"><a href="#2-创建一个git用户，用来运行git服务" class="headerlink" title="2.创建一个git用户，用来运行git服务"></a>2.创建一个git用户，用来运行git服务</h2><pre><code># adduser git  </code></pre><p><img src="http://img.blog.csdn.net/20170209181024793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="3-初始化git仓库：这里我们选择-usr-local-tomcat7-webapps-baby-android-来作为我们的git仓库"><a href="#3-初始化git仓库：这里我们选择-usr-local-tomcat7-webapps-baby-android-来作为我们的git仓库" class="headerlink" title="3.初始化git仓库：这里我们选择/usr/local/tomcat7/webapps/baby_android/来作为我们的git仓库"></a>3.初始化git仓库：这里我们选择/usr/local/tomcat7/webapps/baby_android/来作为我们的git仓库</h2><pre><code># git init</code></pre><p>仓库路径  /usr/local/tomcat7/webapps/baby_android/</p>
<p><img src="http://img.blog.csdn.net/20170209181915113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>执行以上命令，会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，设置权限：</p>
<pre><code>[root@localhost webapps]# chown - Rh git:users baby </code></pre><h2 id="5-创建SSH-Key"><a href="#5-创建SSH-Key" class="headerlink" title="5.创建SSH Key"></a>5.创建SSH Key</h2><p> 首先在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<h2 id="6-Git服务器打开RSA认证"><a href="#6-Git服务器打开RSA认证" class="headerlink" title="6.Git服务器打开RSA认证"></a>6.Git服务器打开RSA认证</h2><p>然后就可以去Git服务器上添加你的公钥用来验证你的信息了。在Git服务器上首先需要将/etc/ssh/sshd_config中将RSA认证打开，即：</p>
<pre><code>1.RSAAuthentication yes    
2.PubkeyAuthentication yes    
3.AuthorizedKeysFile  .ssh/authorized_keys</code></pre><p>这里我们可以看到公钥存放在.ssh/authorized_keys文件中。所以我们在/home/git下创建.ssh目录，然后创建authorized_keys文件，并将刚生成的公钥导入进去。<br>创建文件夹 mkdir 路径/文件夹名<br>创建文件 vi 路径/文件名<br>然后再次clone的时候，或者是之后push的时候，就不需要再输入密码了：</p>
<h2 id="7-禁用git用户的shell登陆"><a href="#7-禁用git用户的shell登陆" class="headerlink" title="7.禁用git用户的shell登陆"></a>7.禁用git用户的shell登陆</h2><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p>
<pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash </code></pre><p>最后一个冒号后改为：<br><img src="http://img.blog.csdn.net/20170209185636959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell  </code></pre><p> git clone <a href="mailto:git@42.96.150.57" target="_blank" rel="noopener">git@42.96.150.57</a>: /usr/local/tomcat7/webapps/baby/</p>
<h2 id="8-客户端基本操作"><a href="#8-客户端基本操作" class="headerlink" title="8. 客户端基本操作"></a>8. 客户端基本操作</h2><p>git add .<br>git commit<br>git push</p>
<h2 id="9-服务器自动更新部署"><a href="#9-服务器自动更新部署" class="headerlink" title="9.服务器自动更新部署"></a>9.服务器自动更新部署</h2><ol>
<li>进入到  /usr/local/tomcat7/webapps/baby/.git 文件夹中，会发现 .git/hook 文件夹在里面，进入到 hook 中，里面有很多的 sample 脚本，这里我们只需要用到 post-update。<br>post-update脚本</li>
<li>设置文件权限<pre><code>chown -Rh git:users baby</code></pre></li>
</ol>
<h2 id="10-创建git服务器远程仓库"><a href="#10-创建git服务器远程仓库" class="headerlink" title="10.创建git服务器远程仓库"></a>10.创建git服务器远程仓库</h2><pre><code>$ mv post-update.sample post-update
    $ vim post-update</code></pre><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ol>
<li>Git: push 出错的解决 master -&gt; master (branch is currently checked out)<br>这是由于git默认拒绝了push操作，需要进行设置，修改.git/config添加如下代码：<pre><code> [receive]
 denyCurrentBranch = ignore</code></pre>线上添加文件设置权限<pre><code>chown -Rh git:users baby</code></pre></li>
</ol>
]]></content>
  </entry>
</search>
