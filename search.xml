<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AndroidUI 加载和绘制流程]]></title>
    <url>%2FAndroidUI-%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.html</url>
    <content type="text"><![CDATA[源码总结View是如何被添加到屏幕窗口上去的 在Activity的onCreate方法中调用setContentView将我们的布局传入 内部调用了Window的唯一实例对象PhoneWindow的setContentView方法 内部创建了顶层布局容器DecorView 在DecorView中加载了基础布局ViewGroup(主题布局)， 将我们的布局添加到基础布局的FrameLayout中 View的绘制流程 绘制入口 ActivityThread.handlerResumeActivity WindowManagerImpl.addView(decorView, layoutParams) WindowManagerGlobal.addView() 绘制的类及方法 ViewRootImpl.addView(decorView, layoutParams, parentView) ViewRootImpl.requestLayout()-&gt;scheduleTraversals()-&gt;doTraversals()-&gt;performTraversals() 绘制流程的三大步骤 ViewRootImpl.performMeasure() ViewRootImpl.performLayout() ViewRootImpl.performDraw 绘制中的测量 MeasureSpec的确定及计算: 顶层DecoView和其他View DecorView通过窗口大小和DecoView本身大小确定 其他View通过父View的MeasureSpec和本身的大小确定 绘制中的布局 view.layout的方法确定自身的位置 若是ViewGroup类型，需要调用onLayout的方法确定子View的位置 绘制中的绘制 绘制背景drawableBackground 绘制自己onDraw 绘制子View dispatchDraw 绘制前景，滚动条装等饰 最后onMeasure -&gt; onLayout(ViewGroup要实现) -&gt; onDraw(可选，系统控件不用实现)]]></content>
      <categories>
        <category>AndroidUI</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插件化]]></title>
    <url>%2F%E6%8F%92%E4%BB%B6%E5%8C%96.html</url>
    <content type="text"><![CDATA[VirtualAPK是滴滴开源的插件化项目，实现动态加载和运行apk的功能。支持任何class的加载，资源的加载及四大组件android 插件化框架VitualAPK解析]]></content>
  </entry>
  <entry>
    <title><![CDATA[阿里镜像]]></title>
    <url>%2F%E9%98%BF%E9%87%8C%E9%95%9C%E5%83%8F.html</url>
    <content type="text"><![CDATA[阿里镜像1234567891011121314151617181920212223242526272829303132buildscript &#123; ext.kotlin_version = &apos;1.2.71&apos; repositories &#123; // 以下四行代码为阿里gradle 源 maven&#123; url &apos;https://maven.aliyun.com/repository/google&apos;&#125; maven&#123; url &apos;https://maven.aliyun.com/repository/gradle-plugin&apos;&#125; maven&#123; url &apos;https://maven.aliyun.com/repository/public&apos;&#125; maven&#123; url &apos;https://maven.aliyun.com/repository/jcenter&apos;&#125; google() jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.2.0&apos; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; &#125;&#125;allprojects &#123; repositories &#123; // 所有的model 都优先使用阿里源 maven&#123; url &apos;https://maven.aliyun.com/repository/google&apos;&#125; maven&#123; url &apos;https://maven.aliyun.com/repository/gradle-plugin&apos;&#125; maven&#123; url &apos;https://maven.aliyun.com/repository/public&apos;&#125; maven&#123; url &apos;https://maven.aliyun.com/repository/jcenter&apos;&#125; google() jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125;]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>阿里</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月25日]]></title>
    <url>%2F8%E6%9C%8825%E6%97%A5.html</url>
    <content type="text"><![CDATA[事件分发 事件分发的对象是MotionEvent,通过触摸屏幕和点击按键产生 事件分发的组件包括Activity，ViewGroup，View以及硬件驱动。 事件传递的方法，Native通过监听，读取dev/input/eventX文件产生新事件，发送给Java层。经过上面提到的组件，主要通过dispatchTouchEvent(),onInterceptTouchEvent(),onTouchEvent()三个方法传递，拦截和消费 Activity和View没有OnInterceptTouchEvent方法，无需拦截事件 在调用子View的dispatchTouchEvent时会判断是否设置了onTouchListener，会回调onTouch方法，返回true则为已经消费了,就不会调用onTouchEvent()的方法及内部的OnClick()方法 处理滑动冲突的方式1.外部拦截：由重写父View在onInterceptTouchEvent()根据业务来判断move事件是否要拦截事件，down和up事件不拦截。2. 内部拦截，父View除了down事件都拦截，然后由子View通过requesDisallowInterceptTouchEvent()来控制父类是否要拦截，或者交给子View处理]]></content>
      <tags>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月21日]]></title>
    <url>%2F8%E6%9C%8821%E6%97%A5.html</url>
    <content type="text"><![CDATA[模板方法模式模板方法模式：在模板类中定义算法或任务执行的流程框架，将一些具体步骤延迟到子类中去实现。即可定义出不同的表现类。 项目实例在项目中订单类型往往很多，订单的处理方式也是别有不同。现在介绍一个用户扫码点餐后，收银接受订单消息的处理流程。首先看一下流程 用户下单：下单来源：支付宝，微信，口碑等，订单类型：堂食，自提，外卖 服务端收到下单请求，定义与之对应的消息推送给收银机 商户在收银机上收到下单消息，进行处理 服务端收到收银的处理结果，推送消息给用户 用户收到消息上面流程在自动审核消息里就是一个通用的过程，因此可以多这个过程制定一个步骤，具体实现由开发者定义。 整个流程中收银机处理的就是订单消息。由于订单的来源及订单类型的多种多样，也就意味着存在两方面的不同。1. 订单数据：基础数据+扩展数据 2.业务处理不同，不同的订单类型需要有不同的UI透出和额外的特殊操作。因此我们可以定义一个基础的UI操作类，定义出，获取订单数据，填充数据等]]></content>
  </entry>
  <entry>
    <title><![CDATA[8月20号]]></title>
    <url>%2F8%E6%9C%8820%E5%8F%B7.html</url>
    <content type="text"><![CDATA[四大引用垃圾回收机制在回收对象的时候，会判断是否有引用指向对象 强引用 程序中大部分的对象都是强引用，如果一个对象具有一个强引用指向它，那垃圾回收器是不会回收他的，在内存不足的情况，系统宁愿报outOfMemery也不会回收这些对象 软引用 如果一个对象只具有软引用，那内存充足的情况是不会被回收的，但在系统内存不足的情况，垃圾回收器还是会回收的。在未被回收之前，程序能正常使用该对象。软引用和一个引用队列管理，若软应用被回收，就会将软应用加入的引用队列中 弱引用弱引用和软引用的区别在于，只具有弱引用的对象具有更短的生命周期，当垃圾回收器扫描到弱引用对象时，就会回收掉该对象。无论内存是否充足。回收后同样会将该引用加入到相关联的引用队列中 虚引用 虚引用顾名思义就是形同虚设，对对象的生命周期毫无影响。一个对象被虚引用指引，就和没有引用一下。会被回收。与软引用和虚引用的区别在于：他必须和引用队列联合使用。唯一目的就是对象被回收的时候收到一个系统通知]]></content>
  </entry>
  <entry>
    <title><![CDATA[8月16日]]></title>
    <url>%2F8%E6%9C%8816%E6%97%A5.html</url>
    <content type="text"><![CDATA[HashMap HashMap是线程不安全的 允许key和value为null 不保证存储的有序性 影响HashMap性能的两个变量，init capacity(16)和loadFactor(0.75),load链表长度，减少Hash faile-fast机制，不允许迭代遍历时remove，add 1.7和1.8jdk版本的数据存储结构.Entry,数组+链表。Node，数组+链表/红黑树 扩容大小2倍，容量为2次幂，方便获取捅数组位置提高效率 HashSet基于HashMap实现，value为object对象 HashTable 线程安全，synchronize修饰方法 key，value不为null 不保证有序性4.initcapcity(11) loadFactor 0.75 扩容大小2倍+1，容量为奇数或者素数，使哈希更加均匀 ConcurrentHashMap 并发容器，多线程下更加高效 key或者value不为null cas无所操作。inittable初始化.SIZECTl，synchronnize 扩容，rehash]]></content>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月14日]]></title>
    <url>%2F8%E6%9C%8814%E6%97%A5.html</url>
    <content type="text"><![CDATA[Android中使用ProtoBuf简介Protobuf是一种Google开发的一种格式，这种格式与开发语言无关，与运行平台无关，用于序列化数据结构，并且很容易扩展，可用于通讯协议和数据存储等，类似于XML，json，但是序列化，反序列化，和数据的大小都远远高于其他数据结构。因为他会将具备可读性的key值的信息都进行过滤，转化更加精简的数据。 优势 数据更加精简 数据大小是json数据的3~10倍 压缩性能是可以提升20~100倍 数据歧义少 代码自动生成注意数据大小的减少是。对key值的特殊定义，及数据都转成了16进制。性能的提升，主要针对整形，浮点型的优化处理。字符型相对提升]]></content>
      <tags>
        <tag>Protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月13日]]></title>
    <url>%2F8%E6%9C%8813%E6%97%A5.html</url>
    <content type="text"><![CDATA[Android打包流程打包流程包括包含四步骤 通过aapt工具打包res资源文件，生成R.java,resources.arsc和res文件 处理.aidl文件，生成对应的java接口文件 通过java compiler编译R.java, java接口文件，java源文件，生成.class文件 通过dex命令，将.class文件和第三方库的.class文件处理称classes.dex 通过apkbuilder工具，将Dex文件，res资源合并成一个APK 通过jarsinger工具，为APK进行签名 通过zipalign工具进行apk的对齐优化 自定义Gradle插件 创建一个module，无论phone还是Android Library，因为后面会删掉大部分文件 删除module下的文件及文件夹，只保留空的src/main目录及build.gradle文件 创建groovy文件夹，定义包名。如java项目一样 创建一个类MyPlugin.groovy 在build.build中加入groovy引用和用于上传的maven的引用 1234567891011121314151617181920212223242526272829apply plugin: &apos;groovy&apos;apply plugin: &apos;maven&apos;dependencies &#123; //gradle sdk compile gradleApi() //groovy sdk compile localGroovy()&#125;repositories &#123; mavenCentral()&#125;group = &apos;com.zyx.plugin&apos; version = &apos;1.0.0&apos;uploadArchives &#123; repositories &#123; mavenDeployer &#123; //提交到远程服务器： // repository(url: &quot;http://www.xxx.com/repos&quot;) &#123; // authentication(userName: &quot;admin&quot;, password: &quot;admin&quot;) // &#125; //本地的Maven地址设置为D:/repos repository(url: uri(&apos;/Users/zhengyangxin/StudioProjects/myProject/LibraryCollection/pluginrepos&apos;)) &#125; &#125;&#125; 插件已经编好，接着需要告诉gradle我们定义了哪个插件，需要创建文件src/main/resources/META-INF/gradle-plugins/XXXX.properties, 这里的XXXX就是外部module引用的名称，在这里我们定义为com.zyx.plugin.properties 1apply plugin: &apos;com.zyx.plugin&apos; 然后在XXXX.properties指明我们定义的插件 1implementation-class=com.hc.plugin.MyPlugin 最后可以进行打包一个plugin在本地，通过定义的uploadArchives Task 在需要的modlue中引用自定义的plugin12345678910111213apply plugin: &apos;com.zyx.plugin&apos;buildscript &#123; repositories &#123; maven &#123;//本地Maven仓库地址 url uri(&apos;/Users/zhengyangxin/StudioProjects/myProject/LibraryCollection/pluginrepos&apos;) &#125; &#125; dependencies &#123; //格式为--&gt;group:module:version classpath &apos;com.zyx.plugin:plugin:1.0.0&apos; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[8月8日]]></title>
    <url>%2F8%E6%9C%888%E6%97%A5.html</url>
    <content type="text"><![CDATA[Android开源框架 AoppermissionAoppermission是基于Aspect实现。实现过程及原理分析。Android的常用Aop有两种方式1.通过JNI Hook，2.静态织入 Acpect基础知识 注解@Aspect，申明切面标记类 @Pointcut, 定义切点，标记方法 @Befeore 前置通知，切点前执行 @Around 围绕切点执行 @after 后置通知，切点后执行 @AfterReturening,返回返回值，切点返回值 @AfterThrowing ，异常通知，切点抛出异常 首先需要依赖com.hujiang.aspectjx:gradle-android-plugin-aspectjx，配置好了所需的环境 通过定义注解，包括NeedPermission,PermissionCanceled,PermissionDenied，三个注解对应这申请权限的三种情况。通过源码看他们的作用域都是Method，保留时间都是一直到运行时期，那就意味着，我们可以通过反射的技术实现想做的，而本项目也恰恰是基于反射和Aspect实现 摘录纵向关系OOP，横向关系AOP OOP是面向对象编程，按照单一职责原则会将会定义一个个类，每个类只负责一个责任。当我们要使用这个时会引用他，使他分散在个个模块，到处都有。如日志，埋点等。从对象组织角度来讲，采用的分类方式是类似生物学的方式，以继承为主线 AOP是面向切面编程，我们从横向的的角度去观察这些对象，无需到处调用。这些需要打印日志的地方就是一个切点，AOp会在适当的时机打印OOP是将问题划分到某个单个模块里去，而AOP是将把涉及到众多模块的某一类问题进行统一管理。AOP是将这些功能集中起来放到一个地方进行管理。是与业务逻辑进行隔离解耦 实现特定方法的前后执行 硬编码，在执行方法前添加额外的执行方法 静态织入，通过AspectJ，通过扫描文件分析代码，找到切点JoinPoint，通过自动生成代码获取方法的各种信息， JDK动态代理是对接口的代理，CGLib是对类的代理，把被代理的对象的class加载起来修改字节码，修改其字节码生成一个继承被代理对象的子类.通过子类增强功能]]></content>
  </entry>
  <entry>
    <title><![CDATA[8月7日]]></title>
    <url>%2F8%E6%9C%887%E6%97%A5.html</url>
    <content type="text"><![CDATA[Android中AOP应用在Android开发中，有很多知名的开源框架在使用AOP思想。例如ButterKnife,Retrofit,Hugo等。AOP可以做性能检测和埋点技术也有很多 性能检测和优化，360的ArgusAPM,滴滴的booster，Hugo 埋点技术，逻辑思维的DDAuto Tracker, 网易的HubbleData 通过AOP技术，还可以在我们向服务器请求数据时，会显示一个Loding，结果返回后隐藏它，可以通过AOP技术将Loading动作与业务主体分离 Android的权限管理Aopermission]]></content>
      <categories>
        <category>“日记”</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月6日]]></title>
    <url>%2F8%E6%9C%886%E6%97%A5.html</url>
    <content type="text"><![CDATA[UMLUML是一种可视化的面向对象的建模语言,可以用来描述系统的静态结构和动态行为。用得最多的是类图，时序图，用例图。 类图类图中类是对象的集合，用来描述类的对象结构类及与类,系统之间的交互关系 泛化关系(表现为is a)：实线加指向父类或接口的空心箭头,包括类与类的继承，接口与接口的继承，类对接口的实现. 实现抽象：虚线+指向抽象的类的空心箭头 聚合关系：不是强依赖关系，用实线+空心菱形箭头指向依赖对象，公司和员工的关系 组合关系：强依赖关系(共存),用实线+实心菱形箭头指向依赖对象，公司和部门的关系，同时创建，同生命周期 依赖关系：通过入参依赖，用虚线+实心箭头，体现为局部变量，方法参数或者静态调用方法 关联关系(has a)：一个类知道另一个类的属性和方法，是另一个类的全局变量 时序图用来显示对象之间的交互关系的图，涉及到角色,生命线，控制焦点和消息等元素消息可以分为：同步消息，异步消息，返回消息，自关联消息 用例图用来描述角色和系统之间的关系，角色与系统交互及系统反应，包括扩展关系和包含关系 AOPAOP面向切面编程。程序设计原则中的单一职责原则，要求我们一个类只负责一个任务，那就意味着一个程序将会有很多类，负责不同能功能。好处是解耦了，但同时如果需要对类的方法进行埋点统一配置等，将会异常繁琐。而AOP就是为了解决这个问题. 横切关注点贯穿多个模块的非主体业务功能，如日志功能 AOP的几种实现方式 动态代理 APT是一种编译期注解处理技术。通过注解和处理来实现编译期生成代码,和源代码一起编译成class文件。将拓展的关注点代码放入注解处理器中 AspectJ是一种编译器。java编译器基础上加了关键字识别和编译方法，可以编写Aspect程序植入目标程序，拓展程序功能。 Transform + Javassist/ASMTransform是Android Gradle提供的，可以操作字节码的一种方式。源码-.class-.dex。在.class转变为.dex过程会经历一系列的Transform处理。Javassist/ASM是操作.class字节码 参考]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月4日]]></title>
    <url>%2F8%E6%9C%884%E6%97%A5.html</url>
    <content type="text"><![CDATA[阿里开源项目启动框架Alpha前面已经介绍了它的原理是基于PERT技术实现的。将一个项目过程以任务单元合理的安排资源，有些任务存在依赖关系所以执行顺序是定死的，但有些任务可以是脱离顺序，可以从关键任务路径中拎出来并行，从而一个项目的耗时及资源占比最大的任务即关键任务路径，在保证项目质量的前提下，可以对关键任务路径上的任务进行优化，也可以从次要任务优化，使关键任务资源充足，达到优化整体项目的效果。下面介绍关键代码类及点 Task任务即项目的执行单元，任务包含的元素 任务的状态：空闲(idle)，正在执行(runing)，结束(finish)，等待(wait) 任务优先级：线程是有限的，对于同一时机的任务，其执行顺序也是有先后顺序的 任务执行所在线程的优先级，对于优先级高的可以分配到更多的cpu时间 任务执行的线程：1.线程池子线程；2.主线程 任务名和任务的监听器对象集合 任务的关联关系：1.前驱任务集合，2.后继任务集合。执行顺序 当然可以添加监控器，监控任务的执行情况（任务耗时） Project项目即由多个任务组成的集合体，它本身也是一个任务，但有其特殊的属性和方法定义 定义了项目的生命周期，ProjectStart(),TaskFinish(),ProjectFinish()。项目的开始，项目中某任务的结束，项目的结束 定义开始和结束任务，两个任务是从图的执行角度来讲是唯一的起始和结束点，可以有效衡量一个图的开始和结束，并且方便将图插入另一个图中.startTask, finishTask 项目名称及生命周期监听集合 添加监控器，及项目执行性能统计 流程分析 初始化Project对象，定义startTask，finishTask，定义回调事件 添加任务，建立任务间的顺序关系 添加任务会与startTask与finishTask构成环形的有向图，每个任务会记录它的前驱任务集合和后继任务集合。当且仅当前驱任务执行完毕才会执行它自己，然后是后继任务，也就意味着，finnishTask只会在所有任务执行结束调用，最后的最后回调project的finish 项目意义在项目中的实践， 可以应用于应用启动流程,在应用启动时会初始化很多任务，如数据库，Tinker，图片库，缓存数据等等，这些任务或许可以同步执行，但有些必须顺序执行。通过PERT技术恰恰能解释并优化这个过程 图片上传任务，数据上传等。数据多可以通过并发上传额方式充分利用cpu 项目地址]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>Alpha</tag>
        <tag>启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月3日]]></title>
    <url>%2F8%E6%9C%883%E6%97%A5.html</url>
    <content type="text"><![CDATA[Https的用途和工作模式用Http协议看新闻没什么问题，但换到严肃的场景中就存在安全风向了，如支付，使用普通的Http协议就会被黑客盯上。通过拦截请求假装自己是服务器，让你输入密码等。解决这种问题的思路是对数据加密，加密方式分两种： 对称加密在对称加密中，加密解密都使用相同的秘钥，因此秘钥的保密工作需要做好，只能给使用的人知道,存在问题 秘钥的约定时机，秘钥通过互联网传输一样会被黑客截获 非对称加密加密和解密使用的秘钥不相同。分公钥和私钥，且公钥加密只能私钥解密，反之亦然。对称加密会存在秘钥约定十几的问题，所以需要非对称加密介入。将非对称加密的公钥公开，私钥自己保留。同样存在问题 服务器的回复数据，黑客可以通过公钥解密，且黑客也可以模拟发送请求，所以一对公钥私钥不够，客户端同样需要有自己的公钥和私钥，并且客户端的公钥给服务端 比较对称加密的算法比分对称加密的算法效率高性能也好，大多数场景都是用对称加密 数字证书非对称加密也存在同样的问题，如何将不对称的公钥给对方。一种是放在公网地址上，让对方下载；二是建立链接的时候传给对方。存在问题： 如何鉴别别人发给你的公钥是对的，而不是冒充的通过权威机构(CA)部门的证书，证书里面包括公钥还要发布者的信息及发布机构，证书有效期等，如身份证一样的存在。证书的签名算法即ＣＡ的私钥,给公司的公钥加密。所有用户在网站上得到的是一个证书，你只要得到ＣＡ的公钥去解密签名就能得到公司的公钥了。关于ＣＡ公钥的可靠性，则需要更加权威的机构证实。 Https的工作模式非对称加密性能不及对称加密，通过非对称加密只对对称加密的秘钥进行加密码，而真正通讯的传输数据则通过对称加密的秘钥进行加解密。过程 客户端发送Client Hello 到服务器,会以明文传输TLS版本信息，加密套件候选列表，压缩算法列表等信息，还有一个随机数，在协商对称秘钥的时候使用 服务器返回Server Hello消息，告诉客户端服务器所选的协议版本，加密套件和压缩算法等，还有一个随机数，用于后续秘钥协商 服务器发送证书 客户端从CA仓库里的公钥去解密证书，成功则可信任获得了服务器的公钥。最后客户端产生一个随机数，用服务器公钥加密发送给服务端 客户端接收到Client Key Exchange,通过私钥解密。最后协商出对称加密的秘钥为客户端的随机数+服务端的随机数+Pre-master产生与客户端相同的对称秘钥 客户端和服务端通过协商的对称秘钥进行通讯 小结 对称加密的效率比非对称加密高，但无法解决了秘钥传输的问题。非对称加密可以解决这个问题，但是效率不高 非对称加密需要通过证书合权威机构来验证公钥的合法性 Https是综合了对称加密合非对称加密算法的Http协议，既保证传输安全，有保证了传输效 阿里开源项目Alpha启动框架是一个基于PERT图构建的异步启动框架，使用简单，高效。在应用启动的时候，我们通常会做很多工作需要，为了提高启动速度，我们尽可能的让这些工作并发进行。但这些工作可能存在前后依赖关系，所以我们需要想办法保证执行顺序的正确性。 PERT即计划评审技术，利用网络分析制定计划以及对计划予以评价的技术。它能调整计划的各道工序，合理安排资源，加速计划进度. 四个概念 事件：表示主要活动结束的哪一点 活动：表示从一个事件到另一个事件之间的过程 松弛事件：不影响完工前提下可能被推迟完成的最大时间 关键路线：是PERT中花费时间最长的事件和活动序列 基本要求 构建一个清晰精确的事件活动网络，其中包括时间和资源 对时间活动进行逻辑排序以确定关键路线 确定“不确定性” 计算关键路线和宽裕时间 作用 标识出项目的关键路径，以明确项目活动的重点 对关键步骤进行资源调度及优化 资源发生矛盾时，通过调度非关键路径资源，保证项目进度 通过PERT网络分析法可大大缩短项目完成的时间 在軟件设计的应用 软件的模块化，不同业务线并行开发 应用插件化，使宿主与插件分开编译，提高编译速度]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>Https</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle学习]]></title>
    <url>%2FGradle%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[什么是GradleGradle是一个开源的，非常灵活的自动化构建工具，具有以下几大特点： 高性能:只执行定义的任务，可以复用任务的输入输出，避免不必要的执行 基于JVM:可以利用java，Kotlin,Groovy等编译器支持的语言 定制了基础框架，便于构建 扩展性：可以自定义任务 编辑器的支持 设计Gradle插件1. 总体架构 提取可用的逻辑编写成二进制插件 插件对性能的影响 定制规范，减少配置 将功能与规范隔离 2. 技术 使用静态语言编写插件 尽量通过Gradle内部的ApI实现插件2.3 减少外部依赖]]></content>
  </entry>
  <entry>
    <title><![CDATA[OkHttp]]></title>
    <url>%2FOkHttp.html</url>
    <content type="text"><![CDATA[一. 曾经的网络框架Android的网络框架有四种 HttpClient ： 2.2版本以下存在bug，所以2.3之后建议使用HttpUrlConnection HttpUrlConnection 2.3+， 官方推荐 Volley，谷歌开发，简单的网络任务框架，底层兼容2.3以前版本使用了HttpClient，2.3+使用的是HttpUrlConnection，功能拓展性弱 Okhttp，从Android4.4开始HttpURLConnection的底层实现采用的是okHttp. 优缺点通过上面的比较，在Android发展的每个阶段，他们有各自存在的意义，只是时过境迁，被种种原因被替换或者废弃。这个过程是一个框架发展的过程，从重量级繁杂且难以维护，到轻量级易扩展，到过度版本新老版本的兼容，最后取长补短完善自己的网络框架。化繁为简，然后又能包容万象的过程 网络框架应该有的功能 自定义请求的Header GET，POST 支持文件上传下载 图片加载 支持多任务网络请求操作 支持缓存 支持回调 支持session ….. 二. OkHttp简介一张图了解OkHttp的整个过程在OkHttp中真正核心的东西是Interceptor，他不仅负责拦截请求进行额外的处理(入cookie)，实际上他还会把实际的网络请求，缓存，透明压缩等功能都统一起来，每一个功能都只是一个Interceptor，它们在连接成一个Interceptor.Chain,环环相扣最终完成一次网络请求，从getResponseWithInterceptorChain函数中我们可以看到Interceptor.Chain的分布情况依次是： 在配置OkHttpClinet时设置的interceptors 负责失败重试和重定向的RetryAndFollowUpInterceptor 负责把用户构造的请求转化为发送到服务器的请求，把服务器返回的响应转化为用户友好的响应BridgeInterceptor 负责读取缓存直接返回，更新缓存的CacheInterceptor 负责和服务器建立连接的ConnectInterceptor 配置OkHttpClient时设置的NetworkInterceptor 负责向服务器发送请求数据，从服务器读取响应数据的CallServerInterceptor 在这里位置决定了功能，最后一个一定是CallServerInterceptor，其他的在这之前。责任链模式在Interceptor中得到了很好的实践。对于request变成response对象，每个interceptor都能完成这件事，也由各自的inteceptor决定是否要交给下个interceptor。 三. Interceptor分析首先看分析ConnectInterceptor和CallServerInterceptor，这两个interceptor实现了和服务器进行通信的核心 1. ConnectInterceptor建立连接1234567891011121314/** Opens a connection to the target server and proceeds to the next interceptor. */ @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); Transmitter transmitter = realChain.transmitter(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks); return realChain.proceed(request, transmitter, exchange); &#125; 通过创建一个Exchange对象，他将在后面使用。他的内部是对http，https请求的实现，内部都是利用Okio对Socket的读写操作进行了封装.在内部是对java.io和java.nio进行了封装，内部创建了一个主要的RealConnectionn对象，利用RealConnectionn进行读写 2. CallServerInterceptor 发送和接受数据主要过程： 向服务器发送request header 如果有request body,就向服务器发送 读取response header, 构造response 对象 如果有response body,则创建一个带body的response对象 3. CacheIntercepter 缓存在建立连接，和服务器通讯之前就是CacheIntercepter，我们需要检查响应是否已经本地缓存了，如果缓存了则直接返回，否则进行后面的流程，并把返回的数据写入缓存 获取本地缓存cacheCandidate 如果本地缓存可用则直接返回CacheCandidate，从而打断interceptor链 走剩下的interceptor获取nnetworkResponse networkResponse、cacheResponse构造新的response 根据新的response里的header定制缓存策略，存入缓存中（method 为get） 总结创建一个单例的OkHttpClient，创建请求对象request，初始化请求方式，请求url，请求header，请求body，然后通过client的newcall（request）构建真正的请求对象realcall。有realcall的execute方法和qnqueue方法区分是同步请求还是异步请求，异步请求依赖线程池dispatcher，最终会调用getResponseWithInterceptorsChain方法返回返回response。内部通过这种拦截器对request请求数据和response响应数据进行处理，每个拦截器直接通过realinterceptchain对象的process连接起来（责任链模式）]]></content>
      <tags>
        <tag>网络，Okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维火火种培训]]></title>
    <url>%2F%E4%BA%8C%E7%BB%B4%E7%81%AB%E7%81%AB%E7%A7%8D%E5%9F%B9%E8%AE%AD.html</url>
    <content type="text"><![CDATA[毕业在即，我也在二维火实习了近半年时间，随着对产品和公司的了解我决定将继续留在公司学习，想在未来的某一天看着自己参与或者做的项目投入市场，得到大家的认可。 火种培训火种：二维火的种子（实习生），年轻，活力。星星之火可以燎原。 第一天 2018/6/20 红烧肉：产品研发负责人《开篇介绍》给我们介绍了公司的使命，愿景，价值观等。聊了聊公司的发展历程以及在公司多年来的经历，给了我们一些切身的建议：每个月看书，写日记 todolist等 人参果：产品委员会主席《公司产品介绍》细致的讲述了公司的价值观：正直善良，敬畏之心，天道酬情！讲述了公司在10几年间，产品的迭代更替以及公司的主要产品线（排队，扫码点餐，厨房KDS，收银，供应链，掌柜等等） 第二天 2018/6/21 生抽：交易架构师《高并发下的变成》介绍了Java并发编程的基础，以及交易订单的一些具体场景，如何避免并发导致的数据同步问题。还介绍了锁的应用等等 小米：项目管理主管《流程规范&amp;项目管理》详细介绍了项目的具体含义：一群人为达到某一目标而做某一件事。告诉我们项目即输入物-〉输出物项目的整个流程等 第三天 2018/6/22 四季豆：共享业务总监《二维火服务端技术架构》介绍了千亿级别服务架构的演变过程，从一个点子，几个人快速的做了一个东西推向市场，产品使用量上升，服务器资源有限，添加服务器，负载均衡，缓存设计，业务模块拆封等等 马宝：供应链客户经理《客户端架构》介绍了Android的一些历史及在二维火中的一些具体应用，同时分享了很多有趣的程序员日常。最后一句，8小时的生存，other 生活！ 上了7天请假两天参加毕业典礼 pm开放平台项目 确定项目角色，流程角色及职责 项目经理：简称PM，项目中职责为主导项目全体成员按照项目计划执行，完成项目目标，管控项目的全过程；善于风险识别及跟踪问题解决。更侧重于项目过程中的沟通协作，会议组织，里程碑进度把控，组织过程资产归档，对外汇报等工作。 需求经理：简称DM，负责收集各类需求，整理分析后列入禅道的需求池，对接PD推动需求的实现。 产品经理：简称PD，细化需求制作市场需求文档（简称MRD）；明确项目需求范围边界值，编写产品说明书（简称PRD），协同交互，视觉完善PRD正式版。跟踪产品验收。 立项初始，判定此项目是否为重点业务型项目。 视觉设计师：简称UI，实现PD的页面需求，将其可视化。视觉稿需通过视觉评审。协同PD确认最终界面符合视觉设计稿。 技术经理：简称TM，项目中职责为担任技术总负责，把控项目整体技术方案可行；重点跟进架构设计阶段，开发阶段及发布阶段的具体执行。更侧重于项目过程中的任务计划评估，技术难题解决，代码质量把控，发布管理跟踪等工作。 开发人员：客户端及服务端的代码实现者。完成编码后的自测，联调，根据冒烟用例进行冒烟测试。 测试人员：质量的把关者。需要根据测试用例，担当内部测试，接口测试、预发后测试，线上回归测试等。 配置管理员：简称SCM，进行版本控制，协助完成项目环境配置。 运维人员：简称SA，提供项目环境（开发、测试环境），评审发布计划，协助发布等。 数据库管理员：简称DBA，主要负责产品研发中心所有数据库的运营和维护，评审SQL等。 业务线技术TL：各业务线技术负责人。主要负责立项时候判定项目是否重点技术项目。 架构委员会：由高级架构师，核心应用owner们及业务线技术负责人组成的技术架构组织。如有技术型项目启动时，负责判定项目是否为重点技术型项目。 产品架构委员会：简称PDM，在项目执行过程中主要负责参与二维火核心产品业务的MRD&amp;PRD评审，以及上线后产品目标的验收。 立项会产品组织，项目经理结果通知]]></content>
      <categories>
        <category>二维火</category>
      </categories>
      <tags>
        <tag>JOb</tag>
        <tag>二维火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android IPC]]></title>
    <url>%2FAndroid-IPC.html</url>
    <content type="text"><![CDATA[Android跨进程通讯的几种方式Bundle Bundle实现了Parcelable，方便在进程中传输数据。主要在activity、service、receiver中Intent中应用， 文件共享Android基于Linux，对文件的读写没有限制。存在的问题就是并发读写的问题sp存在缓存策略，内存中存在备份，导致多进程不可靠 使用messenger信使 Messenger可以在不同的进程中传递Message对象，轻松实现数据的跨进程通讯。 它的底层实现是AIDl，内部一次只做一次处理，因此服务端不用考虑线程同步的问题 缺点是只能用来简单的信息传递，并发请求不大合适且无法不支持跨进程的方法的调用]]></content>
      <tags>
        <tag>Android</tag>
        <tag>进程通讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava的使用及源码分析]]></title>
    <url>%2FRxJava%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[基于Rxjava-2.1.10版本源码分析从开源文档范例开始分析 范例一.Flowable.just输出HelloWord123456Flowable.just(&quot;Hello world&quot;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; &#125;&#125;); 1.从just方法开始,首先可以看到三个注解方法12345678@CheckReturnValue //检查返回值@BackpressureSupport(BackpressureKind.FULL) //支持的背压方式@SchedulerSupport(SchedulerSupport.NONE) //调度方式,即处理事件的方式IO数据流，新开一个线程等。public static &lt;T&gt; Flowable&lt;T&gt; just(T item) &#123; //方法参数是个泛型， ObjectHelper.requireNonNull(item, &quot;item is null&quot;); //返回值是个Flowable对象 return RxJavaPlugins.onAssembly(new FlowableJust&lt;T&gt;(item)); &#125; 2.方法第一行是判空操作在很多地方都使用到了，查看方法不为空则返回原对象，否则，抛出异常NullPointerException123456public static &lt;T&gt; T requireNonNull(T object, String message) &#123; if (object == null) &#123; throw new NullPointerException(message); &#125; return object; &#125; 3.方法第三行中的看new FlowableJust(item)创建的实例对象1234567891011121314151617public final class FlowableJust&lt;T&gt; extends Flowable&lt;T&gt; implements ScalarCallable&lt;T&gt; &#123; private final T value; //final变量，赋值后不能改变 public FlowableJust(final T value) &#123; this.value = value; &#125; //重写了Flowable的subscribeActual方法，传入了观察者与发射内容构造一个订阅对象 //由观察者去订阅这个对象 @Override protected void subscribeActual(Subscriber&lt;? super T&gt; s) &#123; s.onSubscribe(new ScalarSubscription&lt;T&gt;(s, value)); &#125; @Override public T call() &#123; return value; &#125;&#125; 4.然后看RxJavaPlugins.onAssembly()方法12345678910@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;) @NonNull public static &lt;T&gt; Flowable&lt;T&gt; onAssembly(@NonNull Flowable&lt;T&gt; source) &#123; //在这里钩子函数为null，即直接返回source Function&lt;? super Flowable, ? extends Flowable&gt; f = onFlowableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source; &#125; 5.所以Flowable.just(“Hello world”)只是生成了一个Flowable对象。接着看subscribe()方法。实现了Consumer接口123456789public interface Consumer&lt;T&gt; &#123; /** * 回调函数accept去消费这个传入值， * Consume the given value. * @param t the value * @throws Exception on error */ void accept(T t) throws Exception;&#125; 6.接着看subscribe()方法123456789@CheckReturnValue@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)@SchedulerSupport(SchedulerSupport.NONE)public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123; //onNext即要去消费的接口对象 //其他传入参数为默认的onError，onComplete接口回调，和最大数量的订阅对象 return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);&#125; 7.然后去看第二个subscribe()内部方法123456789101112131415161718@CheckReturnValue@BackpressureSupport(BackpressureKind.SPECIAL)@SchedulerSupport(SchedulerSupport.NONE)public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Subscription&gt; onSubscribe) &#123; ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;); ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;); ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;); ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;); //上面一系列的判空操作之后，将传入参数组合成一个LambdaSubscriber LambdaSubscriber&lt;T&gt; ls = new LambdaSubscriber&lt;T&gt;(onNext, onError, onComplete, onSubscribe); //调用了第三个subscribe方法 subscribe(ls); return ls;&#125; 8、先来看一下LambdaSubscriber对象，除了对传入参数赋值之外，内部重写了熟悉的onSubscribe、onNext()、onError()、onComplete()三个方法。从6.可以看出在这四个方法中除了onNext()是我们传入的，其他都是框架默认的。源码过长，不copy了。9.接着继续看第三个subscribe(ls)方法1234567891011121314151617181920212223242526@BackpressureSupport(BackpressureKind.SPECIAL)@SchedulerSupport(SchedulerSupport.NONE)@Betapublic final void subscribe(FlowableSubscriber&lt;? super T&gt; s) &#123; ObjectHelper.requireNonNull(s, &quot;s is null&quot;); try &#123; // 传入当前要观察的对象和处理方法对象构建了一个观察者对象 Subscriber&lt;? super T&gt; z = RxJavaPlugins.onSubscribe(this, s); ObjectHelper.requireNonNull(z, &quot;Plugin returned null Subscriber&quot;); //在这传入一个观察者对象 subscribeActual(z); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can&apos;t call onError because no way to know if a Subscription has been set or not // can&apos;t call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException(&quot;Actually not, but can&apos;t throw other exceptions due to RS&quot;); npe.initCause(e); throw npe; &#125;&#125; 10.接着看subscribeActual(),似曾相识在3.中FlowableJust重写了父类的subscribeActual()方法，所以最后有回来了123456@Overrideprotected void subscribeActual(Subscriber&lt;? super T&gt; s) &#123; //1.传入观察者对象和要发射的值创建了一个标量的订阅对象 //2.观察者对象订阅了这个标量的订阅对象 s.onSubscribe(new ScalarSubscription&lt;T&gt;(s, value));&#125; 11.先看ScalarSubscription方法，可以看到当调用了request(n)的方法时onNext方法就会被调用,1234567891011121314151617181920public ScalarSubscription(Subscriber&lt;? super T&gt; subscriber, T value) &#123; this.subscriber = subscriber; this.value = value;&#125;@Overridepublic void request(long n) &#123; if (!SubscriptionHelper.validate(n)) &#123; return; &#125; if (compareAndSet(NO_REQUEST, REQUESTED)) &#123; Subscriber&lt;? super T&gt; s = subscriber; //这里就是LambdaSubscriber中的onNext，也是我们传入的onNext会去回调的地方 s.onNext(value); if (get() != CANCELLED) &#123; s.onComplete(); &#125; &#125;&#125; 12.所以我们要看request()在哪里调用，接着看继续看s.onSubscribe()方法，它就是LambdaSubscriber中的onSubscribe()方法12345678910111213@Overridepublic void onSubscribe(Subscription s) &#123; if (SubscriptionHelper.setOnce(this, s)) &#123; try &#123; //onSubscribe对象是在3.中传入的FlowableInternalHelper.RequestMax.INSTANCE，并调用了accept方法 onSubscribe.accept(this); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.cancel(); onError(ex); &#125; &#125;&#125; 13.接着继续看FlowableInternalHelper.RequestMax.INSTANCE。123456789public enum RequestMax implements Consumer&lt;Subscription&gt; &#123; //枚举法创建的单例 INSTANCE; @Override public void accept(Subscription t) throws Exception &#123; //可以看到在这里调用了request方法 t.request(Long.MAX_VALUE); &#125;&#125; 14.接着可以回到11.ScalarSubscription类中，在request方法中就调用了LambdaSubscriber的onNext*()方法并传入了value值15.接着再去看LambdaSubscriber类中的onNext方法12345678910111213@Override public void onNext(T t) &#123; if (!isDisposed()) &#123; try &#123; //在这里回调了我们当初我们传入的实现对象onNext的accept方法， onNext.accept(t); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); get().cancel(); onError(e); &#125; &#125; &#125; 16.走完onNext方法后，继续看11.它会继续走s.onComplete()方法，这个方法也是默认的Functions.EMPTY_ACTION1234567891011static final class EmptyAction implements Action &#123; @Override public void run() &#123; //空方法 &#125; @Override public String toString() &#123; return &quot;EmptyAction&quot;; &#125; &#125; 17.至于onError方法会14.在onNext()发生异常时去调用，且在这里也是默认传入的Functions.ON_ERROR_MISSING123456static final class OnErrorMissingConsumer implements Consumer&lt;Throwable&gt; &#123; @Override public void accept(Throwable error) &#123; RxJavaPlugins.onError(new OnErrorNotImplementedException(error)); &#125;&#125; 最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext()进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式]]></content>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射那些事]]></title>
    <url>%2FJava%E5%8F%8D%E5%B0%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
    <content type="text"><![CDATA[反射机制的定义在运行状态期间，能过动态的知道一个类的属性和方法，能够动态的调用一个对象的属性和方法的功能。 反射机制的功能在运行期间 判断任意一个对象所属的类 构建任意一个类的对象 判断任意一个类的属性和方法 调用任意一个对象的方法 生成动态代理 反射机制的应用场景 逆向代码，反编译 与注解相结合的框架，retrofit 单纯的反射机制框架，EventBus 动态生成类框架，Gson 通过反射获取类信息每个类被加载后，系统会为该类生成一个对应的Class对象，通过该Class对象就可以访问JVM中的这个类 在JAVA程序中获得Class对象通常有三种方法 使用Class类的forName()静态方法,传入全限定名 调用某个类的class属性 通过对象getClass()获取Class对象12341.Classs class = Class.forName(com.zyx.Person);2.Class calss = Person.class;3.Person person = new Person();Class class = person.getClass(); 获取class对象的属性、方法、构造函数 获取class对象的属性 1234Field[] allFields = class.getDeclaredFileds();// 获取所有声明的属性Filed[] publicFileds = calss.getFields[]; //获取所有public属性Field ageField = class.getDeclaredFiled(&quot;age&quot;);// 获取指定声明的属性Filed desFiled = calss.getField(&quot;age&quot;); //获取指定public属性 获取class对象的方法 12345Method[] methods = class.getDeclaredMethods();// 获取所有声明的方法Method[] publicFileds = calss.getMethods[]; //获取所有public方法，Method[] publicFileds = calss.getMethods[]; //获取所有public方法，带指定形参列表的方法Method method= class.getDeclaredMethods(&quot;info&quot;,String.class);// 获取指定声明的方法，Method infoMethod = calss.getMethod(&quot;info&quot;,String.class); //获取指定public方法,带指定形参列表的方法 获取class对象的构造函数 1Constructor 通过Java反射生成并操作对象生成实例 使用Class对象的newInstance()方法来创建Class对象对应的实例，但对应类必须有默认的构造函数 先使用Class的对象获取指定的Constructor对象，在调用Constructor对象的newInstance()方法调用方法 通过Class对象的getMethods()或者getMethod()获得指定方法，返回Method对象或者数组。 通过Method对象中的invoke()方法。第一个参数传调用该方法的对象，第二个参数传对应该方法的参数。123Object obj = class.newInstance();Method methdo = calss.getDeclareMethod(&quot;setAge&quot;, int.calss);method.invoke(obj, 28); //会检查调用权限 访问成员变量赋值1234Object obj = class.newInstance();Field field = class.getField(&quot;age&quot;);field.setInt(obj, 28);int age = field.getInt(obj); 代理模式定义给某个类提供一个代理对象，并由代理对象控制对原对象的访问，即客户不直接操控原对象，而是通过代理对象操控原对象 代理模式的分类 静态代理，在编译时就实现好了，会生成对应的Class实际文件 动态代理，在运行时生成，在运行时生成类字节码被加载到JVM中 代理模式的思路 代理对象和目标对象均实现同一个行为接口 代理对象和目标对象分别实现具体接口逻辑 在代理对像的构造函数中实例化一个目标对象 在代理对象中调用目标对象的行为接口 客户端想要调用目标对象的行为接口只能通过代理对象来操作 Java反射机制和动态代理动态代理介绍 运行时生成代理类，并将代理类的字节码载入当前代理的ClassLoader 不需要多些多写一个与目标类相同的代理类 可以在运行时定制代理类的执行逻辑涉及的类 java.lang.reflect.Proxy,生成代理类的主类，通过Proxy生成的代理类都继承Proxy。Proxy提供了创建动态代理类和代理对象的方法，是所有动态代理类的父类。 java.lang.reflect.InvacationHandle 调用处理器，当调用动态代理的方法时会直接转到InvocationHandle的invoke()方法 泛型与Class避免强制转换泛型参数化类型 getGenericType();普通类型 getType()]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>【反射机制】</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型那些事]]></title>
    <url>%2F%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
    <content type="text"><![CDATA[泛型的目的语法糖即糖衣语法，这种语法对语言并没有影响，只是方便了程序员的使用。主要包括：泛型，变长参数，条件编译，自动拆装箱，内部类等。虚拟机并不支持这种语法，在编译期就会被还原为基础语法结构，这个过程被称为解语法糖。泛型的目的：通过泛型使得在编译期间完成类型转换工作，避免运行时强制类型转换而出现ClassCastException，类型转换异常 泛型初窥JDK1.5之后添加泛型的好处 类型安全，将类型检测挪到了编译期。 消除了代码中许多的强制类型转换，增强了代码的可读性 为较大的优化带来了可能泛型使用泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当做类型使用方法声明定义的形参只能在该方法里使用修饰符 返回值类型 方法名（形参列表）{ 方法体}类型通配符 任意通配符：？匹配任意的类型，用作读取不能添加 上限通配符：使用extends关键字指定这个类型必须是继承某个类，或者是实现某个接口（子类或者本身） 下限通配符：使用super关键字指定这个类型必须是某个类的父类，或者是某个接口的父类 类型擦除作用于编译期间，所以运行期间泛型信息是被擦除的，编译后的Class不包含泛型信息。静态方法，静态初始化或者静态变量声明和初始化不允许使用类型形参。也不能使用instance of运算符]]></content>
      <categories>
        <category>“JAVA”</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合类分析理解]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%E7%B1%BB%E5%88%86%E6%9E%90%E7%90%86%E8%A7%A3.html</url>
    <content type="text"><![CDATA[Java集合面试总结 Collecton 和 MapCollection包括 Set List Queue 主要分析 ArrayList 动态数组 capacity 扩容机制 1.5倍， 初始 java1.8 : 10 ;android 21 :12 内部元素变动 System.copyarray(); 线程不安全 LinkList双向链表Node()函数，该函数以O(1/2)的性能去获取一个节点链表操作线程不安全 HashMap hash()方法 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) able的长度都是2的幂，因此index仅与hash值的低n位有关 计算方式 tableSizeFor() 找到大于等于initialCapacity的最小的2的幂 Node[] tab哈希桶数组.哈希冲突，开放地址和链地址法 根据key获取哈希桶数组索引位置 tab 长度为2的幂次 threshold 所能容纳的key-value对极限 Map m = Collections.synchronizeMap(hashMap)实现同步 初始 capacity 16 loadFactor 0.75 TreeMap 红黑树的定义，节点非红即黑，根节点为黑色，不能连续的红色，任意节点到末端的路径黑色个数相同 红黑树的平衡调整，颜色和结构 继承了SortMap ，put()函数会做比较 寻找后继节点，中序遍历 LinkHashMap 与HashMap类似，不过保证了put顺序 主要实现了afterNodeAccess(),afterNodeInsert(),afterNoderemoval三个方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 线程那些事]]></title>
    <url>%2Fandroid-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5.html</url>
    <content type="text"><![CDATA[线程和线程安全线程是什么 线程为进程的一个实体 轻量级进程 是CPU调度和分配的基本单位 可与同一进程内的线程共享进程内的全部资源 android 进程通过fork创建，线程通过pthread.creat创建 并发的优势促使多线程的出现 资源利用率 ，提高 公平性，共享资源 便利性，多任务并发执行比单任务更容易执行 线程安全多线程的引入意味着引入了线程安全。当单线程能正确运行的代码，在多线程访问的情况下，不管线程以何种顺序访问，并不添加同步代码都能正确表现行为，则称它为线程安全的 并发的三大要素原子性指的是一个或者多个不能再被分割的操作value = 1; //院子操作value++; //复合操作 数据竞争指多进程访问共享资源，不做同步 有序性可见性当一个线程对某个变量做出修改时，其他线程可以立刻读取修改后的值 volatile 是一种稍弱的同步机制，用来确保变量更新操作同步到其他线程，虚拟机不会指令重排 锁与volatile不同，锁具有两个特性：互斥性和可见性 内置锁Sychronized关键字可作用于class和java对象 锁的原理 锁实现了内存可见性和操作原子性 释放锁时，该线程的本地内存中的共享变量会被刷新到内存中 锁不会被继承 同步代码块是使用monitorenter和monitorexit指令实现的，同步方法是通过ACC_SYNCHRONIZED标识符实现 锁的使用原则 可能被多个线程同时访问的可变变量，在访问它时都需要持有一个锁，变量由这个锁保护 每个可变变量都只有一个锁来保护，知道锁的范围 当锁作用于多个变量时，对每个变量的操作都应该由同一个恶锁保护 在Android中，工作线程尽量不要和UI线程做同步 重入锁优化显示锁reentrantLocksemaphorecountDownLatchCyclicBarrierFutureTask 原子变量和非阻塞算法Atomiccas非阻塞算法性能比较 https://segmentfault.com/l/1500000012849264/play]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bit Manipulation]]></title>
    <url>%2Fbit-manipulation.html</url>
    <content type="text"><![CDATA[Bit Manipulation(位运算)：一共五种运算：与，或，异或，左移，右移。 常用技巧：（1） n &amp; （n-1）能够消灭n中最低位中的1。（2） 右移：除以2， 左移：乘以2。（3） 异或性质：交换律，0^a=a, a^a=0;（3） 将常用字符、数字等均转为按位运算，可以节约空间。 例题Number of 1 Bits使用右移。使用n&amp;(n-1)可以消灭一个1的性质来求解。12345678public static int hammingWeight(int n) &#123; int cnt = 0; while (n &gt; 0) &#123; cnt += (n &amp; 1); n &gt;&gt;= 1; &#125; return cnt;&#125; Missing Number这道题给我们n个数字，是0到n之间的数但是有一个数字去掉了，让我们寻找这个数字，要求线性的时间复杂度和常数级的空间复杂度。解法一:最直观的一个方法是用等差数列的求和公式求出0到n之间所有的数字之和，然后再遍历数组算出给定数字的累积和，然后做减法，差值就是丢失的那个数字12345678public static int missingNumber(int[] nums) &#123; int sum = 0; int n = nums.length; for(int i =0; i&lt; n; i++)&#123; sum += nums[i]; &#125; return (int)(0.5 * n * (n + 1) - sum);&#125; 解法二：，使用位操作Bit Manipulation来解的，用到了异或操作的特性。思路是既然0到n之间少了一个数，我们将这个少了一个数的数组合0到n之间完整的数组异或一下，那么相同的数字都变为0了，剩下的就是少了的那个数字了12345678public static int missingNumber1(int[] nums) &#123; int res = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; int midres = (i + 1) ^ nums[i]; res ^= midres; &#125; return res;&#125; 解法三：这道题还可以用二分查找法来做，我们首先要对数组排序，然后我们用二分查找法算出中间元素的下标，然后用元素值和下标值之间做对比，如果元素值大于下标值，则说明缺失的数字在左边，作为读者的你可能会提出，排序的时间复杂度都不止O(n)，何必要多此一举用二分查找，还不如用上面两种方法呢。对，你说的没错，但是在面试的时候，有可能人家给你的数组就是排好序的，那么此时用二分查找法肯定要优于上面两种方法，所以这种方法最好也要掌握以下123456789101112131415public static int missingNumber2(int[] nums) &#123; if(nums == null || nums.length ==0) return -1; int low = 0; int high = nums.length - 1; while (low &lt;= high)&#123; int mid = low + (high - low)/2; if(nums[mid] &gt; mid)&#123; high = mid -1; &#125;else &#123; low = mid + 1; &#125; &#125; return low;&#125; Power of Two使用n&amp;(n-1）=0来判断。注意0和负数的情况。这道题让我们判断一个数是否为2的次方数，而且要求时间和空间复杂度都为常数解法一：那么我们很容易看出来2的次方数都只有一个1，剩下的都是0，所以我们的解题思路就有了，我们只要每次判断最低位是否为1，然后向右移位，最后统计1的个数即可判断是否是2的次方数12345678public static boolean isPowerOfTwo(int n) &#123; int cnt = 0; while (n &gt; 0) &#123; cnt += (n &amp; 1); n &gt;&gt;= 1; &#125; return cnt == 1;&#125; 解法二：这道题还有一个技巧，如果一个数是2的次方数的话，根据上面分析，那么它的二进数必然是最高位为1，其它都为0，那么如果此时我们减1的话，则最高位会降一位，其余为0的位现在都为变为1，那么我们把两数相与，就会得到0，用这个性质也能来解题。12345678public static boolean isPowerOfTwo2(int n)&#123; int result = n &amp; (n - 1); if(n &gt; 0 &amp;&amp; result == 0)&#123; return true; &#125;else &#123; return false; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自建梯子，畅行无阻]]></title>
    <url>%2Fvpn.html</url>
    <content type="text"><![CDATA[自建梯子教程自己搭建ss/ssr服务器教程（适合初学者） ###【一键部署ssr代码】yum -y install wgetwget -N –no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 备用地址yum -y install wgetwget -N –no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh参数配置远程端口密码加密方式 aes-256-cfb协议 auth_chain_a混淆方式 plain ###【谷歌BBR加速教程】 yum -y install wget wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Largest Rectangle in Histogram and Maximal Rectangle]]></title>
    <url>%2FLargest-Rectangle-in-Histogram.html</url>
    <content type="text"><![CDATA[题目链接：Largest Rectangle in HistogramMaximal RectangleLargest Rectangle in Histogram 这道题算是比较难的一道题，最简单的做法就是对于任意一个bar，向左向右遍历，知道高度小于该bar。这时候计算该区域的面积。对于每一个bar，我们都做如上处理，最后得到最大值。当然这样的做法是O(n2)，过不了大数据集合测试。 从上面我们直到，对于任意一个bar n，我们得到的包含该bar n的矩形区域里面bar n是最小的。我们使用ln和rn来表示bar n向左及向右第一个小于bar n的bar的索引位置。譬如题目中bar 2的高度是5,它的ln为1，rn为4.包含bar的矩形区域面积为（4-1-1）*5=10 我们可以从左往右遍历所有的bar，并将其push到一个stack中，如果dangqianbar的高度小于栈顶bar，我们pop出栈顶bar，同时以该bar计算举行面积。纳闷我们如何知道该bar的ln和rn呢？rn铁定就是当前遍历到的bar的索引，而ln则是当前栈顶bar的索引，因为此时栈顶bar的高度一定小于pop出来的bar的高度。 复杂度分析因为要找三个元素，所以时间复杂度为O(n)，空间复杂度为O(1) 代码112345678910111213141516public static int largestRectangleArea(int[] height )&#123; int maxArea = 0; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); int i = 0; while (i &lt;= height.length)&#123; int h = (i == height.length ? 0 : height[i]); if(s.isEmpty() || h &gt;= height[s.peek()])&#123; s.push(i); i++; &#125;else &#123; int t = s.pop(); maxArea = Math.max(maxArea, height[t] * (s.isEmpty() ? i : i - s.peek() - 1)); &#125; &#125; return maxArea;&#125; Maximal Rectangle此题是之前那道的 Largest Rectangle in Histogram直方图中最大的矩形 的扩展，这道题的二维矩阵每一层向上都可以看做一个直方图，输入矩阵有多少行，就可以形成多少个直方图，对每个直方图都调用 Largest Rectangle in Histogram 直方图中最大的矩形 中的方法，就可以得到最大的矩形面积。那么这道题唯一要做的就是将每一层构成直方图，由于题目限定了输入矩阵的字符只有 ‘0’ 和 ‘1’ 两种，所以处理起来也相对简单。方法是，对于每一个点，如果是‘0’，则赋0，如果是 ‘1’，就赋之前的height值加上1。具体参见代码如下： 代码2123456789101112131415161718192021222324252627282930313233343536373839public static int maximalRectangle(char[][] matrix) &#123; if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0; int[] height = new int[matrix[0].length]; for(int i = 0; i &lt; matrix[0].length; i ++)&#123; if(matrix[0][i] == &apos;1&apos;) height[i] = 1; &#125; int result = largestRectangleArea(height); for(int i = 1; i &lt; matrix.length; i ++)&#123; resetHeight(matrix, height, i); result = Math.max(result, largestRectangleArea(height)); &#125; return result;&#125;private static void resetHeight(char[][] matrix, int[] height, int idx)&#123; for(int i = 0; i &lt; matrix[0].length; i ++)&#123; if(matrix[idx][i] == &apos;1&apos;) height[i] += 1; else height[i] = 0; &#125;&#125;public static int largestRectangleArea(int[] height )&#123; int maxArea = 0; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); int i = 0; while (i &lt;= height.length)&#123; int h = (i == height.length ? 0 : height[i]); if(s.isEmpty() || h &gt;= height[s.peek()])&#123; s.push(i); i++; &#125;else &#123; int t = s.pop(); maxArea = Math.max(maxArea, height[t] * (s.isEmpty() ? i : i - s.peek() - 1)); &#125; &#125; return maxArea;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需常记心头]]></title>
    <url>%2F%E9%9C%80%E5%B8%B8%E8%AE%B0%E5%BF%83%E5%A4%B4.html</url>
    <content type="text"><![CDATA[在二维火工作收集的经典语句！不要起个大早，赶个晚集无法快速落地的“点子”都属于“忽悠”。趋势、潮流瞬息万变，竞争对手如狼似虎。再好的点子，如果只是挂在嘴上，不执行、不落实，等于把机会拱手送给别人。 清空自己用户都很懒，并且时间宝贵，面对陌生的功能需要快速做出决定。所以在设计每一个细节时，尽量清空自己，忘掉身份，忘掉流程，让自己变成一个小白。最终呈现给用户的内容才是浅显易懂的。 不要被用户牵着鼻子走与用户聊需求时，要挖掘其背后真实的目的。用户不会替我们考虑灵活性、普遍性、规范性。个性化的需求如何落实到通用的产品中区，需要思考，不能被用户带到沟里去。 切记习以为常习惯一个人，习惯一件事，会让自己变得麻木，忽视其中存在的问题。我们的产品对大部分用户来说是陌生的，用户可能会卡在一些我们倒背如流的节点上，设计和使用自己的产品时需要保持敏感 定期回顾行业在发展，技术在进步，客户的认知在变化，我们自己也在成长。长时间不用的东西，定期去回顾，会发现很多问题。有些功能用的很少，可能设计过时了，或者流程出问题了。 产品能解决的事不要靠人去解决“这个功能给店家培训一下就好”，这句话是不负责任的，一个功能点做一次培训，一家店做一次培训，一千个功能点和十万店家需要多少人去培训多少次？人力成本的投入是巨大的，要用好的设计去引导用户，而不是靠人力去解决问题。]]></content>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find Mininum in Rotated Sorted Array I and II]]></title>
    <url>%2FFind-Mininum-in-Rotated-Sorted-Array.html</url>
    <content type="text"><![CDATA[题目链接:Find Minimum in Rotated Sorted ArrayFind Minimum in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).Find the minimum element.I和II的区别在于是否有重复元素 题目的要求 一个升序的数组且无重复元素 在处理数组前进行部分反转 找出最小元素 题目分析 寻找最小值，我们可以用二分查找法来做 在一个区间的A，如果A[start] &lt; A[end]，那么该区间一定是有序的 解题思路假设一个轮转的排序数组arr，我们首先获取中间元素的值，arr[mid], mid = start + (end - start)/2.因为没有重复数组，那么就有两种情况。 arr[mid] &gt; arr[start], 那么最小值一定在右半区间，eg:{4,5,6,7,0,1,2} 中间数为7.7&gt;4,最小元素一定在{7,0,1,2} arr[mid] &lt; arr[start], 那么最小值一定在左半区间,eg:{7,0,1,2,3,4,5,6}中间数为2,2&lt;7，最小元素一定在{7,0,1,2} 处理重复元素，当arr[mid] == arr[start], 跳过start++. 边界值 输入数组arr == null, arr.length == 0 ,return 0 arr.length == 1, return arr[0] 输入数组arr为有序数组，return arr[start]; 复杂度时间复杂度为O(logn)，空间复杂度为O(N) 代码123456789101112131415161718192021222324public static int findMin(int[] arr)&#123; if(arr == null || arr.length == 0) return 0; if(arr.length == 1) return arr[0]; int start = 0; int end = arr.length -1; while (start &lt; end)&#123; if(arr[start] &lt; arr[end])&#123; return arr[start]; &#125; int min = start + (end - start)/2; It can avoid overflow. if(arr[start] &lt; arr[min])&#123; start = min; &#125;else if(arr[start] &lt; arr[min])&#123; end = min; &#125;else&#123; start++; //处理重复元素 &#125; &#125; return arr[start] &lt; arr[end] ? arr[start] : arr[end];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3Sum]]></title>
    <url>%2F3Sum.html</url>
    <content type="text"><![CDATA[题目链接：3SumGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets.123456For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 题目的两点要求： 每个答案组里面的三个数字是要从小到大排列起来的 每个答案不可以和其他的答案相同 题目分析： 每个答案数组triplet中的元素是要求升序排列的 不能包含重复的答案数组 解题思路： 因为要求每个答案数组中的元素都是升序排列的，所以开头我们要对数组进行排序 因为不能包含重复的答案数组，我们要在代码里做去重操作 归根结底是Two pointers的想法，定位其中两个指针，根据和的大小移动另外一个 复杂度分析因为要找三个元素，所以时间复杂度为O(n2)，空间复杂度为O(1) 代码12345678910111213141516171819202122232425public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(nums.length &lt; 3) return result; Arrays.sort(nums); int i = 0; while (i &lt; nums.length -2)&#123; if(nums[i] &gt; 0) return result; int j = i + 1; int k = nums.length - 1; while (j &lt; k)&#123; int sum = nums[i] + nums[j] + nums[k]; if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k])); if(sum &lt;= 0) while (nums[j] == nums[++j] &amp;&amp; j &lt; k); if(sum &gt;= 0) while (nums[k] == nums[--k] &amp;&amp; j &lt; k); &#125; while (nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2); &#125; return result;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20171117picture]]></title>
    <url>%2F20171117picture.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo优化参考]]></title>
    <url>%2F20171117hexo.html</url>
    <content type="text"><![CDATA[hexo的next主题个性化教程:打造炫酷网站 使用Hexo基于GitHub Pages搭建个人博客 为 hexo NexT 添加 Gitment 评论插件(Next 5.1.3已集成) hexo添加音乐、high一下及一些坑]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读 一本书]]></title>
    <url>%2F20171117read.html</url>
    <content type="text"><![CDATA[想做一个会阅读的人！阅读的目的可以从三方面理解：1.获取资讯，2.为了娱乐，3.增进阅读的理解力。会读书的人都是主动的阅读，为了提高阅读的理解力。 阅读的三个阶段： 基础阅读：掌握基础的字面上的意思 分析阅读：对书进行剖析，与作者深度沟通交流 主题阅读：同一主题书籍的相互对比，提炼。 分析阅读有：第一阶段：找出一本书在谈些什么的规则 了解这本书的种类和主题，并分类 能用简短的语句概括这本书的主要内容 按照书的特定顺序和重要内容，罗列书的大纲，并罗列重要部分的摘要 确定作者想要解决的问题 第二阶段：诊释一本书的内容规则 找出关键字，与作者达成共识 理解关键字所在的句子，明确主题 分析重要句字所在的重要段落，知道作者重要的论述是什么。 确定作者已经解决了哪些问题，还有哪些是没解决的。判断哪些是作者已知的未解决问题 第三阶段：像是沟通知识一样的评论一本书的规则 在了解整本书的大纲并能诠释这本书前，不能轻易批评 避免争强好胜盲目反对 批评之前要证明自己分清了知识与个人观点的不同常见评判标准 作者知识不足 作者知识错误 作者逻辑错误 作者分析不全 把书本内容变成自己的知识和能力（实用性阅读指南）大严峻之认为：一本书的重要内容只占整本书的20%，这20%最重要的又仅有4%。 带着目标主动阅读，找重点 想想你希望通过这本书获得什么 用二八法则关注书中20%最重要的知识做好读书笔记，尤其是思维导图 笔记不是做单纯的摘录，而是提炼书本内容，并形成自己的理解，通过笔记完成信息到知识的转换，实现输出 将我们头脑中正在思考的内容，以可视化的图形呈现出来的思考工具 付诸行动，将学到的知识转化为能力 设立具体的、可达到的行动目标 思考现状和目标的差距 将目标进一步具体化，细化到每一天之行，确定行动的优先顺序 如何在三年内有效地打造自己的专业能力(高效能阅读)下定决心锁定一个主题 请下定决心，锁定一个主题。只有骨气勇气锁定一个主题，就能形成思考的轴。有了这个轴，所有的信息都会随之而来。 读书要 先专后博 ，深入思考一件事的时候，是不得不同时思考其他很多事。这是因为，人的生活本来就是综合性、整体性的。 把读书的七成投资在垂直型阅读上投资基础 “70:20:10模式”，读书要7成投资在垂直型阅读，2成阅读支持现有业务或新业务的书，1成是阅读未知领域。 观察业务能力强的前辈的书架观察或让前辈推荐他们认为好的书 对业界关键人物进行定点观测常常了解最新业界消息 未完待续~~~]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Merge Sorted Array]]></title>
    <url>%2F20171116.html</url>
    <content type="text"><![CDATA[题目链接:Merge Sorted ArrayGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.由题意得：1.A和B两个数组都是有序的数组，大小分别为m和n2.合并两数组在A数组中，A数组容量足够大。思路分析：如果暴力解法即(无脑解法)，遍历A数组和B数组每个元素比较，若A[i] &lt; B[j]，则继续比较下一个B元素，否则将A数组i及之后的元素往后移动以为。这种解法想想就不可能。换一种思路两数组都反向递减遍历。两数组总长度index = m+n-1, 遍历若A[i] &lt; B[j]，则A[index] = A[j] j–,否则A[index] = B[i] i–,index–。代码如下：12345678910111213141516171819202122public static int[] megerArray(int[] A, int m, int[] B, int n)&#123; int aCount = m-1, bCount = n-1, index = m+n-1; while (index &gt;= 0)&#123; if(aCount&gt;=0 &amp;&amp; bCount&gt;=0)&#123; if(A[aCount] &gt; B[bCount])&#123; A[index] = A[aCount]; aCount--; &#125;else &#123; A[index] = A[bCount]; bCount--; &#125; &#125;else if(aCount &gt;= 0)&#123; A[index] = A[aCount]; aCount--; &#125;else if(bCount &gt;=0)&#123; A[index] = A[bCount]; bCount--; &#125; index--; &#125; return A;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pascal's Triangle II]]></title>
    <url>%2FPascal-s-Triangle-II.html</url>
    <content type="text"><![CDATA[题目链接: Pascal’s Triangle IIGiven an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. Note:Could you optimize your algorithm to use only O(k) extra space? 这道题跟Pascal’s Triangle很类似，只是这里只需要求出某一行的结果。Pascal’s Triangle中因为是求出全部结果，所以我们需要上一行的数据就很自然的可以去取。而这里我们只需要一行数据，就得考虑一下是不是能只用一行的空间来存储结果而不需要额外的来存储上一行呢？这里确实是可以实现的。对于每一行我们知道如果从前往后扫，第i个元素的值等于上一行的list[i]+list[i-1]，可以看到数据是往前看的，如果我们只用一行空间，那么需要的数据就会被覆盖掉。所以这里采取的方法是从后往前扫，这样每次需要的数据就是list[i]+list[i-1]，我们需要的数据不会被覆盖，因为需要的res[i]只在当前步用，下一步就不需要了。这个技巧在动态规划省空间时也经常使用，主要就是看我们需要的数据是原来的数据还是新的数据来决定我们遍历的方向。时间复杂度还是O(n^2)，而空间这里是O(k)来存储结果，仍然不需要额外空间。代码如下：12345678910111213public static List&lt;Integer&gt; getRow(int row)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(row&lt;0) return list; list.add(1); for (int line = 1; line &lt; row; line++)&#123; for (int index = list.size() - 1; index &gt; 0; index --)&#123; list.set(index, list.get(index-1)+list.get(index)); &#125; list.add(1); &#125; return list;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adroid studio常用技巧]]></title>
    <url>%2FAdroid-studio%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7.html</url>
    <content type="text"><![CDATA[Android studio 是Google官方定制的Android开发工具，俗话说工欲善其事必先利其器，充分利用开发工具不仅能大大提高工作效率，同时也是个人能力的一种体现。在此提供关键字和官方文档方便查阅和记忆 1.Android 国际化多语言实现Translations Editor 翻译编辑preview中导航栏Language，设置及时显示语言Localize the UI with Translations Editor 2.最小化用户遇到“打开方式”对话框的概率Android App LinksAdd Android App Links 3.使用 Lint 改进代码手动运行检查或从命令行运行 Lint使用 Lint 改进您的代码 4.使用注解改进代码检查support-annotations依赖使用注解改进代码检查]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>Adroid studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pascal's Triangle]]></title>
    <url>%2FPascal-s-Triangle.html</url>
    <content type="text"><![CDATA[题目链接:Pascal’s Triangle Given numRows, generate the first numRows of Pascal’s triangle.For example, given numRows = 5,Return1234567[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 这道题比较简单，属于基础的数组操作。知道规律就好做了，它的规律如下：1.每行的元素个数等于行数2.每行的第一个元素和最后一个元素等于13.第三行起，每行除第一个和最后一个元素外之间的元素第i行第k个元素 = 行数i-1行第k个元素 + 行数i-1行第k-1元素4.隐藏条件：当行数i和元素j的下表相等时 ，i行的第j个元素等于1具体代码如下： //方法一 public static List&lt;List&lt;Integer&gt;&gt; generate(int numRows){ List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;&gt;(); if(numRows &lt;= 0){ return triangle; } for (int i = 0; i &lt; numRows; i++) { List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; i+1; j++) { if(j ==0 || j == i){ row.add(1); }else { row.add(triangle.get(i-1).get(j-1) + triangle.get(i-1).get(j)); } } triangle.add(row); } return triangle; } //方法二 public static int[][] pascal(int rowNums){ if(rowNums&lt;=0) return new int[1][1]; int[][] arr = new int[rowNums][]; for (int i = 0; i &lt; rowNums; i++){ arr[i] = new int[i+1]; for (int j = 0; j &lt; i+1; j++){ if(j == 0 || j == i){ arr[i][j] = 1; }else { arr[i][j] = arr[i-1][j-1] + arr[i-1][j]; } } } return arr; } 算法时间复杂度应该是O(1+2+3+…+n)=n(n-1)/2=O(n^2)，空间上只需要二维数组来存储结果，不需要额外空间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plus One]]></title>
    <url>%2FPlus-One.html</url>
    <content type="text"><![CDATA[题目链接 Plus One Given a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list. 这道题很简单，就是考加法的进位运算问题对一个数组进行加一操作，具体思路： 维护一个进位，对每一位进行加一，然后判断进位，如果有继续到下一位，否则就可以返回了，因为前面不需要计算了。有一个小细节就是如果到了最高位进位仍然存在，那么我们必须重新new一个数组，然后把第一个为赋成1（因为只是加一操作，其余位一定是0，否则不会进最高位）。代码如下： 123456789101112131415public static int[] plusOne(int[] digit)&#123; int one = 1; int sum = 0; for(int i = digit.length -1 ; i &gt;= 0; i--)&#123; sum = digit[i] + one; digit[i] = sum % 10; //取余 one = sum / 10; //取整 if(one == 0)&#123; //无需进位，则返回即可 return digit; &#125; &#125; int[] res = new int[digit.length + 1]; //当最高位仍需进位则重新new一个数组 res[0] = 1; return res; &#125; 因为只需要一次扫描，所以算法复杂度是O(n)，n是数组的长度。而空间上，一般情况是O(1)，但是如果数是全9，那么是最坏情况，需要O(n)的额外空间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo，换电脑怎么更新博客]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Hexo%EF%BC%8C%E6%8D%A2%E7%94%B5%E8%84%91%E6%80%8E%E4%B9%88%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[hexo官方给了一些迁移的方法，不过它上面介绍的方法都是把博客文章从hexo系统迁移到其他博客系统的方法。然而我们这里要讨论的是： 当我们更换电脑的时候我们应该怎么办？所以默认你已经成功利用hexo和github发布博客，如果还没有，网上很多资料。具体的思路是：在生成的已经推到github上的hexo静态代码出建立一个分支，利用这个分支来管理自己hexo的源文件。如果能在刚刚配置hexo的时候就想好以后的迁移的问题就太好了，可以省掉很多麻烦，可实际使用中，刚刚配置hexo的时候，好多人都是初学，不会想到以后的问题，我就是这样的。 具体操作： 克隆gitHub上面生成的静态文件到本地 1git clone git@github.com:ZhengYangxin/zhengyangxin.github.io.git 把克隆到本地的文件除了git的文件都删掉，找不到git的文件的话就当删了吧。不要用hexo init初始化。 将之前使用hexo写博客时候的整个目录（所有文件）搬过来。把该忽略的文件忽略了 123456789.DS_StoreThumbs.dbdb.json*.logpublic/.deploy*/node_modules##注意忽略node_modules,这个文件换一台电脑都需要用npm install 重新生成 创建一个叫hexo的分支 1git checkout -b hexo 提交复制过来的文件并推送至hexo分支 123git add --allgit commit -m &quot;新建分支源文件&quot;git push --set-upstream origin hexo 到这里基本上就搞定了，以后再推就可以直接git push了，hexo的操作跟以前一样。今后无论什么时候想要在其他电脑上面用hexo写博客，就先装好node然后直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。 1git clone -b hexo git@github.com:ZhengYangxin/zhengyangxin.github.io.git 这样做完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。]]></content>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法面试准备]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.html</url>
    <content type="text"><![CDATA[一道排序体题需要考与面试官沟通的点 有没有可能包含大量的重复元素 是否近乎有序 数据取值范围是否有限 是否需要稳定排序 是否用链式存储 数据大小足够装载内存里 算法面试优秀不意味技术面试优秀 考虑项目经历和项目中遇到的实际问题 印象最深的bug 面向对象 设计模式 网络相关：安全相关、内存相关、并发相关 系统设计：scalability 技术面试优秀不意味着能够拿到Offer创建自己的项目 自己做小应用 自己解决小问题 “不是项目”的项目：书籍的整理 技术分享，blog、github 了解过去自身的思考行为方式 遇到最大的挑战 犯过的错误 遭遇的失败 最享受的工作内容 遇到冲突处理方式 做的最与众不同的事儿 准备好问面试官的问题 整个小组的大概运行模式是怎么样的 整个项目组的后续规划是如何 这个产品中某个问题的解决方案 为什么选择某些技术？标准？ 对某技术很感性局，是否有机会深入 算法面试没这么难 没必要啃完《算法导论》 高级数据结构和算法面试提及概率很低（红黑树、计算几何、B-Tree、数论、斐波那契堆、FFT） 准备范围关注基础算法和数据结构，非“有意思”的题目 各种排序算法 基础数据结构和算法实现：堆、二叉树、图… 基础数据结构使用：链表、栈、队列、哈希表、图、Trie… 基础算法：深度优先、广度优先、二分查找、递归… 基本算法思想：递归、分支、回溯搜索、贪心、动态规划… 解决算法问题的整体思路 注意题目中的条件 当没有思路时（测试用例，暴力解法——&gt;优化） 优化算法（算法思路、数据结构、空间换时间、预处理数据、瓶颈除找解决方案） 实际编写问题，极端条件的判断（数组为空、字符串为空、数据为NULL），代码规范（变量名、模块化、复用性）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git相关操作]]></title>
    <url>%2Fgit%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[一. git关联本地与远程分支12$ git branch --set-upstream-to=origin/dev2.2 masterBranch master set up to track remote branch dev2.2 from origin. 远程分支在前，本地分支在后。关联之后就可以正常的pull代码了。 二.查看所有分支（本地、远程）123456$ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/dev2.2 remotes/origin/master 三.当前关联的远程分支12$ git branch -vv* master beb7725 [origin/dev2.2: behind 1] 首页本地记录上次关闭之前的状态 四.git merge 和 git merge –no-ff根据这张图片可以看出Git merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。git merge 则不会显示 feature，只保留单条分支记录。 五.merge 与 rebase 的区别1.Git merge 会生成一个新得合并节点，而rebase不会比如：123 D---E test /A---B---C---F master 使用merge合并, 为分支合并自动识别出最佳的同源合并点： git merge master123 D--------E / \A---B---C---F----G test, master 操作会舍弃 master 分支上提取的 commit，同时不会像 merge 一样生成一个合并修改内容的 commit，相当于把 master 分支（当前所在分支）上的修改在 deve 分支（目标分支）上原样复制了一遍:git rebase test1A---B---D---E---C&apos;---F&apos; test, master 使用git pull时默认是merge， 加 –rebase参数使其使用rebase方式1git pull --rebase 2.rebase和merge的不同适用场景 rebase场景：如果修改了某个公用代码的BUG，这个时候就应该是把所有的OEM版本分支rebase到这个修复BUG的分支上来，在rebase过程中，Git会要你手动解决代码上的冲突，你需要做的就是把修复BUG的代码放到目标分支代码里面去。rebase的结果是：所有的分支依然存在 merge场景：因为成员的代码开发工作已经完成了，也不需要再保留这个分支了，所以我们可以把这个成员分支merge到主分支上，当然冲突在所难免，手工解决的工作肯定逃不掉，但是利大于弊不是吗。merge以后，分支就不存在了，但是在git的所有分支历史中还能看到身影。 一般我们把别的分支合并到master时用merge，而把master合并到别的分支时会用到rebase的原因，这是因为master分支一般commit会比较频繁。 所以每次下拉代码fetch之后用rebase的原因就是：本地commit之后，fetch远端代码，此时，远端代码可能会被若干人修改会有若干个commit，而本地就一个commit，然后git rebase的时候，是默认rebase 远端代码，此时会将本地commit应用到远端代码，也就只需要解决一次冲突，并且rebase之后没有新的commit，很友好。但是，如果使用merge，则会产生新的commit。 六.网上推荐的工作流一般是用fetch+rebase (相比pull+merge工作流更干净，不容易出错)比如dev是你的公共开发分支* git checkout dev # 本地切到公共分支 git pull # 将本地的dev更新 git checkout -b bug_101026 # 新建一个主题分支（一个bug，一个功能什么的）… # 改动.. commit.. 测试… git fetch origin # 更新upstream git rebase origin/dev # 将你的commits移到的末尾 git checkout dev # 切换到公共分支 git pull # 更新公共分支 git rebase bug_101026 # 将你的主题分支加到公共分支的末尾 git push # 推送]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中方法调用参数传递的方式是传值，有且只有传值]]></title>
    <url>%2FJava%E4%B8%AD%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BC%A0%E5%80%BC%EF%BC%8C%E6%9C%89%E4%B8%94%E5%8F%AA%E6%9C%89%E4%BC%A0%E5%80%BC.html</url>
    <content type="text"><![CDATA[Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does Java pass by refrence or pass by value）基本数据类型与引用数据类型 8种基本数据类型 引用数据类型：类、接口类型、数组类型、枚举类型、注解类型。 区别： 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 例如，有一个类Person,有属性name,age,带有参的构造方法， Person p = new Person(“zhangsan”,20); 在内存中的具体创建过程是： 1.首先在栈内存中位其p分配一块空间; 2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值””，0； 3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作； 4.调用构造方法，为两个属性赋值为”Tom”,20；（注意这个时候p与Person对象之间还没有建立联系）； 5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。 相关知识：静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在整个程序的生命周期内都存在，由编译器在编译的时候分配。 堆区： 一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错 栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限 文字常量区： 常量字符串就是放在这里的。 程序结束后由系统释放。 程序代码区：存放函数体的二进制代码。 在Java中，所有的对象变量都是引用，Java通过引用来管理对象。然而在给方法传参时，Java并没有使用传引用的方式，而是采用了传值的方式。例如下面的badSwap()方法：123456public void badSwap(int var1, int var2) &#123; int temp = var1; var1 = var2; var2 = temp; &#125; 当badSwap方法结束时，原有的var1和var2的值并不会发生变化。即使我们用其它Object类型来替代int，也不会有变化，因为Java在传递引用时也是采用传值的方式。（译者注：这里是关键，全文的核心是：1. Java中对象变量是引用 2. Java中方法是传值的 3. 传方法中参数时，传递的是引用的值）代码： 12345678910111213141516171819public void tricky(Point arg1, Point arg2) &#123; arg1.x = 100; arg1.y = 100; Point temp = arg1; arg1 = arg2; arg2 = temp; &#125; public static void main(String [] args) &#123; Point pnt1 = new Point(0,0); Point pnt2 = new Point(0,0); System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y: &quot; +pnt1.y); System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y); System.out.println(&quot; &quot;); tricky(pnt1,pnt2); System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y:&quot; + pnt1.y); System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y); &#125; 执行main()的输出如下： 1234X: 0 Y: 0 X: 0 Y: 0 X: 100 Y: 100 X: 0 Y: 0 这个方法成功地改变了pnt1的值，但pnt1和pnt2的交换却失败了！这是Java参数传递机制里最让人迷惑的地方。在main()中，pnt1和pnt2是Point对象的引用，当将pnt1和pnt2传递给tricky()时，Java使用的正是传值的方式，将这两个引用的传给了 arg1和arg2。也就是说arg1和arg2正是pnt1和pnt2的复制，他们所指向的对象是相同的。详情可见下面的图示： 在作为参数传递后，对象至少有两个引用指向自己在main()中，引用被复制并以传值的方式进行传递，对象本身并不会被传递。因此，tricky()方法中pnt1所指向的对象发生了变化。因为传递的是引用的复制，因此引用的交换既不能引起对象的交换，更不会使原始引用发生变化。如图2所示，tricky()交换了arg1与arg2，但不会影响pnt1和pnt2。因此若想交换原始引用pnt1和pnt2，那么不能通过调用方法的方式来实现。在作为参数传递后，对象至少有两个引用指向自己 总结： Java中对象变量是引用 Java中方法是传值的 传方法中参数时，传递的是引用的值]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try catch finally的执行顺序及数据处理情况]]></title>
    <url>%2Ftry-catch-finally%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%83%85%E5%86%B5.html</url>
    <content type="text"><![CDATA[结论 不管有木有出现异常，finally块中的代码都会执行 当try或catch中有return时，finally仍然会执行 当try或catch中有return时,finally是在return前执行的（此时并没有返回运算后的结果，而是先把运算结果保存起来，而后再去执行finally，此如果finally若有rentrn，则程序结束，若无则操作后跳回try或catch继续执行） finally中最好不要包含return，否则程序会提前推出，返回值不是catch或catch的值 注意 例1 12try&#123;&#125; catch()&#123;&#125;finally&#123;&#125; return;显然程序按顺序执行。 例2 1234try&#123; return; &#125;catch()&#123;&#125; finally&#123;&#125; return;程序执行try块中return之前（包括return语句中的表达式运算）代码；再执行finally块，最后执行try中return;finally块之后的语句return，因为程序在try中已经return所以不再执行。 例3 12345try&#123; &#125; catch()&#123;return;&#125; finally&#123;&#125; return;程序先执行try，如果遇到异常执行catch块，有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，最后执行catch块中return. finally之后也就是4处的代码不再执行。无异常：执行完try再finally再return. 例4 123try&#123; return; &#125;catch()&#123;&#125; finally&#123;return;&#125;程序执行try块中return之前（包括return语句中的表达式运算）代码；再执行finally块，因为finally块中有return所以提前退出。 例5 123try&#123;&#125; catch()&#123;return;&#125;finally&#123;return;&#125;程序执行catch块中return之前（包括return语句中的表达式运算）代码；再执行finally块，因为finally块中有return所以提前退出。 例6 12345try&#123; return;&#125;catch()&#123;return;&#125; finally&#123;return;&#125;程序执行try块中return之前（包括return语句中的表达式运算）代码；有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；则再执行finally块，因为finally块中有return所以提前退出。无异常：则再执行finally块，因为finally块中有return所以提前退出。 finally块中改变返回值的特殊情况这里涉及到java的引用传递和值传递，首先要明白java全部都是传值的。对于基本数据类型的值是存在栈中的，它是将数据完完整整的拷贝，生成一个新的变量值；对于引用类型的数据既对象它的数据存在于堆中，栈中保存的是指向数据的引用地址，它是将对象的引用地址值拷贝了，所以修改了对象内容，但地址值是不变的。测试代码code11234567891011121314151617181920public class FinallyTest &#123; public static void main(String[] args) &#123; System.out.println(new FinallyTest().test());; &#125; static int test() &#123; int x = 1; try &#123; x++; return x; &#125; finally &#123; ++x; &#125; &#125;&#125; 输出2测试代码code2 12345678910111213141516171819202122232425262728293031public class FinallyTest2 &#123; public static void Main(string[] args) &#123; /*测试test1*/ List&lt;string&gt;relist=test1(); foreach (var item in relist) &#123; Console.WriteLine(item); &#125; Console.ReadLine(); &#125; private static List&lt;string&gt; test1() &#123; List&lt;string&gt; strlist = new List&lt;string&gt;(); strlist.Add(&quot;zs&quot;); strlist.Add(&quot;ls&quot;); strlist.Add(&quot;ww&quot;); strlist.Add(&quot;mz&quot;); try &#123; strlist.Add(&quot;wq&quot;); return strlist; &#125; finally &#123; strlist.Add(&quot;yyy&quot;); &#125; &#125; &#125; 测试输出结果：zslswwmzwqyyy 所以可得如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况： 1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。 2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。 最终结论：任何执行try或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试基础（一）]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[基础数据类型基本数据类型分为原始类型和包装类型，Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型(wrapper class)，int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 8种原始类型 容量 对应包装类型 byte(字节) 8 位 Byte shot(短整型) 16位 Short int(整型) 32 位 Integer long(长整型) 64 位 Long float(浮点型) 32 位 Float double(双精度) 64 位 Double char(字符型) 16 位 Character boolean(布尔型) 1 位 Boolean 注意几点： 1、各数据类型按容量大小（表数范围大小）由小到大排列为： byte &lt;—— short, char &lt;——int &lt;——long &lt;——float &lt;——double 2、基本类型之间的转换原则： 1）运算时，容量小的类型自动转换为容量大的类型； 2）容量大的类型转换为容量小的类型时，要加强制转换符，且精度可能丢失； 12345678910111213141516如：float f = 1.2f;int ff = (int) f;System.out.println(ff); 1``` 3）short，char之间不会互相转换（需要强制转换），byte、short、char并且三者在计算时首先转换为int类型；4）实数常量默认为double类型， 整数常量默认为int类型；**3、包装类及String类都是定定义为public final class的，因此这几个都不能被继承； ****4、原始类型是可以通过==直接判断是否相等的，而包装类型是类，通过==判断值是否相等是不对的，必须通过equals()函数****下面的程序中，temp的最终值是什么？ ** long temp=(int)3.9; 3 temp%=2; 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556A .0B .1C .2D .3E .4**short s1 = 1; s1 = s1 + 1;有什么错（错误）? short s1 = 1; s1 += 1;有什么错（正确）?****下面哪个不是JAVA关键字 **A integerB doubleC floatD default###2.1.2 历年考题**下面哪些不是java的简单数据类型?** ACA. short B. Boolean C. Double D. float**0.6332的数据类型是（）** AA float B double C Float D Double**float f=3.4;是否正确?** 错**下面哪些类可以被继承**下面哪些类可以被继承？ ABDEJava.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoaderA、Thread B、Number C、Double D、Math E、ClassLoader**String 是最基本的数据类型吗?**不是**int和Integer有什么区别?** 原始类型和封装类型，java5后自动拆箱和封箱机制**5、请写出下面程序的运行结果：** class AutoUnboxingTest { public static void main(String[] args) { Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 System.out.println(b == c); // true b自动装箱然后自动拆箱成int类型再和c比较 } }1234567## 2.2 String、StringBuilder、StringBuffer### 2.2.1 String字符串常量，不可更改，因为其内部定义的是一个final类型的数组来保存值的，如下： private final char value[];123456789所以，当我们每次去“更改”String变量的值的时候（包括重新赋值或者使用String内部的一些方法），其实是重新新建了一个String对象（new String）来保存新的值，然后让我们的变量指向新的对象。因此，当我们需要频繁改变字符串的时候，使用String会带来较大的开销。定义String的方法有两种：（1）String str = &quot;abc&quot;;（2）String str2 = new String(&quot;def&quot;);第一种方式创建的String对象“abc”是存放在字符串常量池中，创建过程是，首先在字符串常量池中查找有没有&quot;abc&quot;对象，如果有则将str直接指向它，如果没有就在字符串常量池中创建出来“abc”，然后在将str指向它。当有另一个String变量被赋值为abc时，直接将字符串常量池中的地址给它。如下： String a = “abc”;String b = “abc”;System.out.println(a == b); //打印 true12也就是说通过第一种方式创建的字符串在字符串常量池中，是可共享的。同时，也是不可更改的，体现在： String a = “abc”;String b = “abc”;b = b + “def”;123此时，字符串常量池中存在了两个对象“abc”和“abcdef”。第二种创建方式其实分为两步： String s = “def”;String str2 = new String(s);123456789101112131415161718192021222324第一步就是上面的第一种情况；第二步在堆内存中new出一个String对象，将str2指向该堆内存地址，新new出的String对象内容，是在字符串常量池中找到的或创建出“def”对象，相当于此时存在两份“def”对象拷贝，一份存在字符串常量池中，一份被堆内存的String对象私有化管理着。所以使用String str2 = new String(&quot;def&quot;);这种方式创建对象，实际上创建了两个对象。###2.2.2 StringBuffer(JDK 1.0) 和StringBuilder(JDK1.5)StringBuffer和StringBuilder在功能上基本完全相同，它们都继承自AbstractStringBuilder，使用方法也都一样;可以对StringBuffer和StringBuilder对象进行改变，每次改变还是再原来的对象上发生的，不会重新new出新的StringBuffer或StringBuilder对象来。所以，当我们需要频繁修改字符串内容的时候，使用StringBuffer和StringBuilder是很好地选择。StringBuffer和StringBuilder的最主要区别就是线程安全方面，由于在StringBuffer内大部分方法都添加了synchronized同步，所以StringBuffer是线程安全的，而StringBuilder不是线程安全的。因此，当我们处于多线程的环境下时，我们需要使用StringBuffer，如果我们的程序是线程安全的使用StringBuilder在性能上就会更优一点。历年面试题：**String与StringBuffer的区别：**## 2.3 关键字### 2.3.1 switch**1、switch中的参数类型**在jdk1.7 之前switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。在jdk1.7 及1.7以后，switch也支持了String类型，如下： String str = “abc”;switch (str) {case “abc”: System.out.println(“—–abc—–”); break;case “aaa”: System.out.println(“—–aaa—–”); break;}12枚举类型 enum ColorEnum { RED, GREEN, BLUE} public static void main(String[] args) { ColorEnum color = ColorEnum.BLUE; switch (color) { case RED: System.out.println(“红色”); break; case GREEN: System.out.println(“绿色”); break; case BLUE: System.out.println(“蓝色”); break; }}123456789101112131415161718**历年试题：****swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?**### 2.3.2 break,continue,gotobreak的作用是跳出当前循环块（for、while、do while）或程序块（switch）。在循环块中的作用是跳出当前正在循环的循环体。在程序块中的作用是中断和下一个case条件的比较。 continue用于结束循环体中其后语句的执行，并跳回循环程序块的开头执行下一次循环，而不是离开循环体。goto:goto是java中的保留字，现在没有在java中使用。 **break,continue与标签**“标签”是后面跟一个冒号的标识符，就象下面这样：```label1: 对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方——在标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环或者一个开关。这是由于 break 和 continue 关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。如下所示： 12345678910111213label1:外部循环&#123; 内部循环 &#123; //... break; //1 //... continue; //2 //... continue label1; //3 //... break label1; //4 &#125;&#125; 在条件 1 中，break 中断内部循环，并在外部循环结束。 在条件 2 中，continue 移回内部循环的起始处。 在条件 3 中，continue label1 却同时中断内部循环以及外部循环，并移至 label1 处。随后，它实际是继续循环，但却从外部循环开始。 在条件 4 中，break label1 也会中断所有循环，并回到 label1 处，但并不重新进入循环。也就是说，它实际是完全中止了两个循环。 示例： 123456789101112public static void main(String[] args) &#123; outerCycle: for(int i = 0; i &lt; 10; i++)&#123; for(int j = 0; j &lt; 10; j++)&#123; if(j == 5)&#123; continue outerCycle; &#125; System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;) &quot;); &#125; System.out.println(); &#125;&#125; 给外层循起始处加了标签（也就是说给外层循环起了个名字）“outerCycle”，在内层循环使用“continue outerCycle”时，就相当于在outerCycle这个循环中直接使用continue语句。 (0,0) (0,1) (0,2) (0,3) (0,4) (1,0) (1,1) (1,2) (1,3) (1,4) (2,0) (2,1) (2,2) (2,3) (2,4) (3,0) (3,1) (3,2) (3,3) (3,4) (4,0) (4,1) (4,2) (4,3) (4,4) (5,0) (5,1) (5,2) (5,3) (5,4) (6,0) (6,1) (6,2) (6,3) (6,4) (7,0) (7,1) (7,2) (7,3) (7,4) (8,0) (8,1) (8,2) (8,3) (8,4) (9,0) (9,1) (9,2) (9,3) (9,4) 123456789101112public static void main(String[] args) &#123; outerCycle: for(int i = 0; i &lt; 10; i++)&#123; for(int j = 0; j &lt; 10; j++)&#123; if(j == 5)&#123; break outerCycle; &#125; System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;) &quot;); &#125; System.out.println(); &#125;&#125; 运行结果 (0,0) (0,1) (0,2) (0,3) (0,4) 历年试题： 请写出下面程序的运行结果 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) &#123; int i = 0; outer: // 第一个标签 for (; true; ) &#123; inner: //第二个标签 for (; i &lt; 10; i++) &#123; prt(&quot;i = &quot; + i); if (i == 2) &#123; prt(&quot;continue&quot;); continue; &#125; if (i == 3) &#123; prt(&quot;break&quot;); i++; // 注意 break; &#125; if (i == 7) &#123; prt(&quot;continue outer&quot;); i++; //注意 continue outer; &#125; if (i == 8) &#123; prt(&quot;break outer&quot;); break outer; &#125; for (int k = 0; k &lt; 5; k++) &#123; if (k == 3) &#123; prt(&quot;continue inner&quot;); continue inner; &#125; &#125; &#125; &#125;&#125;static void prt(String s) &#123; System.out.println(s);&#125; 下面是输出结果：i = 0continue inneri = 1continue inneri = 2continuei = 3breaki = 4continue inneri = 5continue inneri = 6continue inneri = 7continue outeri = 8break outer 需要匹配后通过break关键字跳出程序块，不然继续向下执行 下面的方法，当输入为2的时候返回值是多少?（） 123456789101112public static int getValue(int i) &#123; int result = 0; switch (i) &#123; case 1: result = result + i; case 2: result = result + i * 2; case 3: result = result + i * 3; &#125; return result;&#125; A0 B2 C4 D10 break语句的描述中，正确的是( ) A、只中断最内层的循环 B、只中断最外层的循环 C、借助于标号，可以实现任何外层循环中断 D、只中断某一层的循环 ##2.4 值传递和引用传递 首先要说明的是java中是没有指针的，java中只存在值传递，只存在值传递！！！ 然而我们经常看到对于对象（数组，类，接口）的传递似乎有点像引用传递，可以改变对象中某个属性的值。但是不要被这个假象所蒙蔽，实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以还是按值传递。 需要注意的是当传递的是数组名或对象实例的话，其实传递的都是地址拷贝 1234567891011public class Test3 &#123; public static void change(int a)&#123; a=50; &#125; public static void main(String[] args) &#123; int a=10; System.out.println(a); //10 change(a); System.out.println(a); //10 &#125;&#125; 1234567891011public class Test3 &#123; public static void change(int []a)&#123; a[0]=50; &#125; public static void main(String[] args) &#123; int []a=&#123;10,20&#125;; System.out.println(a[0]); //10 change(a); System.out.println(a[0]); //50 &#125;&#125; 1234567891011121314151617181920class Emp &#123; public int age;&#125;public class Test &#123; public static void change(Emp emp) &#123; emp.age = 50; emp = new Emp();//再创建一个对象 emp.age=1000; &#125; public static void main(String[] args) &#123; Emp emp = new Emp(); emp.age = 100; System.out.println(emp.age); //100 change(emp); System.out.println(emp.age); //50 System.out.println(emp.age); //50 &#125;&#125; 历史考题 指出下列程序运行的结果 （） 1234567891011121314151617181920212223242526public class Example &#123; String str = new String(&quot;good&quot;); char[] ch = &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos; &#125;; public static void main(String args[]) &#123; Example ex = new Example(); ex.change(ex.str, ex.ch); System.out.print(ex.str + &quot; and &quot;); //good and gbc System.out.print(ex.ch); &#125; public void change(String str, char ch[]) &#123; str = &quot;test ok&quot;; ch[0] = &apos;g&apos;; &#125;&#125; A、 good and abc B、 good and gbc C、 test ok and abc D、 test ok and gbc ##2.5 数组 声明数组的两种方式： int a[];int []a; 通过上边的定义，我们只是得到了一个数组的引用。这时已经为引用分配了存储空间，但是还没有给数组对象本身分配任何空间。想要给数组对象分配存储空间，必须使用初始化表达式。 初始化数组的方式： int a[] = new int[8]; //分配空间，赋值默认值int a[] = {0,1,2,3};int a[] = new int[]{0,1,2,3}; 默认初始化 如果我们利用int a[] = new int[6]，为数组元素分配了空间，但没有初始化，Java会为他们分配默认值。如下表所示： 基本类型 默认值boolean falsechar ‘/u0000’(null)byte (byte)0short (short)0int 0long 0Lfloat 0.0fdouble 0.0d 7.下面哪些语句能够正确地生成5个空字符串？ A.String a[]=new String[5]；for(int i=0;i&lt;5;a[i++]=””); B.String a[]={“”，””，””，””，””}； C.String a[5]； D.String[5] a； E.String []a=new String[5];for(int i=0;i&lt;5;a[i++]=null); 5.下面哪个语句正确地声明一个整型的二维数组？ A. int a[][] = new int[][]； B. int a[10][10] = new int[][]； C. int a[][] = new int[10][10]； D. int [][]a = new int[10][10]； E. int []a[] = new int[10][10]； 27.哪个语句创建了一个数组实例？ A. int[] ia = new int [15]; B. float fa = new float [20]; C. char[] ca = “Some String”; D. int ia [][] = {4, 5, 6} {1, 2, 3}; 数组有没有length()这个方法? String有没有length()这个方法？没有，有 请问下面程序在初始化后，a[0]和b[0]的值是多少？ String []a = new String[10]; //nullint []b = new int[10]; //0 下面程序的运行结果是： 1234int index=1; int foo[]=new int[3]; int bar=foo[index]; int baz=bar+index; A. baz has a value of 0B. baz has value of 1C. baz has value of 2D. an exception is thrownE. the code will not compile 下面代码的运行结果为：（） 1234567891011121314import java.io.*;import java.util.*;public class foo&#123; public static void main (String[] args)&#123; String s; System.out.println(&quot;s=&quot; + s); &#125;&#125; A 代码得到编译，并输出“s=” B 代码得到编译，并输出“s=null” C 由于String s没有初始化，代码不能编译通过 D 代码得到编译，但捕获到 NullPointException异常 ##2.6 构造函数相关 1、如果一个类中没有写任何的构造方法，JVM会生成一个默认的无参构造方法。 2、如果一个基类中写了有参构造函数，没有定义无参构造函数，基类是不会默认生成无参构造函数的。而且子类的构造函数中，如果没有显示通过super.调用基类构造函数，那么默认是调用父类的无参构造方法（即默认为super()，一般这句话省略了）。 下面哪三个描述是正确的？ B、C、E A. 默认构造器初始化方法变量 B. 默认构造器有和它所在类相同的访问修饰词. C. 默认构造器调用其父类的无参构造器. D. 如果一个类没有无参构造器,编译器会它创建一个默认构造器. E. 只有当一个类没有任何构造器时，编译器会为它创建一个默认构造器 以下子类B的情形哪一个是可以通过编译的： 12345678910111213141516171819202122public class A &#123; public A(String s)&#123; &#125; &#125; public class B extends A &#123; String name = &quot;llyB&quot;; &#125; public class B extends A &#123; String name = &quot;llyB&quot;; public B(String s)&#123;&#125; &#125; public class B extends A &#123; String name = &quot;llyB&quot;; public B(String s)&#123; super(s); &#125; &#125; 能 所以，只要记住，在子类的构造方法中，只要里面没有显示的通过super去调用父类相应的构造方法，默认都是调用super()，即无参构造方法，因此要确保父类有相应的构造方法。 3、Java创建对象的几种方式： (1) 用new语句创建对象，这是最常见的创建对象的方法。(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。(3) 调用对象的clone()方法。(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。 (1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。 历年考题：不通过构造函数也能创建对象吗（A） A 是 B 否 下列说法正确的有（c） A． class中的constructor不可省略 B． constructor必须与class同名，但方法不能与class同名 C． constructor在一个对象被new时执行 D．一个class只能定义一个constructor 4、构造函数调用顺序 在Java中，子类的构造过程中必须调用其父类的构造函数，是因为有继承关系存在时，子类要把父类的内容继承下来。但如果父类有多个构造函数时，该如何选择调用呢？ 第一个规则：子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，那么编译器会帮我们加上一个默认的构造方法（就是没有参数的构造方法），但是如果你自己写了构造方法，那么编译器就不会给你添加了，所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是如果在子类构造方法中我们并没有显示的调用基类的构造方法，如：super(); 这样就会调用父类没有参数的构造方法。 第二个规则：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数，此时无参的构造函数就不会被调用。 总之，一句话：子类没有显示调用父类构造函数，不管子类构造函数是否带参数都默认调用父类无参的构造函数，若父类没有则编译出错。 历年考题：下面是People和Child类的定义和构造方法，每个构造方法都输出编号。在执行new Child(“mike”)的时候都有哪些构造方法被顺序调用？请选择输出结果 ( ) 123456789101112131415161718192021222324252627class People &#123; String name; public People() &#123; System.out.print(1); &#125; public People(String name) &#123; System.out.print(2); this.name = name; &#125;&#125;class Child extends People &#123; People father; public Child(String name) &#123; System.out.print(3); this.name = name; father = new People(name + &quot;:F&quot;); &#125; public Child() &#123; System.out.print(4); &#125; &#125; A312 B 32 C 432 D 132 5、override与Overloading Override（重写）: 在子类中定义与父类具有完全相同的名称和参数的方法，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，是子类与父类之间多态性的一种体现。特点如下： （1）子类方法的访问权限只能比父类的更大，不能更小（可以相同）； （2）如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法； Overload（重载）: 同一个类中可以有多个名称相同的方法，但方法的参数个数和参数类型或者参数顺序不同； 关于重载函数返回类型能否不一样，需分情况：（1）如果几个Overloaded的方法的参数列表不一样（个数或类型），它们的返回者类型当然也可以不一样；（2）两个方法的参数列表完全一样，则不能通过让其返回类型的不同来实现重载。（3）不同的参数顺序也是可以实现重载的；（4）构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载。 2.7 静态代码块执行顺序执行顺序：1.静态代码块 –&gt; 2.普通代码块 –&gt; 3.构造方法 需要明白的是，1是类级别的，2和3是实例级别的，所以在父子类关系中，上述的执行顺序为： 父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法； 也就是上到下（父类到子类）先走完 类级别的（静态的）–&gt; 再依次走完父类的所有实例级别代码 –&gt; 再走子类所有实例级别代码 历史题目： 如下代码的输出结果： 123456789101112131415161718192021222324252627282930public class HelloB extends HelloA &#123; public HelloB() &#123; System.out.println(&quot;-----------HelloB 构造方法------------&quot;); &#125; &#123; System.out.println(&quot;I’m B class&quot;); &#125; static&#123; System.out.println(&quot;static B&quot;); &#125; public static void main(String[] args)&#123; new HelloB(); &#125;&#125;class HelloA&#123; public HelloA()&#123; System.out.println(&quot;-----------HelloA 构造方法------------&quot;); &#125; &#123; System.out.println(&quot;I’m A class&quot;); &#125; static&#123; System.out.println(&quot;static A&quot;); &#125;&#125; 输出结果：static Astatic BI’m A class———–HelloA 构造方法————I’m B class———–HelloB 构造方法———— 下面程序的运行结果是什么（） 1234567891011121314151617181920212223242526class HelloA &#123; public HelloA() &#123; System.out.println(&quot;HelloA&quot;); &#125; &#123; System.out.println(&quot;I&apos;m A class&quot;); &#125; static &#123; System.out.println(&quot;static A&quot;); &#125;&#125;public class HelloB extends HelloA &#123; public HelloB() &#123; System.out.println(&quot;HelloB&quot;); &#125; &#123; System.out.println(&quot;I&apos;m B class&quot;); &#125; static &#123; System.out.println(&quot;static B&quot;); &#125; public static void main(String[] args) &#123; new HelloB(); &#125;&#125; 答案： 123456static Astatic BI&apos;m A classHelloAI&apos;m B classHelloB 2.8 面向对象1、Java面向对象的基本思想之一是封装细节并且公开接口。Java语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为四种级别： （1）public： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问； （2）protected： 用protected修饰的类、类属变量及方法，包内的任何类及包外那些继承了该类的子类才能访问（此处稍后解释），protected重点突出继承； （3）default： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。default重点突出包； （4）private： 用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。 修饰符 当前类 同 包 子 类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 2、final修饰的类不能被继承，没有子类。 3、abstract修饰的类不能被实例化，必须被子类继承。类只要有一个抽象方法就必定是抽象类，但抽象类不一定要有抽象方法。声明方式必须是：void C();``` 不能带我实现体大括号。1234历史题目：**1、如下代码：** class A { A() { } } class B extends A { }123456789101112131415161718192021222324252627282930313233343536哪两个说明是正确的？ A. B类的构造器应该是 public.B. B类的构造器应该是没有参数C. B类的构造器应该调用this().D. B类的构造器应该调用super().**是否可以继承String类?**String类是final类故不可以继承。**以public修饰的类如：public class Car&#123;…&#125; 则Car( ) **A、可被其它程序包中的类使用 B、仅能被本程序包中的类使用C、不能被任意其它类使用 D、不能被其它类继承### 2.9 equals与==的区别**（1）==是一个运算符，它比较的是值** 对于基本数据类型，直接比较其数据值是否相等。如果是不同的基本数据类型之间进行比较，则遵循基本数据类型间运算的转换原则。如下： ``` if(12 == 12.0)&#123; System.out.println(&quot;-----12 == 12.0-------&quot;); &#125; ``` 此时打印了-----12 == 12.0-------，因为低一级的int类型的12自动转换为高一级的float类型对于引用类型，==比较的还是值，只不过此时比较的是两个对象变量的内存地址。所以，用==来比较对象，实际上是判断这两个对象是否是同一个new出来的对象，或者是否是一个对象赋值给另一个对象的情况。如： String s1 = new String(“abc”);String s2 = s1;//将s1对的内存地址赋给了s2，此时s1==s2返回true；1234**（2）equals**equals方法是属于Object类的一个方法，其实现源码如下： public boolean equals(Object obj) { return (this == obj);}12345可以看到，其实equals方法里面用的还是==运算符，所以对于那些没有重写过Object类的equals方法来说，==和equals方法是等价的！然而，很多类都自己去重写了equals方法，比如String类、所有基本数据类型的包装类等String类的equals源码如下： public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n– != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;}123456789101112首先判断是否是同一个new出来的对象，即判断内存地址是否相同；如果不同则判断对象中的内容是否相同。Integer类的equals方法如下：``` public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false; &#125; 直接转成判断值是否相等了。 因此，对于String类和所有基本数据类型的包装类来说，equals方法就是判断其内容是否相等。对于其他类来说，要具体看其是否重写了equals方法及具体业务实现。 另：对于基本数据类型来说，使用equals方法，需要用该基本类型对应的包装类，因为equals是针对对象来使用的！ 下面程序的运行结果是（） 123String str1 = &quot;hello&quot;;String str2 = &quot;he&quot; + new String(&quot;llo&quot;);System.err.println(str1 == str2); ##其它基础 &amp;和&amp;&amp;的区别 &amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。 下面的语句会产生什么样的输出? System.out.println(4&amp;7); A.4 B.5 C.6 D.7 E.0 5、try、catch、finally执行顺序问题 14. 如下代码： 123456789101112131415public class Foo &#123;public static void main(String[] args) &#123;try &#123;return;&#125; finally &#123;System.out.println( &quot;Finally&quot; );&#125;&#125;&#125; 输出结果是什么? A A. Finally B.编译失败 C. 代码正常运行但没有任何输出. D. 运行时抛出异常 下面函数将返回？ 123456789publicstaticintfunc ()&#123; try&#123; return 1; &#125;catch(Exception e)&#123; return 2; &#125;finally&#123; return 3; &#125;&#125; A、1 B、2 C、3 D、编译错误]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之线性表]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8.html</url>
    <content type="text"><![CDATA[什么是线性表线性表就是由n（n&gt;0）个数据元素a1,a2….组成的有限序列 数据元素的个数为n，表长度，当n=0时为空表 一个线性表为非空表，既n&gt;0，则可以简单记为（a1,a2….,an) 数据元素ai表示了各个元素，在不同场合含义不同逻辑结构特点 有且仅有一个开始结点a1,没有直接前驱结点,有且仅有一个后继结点a2 有且仅有一个终结点an,没有直接后继结点，有且仅有一个前驱结点an-1 其余内部结点ai（2&lt;=i&lt;=n-1）都有且仅有一个前驱结点和一个后继结点 同一个线性表，各个数据元素ai必须具有相同的数据类型 线性表的基本运算 初始化 计算表表长 获取结点 查找结点 插入结点 删除结点 顺序表 顺序表就是按照顺序存储方式存储的线性表，该线性表的结点按照逻辑次依次存放在计算机的一组连续的存储单元中 结点ai存储地址的LOC(ai)计算式：LOC(ai)=a1+(i-1)*c (0&lt;=i&lt;=n) 重点 插入结点：先判断结点数量是否已满，以及插入结点序号是否正确，满足，将顺序表的数据后移，同时插入节点，更新结点数量表长度 删除结点：先判断待删除结点序号是否正确，然后开始移动数据，并更新结点数量 顺序表缺点 在插入和删除节点的时候，往往需要移动大量的数据 如果表比较大，有时比较难分配足够的连续存储空间，往往导致内存分配失败，而无法存储 链表结构 链表结构是一种动态存储分配的结构形式，可以根据需要动态申请内存单元 链表中每个结点都包含如下两部分 数据部分，保存的是该节点的实际数据 地址部分，保存的是下一个节点的地址 采用引用来指示下一个数据的地址，因此在链表结构中，逻辑上相邻的结点在内存中并不一定相邻，逻辑上相邻关系通过地址部分的引用变量来实现。 链表结构分类 单链表 双链表:每个结点包含两个引用，一个指向下一个结点，一个指向上一个结点 单循环链表:在单链表中，将终端结点的引用域null改为指向表头结点或者开始结点 多重链的循环表：将表中结点链在多个环上 重点 追加结点 头引用head]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构（一）]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[什么是数据结构 数据结构是数据对象、存在于该对象的实例以及组成实例的数据元素之间的关系，并且这种关系可以通过定义相关的函数来给出 数据结构是抽象数据类型ADT的物理实现 一个数据结构是由数据元素依据某种逻辑联系起来的，对数据元素之间逻辑关系的描述称为数据的逻辑结构。由于数据必须在计算机内存储，数据的存储结构是其在计算机内的表示，既数据的实现形式 基本概念 数据（Data）：数据是信息的载体，其能够被计算机识别、存储和加工处理，是计算机程序加工的“原材料”。 数据元素：数据元素是数据的基本单位，其也称之为元素，结点、顶点、记录等。 数据项：一个元素可以由若干个数据项组成，数据项是具有独立含义的最小标识单位。数据项也可称之为字段、域、属性 数据结构：是指数据间的相互关系，也就是数据的组织形式。 ####数据结构的内容 数据的逻辑结构 数据的存储结构 数据的运算（检索、插入、删除、更新、排序等） 数据结构分类 按逻辑结构分类 线性结构 线性结构是非空集 线性结构有且仅有一个开始结点和一个终端结点 线性结构所有结点最多只有一个直接前驱结点和一个直接后继结点 线性表、栈、队列和串等 非线性结构 非线性结构是非空集 非线性结构的一个结点可能有多个直接前驱结点和多个直接后继结点 数组、广义表、树结构和图结构等 按存储结构分类 顺序存储结构 在一块连续的存储区域一个接着一个的存放数据 线性存储方式主要用于线性逻辑结构的数据存放 链式存储结构 不要求逻辑上相邻的结点物理位置上相邻，结点间的逻辑关系由附加的引用字段表示。一个结点的引用字段往往指向下一个结点的存放位置。 也称链式存储结构 索引存储结构 采用附加的索引表的方式来存储结点信息 散列存储方式 根据结点的关键字 直接计算出该结点的存储地址的一种存储方式 常用数据结构 数组数组是一种聚合数据类型，是将具有相同类型的若干变量有序的组织在一起的计集合。 栈栈是一种特殊的线性表，其只能在一个表的固定端进行数据节点的插入和删除操作。 队列队列和栈类似也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，在表的另一端进行删除操作。 链表链表是一种数据元素按照链式存储结构进行存储的数据结构。 树树是典型的非线性结构，其中包括了n个结点的有穷集合。 图图是另一种非线性结构 堆堆是一种特殊的树形结构，我们一般讨论的是堆都是二叉树。 散列表散列表源自于散列函数，结构中存在关键字和T相等的记录。]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是算法]]></title>
    <url>%2F%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[算法： 算法是模型分析的一组可行的、确定的和有穷的规则（广泛） 算法是解决实际问题的一种精确的描述方法 算法是对特定问题的求解步骤的一种精确描述方法 算法的特性 有穷性：算法的指令或者执行步骤是有限的 确切的：算法的每一个指令和步骤都必须有明确的定义和描述 输入：一个算法应该有的输入条件，用于初始化 输出：一个算法应该有个名明确的结果输出 可行性：执行步骤的可行，且有可以在有限时间内完成 算法分类 按照应用来分类 基础算法、数据结构、几何、加密、查询、排序等等 按照确定性来分类 确定性算法：有限时间内完成，结果唯一 非确定性算法：有限时间内完成，结果往往不唯一 按照算法思路 递推、递归、穷举、贪婪、分治、动态规划、迭代等算法 算法概念 数据结构+算法+程序设计语言 = 程序 数据结构表示处理对象，算法是计算和处理的核心方法，程序设计语言是算法的实现方法。这几者综合便构成了一个程序 算法的表示 自然语言表示 流程图 N-S图 伪代码表示 算法性能评价 时间复杂度：算法执行所消耗的时间，时间越短，性能越好,算法越好。 与每条语句执行的数量有关 与问题的规模有关 空间复杂度：算法执行所消耗的存储空间，消耗越小，算法越好。 程序保存所需要的存储空间，程序的大小 程序执行过程中所需消耗的存储空间（变量等） 算法实例一个班级学生档案集中查找某一个学生的档案伪代码12345678910变量 x = 输入需要查找的数据变量 arr = 随机生产数组数据for 1到20&#123; if(arr[i] ==)&#123; 找到数据 break; &#125;&#125;输出该数据的位置程序结束 Code1234567891011121314151617181920212223242526272829303132public Class Test1&#123; static int N = 20; public static void main(String args[])&#123; int arr[] = new int[N]; int x; int pos = -1; Random r= new Random(); for(int i=0; i&lt;N; i++)&#123; arr[i] = r.nextInt(100); &#125; System.out.println(&quot;生成随机数序列&quot;) for(int i=0; i&lt;N; i++)&#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.print(&quot;输入要查找的整数&quot;); Scanner input = new Scanner(System.in); x = input.getInt(); for(int i=0; i&lt;N; i++)&#123; if(arr[i] == x)&#123; pos = i; break; &#125; &#125; if(f&lt;0)&#123; System.out.print(&quot;未找到数据&quot;); &#125;else&#123; System.out.print(x+&quot;数据位于&quot;+pos+&quot;位置，是数组的第&quot;+(pos+1)+&quot;个元素&quot;); &#125; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三方登录的注意与坑]]></title>
    <url>%2F%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%B8%8E%E5%9D%91.html</url>
    <content type="text"><![CDATA[三方登录实多平台快捷方现方式Mob平台 集成开发 三方登录和分享ShareSdk.xml 配置AndroidManifest.xml 配置 注意点 微信平台 包名千万不要写错 数字签名 是MD5 非 SHA1(大部分平台都是SHA1) 测试签名和发行签名区分或统一。 QQ 平台 添加测试账号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据传输加密——非对称加密算法RSA+对称算法AES]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8A%A0%E5%AF%86%E2%80%94%E2%80%94%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95RSA-%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95AES.html</url>
    <content type="text"><![CDATA[数据传输加密&emsp;&emsp;在开发应用过程中，客户端与服务端经常需要进行数据传输，涉及到重要隐私信息时，开发者自然会想到对其进行加密，即使传输过程中被“有心人”截取，也不会将信息泄露。对于加密算法，相信不少开发者也有所耳闻，比如MD5加密，Base64加密，DES加密，AES加密，RSA加密等等。在这里我主要向大家介绍一下我在开发过程中使用到的加密算法，RSA加密算法+AES加密算法。简单地介绍一下这两种算法吧。 RSA&emsp;&emsp;之所以叫RSA算法，是因为算法的三位发明者RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准，主要的算法原理就不多加介绍，如果对此感兴趣的话，建议去百度一下RSA算法。需要了解的是RSA算法属于非对称加密算法，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。简单的说是“公钥加密，私钥解密；私钥加密，公钥解密”。 AES &emsp;&emsp;高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 为什么要结合使用这两种算法&emsp;&emsp;如果不清楚非对称算法和对称算法，也许你会问，为什么要结合使用这两种算法，单纯使用一种算法不行吗？这就要结合不同的场景和需求了。 &emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密的情况&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密，例如绑定银行卡的时候，需要传递用户的银行卡号，手机号等重要信息，客户端这边就需要对这些重要信息进行加密，使用RSA公钥加密，服务端使用RSA解密，然后返回一些普通信息，比如状态码code,提示信息msg,提示操作是成功还是失败。这种场景下，仅仅使用RSA加密是可以的。 &emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密的情况&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密,例如客户端登录的时候，传递用户名和密码等资料，需要进行加密，服务端验证登录信息后，返回令牌token需要进行加密，客户端解密后保存。此时就需要结合这两种算法了。至于整个流程是怎样的，在下面会慢慢通过例子向你介绍，因为如果一开始就这么多文字类的操作，可能会让读者感到一头雾水。 使用RSA加密和解密产生公钥和私钥：产生RSA公钥和密钥的方法有很多，在这里我直接使用我封装好的方法产生，都最后我会将两个算法的工具类赠送给大家。 12345678910111213141516171819202122232425262728/** * 生成公钥和私钥 * * @throws Exception * */public static void getKeys() throws Exception &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;); keyPairGen.initialize(1024); KeyPair keyPair = keyPairGen.generateKeyPair(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); String publicKeyStr = getPublicKeyStr(publicKey); String privateKeyStr = getPrivateKeyStr(privateKey); System.out.println(&quot;公钥\r\n&quot; + publicKeyStr); System.out.println(&quot;私钥\r\n&quot; + privateKeyStr);&#125;public static String getPrivateKeyStr(PrivateKey privateKey) throws Exception &#123; return new String(Base64Utils.encode(privateKey.getEncoded()));&#125;public static String getPublicKeyStr(PublicKey publicKey) throws Exception &#123; return new String(Base64Utils.encode(publicKey.getEncoded()));&#125; 公匙1MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCRQZ5O/AOAjeYAaSFf6Rjhqovws78I716I9oGF7WxCIPmcaUa1YuyLOncCCuPsaw69+RMWjdbOBp8hd4PPM/d4mKTOVEYUE0SfxhhDTZaM5CzQEUXUyXy7icQTGR5wBjrbjU1yHCKOf5PJJZZQWB06husSFZ40TdL7FdlBpZ1u1QIDAQAB 私钥1MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJFBnk78A4CN5gBpIV/pGOGqi/CzvwjvXoj2gYXtbEIg+ZxpRrVi7Is6dwIK4+xrDr35ExaN1s4GnyF3g88z93iYpM5URhQTRJ/GGENNlozkLNARRdTJfLuJxBMZHnAGOtuNTXIcIo5/k8klllBYHTqG6xIVnjRN0vsV2UGlnW7VAgMBAAECgYBMoT9xD8aRNUrXgJ7YyFIWCzEUZN8tSYqn2tPt4ZkxMdA9UdS5sFx1/vv1meUwPjJiylnlliJyQlAFCdYBo7qzmib8+3Q8EU3MDP9bNlpxxC1go57/q/TbaymWyOk3pK2VXaX+8vQmllgRZMQRi2JFBHVoep1f1x7lSsf2TpipgQJBANJlO+UDmync9X/1YdrVaDOi4o7g3w9u1eVq9B01+WklAP3bvxIoBRI97HlDPKHx+CZXeODx1xj0xPOK3HUz5FECQQCwvdagPPtWHhHx0boPF/s4ZrTUIH04afuePUuwKTQQRijnl0eb2idBe0z2VAH1utPps/p4SpuT3HI3PJJ8MlVFAkAFypuXdj3zLQ3k89A5wd4Ybcdmv3HkbtyccBFALJgs+MPKOR5NVaSuF95GiD9HBe4awBWnu4B8Q2CYg54F6+PBAkBKNgvukGyARnQGc6eKOumTTxzSjSnHDElIsjgbqdFgm/UE+TJqMHmXNyyjqbaA9YeRc67R35HfzgpvQxHG8GN5AkEAxSKOlfACUCQ/CZJovETMmaUDas463hbrUznp71uRMk8RP7DY/lBnGGMeUeeZLIVK5X2Ngcp9nJQSKWCGtpnfLQ== &emsp;&emsp;很明显，公钥字符串长度比较短，私钥的比较长。生成完密钥后，公钥可以存放在客户端，即使被别人知道公钥，也是没有问题的；私钥则一定要保存在服务端。如果到时公司面临人事变动，避免私钥被离职人员泄露，可以重新生成公钥和密钥。 使用公钥加密，私钥解密这里在客户端模拟加密的情况，对字符串”Beyond黄家驹”使用RSA加密，调用RSAUtils的encryptByPublicKey()方法，输出结果为：1密文: BRFjf3tUqRqlwuP5JtzxZinf7lp+AHuHM9JSabM5BNFDxuUe9+uuO6RpCHVH5PibifqQHzGNsyZn1G9QcIENT9Tbm+PZwAbNUlMPZRDBU1FSnOtY8dBdeW/lJdnY9sJVwNvIBnOLQk66hxRh6R2149dwlgdsGUpWMOMBzcP3vsU= 在服务端，可以使用RSAUtils的decryptByPrivateKey()方法进行解密，现在模拟服务端解密&emsp;&emsp;在这里虽然没有完全模拟数据传输过程，比如说客户端发起一个网络请求，传递参数给服务端，服务端接收参数并进行处理，也是为了让大家可以更加容易明白，所以这里只是进行简单的模拟。可以看到Android客户端端和Java服务端的RSA加密解密算法是可以互通的，原因是他们所使用到的base64加密类是一致的，所以才可以实现加密和解密的算法互通。&emsp;&emsp;使用到的jar包都是javabase64-1.3.1.jar,相信不少人都知道，java中有自带的Base64算法类，但是安卓中却没有，之前出现的情况是，使用的Base64类不统一，比如在安卓客户端开发使用的Base64算法是使用第三方提供的jar包，而java服务端中使用的是JDK自带的Base64,导致从客户端传过来的密文，服务端解析出错。 &emsp;&emsp;上面的例子展示了客户端使用公钥加密，服务端使用私钥解密的过程。也许你会这么想，既然可以如此，那服务端那边信息也可以通过RSA加密后，传递加密信息过来，客户端进行解密。但是，这样做，显示是不安全的。原因是，由于客户端并没有保存私钥，只有公钥，只可以服务端进行私钥加密，客户端进行公钥解密，但由于公钥是公开，别人也可以获取到公钥，如果信息被他们截取，他们同样可以通过公钥进行解密，那么这样子加密，就毫无意义了，所以这个时候，就要结合对称算法，实现客户端与服务端之前的安全通信了。 使用AES加密解密加密模拟客户端进行AES加密，我们通过调用AESUtils中的generateKey()方法，随机产生一个密钥，用于对数据进行加密。输出的结果为：12密钥: 6446c69c0f914a57密文: GECDQOsc22yV48hdJENTMg== 解密&emsp;&emsp;模拟服务端进行AES解密，由于AES属于对称算法，加密和解密需要使用同一把密钥，所以，服务端要解密传递过来的内容，就需要密钥 + 密文。这里模拟一下服务端解密。&emsp;&emsp;到这里也许你会问，客户端使用AES进行加密，服务端要进行解密的话，需要用到产生的密钥，那密钥必须从客户端传输到服务端，如果不对密钥进行加密，那加密就没有意义了。所以这里终于谈到了重点，RSA算法+AES算法结合使用。 RSA算法+AES算法的使用&emsp;&emsp;举一个简单的例子来说明一下吧，例如实名认证功能，需要传递用户真实姓名和身份证号，对于这种重要信息，需要进行加密处理。 客户端使用RSA + AES对重要信息进行加密客户端加密过程主要分为以下三个步骤： 客户端随机产生AES的密钥； 对身份证信息（重要信息）进行AES加密； 通过使用RSA对AES密钥进行公钥加密。 &emsp;&emsp;这样在传输的过程中，即时加密后的AES密钥被别人截取，对其也无济于事，因为他并不知道RSA的私钥，无法解密得到原本的AES密钥，就无法解密用AES加密后的重要信息。 服务端使用RSA + AES对重要信息进行解密 服务端解密过程主要分为以下两个步骤： 对加密后的AES密钥进行RSA私钥解密，拿到密钥原文； 对加密后的重要信息进行AES解密，拿到原始内容。 &emsp;&emsp;现实开发中，服务端有时也需要向客户端传递重要信息，比如登录的时候，返回token给客户端，作为令牌，这个令牌就需要进行加密，原理也是差不多的，比上面多一个步骤而已，就是将解密后的AES密钥，对将要传递给客户端的数据token进行AES加密，返回给客户端，由于客户端和服务端都已经拿到同一把AES钥匙，所以客户端可以解密服务端返回的加密后的数据。如果客户端想要将令牌进行保存，则需要使用自己定义的默认的AES密钥进行加密后保存，需要使用的时候传入默认密钥和密文，解密后得到原token。 &emsp;&emsp;上面提及到客户端加密，服务端返回数据不加密的情况，上面说到仅仅使用RSA是可以，但是还是建议同时使用这两种算法，即产生一个AES密钥，使用RSA对该密钥进行公钥加密，对重要信息进行AES加密，服务端通过RSA私钥解密拿到AES密钥，再对加密后的重要信息进行解密。如果仅仅使用RSA，服务端只通过RSA解密，这样会对于性能会有所影响，原因是RSA的解密耗时约等于AES解密耗时的100倍，所以如果每个重要信息都只通过RSA加密和解密，则会影响服务端系统的性能，所以建议两种算法一起使用。 同时还有相应的JS版RSA和AES算法，使用方式也差不多，在这里简单演示一下： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;RSA+AES.html&lt;/title&gt; &lt;meta name=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;this is my page&quot;&gt; &lt;meta name=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/rsa.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/aes.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var key = getKey();//随机产生AES密钥 var encryptKey = RSA(key);//对AES密钥进行RSA加密 console.log(&quot;encryptKey: &quot; + encryptKey); //测试AES加密和解密 var cipherText = AESEnc(key,&quot;123456&quot;); var plainText = AESDec(key,cipherText); console.log(&quot;密文: &quot; + cipherText); console.log(&quot;明文: &quot; + plainText); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; This is my HTML page. &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 打开页面后，查看控制台输出：同时，模拟服务端解密，运行结果如下： 需要注意的是: 1.RSAUtils中配置公钥和密钥，可以使用getKeys()方法产生。如果是客户端，则无须配置私钥，把没有私钥的RSAUtils放到客户端，因为仅需要用到公钥加密的方法。 2.AESUtils中配置偏移量IV_STRING； 3.rsa.js中最底部配置公钥，须和上面RSAUtils配置的公钥一致； 4.aes.js中的底部var iv = CryptoJS.enc.Utf8.parse(“16-Bytes–String”); //加密向量中，替换里面的字符串，加密向量须和是上面的AESUtils中的偏移量一致。 各种语言的加密的处理方式有所差异，所以我们需要因地制宜。了解此加密的思想方法即可 php 和 java RSA 对称加密互通的问题 php与java通用AES加密解密算法 Android错误解决：java.lang.NoSuchMethodError: No static method encodeBase64String]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全、Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio修改包名]]></title>
    <url>%2FAndroid-Studio%E4%BF%AE%E6%94%B9%E5%8C%85%E5%90%8D.html</url>
    <content type="text"><![CDATA[Android Studio修改包名 修改包显示方式 通过修改包显示方式，我们可以更方便的修改包名。 修改包名 改build.gradle(module：APP名字)文件中的 applicationId clean和rebuild project 关闭android studio重启(可选) 亲测有效，完美~ 简易操作，全局替换ctr+shift+r]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>包名修改</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件传递机制]]></title>
    <url>%2F%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[Touch事件传递机制其中Activity和View控件（TextView）拥有分派和处理事件方法，View容器（LinearLayout）具有分派，拦截，处理事件方法。这里也有个比喻：领导都会把任务向下分派，一旦下面的人把事情做不好，就不会再把后续的任务交给下面的人来做了，只能自己亲自做，如果自己也做不了，就只能告诉上级不能完成任务，上级又会重复他的过程。另外，领导都有权利拦截任务，对下级隐瞒该任务，而直接自己去做，如果做不成，也只能向上级报告不能完成任务。123456//分派事件public boolean dispatchTouchEvent(MotionEvent ev)//拦截事件 public boolean onInterceptTouchEvent(MotionEvent ev)//处理事件public boolean onTouchEvent(MotionEvent event) 从上面两张事件传递图我们的出来一些结论： 事件是先有dispatchTouchEvent分派给下一级 要经过onInterceptTouchEvent是否需要拦截，不拦截传递给下一级，最终传递给view控件， onTouchEvent方法中，在处理事件中，如果返回True，则表示能处理，传递将会终止。反着，不能，如果不能的话，这会返回上一级的onTouchEvent方法中，如果还是false，会一直到到上一层的onTouchEvent方法中。 好奇的我们会发现一个问题：图二中的黄色线，没有像红色线那样，先传递到最底层，然后再回滚回去，这是为什么呢？ 答：就如我们故事中，他都知道了，底下人都不会去做了，那么他干嘛还分派给他呢，他就会自己做了，直接给onTouchEvent ，这就是事件传递中的“记忆”功能。我们是手指点击蓝色区域，Touch事件有两个，第一个ACTION_DOWN，第二个ACTION_UP，第一个 ACTION_DOWN事件向下传递到某View，它把事件继续传递交给它的子View，它会记录该事件是否被它下面的View给处理成功了，（怎么能知 道呢？如果该事件会再次被向上传递到我这里来由我的onTouchEvent来处理，那就说明下面的View都没能成功处理该事件）；当第二个 ACTION_UP事件向下传递到该View，该View的dispatchTouchEvent方法机会判断，若上次的事件由下面的view成功处理 了，那么这次的事件就继续交给下面的来处理，若上次的事件没有被下面的处理成功，那么这次的事件就不会向下传递了，该View直接调用自己的 onTouchEvent方法来处理该事件。 PS：关于这“记忆”功能的信息只在一系列事件完成之前有效，也就是从ACTION_DOWN事件开始，直到后续事件 ACTION_MOVE，ACTION_UP结束后，“记忆”的信息就会清除。也就是说如果某View处理ACTION_DOWN事件失败了 （onTouchEvent()返回false），那么后续的ACTION_MOVE,ACTION_UP等事件就不会再传递到该View了，由其父 View自己来处理。在下一次发生ACTION_DOWN事件的时候，还是会传递到该View的。 补充说明： -》若在向下传递的过程中被拦截了，即onInterceptTouchEvent方法返回true，则事件将停止向下传递，直接由当前的onTouchEvent方法来处理，若处理成功则OK，若处理不成功，则事件会向上传递。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Teach you to recognize MVC, MVP and MVVM]]></title>
    <url>%2FTeach-you-to-recognize-MVCMVPMVVM.html</url>
    <content type="text"><![CDATA[Teach you to recognize MVC, MVP AND MVVMI believe we are no stranger to MVC, MVP and MVVM, as the three most familiar Android framework. Their applications can be very extensive, but for some novice, it can be difficult to distinguish between them three. Article focus: Learn and distinguish between MVC, MVP and MVVM. Know how these three models in the use of Android. Out of the DataBinding errors. Understand the development model of MVP data binding. MVCMVC means Model View Controller, is the most common framework in the software architecture, simply through the control of controller to operate the modle layer of data, and return to view layer display. Use the traditional MVC, which View, corresponding to a variety of layout files, but these layout files are not as powerful as the Web Side, can do very limited. Controller correspods to the Activity, but Activity has the function of operating UI. We in the actual project will hava a lot of UI operations, and also do a lot of View should be dong in the layer MVC there is an important flaw, we look at the picture above, view layer and the model layer is mutual konw, which means that there is coupling between the two layers. The Coupling is very fatal for large program, beacuse it means that development, testing, maintenance need to spend a lot of energy. MVPMVP as MVC evolution, to solve a lot of MVC shortcommings. For Android, MVP model layer relative to the MVC is the same, but activity and fragment is no longer the controller layer, but the pure view layer.And all fordwarding of user events is handled by the presenter layer. It can be seen from the figure that the most obvious difference is that the view and model layer are no longer mutual konw and complete descoupling. Instead of the precenter layer acts as bridge, the events used to manipulate the view layer are passed to the presenter layer, the presenter layer to mainpulate the model layer, and the data is returned to the view layer. the view layer and the model layer are completely unconnected throughout the process. MVVMMVVM最早是由微软提出的 From the figure to see that it is similiar to MVP, but the presenter layerbe replaced by ViewModel layer. And the view layer and the viewmodel are bound to each other, the means that when you update the data of the viewmodel layer, the view layer changes accordingly ui. Last: MVP + DatabindingWe use the data binding framework to save similar findViewById and data binding time, and the use of presenter to separate the business logic and view layer.]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>模式、Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化之布局]]></title>
    <url>%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[性能优化之布局重用减少视图层级需要时加载，懒加载布局使用工具：Hierarchy View Android 性能优化方法使用Dalvik提供的 dalvik.system.VMRuntime类来设置最小堆内存为例: bitmap 设置图片尺寸避免 内存溢出 OutOfMemoryError的优化方法options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一 Android 还有一些性能优化的方法：首先内存方面，可以参考 Android堆内存也可自己定义大小 和 优化Dalvik虚拟机的堆内存分配基础类型上，因为Java没有实际的指针，在敏感运算方面还是要借助NDK来完成。这点比较有意思的是Google 推出NDK可能是帮助游戏开发人员，比如OpenGL ES的支持有明显的改观，本地代码操作图形界面是很必要的。图形对象优化，这里要说的是Android上的Bitmap对象销毁，可以借助recycle()方法显示让GC回收一个Bitmap对象，通常对一个不用的Bitmap可以使用下面的方式。 从代码角度进行优化静态变量引起内存泄露使用Application的Context及时关闭资源使用Bitmap及时调用recycle()对Adapter进行优化代码“微优化” 使用软引用和弱引用 Android 中的Activity、Window、View之间的关系Activity在onCreate时调用attach方法，在attach方法中会创建window对象。window对象创建时并没有创建 DocerView 对象。用户在Activity中调用setContentView,然后调用window的setContentView，这时会检查DecorView是否存在，如果不存在则创建DecorView对象，然后把用户自己的 View 添加到 DecorView 中。 Activity的几种LaunchMode及使用场景Android关于Task的一些实践 Android 设计模式之MVC模式MVC模式下，系统框架的类库被划分为3种：模型（Model）、视图（View）、控制器（Controller）。模型对象负责建立数据结构和相应的行为操作处理。视图对象负责在屏幕上渲染出相应的图形信息展示给用户看。控制器对象负责截获用户的按键和屏幕触摸等事件，协调Model对象和View对象。 用户与视图交互，视图接收并反馈用户的动作；视图把用户的请求传给相应的控制器，由控制器决定调用哪个模型，然后由模型调用相应的业务逻辑对用户请求进行加工处理，如果需要返回数据，模型会把相应的数据返回给控制器，由控制器调用相应的视图，最终由视图格式化和渲染返回的数据，对于返回的数据完全可以增加用户体验效果展现给用户。 教你认清MVC，MVP和MVVM如何设计MVP中的Presentation层google 官方mvp实例的实践之mvp-databinding-Rxjava（一） Netty 4.0在Android 上的使用，长连接断线自动重连]]></content>
  </entry>
  <entry>
    <title><![CDATA[android系统架构(一)]]></title>
    <url>%2Fandroid%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-%E4%B8%80.html</url>
    <content type="text"><![CDATA[出发点&emsp;&emsp;由于在学习Android的时候并没有很系统地进行学习，知识点比较零碎，所以需要将自己的知识点进行系统的整理，那么首要的我需要将android的系统架构搞清楚，这样才能分清楚我所了解的知识点附属于哪个层面，是内核还是应用层，可以进行怎样的扩展，在哪些场景去运用。 Android架构解析Google工程师多图详解Android系统架构Android基础之Android系统架构Android维基百科Android对Linux内核的增强Android系统架构详解(2)–Android Runtime 以上是我在这个课题下的一些参考博客或者网页链接。里面有对于android架构的一些较好的分析理解，接下来是阅读后自己的一些整理。 Android采用层次化系统架构，官方公布的标准架构如下图所示。 Android由底层往上分为4个主要功能层，分别是Linux内核层（Linux Kernel），系统运行时库层（Libraries和Android Runtime），应用程序架构层（Application Framework）和应用程序层（Applications）。 接下来对这几个层面进行逐个分析： Linux内核层&emsp;&emsp;Android以Linux操作系统内核为基础，借助Linux内核服务实现硬件设备驱动，进程和内存管理，网络协议栈，电源管理，无线通信等核心功能。Android4.0版本之前基于Linux2.6系列内核，4.0及之后的版本使用更新的Linux3.X内核，并且两个开源项目开始有了互通。Linux3.3内核中正式包括一些Android代码，可以直接引导进入Android。Linux3.4增添了电源管理等更多功能，以增加与Android的硬件兼容性，使Android在更多设备上得到支持。直到现在最新的android6.0仍然继续延用着linux3.4.0，而linux最新的版本已经到了4.3系列，那么为什么android没有继续去更新Linuxkernel的版本也是一个值得探讨的课题。 &emsp;&emsp;Android内核 对Linux内核进行了增强，增加了一些面向移动计算的特有功能。例如，低内存管理器LMK（Low Memory Keller），匿名共享内存（Ashmem）,以及轻量级的进程间通信Binder机制等。这些内核的增强使Android在继承Linux内核安全机制的同时，进一步提升了内存管理，进程间通信等方面的安全性。 硬件抽象层&emsp;&emsp;内核驱动和用户软件之间还存在所谓的硬件抽象层（Hardware Abstract Layer,HAL），它是对硬件设备的具体实现加以抽象。HAL没有在Android官方系统架构图中标明，下图标出了硬件抽象层在android系统中的位置： &emsp;&emsp;鉴于许多硬件设备厂商不希望公开其设备驱动的源代码，如果能将android的应用框架层与linux系统内核的设备驱动隔离，使应用程序框架的开发尽量独立于具体的驱动程序，则android将减少对Linux内核的依赖。HAL由此而生，它是对Linux内核驱动程序进行的封装，将硬件抽象化，屏蔽掉了底层的实现细节。HAL规定了一套应用层对硬件层读写和配置的统一接口，本质上就是将硬件的驱动分为用户空间和内核空间两个层面；Linux内核驱动程序运行于内核空间，硬件抽象层运行于用户空间。 系统运行库层&emsp;&emsp;官方的系统架构图中，位于Linux内核层之上的系统运行库层是应用程序框架的支撑，为Android系统中的各个组件提供服务。系统运行库层由系统类库和Android运行时构成。 系统类库系统类库大部分由C/C++编写，所提供的功能通过Android应用程序框架为开发者所使用。例如SQlite,WebKit,SSL都在会在日常开发中有用到 运行时Android运行时包含核心库和Dalvik虚拟机两部分。 核心库：核心库提供了Java5 se API的多数功能，并提供Android的核心API，如android.os，android.net，android.media等。 Dalvik虚拟机：Dalvik虚拟机是基于apache的java虚拟机，并被改进以适应低内存，低处理器速度的移动设备环境。Dalvik虚拟机依赖于Linux内核，实现进程隔离与线程调试管理，安全和异常管理，垃圾回收等重要功能。 Dalvik和标准Java虚拟机有以下主要区别： Dalvik基于寄存器，而JVM基于栈。一般认为，基于寄存器的实现虽然更多依赖于具体的CPU结构，硬件通用性稍差，但其使用等长指令，在效率速度上较传统JVM更有优势。 Dalvik经过优化，允许在有限的内存中同时高效地运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行，都拥有一个独立的Dalvik虚拟机实例。Android这种基于Linux的进程“沙箱”机制，是整个安全设计的基础之一。 Dalvik虚拟机从DEX（Dalvik Executable）格式的文件中读取指令与数据，进行解释运行。DEX文件由传统的，编译产生的CLASS文件，经dx工具软件处理后生成。 Dalvik的DEX文件还可以进一步优化，提高运行性能。通常，OEM的应用程序可以在系统编译后，直接生成优化文件（.ODEX）； 第三方的应用程序则可在运行时在缓存中优化与保存，优化后的格式为DEY（.dey文件）。 &emsp;&emsp;这部分内容，即从android4.4开始就出现了ART（android runtime），但是这个ART并不是指这一节的主题，而是一种用来代替Dalvik的新型运行环境。当然在4.4的正式环境中用的还是Dalvik，真正开始用ART取代Dalvik是从android5.0开始的。（todo:针对这个改动，楼主会专门另开一个篇幅的文章去探究ART和Dalvik之间的区别） 另外这一节中有提到NDK,相信对于开发者而言SDK和NDK都是必要要接触和了解的东西，那么先从下图来看看sdk和ndk的关系。 &emsp;&emsp;很显然地，ndk可以通过native code跨过使用dalvik runtime,直接调用到android内核资源，而sdk则需要在dalvik runtime环境下才能调用到内核资源。然而两者并不是各司其职，各不相关。android提供了JNI(Java native interface)使两者可以进行相互调用和通信。 应用程序框架层&emsp;&emsp;应用程序框架层提供开发Android应用程序所需的一系列类库，使开发人员可以进行快速的应用程序开发，方便重用组件，也可以通过继承实现个性化的扩展。 应用层&emsp;&emsp;Android平台的应用层上包括各类与用户直接交互的应用程序，或由java语言编写的运行于后台的服务程序。例如，智能手机上实现的常见基本功能 程序，诸如SMS短信，电话拨号，图片浏览器，日历，游戏，地图，web浏览器等程序，以及开发人员开发的其他应用程序。 &emsp;&emsp;将android的基本架构进行了一个总体的分析和罗列，我们可以发现，平时开发中最常接触和用到的一定是application层，但是我们也不难发现，一些application层应用到的东西都能在系统层找到对应的踪迹，例如sqlite,webkit,甚至alarm。他们是怎么从底层到达application层供我们日常开发所用，这个也是需要去了解和研究的。本篇文章的目的在开篇已经阐述过，是为了能更好地将自己的知识对号入座，并且去补充一些自己在某些层面上缺乏的知识，最终可以将自己的知识形成一个整体的体系结构。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Netty项目实践（一）]]></title>
    <url>%2FNetty%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[为什么要学需要要做一个中间件，接受由硬件通过wifi和手机反复传递过来的数据（温湿度），然后再通过中间件将数据写入数据库。由于数据是时时接收的，所以用普通的http请求难以完全实现，所以考虑建立长链接实现功能。 Netty的使用场景非常吻合： 构建高性能、低时延的各种Java中间件，例如MQ、分布式服务框架、ESB消息总线等，Netty主要作为基础通信框架提供高性能、低时延的通信服务； 公有或者私有协议栈的基础通信框架，例如可以基于Netty构建异步、高性能的WebSocket协议栈； 各领域应用，例如大数据、游戏等，Netty作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。参考:通俗地讲，Netty 能做什么？Netty那些不得不说的事;Netty系列之Netty高性能之道学习过程 创建Maven 项目BabyNetty123456&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zyx.baby&lt;/groupId&gt; &lt;artifactId&gt;BabyNetty&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; GroupID:是项目组织唯一的标识符，实际对应JAVA的包的结构，是main目录里java的目录结构。ArtifactID:就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。 创建两个模块JavaClient，NettyCoreJavaClient:打算用于对服务器的一些数据请求NettyCore：数据接收，分发处理 依赖jar和插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!--“打包“这个词听起来比较土，比较正式的说法应该是”构建项目软件包“，具体说就是将项目中的各种文件，比如源代码、编译生成的字节码、配置文件、文档，按照规范的格式生成归档，最常见的当然就是JAR包和WAR包了，--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;mainClass&gt;org.origin.netty.Start&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;dependencies&gt; &lt;!--是一个能够将Java bean/map/collection/Java array/xml转换成JSON并且反过来将JSON转换成java对象的类库--&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; &lt;!--Netty包--&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;5.0.0.Alpha2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置Log4j日志组件日志是应用软件中不可缺少的部分，Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录。在apache网站：jakarta.apache.org/log4j 可以免费下载到Log4j最新版本的软件包。参考：最详细的Log4j使用教程 核心NettyCore编写 常量数据集定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.zyx.baby.domain;/** * Created by 三金Sir on 2017/3/19. */public class Constant &#123; public static final String ENCODING="UTF-8"; public static final String CLIENT_SERVER="JAVASERVER"; //not used public static final String CLIENT_IOS_SECRET ="BABY_IOS"; public static final String CLIENT_ANDROID_SECRET ="BABY_ANDROID"; public static final String CLIENT_HARDWARE="BABY_HARDWARE"; public enum Type&#123; SERVER_CONNECT(1000), //Java client connect LOGIN(2000), LOGINOUT(2001), RECONNECT(1020), // app client reconnect SUCCESS_AWARE(4000), // notify client the operation is apply successful. INTERNAL_ERROR(4001), // middleware error DATA_ERROR(4002); // json data parse error public int value; Type(int value)&#123; this.value = value; &#125; public int value() &#123; return value; &#125; public static Type parse(int value)&#123; switch (value)&#123; case 1000: return SERVER_CONNECT; case 2000: return LOGIN; case 2001: return LOGINOUT; case 4000: return SUCCESS_AWARE; case 4001: return INTERNAL_ERROR; case 1020: return RECONNECT; default: return DATA_ERROR; &#125; &#125; &#125;&#125; 知识点 Java 枚举enum - 在实际编程中，往往存在着这样的“数据集”，它们的数值在程序中是稳定的，而且“数据集”中的元素是有限的。 - 例如星期一到星期日七个数据元素组成了一周的“数据集”，春夏秋冬四个数据元素组成了四季的“数据集”。 - 在Java中如何更好的使用这些“数据集”呢？因此枚举便派上了用场，以下代码详细介绍了枚举的用法。 #### 参考 ： [Java 枚举enum 使用详解](http://blog.csdn.net/zcback1/article/details/51014229?locationNum=4&amp;fps=1).&lt;/br&gt;[java enum(枚举)使用详解 + 总结](http://blog.csdn.net/zhushuai1221/article/details/51775811?locationNum=7&amp;fps=1). 数据格式定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.zyx.baby.domain;import io.netty.buffer.ByteBuf;import net.sf.json.JSONObject;import java.nio.charset.Charset;/** * Created by 三金Sir on 2017/3/19. */public class DataPacket &#123; private Constant.Type type; // SERVER、BLUETOOTH、WIFI private String from = "SERVER"; private String to=""; private String data = ""; public DataPacket(Constant.Type type,String data)&#123; this.type = type; this.from = "SERVER"; this.data = data; &#125; public DataPacket(String to)&#123; this.type = Constant.Type.SUCCESS_AWARE; this.from = "SERVER"; this.to = to; this.data = ""; &#125; public DataPacket(Constant.Type type, String to, String data) &#123; this.type = type; this.to = to; this.data = data; &#125; public DataPacket(Constant.Type type, String from, String to, String data) &#123; this.type = type; this.from = from; this.to = to; this.data = data; &#125; // Getter&amp;Setter begin public Constant.Type getType() &#123; return type; &#125; public void setType(Constant.Type type) &#123; this.type = type; &#125; public String getFrom() &#123; return from; &#125; public void setFrom(String from) &#123; this.from = from; &#125; public String getTo() &#123; return to; &#125; public void setTo(String to) &#123; this.to = to; &#125; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125; // Getter&amp;Setter end public static DataPacket parse(Object object)&#123; ByteBuf receive = (ByteBuf)object; JSONObject json=JSONObject.fromObject(receive.toString(Charset.forName(Constant.ENCODING))); receive.release(); return new DataPacket(Constant.Type.parse(json.getInt("type")),json.getString("from"),json.getString("to"),json.getString("data")); &#125; @Override public String toString() &#123; return "&#123;" + "\"type\":" + type.value() + ", \"from\":\"" + from + '"' + ", \"to\":\"" + to + '"' + ", \"data\":\"" + data + '"' + '&#125;'; &#125;&#125; 知识点：netty中ByteBuf部分netty中ByteBuf部分的分析Netty之ByteBuf[ Netty中的ByteBuf原理分析]http://blog.csdn.net/u012832964/article/details/50899511 配置拦截器，连接设备身份认证 过程：- verify = 设备标识字段+时间戳 - MD5加密后与客户端发送code匹配 - 成功,返回标识字段;否则null,Access denied 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.zyx.baby.interceptor;import com.zyx.baby.domain.Constant;import com.zyx.baby.domain.DataPacket;import com.zyx.baby.utils.Util;import io.netty.channel.ChannelHandlerContext;import static org.apache.log4j.Logger.*;/** * 连接设备拦截器 * Created by 三金Sir on 2017/3/19. */public class Interceptor &#123; private static final org.apache.log4j.Logger log = getLogger(Interceptor.class); public static String authIntercept(DataPacket pkt, ChannelHandlerContext ctx)&#123; String secret = Constant.CLIENT_SERVER; try &#123; String[] data = pkt.getData().split("&amp;"); String code = data[0]; String timestamp = data[1]; String verify; if(pkt.getType() == Constant.Type.SERVER_CONNECT) verify = Constant.CLIENT_SERVER + timestamp; else verify = Constant.CLIENT_HARDWARE + timestamp; String validateCode = Util.md5(verify); boolean isLogin = pkt.getType() == Constant.Type.LOGIN || pkt.getType() == Constant.Type.RECONNECT; if(isLogin &amp;&amp; !code.equals(validateCode))&#123; verify = Constant.CLIENT_HARDWARE + timestamp; validateCode = Util.md5(verify); secret = Constant.CLIENT_HARDWARE; &#125; if(isLogin &amp;&amp; !code.equals(validateCode))&#123; verify = Constant.CLIENT_ANDROID_SECRET + timestamp; validateCode = Util.md5(verify); secret = Constant.CLIENT_ANDROID_SECRET; &#125; if(isLogin &amp;&amp; !code.equals(validateCode))&#123; verify = Constant.CLIENT_IOS_SECRET + timestamp; validateCode = Util.md5(verify); secret = Constant.CLIENT_IOS_SECRET; &#125; if (!code.equals(validateCode)) &#123;// SystemService.sendMessage(new DataPacket(Constant.Type.DATA_ERROR, "Access denied."), ctx); ctx.close(); log.warn("[ socket interceptor ] Access denied."); return null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; return secret; &#125;&#125; 未完待续~~~]]></content>
      <categories>
        <category>项目实践</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Subline3下的两款Markdown插件]]></title>
    <url>%2FSubline3%E4%B8%8B%E7%9A%84%E4%B8%A4%E6%AC%BEMarkdown%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[MarkdownEditingMarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。 安装插件安装插件之前，我们需要首先安装一个Sublime 中最不可缺少的插件 Package Control, 以后我们安装和管理插件都需要这个插件的帮助。 安装”Package Control”使用快捷键 “ ctrl + `” 打开Sublime的控制台 ,或者选择 View &gt; Show Console在控制台的命令行输入框，把下面一段代码粘贴进去，回车 就可以完成Pacakge Control 的安装了。 1import urllib.request,os,hashlib; h = &apos;eb2297e1a458f27d836c04bb0cbaf282&apos; + &apos;d0e7a3098092775ccb37ca9d6b2e4b7d&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 安装MarkdownEditingPackage Control 安装成功后我们就可以使用它方便的管理插件了，首先使用快捷键 ‘command + shift + p ‘ 进入到Sublime 命令面板，输入 “package install” 从列表中选择 “install Package” 然后回车。这时候Sublime开始请求远程插件仓库的索引，所以第一次使用可能会有一些小的延时。看到列表的更新之后输入 “markdown ed” 关键字，选择“MarkdownEditing” 回车。 插件安装完毕后需要重新启动Sublime插件才能生效。下面是我使用sublime编辑代码片断的显示效 输入 “mdi + tab” 会自动插入下面的图片标记1![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 输入 “mdl + tab” 会自动生成下面的链接标记1[](link) Markdown Preview 插件Mardown Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。 安装通过按组合键Ctrl+Shift+P或是点击Preference-&gt;Package Control调出命令面板，然后再输入 install，选择 Package Control: install package。在插件安装面板输入markdown找到Markdown Preview并点击安装即可。 使用通过按组合键Ctrl+Shift+P或是点击Preference-&gt;Package Control调出命令面板，输入mdp，下图中红框圈出的就是在浏览器中预览markdown文件。选中后，你将见到两个选项：GitHub和Mardown。GitHub选项意味着使用GitHub的在线API来解析.md文件。它的解析速度取决于你的联网速度。据称有每天60次访问的限制。[2]但能免费获得GFM格式的语法支持和EMOJI表情的支持。另外一个常用功能是图中第五个，Export HTML in Sublime Text，即导出html文件到sublime text。 快捷键设置Sublime Text支持自定义快捷键，markdown preview默认没有快捷键，我们可以自己为preview in browser设置快捷键。方法是在Preferences -&gt; Key Bindings User打开的文件的中括号中添加以下代码(可在Key Bindings Default找到格式)： 1&#123; &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;&#125; &#125; 这里：“alt+m”可设置为自己喜欢的按键。“parser”:”markdown”也可设置为”parser”:”github”，改为使用Github在线API解析markdown。]]></content>
      <categories>
        <category>辅助工具</category>
      </categories>
      <tags>
        <tag>Subline</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云Centos7搭建Git服务器仓库]]></title>
    <url>%2F%E9%98%BF%E9%87%8C%E4%BA%91Centos7%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%93%E5%BA%93.html</url>
    <content type="text"><![CDATA[阿里云Centos7 搭建Git服务器仓库，记录过程 1.首先需要安装Git，可以使用yum源在线安装：1[root@localhost Desktop]# yum install -y git 2.创建一个git用户，用来运行git服务1# adduser git 3.初始化git仓库：这里我们选择/usr/local/tomcat7/webapps/baby_android/来作为我们的git仓库1# git init 仓库路径 /usr/local/tomcat7/webapps/baby_android/ 执行以上命令，会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，设置权限：1[root@localhost webapps]# chown - Rh git:users baby 5.创建SSH Key 首先在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 6.Git服务器打开RSA认证然后就可以去Git服务器上添加你的公钥用来验证你的信息了。在Git服务器上首先需要将/etc/ssh/sshd_config中将RSA认证打开，即：1231.RSAAuthentication yes 2.PubkeyAuthentication yes 3.AuthorizedKeysFile .ssh/authorized_keys 这里我们可以看到公钥存放在.ssh/authorized_keys文件中。所以我们在/home/git下创建.ssh目录，然后创建authorized_keys文件，并将刚生成的公钥导入进去。创建文件夹 mkdir 路径/文件夹名创建文件 vi 路径/文件名然后再次clone的时候，或者是之后push的时候，就不需要再输入密码了： 7.禁用git用户的shell登陆出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：1git:x:1001:1001:,,,:/home/git:/bin/bash 最后一个冒号后改为：1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell git clone git@42.96.150.57: /usr/local/tomcat7/webapps/baby/ 8. 客户端基本操作git add .git commitgit push 9.服务器自动更新部署 进入到 /usr/local/tomcat7/webapps/baby/.git 文件夹中，会发现 .git/hook 文件夹在里面，进入到 hook 中，里面有很多的 sample 脚本，这里我们只需要用到 post-update。post-update脚本 设置文件权限1chown -Rh git:users baby 10.创建git服务器远程仓库12$ mv post-update.sample post-update $ vim post-update 注意： Git: push 出错的解决 master -&gt; master (branch is currently checked out)这是由于git默认拒绝了push操作，需要进行设置，修改.git/config添加如下代码：12[receive]denyCurrentBranch = ignore 线上添加文件设置权限1chown -Rh git:users baby]]></content>
  </entry>
</search>
