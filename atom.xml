<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fighting！</title>
  
  <subtitle>潜行者的沉默</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangxin.online/"/>
  <updated>2019-09-09T00:37:03.551Z</updated>
  <id>http://yangxin.online/</id>
  
  <author>
    <name>三金Sir</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>8月25日</title>
    <link href="http://yangxin.online/8%E6%9C%8825%E6%97%A5.html"/>
    <id>http://yangxin.online/8月25日.html</id>
    <published>2019-08-25T08:46:06.000Z</published>
    <updated>2019-09-09T00:37:03.551Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h4><ol><li>事件分发的对象是MotionEvent,通过触摸屏幕和点击按键产生</li><li>事件分发的组件包括Activity，ViewGroup，View以及硬件驱动。</li><li>事件传递的方法，Native通过监听，读取dev/input/eventX文件产生新事件，发送给Java层。经过上面提到的组件，主要通过dispatchTouchEvent(),onInterceptTouchEvent(),onTouchEvent()三个方法传递，拦截和消费</li><li>Activity和View没有OnInterceptTouchEvent方法，无需拦截事件</li><li>在调用子View的dispatchTouchEvent时会判断是否设置了onTouchListener，会回调onTouch方法，返回true则为已经消费了,就不会调用onTouchEvent()的方法及内部的OnClick()方法</li><li>处理滑动冲突的方式1.外部拦截：由重写父View在onInterceptTouchEvent()根据业务来判断move事件是否要拦截事件，down和up事件不拦截。2. 内部拦截，父View除了down事件都拦截，然后由子View通过requesDisallowInterceptTouchEvent()来控制父类是否要拦截，或者交给子View处理 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;事件分发&quot;&gt;&lt;a href=&quot;#事件分发&quot; class=&quot;headerlink&quot; title=&quot;事件分发&quot;&gt;&lt;/a&gt;事件分发&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;事件分发的对象是MotionEvent,通过触摸屏幕和点击按键产生&lt;/li&gt;
&lt;li&gt;事件分发的组件包括Acti
      
    
    </summary>
    
    
      <category term="事件分发" scheme="http://yangxin.online/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>8月21日</title>
    <link href="http://yangxin.online/8%E6%9C%8821%E6%97%A5.html"/>
    <id>http://yangxin.online/8月21日.html</id>
    <published>2019-08-21T14:20:58.000Z</published>
    <updated>2019-08-21T17:41:04.526Z</updated>
    
    <content type="html"><![CDATA[<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>模板方法模式：在模板类中定义算法或任务执行的流程框架，将一些具体步骤延迟到子类中去实现。即可定义出不同的表现类。</p><h4 id="项目实例"><a href="#项目实例" class="headerlink" title="项目实例"></a>项目实例</h4><p>在项目中订单类型往往很多，订单的处理方式也是别有不同。现在介绍一个用户扫码点餐后，收银接受订单消息的处理流程。首先看一下流程</p><ol><li>用户下单：下单来源：支付宝，微信，口碑等，订单类型：堂食，自提，外卖</li><li>服务端收到下单请求，定义与之对应的消息推送给收银机</li><li>商户在收银机上收到下单消息，进行处理</li><li>服务端收到收银的处理结果，推送消息给用户</li><li>用户收到消息<br>上面流程在自动审核消息里就是一个通用的过程，因此可以多这个过程制定一个步骤，具体实现由开发者定义。</li></ol><p>整个流程中收银机处理的就是订单消息。由于订单的来源及订单类型的多种多样，也就意味着存在两方面的不同。1. 订单数据：基础数据+扩展数据 2.业务处理不同，不同的订单类型需要有不同的UI透出和额外的特殊操作。因此我们可以定义一个基础的UI操作类，定义出，获取订单数据，填充数据等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;模板方法模式&quot;&gt;&lt;a href=&quot;#模板方法模式&quot; class=&quot;headerlink&quot; title=&quot;模板方法模式&quot;&gt;&lt;/a&gt;模板方法模式&lt;/h4&gt;&lt;p&gt;模板方法模式：在模板类中定义算法或任务执行的流程框架，将一些具体步骤延迟到子类中去实现。即可定义出不同的表现
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>8月20号</title>
    <link href="http://yangxin.online/8%E6%9C%8820%E5%8F%B7.html"/>
    <id>http://yangxin.online/8月20号.html</id>
    <published>2019-08-20T15:20:23.000Z</published>
    <updated>2019-08-21T14:20:34.311Z</updated>
    
    <content type="html"><![CDATA[<h4 id="四大引用"><a href="#四大引用" class="headerlink" title="四大引用"></a>四大引用</h4><p>垃圾回收机制在回收对象的时候，会判断是否有引用指向对象</p><ol><li>强引用</li></ol><ul><li>程序中大部分的对象都是强引用，如果一个对象具有一个强引用指向它，那垃圾回收器是不会回收他的，在内存不足的情况，系统宁愿报outOfMemery也不会回收这些对象</li></ul><ol><li>软引用</li></ol><ul><li>如果一个对象只具有软引用，那内存充足的情况是不会被回收的，但在系统内存不足的情况，垃圾回收器还是会回收的。在未被回收之前，程序能正常使用该对象。软引用和一个引用队列管理，若软应用被回收，就会将软应用加入的引用队列中</li></ul><ol><li>弱引用<br>弱引用和软引用的区别在于，只具有弱引用的对象具有更短的生命周期，当垃圾回收器扫描到弱引用对象时，就会回收掉该对象。无论内存是否充足。回收后同样会将该引用加入到相关联的引用队列中</li><li>虚引用</li></ol><ul><li>虚引用顾名思义就是形同虚设，对对象的生命周期毫无影响。一个对象被虚引用指引，就和没有引用一下。会被回收。与软引用和虚引用的区别在于：他必须和引用队列联合使用。唯一目的就是对象被回收的时候收到一个系统通知</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;四大引用&quot;&gt;&lt;a href=&quot;#四大引用&quot; class=&quot;headerlink&quot; title=&quot;四大引用&quot;&gt;&lt;/a&gt;四大引用&lt;/h4&gt;&lt;p&gt;垃圾回收机制在回收对象的时候，会判断是否有引用指向对象&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;强引用&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>8月16日</title>
    <link href="http://yangxin.online/8%E6%9C%8816%E6%97%A5.html"/>
    <id>http://yangxin.online/8月16日.html</id>
    <published>2019-08-16T01:13:00.000Z</published>
    <updated>2019-08-16T16:35:41.029Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ol><li>HashMap是线程不安全的</li><li>允许key和value为null</li><li>不保证存储的有序性</li><li>影响HashMap性能的两个变量，init capacity(16)和loadFactor(0.75),load链表长度，减少Hash</li><li>faile-fast机制，不允许迭代遍历时remove，add</li><li>1.7和1.8jdk版本的数据存储结构.Entry,数组+链表。Node，数组+链表/红黑树</li><li>扩容大小2倍，容量为2次幂，方便获取捅数组位置提高效率</li><li>HashSet基于HashMap实现，value为object对象</li></ol><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><ol><li>线程安全，synchronize修饰方法</li><li>key，value不为null</li><li>不保证有序性<br>4.initcapcity(11) loadFactor 0.75</li><li>扩容大小2倍+1，容量为奇数或者素数，使哈希更加均匀</li></ol><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ol><li>并发容器，多线程下更加高效</li><li>key或者value不为null</li><li>cas无所操作。inittable初始化.SIZECTl，synchronnize</li><li>扩容，rehash</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;HashMap是线程不安全的&lt;/li&gt;
&lt;li&gt;允许key和value为null&lt;/li
      
    
    </summary>
    
    
      <category term="Map" scheme="http://yangxin.online/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>8月14日</title>
    <link href="http://yangxin.online/8%E6%9C%8814%E6%97%A5.html"/>
    <id>http://yangxin.online/8月14日.html</id>
    <published>2019-08-14T05:59:11.000Z</published>
    <updated>2019-08-16T14:13:00.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android中使用ProtoBuf"><a href="#Android中使用ProtoBuf" class="headerlink" title="Android中使用ProtoBuf"></a>Android中使用ProtoBuf</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Protobuf是一种Google开发的一种格式，这种格式与开发语言无关，与运行平台无关，用于序列化数据结构，并且很容易扩展，可用于通讯协议和数据存储等，类似于XML，json，但是序列化，反序列化，和数据的大小都远远高于其他数据结构。因为他会将具备可读性的key值的信息都进行过滤，转化更加精简的数据。</p><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ol><li>数据更加精简</li><li>数据大小是json数据的3~10倍</li><li>压缩性能是可以提升20~100倍</li><li>数据歧义少</li><li>代码自动生成<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5>数据大小的减少是。对key值的特殊定义，及数据都转成了16进制。<br>性能的提升，主要针对整形，浮点型的优化处理。字符型相对提升</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android中使用ProtoBuf&quot;&gt;&lt;a href=&quot;#Android中使用ProtoBuf&quot; class=&quot;headerlink&quot; title=&quot;Android中使用ProtoBuf&quot;&gt;&lt;/a&gt;Android中使用ProtoBuf&lt;/h3&gt;&lt;h4 id=&quot;简
      
    
    </summary>
    
    
      <category term="Protobuf" scheme="http://yangxin.online/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>8月13日</title>
    <link href="http://yangxin.online/8%E6%9C%8813%E6%97%A5.html"/>
    <id>http://yangxin.online/8月13日.html</id>
    <published>2019-08-13T11:54:48.000Z</published>
    <updated>2019-08-13T15:35:18.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android打包流程"><a href="#Android打包流程" class="headerlink" title="Android打包流程"></a>Android打包流程</h3><p>打包流程包括包含四步骤</p><ol><li>通过aapt工具打包res资源文件，生成R.java,resources.arsc和res文件</li><li>处理.aidl文件，生成对应的java接口文件</li><li>通过java compiler编译R.java, java接口文件，java源文件，生成.class文件</li><li>通过dex命令，将.class文件和第三方库的.class文件处理称classes.dex</li><li>通过apkbuilder工具，将Dex文件，res资源合并成一个APK</li><li>通过jarsinger工具，为APK进行签名</li><li>通过zipalign工具进行apk的对齐优化</li></ol><h3 id="自定义Gradle插件"><a href="#自定义Gradle插件" class="headerlink" title="自定义Gradle插件"></a>自定义Gradle插件</h3><ol><li>创建一个module，无论phone还是Android Library，因为后面会删掉大部分文件</li><li>删除module下的文件及文件夹，只保留空的src/main目录及build.gradle文件</li><li>创建groovy文件夹，定义包名。如java项目一样</li><li>创建一个类MyPlugin.groovy</li><li><p>在build.build中加入groovy引用和用于上传的maven的引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;groovy&apos;</span><br><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    //gradle sdk</span><br><span class="line">    compile gradleApi()</span><br><span class="line">    //groovy sdk</span><br><span class="line">    compile localGroovy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">group = &apos;com.zyx.plugin&apos; </span><br><span class="line">version = &apos;1.0.0&apos;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            //提交到远程服务器：</span><br><span class="line">            // repository(url: &quot;http://www.xxx.com/repos&quot;) &#123;</span><br><span class="line">            //    authentication(userName: &quot;admin&quot;, password: &quot;admin&quot;)</span><br><span class="line">            // &#125;</span><br><span class="line">            //本地的Maven地址设置为D:/repos</span><br><span class="line">            repository(url: uri(&apos;/Users/zhengyangxin/StudioProjects/myProject/LibraryCollection/pluginrepos&apos;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插件已经编好，接着需要告诉gradle我们定义了哪个插件，需要创建文件src/main/resources/META-INF/gradle-plugins/XXXX.properties, 这里的XXXX就是外部module引用的名称，在这里我们定义为com.zyx.plugin.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.zyx.plugin&apos;</span><br></pre></td></tr></table></figure></li><li><p>然后在XXXX.properties指明我们定义的插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class=com.hc.plugin.MyPlugin</span><br></pre></td></tr></table></figure></li><li><p>最后可以进行打包一个plugin在本地，通过定义的uploadArchives Task</p></li><li>在需要的modlue中引用自定义的plugin<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.zyx.plugin&apos;</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;//本地Maven仓库地址</span><br><span class="line">            url uri(&apos;/Users/zhengyangxin/StudioProjects/myProject/LibraryCollection/pluginrepos&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        //格式为--&gt;group:module:version</span><br><span class="line">        classpath &apos;com.zyx.plugin:plugin:1.0.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android打包流程&quot;&gt;&lt;a href=&quot;#Android打包流程&quot; class=&quot;headerlink&quot; title=&quot;Android打包流程&quot;&gt;&lt;/a&gt;Android打包流程&lt;/h3&gt;&lt;p&gt;打包流程包括包含四步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过aapt工具打
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>8月8日</title>
    <link href="http://yangxin.online/8%E6%9C%888%E6%97%A5.html"/>
    <id>http://yangxin.online/8月8日.html</id>
    <published>2019-08-08T02:27:32.000Z</published>
    <updated>2019-08-12T12:53:50.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android开源框架-Aoppermission"><a href="#Android开源框架-Aoppermission" class="headerlink" title="Android开源框架 Aoppermission"></a>Android开源框架 Aoppermission</h3><p>Aoppermission是基于Aspect实现。实现过程及原理分析。Android的常用Aop有两种方式1.通过JNI Hook，2.静态织入</p><h4 id="Acpect基础知识"><a href="#Acpect基础知识" class="headerlink" title="Acpect基础知识"></a>Acpect基础知识</h4><ol><li>注解@Aspect，申明切面标记类</li><li>@Pointcut, 定义切点，标记方法</li><li>@Befeore 前置通知，切点前执行</li><li>@Around 围绕切点执行</li><li>@after 后置通知，切点后执行</li><li>@AfterReturening,返回返回值，切点返回值</li><li>@AfterThrowing ，异常通知，切点抛出异常</li><li>首先需要依赖com.hujiang.aspectjx:gradle-android-plugin-aspectjx，配置好了所需的环境</li><li>通过定义注解，包括NeedPermission,PermissionCanceled,PermissionDenied，三个注解对应这申请权限的三种情况。通过源码看他们的作用域都是Method，保留时间都是一直到运行时期，那就意味着，我们可以通过反射的技术实现想做的，而本项目也恰恰是基于反射和Aspect实现</li></ol><h4 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h4><p>纵向关系OOP，横向关系AOP</p><ol><li>OOP是面向对象编程，按照单一职责原则会将会定义一个个类，每个类只负责一个责任。当我们要使用这个时会引用他，使他分散在个个模块，到处都有。如日志，埋点等。从对象组织角度来讲，采用的分类方式是类似生物学的方式，以继承为主线</li><li>AOP是面向切面编程，我们从横向的的角度去观察这些对象，无需到处调用。这些需要打印日志的地方就是一个切点，AOp会在适当的时机打印<br>OOP是将问题划分到某个单个模块里去，而AOP是将把涉及到众多模块的某一类问题进行统一管理。AOP是将这些功能集中起来放到一个地方进行管理。是与业务逻辑进行隔离解耦</li></ol><h4 id="实现特定方法的前后执行"><a href="#实现特定方法的前后执行" class="headerlink" title="实现特定方法的前后执行"></a>实现特定方法的前后执行</h4><ol><li>硬编码，在执行方法前添加额外的执行方法</li><li>静态织入，通过AspectJ，通过扫描文件分析代码，找到切点JoinPoint，通过自动生成代码获取方法的各种信息，</li><li>JDK动态代理是对接口的代理，CGLib是对类的代理，把被代理的对象的class加载起来修改字节码，修改其字节码生成一个继承被代理对象的子类.通过子类增强功能</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android开源框架-Aoppermission&quot;&gt;&lt;a href=&quot;#Android开源框架-Aoppermission&quot; class=&quot;headerlink&quot; title=&quot;Android开源框架 Aoppermission&quot;&gt;&lt;/a&gt;Android开源框架
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>8月7日</title>
    <link href="http://yangxin.online/8%E6%9C%887%E6%97%A5.html"/>
    <id>http://yangxin.online/8月7日.html</id>
    <published>2019-08-07T00:46:51.000Z</published>
    <updated>2019-08-08T13:41:28.653Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android中AOP应用"><a href="#Android中AOP应用" class="headerlink" title="Android中AOP应用"></a>Android中AOP应用</h4><p>在Android开发中，有很多知名的开源框架在使用AOP思想。例如ButterKnife,Retrofit,Hugo等。AOP可以做性能检测和埋点技术也有很多</p><ol><li>性能检测和优化，360的ArgusAPM,滴滴的booster，Hugo</li><li>埋点技术，逻辑思维的DDAuto Tracker, 网易的HubbleData</li><li>通过AOP技术，还可以在我们向服务器请求数据时，会显示一个Loding，结果返回后隐藏它，可以通过AOP技术将Loading动作与业务主体分离</li><li>Android的权限管理Aopermission</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Android中AOP应用&quot;&gt;&lt;a href=&quot;#Android中AOP应用&quot; class=&quot;headerlink&quot; title=&quot;Android中AOP应用&quot;&gt;&lt;/a&gt;Android中AOP应用&lt;/h4&gt;&lt;p&gt;在Android开发中，有很多知名的开源框架在使用A
      
    
    </summary>
    
      <category term="“日记”" scheme="http://yangxin.online/categories/%E2%80%9C%E6%97%A5%E8%AE%B0%E2%80%9D/"/>
    
    
      <category term="AOP" scheme="http://yangxin.online/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>8月6日</title>
    <link href="http://yangxin.online/8%E6%9C%886%E6%97%A5.html"/>
    <id>http://yangxin.online/8月6日.html</id>
    <published>2019-08-06T06:45:59.000Z</published>
    <updated>2019-08-08T00:13:45.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>UML是一种可视化的面向对象的建模语言,可以用来描述系统的静态结构和动态行为。用得最多的是类图，时序图，用例图。</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>类图中类是对象的集合，用来描述类的对象结构类及与类,系统之间的交互关系</p><ol><li>泛化关系(表现为is a)：实线加指向父类或接口的空心箭头,包括类与类的继承，接口与接口的继承，类对接口的实现.</li><li>实现抽象：虚线+指向抽象的类的空心箭头</li><li>聚合关系：不是强依赖关系，用实线+空心菱形箭头指向依赖对象，公司和员工的关系</li><li>组合关系：强依赖关系(共存),用实线+实心菱形箭头指向依赖对象，公司和部门的关系，同时创建，同生命周期</li><li>依赖关系：通过入参依赖，用虚线+实心箭头，体现为局部变量，方法参数或者静态调用方法</li><li>关联关系(has a)：一个类知道另一个类的属性和方法，是另一个类的全局变量<a id="more"></a></li></ol><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p>用来显示对象之间的交互关系的图，涉及到角色,生命线，控制焦点和消息等元素<br>消息可以分为：同步消息，异步消息，返回消息，自关联消息</p><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><p>用来描述角色和系统之间的关系，角色与系统交互及系统反应，包括扩展关系和包含关系</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP面向切面编程。程序设计原则中的单一职责原则，要求我们一个类只负责一个任务，那就意味着一个程序将会有很多类，负责不同能功能。好处是解耦了，但同时如果需要对类的方法进行埋点统一配置等，将会异常繁琐。而AOP就是为了解决这个问题.</p><h4 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h4><p>贯穿多个模块的非主体业务功能，如日志功能</p><h4 id="AOP的几种实现方式"><a href="#AOP的几种实现方式" class="headerlink" title="AOP的几种实现方式"></a>AOP的几种实现方式</h4><ol><li>动态代理</li><li>APT是一种编译期注解处理技术。通过注解和处理来实现编译期生成代码,和源代码一起编译成class文件。将拓展的关注点代码放入注解处理器中</li><li>AspectJ<br>是一种编译器。java编译器基础上加了关键字识别和编译方法，可以编写Aspect程序植入目标程序，拓展程序功能。</li><li>Transform + Javassist/ASM<br>Transform是Android Gradle提供的，可以操作字节码的一种方式。源码-.class-.dex。在.class转变为.dex过程会经历一系列的Transform处理。Javassist/ASM是操作.class字节码</li></ol><p><a href="https://juejin.im/post/5d0a0dfce51d45775d516f94" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;UML&quot;&gt;&lt;a href=&quot;#UML&quot; class=&quot;headerlink&quot; title=&quot;UML&quot;&gt;&lt;/a&gt;UML&lt;/h3&gt;&lt;p&gt;UML是一种可视化的面向对象的建模语言,可以用来描述系统的静态结构和动态行为。用得最多的是类图，时序图，用例图。&lt;/p&gt;
&lt;h4 id=&quot;类图&quot;&gt;&lt;a href=&quot;#类图&quot; class=&quot;headerlink&quot; title=&quot;类图&quot;&gt;&lt;/a&gt;类图&lt;/h4&gt;&lt;p&gt;类图中类是对象的集合，用来描述类的对象结构类及与类,系统之间的交互关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;泛化关系(表现为is a)：实线加指向父类或接口的空心箭头,包括类与类的继承，接口与接口的继承，类对接口的实现.&lt;/li&gt;
&lt;li&gt;实现抽象：虚线+指向抽象的类的空心箭头&lt;/li&gt;
&lt;li&gt;聚合关系：不是强依赖关系，用实线+空心菱形箭头指向依赖对象，公司和员工的关系&lt;/li&gt;
&lt;li&gt;组合关系：强依赖关系(共存),用实线+实心菱形箭头指向依赖对象，公司和部门的关系，同时创建，同生命周期&lt;/li&gt;
&lt;li&gt;依赖关系：通过入参依赖，用虚线+实心箭头，体现为局部变量，方法参数或者静态调用方法&lt;/li&gt;
&lt;li&gt;关联关系(has a)：一个类知道另一个类的属性和方法，是另一个类的全局变量
    
    </summary>
    
      <category term="日记" scheme="http://yangxin.online/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="UML" scheme="http://yangxin.online/tags/UML/"/>
    
      <category term="AOP" scheme="http://yangxin.online/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>8月4日</title>
    <link href="http://yangxin.online/8%E6%9C%884%E6%97%A5.html"/>
    <id>http://yangxin.online/8月4日.html</id>
    <published>2019-08-04T07:27:33.000Z</published>
    <updated>2019-08-06T15:00:17.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="阿里开源项目启动框架Alpha"><a href="#阿里开源项目启动框架Alpha" class="headerlink" title="阿里开源项目启动框架Alpha"></a>阿里开源项目启动框架Alpha</h3><p>前面已经介绍了它的原理是基于PERT技术实现的。将一个项目过程以任务单元合理的安排资源，有些任务存在依赖关系所以执行顺序是定死的，但有些任务可以是脱离顺序，可以从关键任务路径中拎出来并行，从而一个项目的耗时及资源占比最大的任务即关键任务路径，在保证项目质量的前提下，可以对关键任务路径上的任务进行优化，也可以从次要任务优化，使关键任务资源充足，达到优化整体项目的效果。下面介绍关键代码类及点</p><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>任务即项目的执行单元，任务包含的元素</p><ol><li>任务的状态：空闲(idle)，正在执行(runing)，结束(finish)，等待(wait)</li><li>任务优先级：线程是有限的，对于同一时机的任务，其执行顺序也是有先后顺序的</li><li>任务执行所在线程的优先级，对于优先级高的可以分配到更多的cpu时间</li><li>任务执行的线程：1.线程池子线程；2.主线程</li><li>任务名和任务的监听器对象集合</li><li>任务的关联关系：1.前驱任务集合，2.后继任务集合。执行顺序</li><li>当然可以添加监控器，监控任务的执行情况（任务耗时）<a id="more"></a></li></ol><h4 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h4><p>项目即由多个任务组成的集合体，它本身也是一个任务，但有其特殊的属性和方法定义</p><ol><li>定义了项目的生命周期，ProjectStart(),TaskFinish(),ProjectFinish()。项目的开始，项目中某任务的结束，项目的结束</li><li>定义开始和结束任务，两个任务是从图的执行角度来讲是唯一的起始和结束点，可以有效衡量一个图的开始和结束，并且方便将图插入另一个图中.startTask, finishTask</li><li>项目名称及生命周期监听集合 </li><li>添加监控器，及项目执行性能统计</li></ol><h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><ol><li>初始化Project对象，定义startTask，finishTask，定义回调事件</li><li>添加任务，建立任务间的顺序关系</li><li>添加任务会与startTask与finishTask构成环形的有向图，每个任务会记录它的前驱任务集合和后继任务集合。当且仅当前驱任务执行完毕才会执行它自己，然后是后继任务，也就意味着，finnishTask只会在所有任务执行结束调用，最后的最后回调project的finish</li></ol><h4 id="项目意义"><a href="#项目意义" class="headerlink" title="项目意义"></a>项目意义</h4><p>在项目中的实践，</p><ol><li>可以应用于应用启动流程,在应用启动时会初始化很多任务，如数<br>据库，Tinker，图片库，缓存数据等等，这些任务或许可以同步执行<br>，但有些必须顺序执行。通过PERT技术恰恰能解释并优化这个过程</li><li>图片上传任务，数据上传等。数据多可以通过并发上传额方式充分利用cpu</li></ol><p><a href="https://github.com/alibaba/alpha" target="_blank" rel="external">项目地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;阿里开源项目启动框架Alpha&quot;&gt;&lt;a href=&quot;#阿里开源项目启动框架Alpha&quot; class=&quot;headerlink&quot; title=&quot;阿里开源项目启动框架Alpha&quot;&gt;&lt;/a&gt;阿里开源项目启动框架Alpha&lt;/h3&gt;&lt;p&gt;前面已经介绍了它的原理是基于PERT技术实现的。将一个项目过程以任务单元合理的安排资源，有些任务存在依赖关系所以执行顺序是定死的，但有些任务可以是脱离顺序，可以从关键任务路径中拎出来并行，从而一个项目的耗时及资源占比最大的任务即关键任务路径，在保证项目质量的前提下，可以对关键任务路径上的任务进行优化，也可以从次要任务优化，使关键任务资源充足，达到优化整体项目的效果。下面介绍关键代码类及点&lt;/p&gt;
&lt;h4 id=&quot;Task&quot;&gt;&lt;a href=&quot;#Task&quot; class=&quot;headerlink&quot; title=&quot;Task&quot;&gt;&lt;/a&gt;Task&lt;/h4&gt;&lt;p&gt;任务即项目的执行单元，任务包含的元素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任务的状态：空闲(idle)，正在执行(runing)，结束(finish)，等待(wait)&lt;/li&gt;
&lt;li&gt;任务优先级：线程是有限的，对于同一时机的任务，其执行顺序也是有先后顺序的&lt;/li&gt;
&lt;li&gt;任务执行所在线程的优先级，对于优先级高的可以分配到更多的cpu时间&lt;/li&gt;
&lt;li&gt;任务执行的线程：1.线程池子线程；2.主线程&lt;/li&gt;
&lt;li&gt;任务名和任务的监听器对象集合&lt;/li&gt;
&lt;li&gt;任务的关联关系：1.前驱任务集合，2.后继任务集合。执行顺序&lt;/li&gt;
&lt;li&gt;当然可以添加监控器，监控任务的执行情况（任务耗时）
    
    </summary>
    
      <category term="日记" scheme="http://yangxin.online/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Alpha" scheme="http://yangxin.online/tags/Alpha/"/>
    
      <category term="启动优化" scheme="http://yangxin.online/tags/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>8月3日</title>
    <link href="http://yangxin.online/8%E6%9C%883%E6%97%A5.html"/>
    <id>http://yangxin.online/8月3日.html</id>
    <published>2019-08-03T01:20:18.000Z</published>
    <updated>2019-08-06T14:58:33.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Https的用途和工作模式"><a href="#Https的用途和工作模式" class="headerlink" title="Https的用途和工作模式"></a>Https的用途和工作模式</h3><p>用Http协议看新闻没什么问题，但换到严肃的场景中就存在安全风向了，如支付，使用普通的Http协议就会被黑客盯上。通过拦截请求假装自己是服务器，让你输入密码等。解决这种问题的思路是对数据加密，加密方式分两种：</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>在对称加密中，加密解密都使用相同的秘钥，因此秘钥的保密工作需要做好，只能给使用的人知道,存在问题</p><ul><li>秘钥的约定时机，秘钥通过互联网传输一样会被黑客截获</li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>加密和解密使用的秘钥不相同。分公钥和私钥，且公钥加密只能私钥解密，反之亦然。对称加密会存在秘钥约定十几的问题，所以需要非对称加密介入。将非对称加密的公钥公开，私钥自己保留。同样存在问题</p><ul><li>服务器的回复数据，黑客可以通过公钥解密，且黑客也可以模拟发送请求，所以一对公钥私钥不够，客户端同样需要有自己的公钥和私钥，并且客户端的公钥给服务端<a id="more"></a></li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>对称加密的算法比分对称加密的算法效率高性能也好，大多数场景都是用对称加密</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>非对称加密也存在同样的问题，如何将不对称的公钥给对方。一种是放在公网地址上，让对方下载；二是建立链接的时候传给对方。存在问题：</p><ul><li>如何鉴别别人发给你的公钥是对的，而不是冒充的<br>通过权威机构(CA)部门的证书，证书里面包括公钥还要发布者的信息及发布机构，证书有效期等，如身份证一样的存在。证书的签名算法即ＣＡ的私钥,给公司的公钥加密。所有用户在网站上得到的是一个证书，你只要得到ＣＡ的公钥去解密签名就能得到公司的公钥了。关于ＣＡ公钥的可靠性，则需要更加权威的机构证实。</li></ul><h4 id="Https的工作模式"><a href="#Https的工作模式" class="headerlink" title="Https的工作模式"></a>Https的工作模式</h4><p>非对称加密性能不及对称加密，通过非对称加密只对对称加密的秘钥进行加密码，而真正通讯的传输数据则通过对称加密的秘钥进行加解密。过程<br><img width="200" src="/images/lADPDgQ9q4pv-gfNBLbNAuA_736_1206.jpg"></p><ol><li>客户端发送Client Hello 到服务器,会以明文传输TLS版本信息，加密套件候选列表，压缩算法列表等信息，还有一个随机数，在协商对称秘钥的时候使用</li><li>服务器返回Server Hello消息，告诉客户端服务器所选的协议版本，加密套件和压缩算法等，还有一个随机数，用于后续秘钥协商</li><li>服务器发送证书</li><li>客户端从CA仓库里的公钥去解密证书，成功则可信任获得了服务器的公钥。最后客户端产生一个随机数，用服务器公钥加密发送给服务端</li><li>客户端接收到Client Key Exchange,通过私钥解密。最后协商出对称加密的秘钥为客户端的随机数+服务端的随机数+Pre-master产生与客户端相同的对称秘钥</li><li>客户端和服务端通过协商的对称秘钥进行通讯</li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>对称加密的效率比非对称加密高，但无法解决了秘钥传输的问题。非对称加密可以解决这个问题，但是效率不高</li><li>非对称加密需要通过证书合权威机构来验证公钥的合法性</li><li>Https是综合了对称加密合非对称加密算法的Http协议，既保证传输安全，有保证了传输效</li></ul><h3 id="阿里开源项目Alpha启动框架"><a href="#阿里开源项目Alpha启动框架" class="headerlink" title="阿里开源项目Alpha启动框架"></a>阿里开源项目Alpha启动框架</h3><p>是一个基于PERT图构建的异步启动框架，使用简单，高效。<br>在应用启动的时候，我们通常会做很多工作需要，为了提高启动速度，我们尽可能的让这些工作并发进行。但这些工作可能存在前后依赖关系，所以我们需要想办法保证执行顺序的正确性。</p><h4 id="PERT"><a href="#PERT" class="headerlink" title="PERT"></a>PERT</h4><p>即计划评审技术，利用网络分析制定计划以及对计划予以评价的技术。它能调整计划的各道工序，合理安排资源，加速计划进度.</p><h5 id="四个概念"><a href="#四个概念" class="headerlink" title="四个概念"></a>四个概念</h5><ol><li>事件：表示主要活动结束的哪一点</li><li>活动：表示从一个事件到另一个事件之间的过程</li><li>松弛事件：不影响完工前提下可能被推迟完成的最大时间</li><li>关键路线：是PERT中花费时间最长的事件和活动序列</li></ol><h5 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h5><ol><li>构建一个清晰精确的事件活动网络，其中包括时间和资源</li><li>对时间活动进行逻辑排序以确定关键路线</li><li>确定“不确定性”</li><li>计算关键路线和宽裕时间</li></ol><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li>标识出项目的关键路径，以明确项目活动的重点</li><li>对关键步骤进行资源调度及优化</li><li>资源发生矛盾时，通过调度非关键路径资源，保证项目进度</li><li>通过PERT网络分析法可大大缩短项目完成的时间</li></ol><h4 id="在軟件设计的应用"><a href="#在軟件设计的应用" class="headerlink" title="在軟件设计的应用"></a>在軟件设计的应用</h4><ol><li>软件的模块化，不同业务线并行开发</li><li>应用插件化，使宿主与插件分开编译，提高编译速度</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Https的用途和工作模式&quot;&gt;&lt;a href=&quot;#Https的用途和工作模式&quot; class=&quot;headerlink&quot; title=&quot;Https的用途和工作模式&quot;&gt;&lt;/a&gt;Https的用途和工作模式&lt;/h3&gt;&lt;p&gt;用Http协议看新闻没什么问题，但换到严肃的场景中就存在安全风向了，如支付，使用普通的Http协议就会被黑客盯上。通过拦截请求假装自己是服务器，让你输入密码等。解决这种问题的思路是对数据加密，加密方式分两种：&lt;/p&gt;
&lt;h4 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h4&gt;&lt;p&gt;在对称加密中，加密解密都使用相同的秘钥，因此秘钥的保密工作需要做好，只能给使用的人知道,存在问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;秘钥的约定时机，秘钥通过互联网传输一样会被黑客截获&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;非对称加密&quot;&gt;&lt;a href=&quot;#非对称加密&quot; class=&quot;headerlink&quot; title=&quot;非对称加密&quot;&gt;&lt;/a&gt;非对称加密&lt;/h4&gt;&lt;p&gt;加密和解密使用的秘钥不相同。分公钥和私钥，且公钥加密只能私钥解密，反之亦然。对称加密会存在秘钥约定十几的问题，所以需要非对称加密介入。将非对称加密的公钥公开，私钥自己保留。同样存在问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器的回复数据，黑客可以通过公钥解密，且黑客也可以模拟发送请求，所以一对公钥私钥不够，客户端同样需要有自己的公钥和私钥，并且客户端的公钥给服务端
    
    </summary>
    
      <category term="日记" scheme="http://yangxin.online/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Https" scheme="http://yangxin.online/tags/Https/"/>
    
      <category term="日记" scheme="http://yangxin.online/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Gradle学习</title>
    <link href="http://yangxin.online/Gradle%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://yangxin.online/Gradle学习.html</id>
    <published>2019-08-02T01:23:14.000Z</published>
    <updated>2019-08-03T14:31:38.648Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Gradle"><a href="#什么是Gradle" class="headerlink" title="什么是Gradle"></a>什么是Gradle</h4><p>Gradle是一个开源的，非常灵活的自动化构建工具，具有以下几大特点：</p><ol><li>高性能:只执行定义的任务，可以复用任务的输入输出，避免不必要的执行</li><li>基于JVM:可以利用java，Kotlin,Groovy等编译器支持的语言</li><li>定制了基础框架，便于构建</li><li>扩展性：可以自定义任务</li><li>编辑器的支持</li></ol><h4 id="设计Gradle插件"><a href="#设计Gradle插件" class="headerlink" title="设计Gradle插件"></a>设计Gradle插件</h4><h5 id="1-总体架构"><a href="#1-总体架构" class="headerlink" title="1. 总体架构"></a>1. 总体架构</h5><ol><li>提取可用的逻辑编写成二进制插件</li><li>插件对性能的影响</li><li>定制规范，减少配置</li><li>将功能与规范隔离</li></ol><h5 id="2-技术"><a href="#2-技术" class="headerlink" title="2. 技术"></a>2. 技术</h5><ol><li>使用静态语言编写插件</li><li>尽量通过Gradle内部的ApI实现插件<br>2.3 减少外部依赖</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是Gradle&quot;&gt;&lt;a href=&quot;#什么是Gradle&quot; class=&quot;headerlink&quot; title=&quot;什么是Gradle&quot;&gt;&lt;/a&gt;什么是Gradle&lt;/h4&gt;&lt;p&gt;Gradle是一个开源的，非常灵活的自动化构建工具，具有以下几大特点：&lt;/p&gt;
&lt;o
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OkHttp</title>
    <link href="http://yangxin.online/OkHttp.html"/>
    <id>http://yangxin.online/OkHttp.html</id>
    <published>2019-05-20T15:02:01.000Z</published>
    <updated>2019-05-28T15:12:54.624Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-曾经的网络框架"><a href="#一-曾经的网络框架" class="headerlink" title="一. 曾经的网络框架"></a>一. 曾经的网络框架</h4><h5 id="Android的网络框架有四种"><a href="#Android的网络框架有四种" class="headerlink" title="Android的网络框架有四种"></a>Android的网络框架有四种</h5><ol><li>HttpClient ： 2.2版本以下存在bug，所以2.3之后建议使用HttpUrlConnection</li><li>HttpUrlConnection 2.3+， 官方推荐</li><li>Volley，谷歌开发，简单的网络任务框架，底层兼容2.3以前版本使用了HttpClient，2.3+使用的是HttpUrlConnection，功能拓展性弱</li><li>Okhttp，从Android4.4开始HttpURLConnection的底层实现采用的是okHttp.</li></ol><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><img src="/image/compare.png" alt=""><br>通过上面的比较，在Android发展的每个阶段，他们有各自存在的意义，只是时过境迁，被种种原因被替换或者废弃。<br>这个过程是一个框架发展的过程，从重量级繁杂且难以维护，到轻量级易扩展，到过度版本新老版本的兼容，最后取长补短完善自己的网络框架。<br>化繁为简，然后又能包容万象的过程</p><h5 id="网络框架应该有的功能"><a href="#网络框架应该有的功能" class="headerlink" title="网络框架应该有的功能"></a>网络框架应该有的功能</h5><ol><li>自定义请求的Header</li><li>GET，POST</li><li>支持文件上传下载</li><li>图片加载</li><li>支持多任务网络请求操作</li><li>支持缓存</li><li>支持回调</li><li>支持session</li><li>…..</li></ol><h4 id="二-OkHttp简介"><a href="#二-OkHttp简介" class="headerlink" title="二. OkHttp简介"></a>二. OkHttp简介</h4><p>一张图了解OkHttp的整个过程<br><img src="/image/OkHttp.jpg" alt=""><br>在OkHttp中真正核心的东西是Interceptor，他不仅负责拦截请求进行额外的处理(入cookie)，实际上他还会把实际的网络请求，缓存，透明压缩等功能都统一起来，每一个功能都只是一个Interceptor，它们在连接成一个Interceptor.Chain,环环相扣最终完成一次网络请求，从getResponseWithInterceptorChain函数中我们可以看到Interceptor.Chain的分布情况依次是：</p><ol><li>在配置OkHttpClinet时设置的interceptors</li><li>负责失败重试和重定向的RetryAndFollowUpInterceptor</li><li>负责把用户构造的请求转化为发送到服务器的请求，把服务器返回的响应转化为用户友好的响应BridgeInterceptor</li><li>负责读取缓存直接返回，更新缓存的CacheInterceptor</li><li>负责和服务器建立连接的ConnectInterceptor</li><li>配置OkHttpClient时设置的NetworkInterceptor</li><li>负责向服务器发送请求数据，从服务器读取响应数据的CallServerInterceptor</li></ol><p>在这里位置决定了功能，最后一个一定是CallServerInterceptor，其他的在这之前。责任链模式在Interceptor中得到了很好的实践。对于request变成response对象，每个interceptor都能完成这件事，也由各自的inteceptor决定是否要交给下个interceptor。</p><h4 id="三-Interceptor分析"><a href="#三-Interceptor分析" class="headerlink" title="三. Interceptor分析"></a>三. Interceptor分析</h4><p>首先看分析ConnectInterceptor和CallServerInterceptor，这两个interceptor实现了和服务器进行通信的核心</p><h5 id="1-ConnectInterceptor建立连接"><a href="#1-ConnectInterceptor建立连接" class="headerlink" title="1. ConnectInterceptor建立连接"></a>1. ConnectInterceptor建立连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** Opens a connection to the target server and proceeds to the next interceptor. */</span><br><span class="line"></span><br><span class="line">  @Override </span><br><span class="line">  public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">    boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, transmitter, exchange);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过创建一个Exchange对象，他将在后面使用。他的内部是对http，https请求的实现，内部都是利用Okio对Socket的读写操作进行了封装.在内部是对java.io和java.nio进行了封装，内部创建了一个主要的RealConnectionn对象，利用RealConnectionn进行读写</p><h5 id="2-CallServerInterceptor-发送和接受数据"><a href="#2-CallServerInterceptor-发送和接受数据" class="headerlink" title="2. CallServerInterceptor 发送和接受数据"></a>2. CallServerInterceptor 发送和接受数据</h5><p>主要过程：</p><ol><li>向服务器发送request header</li><li>如果有request body,就向服务器发送</li><li>读取response header, 构造response 对象</li><li>如果有response body,则创建一个带body的response对象</li></ol><h5 id="3-CacheIntercepter-缓存"><a href="#3-CacheIntercepter-缓存" class="headerlink" title="3. CacheIntercepter 缓存"></a>3. CacheIntercepter 缓存</h5><p>在建立连接，和服务器通讯之前就是CacheIntercepter，我们需要检查响应是否已经本地缓存了，如果缓存了则直接返回，否则进行后面的流程，并把返回的数据写入缓存</p><ol><li>获取本地缓存cacheCandidate</li><li>如果本地缓存可用则直接返回CacheCandidate，从而打断interceptor链</li><li>走剩下的interceptor获取nnetworkResponse</li><li>networkResponse、cacheResponse构造新的response</li><li>根据新的response里的header定制缓存策略，存入缓存中（method 为get）</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>创建一个单例的OkHttpClient，创建请求对象request，初始化请求方式，请求url，请求header，请求body，然后通过client的newcall（request）构建真正的请求对象realcall。有realcall的execute方法和qnqueue方法区分是同步请求还是异步请求，异步请求依赖线程池dispatcher，最终会调用getResponseWithInterceptorsChain方法返回返回response。内部通过这种拦截器对request请求数据和response响应数据进行处理，每个拦截器直接通过realinterceptchain对象的process连接起来（责任链模式）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-曾经的网络框架&quot;&gt;&lt;a href=&quot;#一-曾经的网络框架&quot; class=&quot;headerlink&quot; title=&quot;一. 曾经的网络框架&quot;&gt;&lt;/a&gt;一. 曾经的网络框架&lt;/h4&gt;&lt;h5 id=&quot;Android的网络框架有四种&quot;&gt;&lt;a href=&quot;#Android的
      
    
    </summary>
    
    
      <category term="网络，Okhttp" scheme="http://yangxin.online/tags/%E7%BD%91%E7%BB%9C%EF%BC%8COkhttp/"/>
    
  </entry>
  
  <entry>
    <title>二维火火种培训</title>
    <link href="http://yangxin.online/%E4%BA%8C%E7%BB%B4%E7%81%AB%E7%81%AB%E7%A7%8D%E5%9F%B9%E8%AE%AD.html"/>
    <id>http://yangxin.online/二维火火种培训.html</id>
    <published>2018-06-21T11:51:43.000Z</published>
    <updated>2018-07-04T05:52:30.547Z</updated>
    
    <content type="html"><![CDATA[<p>毕业在即，我也在二维火实习了近半年时间，随着对产品和公司的了解我决定将继续留在公司学习，想在未来的某一天看着自己参与或者做的项目投入市场，得到大家的认可。</p><h3 id="火种培训"><a href="#火种培训" class="headerlink" title="火种培训"></a>火种培训</h3><p>火种：二维火的种子（实习生），年轻，活力。星星之火可以燎原。</p><h3 id="第一天-2018-6-20"><a href="#第一天-2018-6-20" class="headerlink" title="第一天 2018/6/20"></a>第一天 2018/6/20</h3><ul><li>红烧肉：产品研发负责人《开篇介绍》<br>给我们介绍了公司的使命，愿景，价值观等。聊了聊公司的发展历程以及在公司多年来的经历，给了我们一些切身的建议：每个月看书，写日记 todolist等</li><li>人参果：产品委员会主席《公司产品介绍》<br>细致的讲述了公司的价值观：正直善良，敬畏之心，天道酬情！<br>讲述了公司在10几年间，产品的迭代更替以及公司的主要产品线（排队，扫码点餐，厨房KDS，收银，供应链，掌柜等等）<a id="more"></a></li></ul><h3 id="第二天-2018-6-21"><a href="#第二天-2018-6-21" class="headerlink" title="第二天 2018/6/21"></a>第二天 2018/6/21</h3><ul><li>生抽：交易架构师《高并发下的变成》<br>介绍了Java并发编程的基础，以及交易订单的一些具体场景，如何避免并发导致的数据同步问题。还介绍了锁的应用等等</li><li>小米：项目管理主管《流程规范&amp;项目管理》<br>详细介绍了项目的具体含义：一群人为达到某一目标而做某一件事。<br>告诉我们项目即输入物-〉输出物<br>项目的整个流程等</li></ul><h3 id="第三天-2018-6-22"><a href="#第三天-2018-6-22" class="headerlink" title="第三天 2018/6/22"></a>第三天 2018/6/22</h3><ul><li>四季豆：共享业务总监《二维火服务端技术架构》<br>介绍了千亿级别服务架构的演变过程，从一个点子，几个人快速的做了一个东西推向市场，产品使用量上升，服务器资源有限，添加服务器，负载均衡，缓存设计，业务模块拆封等等</li><li>马宝：供应链客户经理《客户端架构》<br>介绍了Android的一些历史及在二维火中的一些具体应用，同时分享了很多有趣的程序员日常。最后一句，8小时的生存，other 生活！</li></ul><p>上了7天请假两天参加毕业典礼</p><p>pm开放平台项目</p><h3 id="确定项目角色，流程角色及职责"><a href="#确定项目角色，流程角色及职责" class="headerlink" title="确定项目角色，流程角色及职责"></a>确定项目角色，流程角色及职责</h3><ol><li>项目经理：简称PM，项目中职责为主导项目全体成员按照项目计划执行，完成项目目标，管控项目的全过程；善于风险识别及跟踪问题解决。更侧重于项目过程中的沟通协作，会议组织，里程碑进度把控，组织过程资产归档，对外汇报等工作。</li><li>需求经理：简称DM，负责收集各类需求，整理分析后列入禅道的需求池，对接PD推动需求的实现。</li><li>产品经理：简称PD，细化需求制作市场需求文档（简称MRD）；明确项目需求范围边界值，编写产品说明书（简称PRD），协同交互，视觉完善PRD正式版。跟踪产品验收。 立项初始，判定此项目是否为重点业务型项目。</li><li>视觉设计师：简称UI，实现PD的页面需求，将其可视化。视觉稿需通过视觉评审。协同PD确认最终界面符合视觉设计稿。 </li><li>技术经理：简称TM，项目中职责为担任技术总负责，把控项目整体技术方案可行；重点跟进架构设计阶段，开发阶段及发布阶段的具体执行。更侧重于项目过程中的任务计划评估，技术难题解决，代码质量把控，发布管理跟踪等工作。</li><li>开发人员：客户端及服务端的代码实现者。完成编码后的自测，联调，根据冒烟用例进行冒烟测试。</li><li>测试人员：质量的把关者。需要根据测试用例，担当内部测试，接口测试、预发后测试，线上回归测试等。</li><li>配置管理员：简称SCM，进行版本控制，协助完成项目环境配置。</li><li>运维人员：简称SA，提供项目环境（开发、测试环境），评审发布计划，协助发布等。</li><li><p>数据库管理员：简称DBA，主要负责产品研发中心所有数据库的运营和维护，评审SQL等。</p></li><li><p>业务线技术TL：各业务线技术负责人。主要负责立项时候判定项目是否重点技术项目。</p></li><li>架构委员会：由高级架构师，核心应用owner们及业务线技术负责人组成的技术架构组织。如有技术型项目启动时，负责判定项目是否为重点技术型项目。</li><li>产品架构委员会：简称PDM，在项目执行过程中主要负责参与二维火核心产品业务的MRD&amp;PRD评审，以及上线后产品目标的验收。</li></ol><h3 id="立项会"><a href="#立项会" class="headerlink" title="立项会"></a>立项会</h3><p>产品组织，项目经理结果通知</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毕业在即，我也在二维火实习了近半年时间，随着对产品和公司的了解我决定将继续留在公司学习，想在未来的某一天看着自己参与或者做的项目投入市场，得到大家的认可。&lt;/p&gt;
&lt;h3 id=&quot;火种培训&quot;&gt;&lt;a href=&quot;#火种培训&quot; class=&quot;headerlink&quot; title=&quot;火种培训&quot;&gt;&lt;/a&gt;火种培训&lt;/h3&gt;&lt;p&gt;火种：二维火的种子（实习生），年轻，活力。星星之火可以燎原。&lt;/p&gt;
&lt;h3 id=&quot;第一天-2018-6-20&quot;&gt;&lt;a href=&quot;#第一天-2018-6-20&quot; class=&quot;headerlink&quot; title=&quot;第一天 2018/6/20&quot;&gt;&lt;/a&gt;第一天 2018/6/20&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;红烧肉：产品研发负责人《开篇介绍》&lt;br&gt;给我们介绍了公司的使命，愿景，价值观等。聊了聊公司的发展历程以及在公司多年来的经历，给了我们一些切身的建议：每个月看书，写日记 todolist等&lt;/li&gt;
&lt;li&gt;人参果：产品委员会主席《公司产品介绍》&lt;br&gt;细致的讲述了公司的价值观：正直善良，敬畏之心，天道酬情！&lt;br&gt;讲述了公司在10几年间，产品的迭代更替以及公司的主要产品线（排队，扫码点餐，厨房KDS，收银，供应链，掌柜等等）
    
    </summary>
    
      <category term="二维火" scheme="http://yangxin.online/categories/%E4%BA%8C%E7%BB%B4%E7%81%AB/"/>
    
    
      <category term="JOb" scheme="http://yangxin.online/tags/JOb/"/>
    
      <category term="二维火" scheme="http://yangxin.online/tags/%E4%BA%8C%E7%BB%B4%E7%81%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android IPC</title>
    <link href="http://yangxin.online/Android-IPC.html"/>
    <id>http://yangxin.online/Android-IPC.html</id>
    <published>2018-03-31T02:39:30.000Z</published>
    <updated>2018-04-22T06:55:24.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android跨进程通讯的几种方式"><a href="#Android跨进程通讯的几种方式" class="headerlink" title="Android跨进程通讯的几种方式"></a>Android跨进程通讯的几种方式</h3><h4 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h4><p>  Bundle实现了Parcelable，方便在进程中传输数据。主要在activity、service、receiver中Intent中应用，</p><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>Android基于Linux，对文件的读写没有限制。存在的问题就是并发读写的问题<br>sp存在缓存策略，内存中存在备份，导致多进程不可靠</p><h4 id="使用messenger信使"><a href="#使用messenger信使" class="headerlink" title="使用messenger信使"></a>使用messenger信使</h4><ol><li>Messenger可以在不同的进程中传递Message对象，轻松实现数据的跨进程通讯。</li><li>它的底层实现是AIDl，内部一次只做一次处理，因此服务端不用考虑线程同步的问题</li><li>缺点是只能用来简单的信息传递，并发请求不大合适且无法不支持跨进程的方法的调用<br><img src="http://opd2n5pxb.bkt.clouddn.com/Messenger%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Alt text" title="Messenger 工作原理图"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android跨进程通讯的几种方式&quot;&gt;&lt;a href=&quot;#Android跨进程通讯的几种方式&quot; class=&quot;headerlink&quot; title=&quot;Android跨进程通讯的几种方式&quot;&gt;&lt;/a&gt;Android跨进程通讯的几种方式&lt;/h3&gt;&lt;h4 id=&quot;Bundl
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yangxin.online/tags/Android/"/>
    
      <category term="进程通讯" scheme="http://yangxin.online/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>RxJava的使用及源码分析</title>
    <link href="http://yangxin.online/RxJava%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"/>
    <id>http://yangxin.online/RxJava的使用及源码分析.html</id>
    <published>2018-03-18T07:25:44.000Z</published>
    <updated>2018-03-27T12:50:09.970Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于Rxjava-2-1-10版本源码分析"><a href="#基于Rxjava-2-1-10版本源码分析" class="headerlink" title="基于Rxjava-2.1.10版本源码分析"></a>基于Rxjava-2.1.10版本源码分析</h3><p>从开源文档范例开始分析</p><h4 id="范例一-Flowable-just输出HelloWord"><a href="#范例一-Flowable-just输出HelloWord" class="headerlink" title="范例一.Flowable.just输出HelloWord"></a>范例一.Flowable.just输出HelloWord</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(&quot;Hello world&quot;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>1.从just方法开始,首先可以看到三个注解方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@CheckReturnValue  //检查返回值</span><br><span class="line">@BackpressureSupport(BackpressureKind.FULL)  //支持的背压方式</span><br><span class="line">@SchedulerSupport(SchedulerSupport.NONE) //调度方式,即处理事件的方式IO数据流，新开一个线程等。</span><br><span class="line">public static &lt;T&gt; Flowable&lt;T&gt; just(T item) &#123; //方法参数是个泛型，</span><br><span class="line">    ObjectHelper.requireNonNull(item, &quot;item is null&quot;);</span><br><span class="line">    //返回值是个Flowable对象</span><br><span class="line">    return RxJavaPlugins.onAssembly(new FlowableJust&lt;T&gt;(item)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>2.方法第一行是判空操作在很多地方都使用到了，查看方法不为空则返回原对象，否则，抛出异常NullPointerException<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T requireNonNull(T object, String message) &#123;</span><br><span class="line">        if (object == null) &#123;</span><br><span class="line">            throw new NullPointerException(message);</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>3.方法第三行中的看new FlowableJust<t>(item)创建的实例对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class FlowableJust&lt;T&gt; extends Flowable&lt;T&gt; implements ScalarCallable&lt;T&gt; &#123;</span><br><span class="line">    private final T value; //final变量，赋值后不能改变</span><br><span class="line">    public FlowableJust(final T value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    //重写了Flowable的subscribeActual方法，传入了观察者与发射内容构造一个订阅对象</span><br><span class="line">    //由观察者去订阅这个对象</span><br><span class="line">    @Override</span><br><span class="line">    protected void subscribeActual(Subscriber&lt;? super T&gt; s) &#123;</span><br><span class="line">        s.onSubscribe(new ScalarSubscription&lt;T&gt;(s, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>4.然后看RxJavaPlugins.onAssembly()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span><br><span class="line">    @NonNull</span><br><span class="line">    public static &lt;T&gt; Flowable&lt;T&gt; onAssembly(@NonNull Flowable&lt;T&gt; source) &#123;</span><br><span class="line">        //在这里钩子函数为null，即直接返回source</span><br><span class="line">        Function&lt;? super Flowable, ? extends Flowable&gt; f = onFlowableAssembly;</span><br><span class="line">        if (f != null) &#123;</span><br><span class="line">            return apply(f, source);</span><br><span class="line">        &#125;</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>5.所以Flowable.just(“Hello world”)只是生成了一个Flowable对象。接着看subscribe()方法。实现了Consumer接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 回调函数accept去消费这个传入值，</span><br><span class="line">     * Consume the given value.</span><br><span class="line">     * @param t the value</span><br><span class="line">     * @throws Exception on error</span><br><span class="line">     */</span><br><span class="line">    void accept(T t) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.接着看subscribe()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@CheckReturnValue</span><br><span class="line">@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)</span><br><span class="line">@SchedulerSupport(SchedulerSupport.NONE)</span><br><span class="line">public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;</span><br><span class="line">    //onNext即要去消费的接口对象</span><br><span class="line">    //其他传入参数为默认的onError，onComplete接口回调，和最大数量的订阅对象</span><br><span class="line">    return subscribe(onNext, Functions.ON_ERROR_MISSING,</span><br><span class="line">            Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7.然后去看第二个subscribe()内部方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@CheckReturnValue</span><br><span class="line">@BackpressureSupport(BackpressureKind.SPECIAL)</span><br><span class="line">@SchedulerSupport(SchedulerSupport.NONE)</span><br><span class="line">public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,</span><br><span class="line">        Action onComplete, Consumer&lt;? super Subscription&gt; onSubscribe) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);</span><br><span class="line">    ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span><br><span class="line">    ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</span><br><span class="line">    ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span><br><span class="line"></span><br><span class="line">    //上面一系列的判空操作之后，将传入参数组合成一个LambdaSubscriber</span><br><span class="line">    LambdaSubscriber&lt;T&gt; ls = new LambdaSubscriber&lt;T&gt;(onNext, onError, onComplete, onSubscribe);</span><br><span class="line"></span><br><span class="line">    //调用了第三个subscribe方法</span><br><span class="line">    subscribe(ls);</span><br><span class="line"></span><br><span class="line">    return ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>8、先来看一下LambdaSubscriber对象，除了对传入参数赋值之外，内部重写了熟悉的onSubscribe、onNext()、onError()、onComplete()三个方法。从6.可以看出在这四个方法中除了onNext()是我们传入的，其他都是框架默认的。源码过长，不copy了。<br>9.接着继续看第三个subscribe(ls)方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@BackpressureSupport(BackpressureKind.SPECIAL)</span><br><span class="line">@SchedulerSupport(SchedulerSupport.NONE)</span><br><span class="line">@Beta</span><br><span class="line">public final void subscribe(FlowableSubscriber&lt;? super T&gt; s) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(s, &quot;s is null&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 传入当前要观察的对象和处理方法对象构建了一个观察者对象</span><br><span class="line">        Subscriber&lt;? super T&gt; z = RxJavaPlugins.onSubscribe(this, s);</span><br><span class="line"></span><br><span class="line">        ObjectHelper.requireNonNull(z, &quot;Plugin returned null Subscriber&quot;);</span><br><span class="line"></span><br><span class="line">        //在这传入一个观察者对象</span><br><span class="line">        subscribeActual(z);</span><br><span class="line">    &#125; catch (NullPointerException e) &#123; // NOPMD</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        // can&apos;t call onError because no way to know if a Subscription has been set or not</span><br><span class="line">        // can&apos;t call onSubscribe because the call might have set a Subscription already</span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">        NullPointerException npe = new NullPointerException(&quot;Actually not, but can&apos;t throw other exceptions due to RS&quot;);</span><br><span class="line">        npe.initCause(e);</span><br><span class="line">        throw npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>10.接着看subscribeActual(),似曾相识在3.中FlowableJust重写了父类的subscribeActual()方法，所以最后有回来了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void subscribeActual(Subscriber&lt;? super T&gt; s) &#123;</span><br><span class="line">    //1.传入观察者对象和要发射的值创建了一个标量的订阅对象</span><br><span class="line">    //2.观察者对象订阅了这个标量的订阅对象</span><br><span class="line">    s.onSubscribe(new ScalarSubscription&lt;T&gt;(s, value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>11.先看ScalarSubscription方法，可以看到当调用了request(n)的方法时onNext方法就会被调用,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ScalarSubscription(Subscriber&lt;? super T&gt; subscriber, T value) &#123;</span><br><span class="line">    this.subscriber = subscriber;</span><br><span class="line">    this.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request(long n) &#123;</span><br><span class="line">    if (!SubscriptionHelper.validate(n)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (compareAndSet(NO_REQUEST, REQUESTED)) &#123;</span><br><span class="line">        Subscriber&lt;? super T&gt; s = subscriber;</span><br><span class="line">        //这里就是LambdaSubscriber中的onNext，也是我们传入的onNext会去回调的地方</span><br><span class="line">        s.onNext(value);</span><br><span class="line">        if (get() != CANCELLED) &#123;</span><br><span class="line">            s.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>12.所以我们要看request()在哪里调用，接着看继续看s.onSubscribe()方法，它就是LambdaSubscriber中的onSubscribe()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onSubscribe(Subscription s) &#123;</span><br><span class="line">    if (SubscriptionHelper.setOnce(this, s)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //onSubscribe对象是在3.中传入的FlowableInternalHelper.RequestMax.INSTANCE，并调用了accept方法</span><br><span class="line">            onSubscribe.accept(this);</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            s.cancel();</span><br><span class="line">            onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.接着继续看FlowableInternalHelper.RequestMax.INSTANCE。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum RequestMax implements Consumer&lt;Subscription&gt; &#123;</span><br><span class="line">    //枚举法创建的单例</span><br><span class="line">    INSTANCE;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Subscription t) throws Exception &#123;</span><br><span class="line">        //可以看到在这里调用了request方法</span><br><span class="line">        t.request(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>14.接着可以回到11.ScalarSubscription类中，在request方法中就调用了LambdaSubscriber的onNext*()方法并传入了value值<br>15.接着再去看LambdaSubscriber类中的onNext方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onNext(T t) &#123;</span><br><span class="line">        if (!isDisposed()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //在这里回调了我们当初我们传入的实现对象onNext的accept方法，</span><br><span class="line">                onNext.accept(t);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(e);</span><br><span class="line">                get().cancel();</span><br><span class="line">                onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>16.走完onNext方法后，继续看11.它会继续走s.onComplete()方法，这个方法也是默认的Functions.EMPTY_ACTION<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class EmptyAction implements Action &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123; </span><br><span class="line">            //空方法</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;EmptyAction&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>17.至于onError方法会14.在onNext()发生异常时去调用，且在这里也是默认传入的Functions.ON_ERROR_MISSING<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final class OnErrorMissingConsumer implements Consumer&lt;Throwable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Throwable error) &#123;</span><br><span class="line">        RxJavaPlugins.onError(new OnErrorNotImplementedException(error));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext-进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式"><a href="#最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext-进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式" class="headerlink" title="最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext()进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式"></a>最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext()进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基于Rxjava-2-1-10版本源码分析&quot;&gt;&lt;a href=&quot;#基于Rxjava-2-1-10版本源码分析&quot; class=&quot;headerlink&quot; title=&quot;基于Rxjava-2.1.10版本源码分析&quot;&gt;&lt;/a&gt;基于Rxjava-2.1.10版本源码分析&lt;/h3&gt;&lt;p&gt;从开源文档范例开始分析&lt;/p&gt;
&lt;h4 id=&quot;范例一-Flowable-just输出HelloWord&quot;&gt;&lt;a href=&quot;#范例一-Flowable-just输出HelloWord&quot; class=&quot;headerlink&quot; title=&quot;范例一.Flowable.just输出HelloWord&quot;&gt;&lt;/a&gt;范例一.Flowable.just输出HelloWord&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Flowable.just(&amp;quot;Hello world&amp;quot;).subscribe(new Consumer&amp;lt;String&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void accept(String s) throws Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;1.从just方法开始,首先可以看到三个注解方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@CheckReturnValue  //检查返回值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@BackpressureSupport(BackpressureKind.FULL)  //支持的背压方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@SchedulerSupport(SchedulerSupport.NONE) //调度方式,即处理事件的方式IO数据流，新开一个线程等。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static &amp;lt;T&amp;gt; Flowable&amp;lt;T&amp;gt; just(T item) &amp;#123; //方法参数是个泛型，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ObjectHelper.requireNonNull(item, &amp;quot;item is null&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //返回值是个Flowable对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return RxJavaPlugins.onAssembly(new FlowableJust&amp;lt;T&amp;gt;(item)); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="RxJava" scheme="http://yangxin.online/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Java反射那些事</title>
    <link href="http://yangxin.online/Java%E5%8F%8D%E5%B0%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html"/>
    <id>http://yangxin.online/Java反射那些事.html</id>
    <published>2018-01-29T03:05:10.000Z</published>
    <updated>2018-04-22T06:55:27.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射机制的定义"><a href="#反射机制的定义" class="headerlink" title="反射机制的定义"></a>反射机制的定义</h2><p>在运行状态期间，能过动态的知道一个类的属性和方法，能够动态的调用一个对象的属性和方法的功能。</p><h2 id="反射机制的功能"><a href="#反射机制的功能" class="headerlink" title="反射机制的功能"></a>反射机制的功能</h2><p>在运行期间</p><ol><li>判断任意一个对象所属的类</li><li>构建任意一个类的对象</li><li>判断任意一个类的属性和方法</li><li>调用任意一个对象的方法</li><li>生成动态代理<a id="more"></a><h2 id="反射机制的应用场景"><a href="#反射机制的应用场景" class="headerlink" title="反射机制的应用场景"></a>反射机制的应用场景</h2></li><li>逆向代码，反编译</li><li>与注解相结合的框架，retrofit</li><li>单纯的反射机制框架，EventBus</li><li>动态生成类框架，Gson</li></ol><h2 id="通过反射获取类信息"><a href="#通过反射获取类信息" class="headerlink" title="通过反射获取类信息"></a>通过反射获取类信息</h2><p>每个类被加载后，系统会为该类生成一个对应的Class对象，通过该Class对象就可以访问JVM中的这个类</p><h4 id="在JAVA程序中获得Class对象通常有三种方法"><a href="#在JAVA程序中获得Class对象通常有三种方法" class="headerlink" title="在JAVA程序中获得Class对象通常有三种方法"></a>在JAVA程序中获得Class对象通常有三种方法</h4><ol><li>使用Class类的forName()静态方法,传入全限定名</li><li>调用某个类的class属性 </li><li>通过对象getClass()获取Class对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Classs  class = Class.forName(com.zyx.Person);</span><br><span class="line">2.Class calss = Person.class;</span><br><span class="line">3.Person person = new Person();</span><br><span class="line">Class class = person.getClass();</span><br></pre></td></tr></table></figure></li></ol><h4 id="获取class对象的属性、方法、构造函数"><a href="#获取class对象的属性、方法、构造函数" class="headerlink" title="获取class对象的属性、方法、构造函数"></a>获取class对象的属性、方法、构造函数</h4><ol><li><p>获取class对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] allFields = class.getDeclaredFileds();// 获取所有声明的属性</span><br><span class="line">Filed[] publicFileds = calss.getFields[]; //获取所有public属性</span><br><span class="line">Field ageField = class.getDeclaredFiled(&quot;age&quot;);// 获取指定声明的属性</span><br><span class="line">Filed desFiled = calss.getField(&quot;age&quot;); //获取指定public属性</span><br></pre></td></tr></table></figure></li><li><p>获取class对象的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = class.getDeclaredMethods();// 获取所有声明的方法</span><br><span class="line">Method[] publicFileds = calss.getMethods[]; //获取所有public方法，</span><br><span class="line">Method[] publicFileds = calss.getMethods[]; //获取所有public方法，带指定形参列表的方法</span><br><span class="line">Method method= class.getDeclaredMethods(&quot;info&quot;,String.class);// 获取指定声明的方法，</span><br><span class="line">Method infoMethod = calss.getMethod(&quot;info&quot;,String.class); //获取指定public方法,带指定形参列表的方法</span><br></pre></td></tr></table></figure></li><li><p>获取class对象的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor</span><br></pre></td></tr></table></figure></li></ol><h4 id="通过Java反射生成并操作对象"><a href="#通过Java反射生成并操作对象" class="headerlink" title="通过Java反射生成并操作对象"></a>通过Java反射生成并操作对象</h4><p><strong>生成实例</strong></p><ol><li>使用Class对象的newInstance()方法来创建Class对象对应的实例，但对应类必须有默认的构造函数</li><li>先使用Class的对象获取指定的Constructor对象，在调用Constructor对象的newInstance()方法<br><strong>调用方法</strong></li><li>通过Class对象的getMethods()或者getMethod()获得指定方法，返回Method对象或者数组。</li><li>通过Method对象中的invoke()方法。第一个参数传调用该方法的对象，第二个参数传对应该方法的参数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = class.newInstance();</span><br><span class="line">Method methdo = calss.getDeclareMethod(&quot;setAge&quot;, int.calss);</span><br><span class="line">method.invoke(obj, 28); //会检查调用权限</span><br></pre></td></tr></table></figure></li></ol><p><strong>访问成员变量赋值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = class.newInstance();</span><br><span class="line">Field field = class.getField(&quot;age&quot;);</span><br><span class="line">field.setInt(obj, 28);</span><br><span class="line">int age = field.getInt(obj);</span><br></pre></td></tr></table></figure></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>给某个类提供一个代理对象，并由代理对象控制对原对象的访问，即客户不直接操控原对象，而是通过代理对象操控原对象</p><h4 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h4><ol><li>静态代理，在编译时就实现好了，会生成对应的Class实际文件</li><li>动态代理，在运行时生成，在运行时生成类字节码被加载到JVM中</li></ol><h4 id="代理模式的思路"><a href="#代理模式的思路" class="headerlink" title="代理模式的思路"></a>代理模式的思路</h4><ol><li>代理对象和目标对象均实现同一个行为接口</li><li>代理对象和目标对象分别实现具体接口逻辑</li><li>在代理对像的构造函数中实例化一个目标对象</li><li>在代理对象中调用目标对象的行为接口</li><li>客户端想要调用目标对象的行为接口只能通过代理对象来操作</li></ol><h4 id="Java反射机制和动态代理"><a href="#Java反射机制和动态代理" class="headerlink" title="Java反射机制和动态代理"></a>Java反射机制和动态代理</h4><p><strong>动态代理介绍</strong></p><ol><li>运行时生成代理类，并将代理类的字节码载入当前代理的ClassLoader</li><li>不需要多些多写一个与目标类相同的代理类</li><li>可以在运行时定制代理类的执行逻辑<br><strong>涉及的类</strong></li><li>java.lang.reflect.Proxy,生成代理类的主类，通过Proxy生成的代理类都继承Proxy。Proxy提供了创建动态代理类和代理对象的方法，是所有动态代理类的父类。</li><li>java.lang.reflect.InvacationHandle 调用处理器，当调用动态代理的方法时会直接转到InvocationHandle的invoke()方法</li></ol><h4 id="泛型与Class"><a href="#泛型与Class" class="headerlink" title="泛型与Class"></a>泛型与Class</h4><p>避免强制转换<br>泛型参数化类型 getGenericType();<br>普通类型 getType()</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;反射机制的定义&quot;&gt;&lt;a href=&quot;#反射机制的定义&quot; class=&quot;headerlink&quot; title=&quot;反射机制的定义&quot;&gt;&lt;/a&gt;反射机制的定义&lt;/h2&gt;&lt;p&gt;在运行状态期间，能过动态的知道一个类的属性和方法，能够动态的调用一个对象的属性和方法的功能。&lt;/p&gt;
&lt;h2 id=&quot;反射机制的功能&quot;&gt;&lt;a href=&quot;#反射机制的功能&quot; class=&quot;headerlink&quot; title=&quot;反射机制的功能&quot;&gt;&lt;/a&gt;反射机制的功能&lt;/h2&gt;&lt;p&gt;在运行期间&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断任意一个对象所属的类&lt;/li&gt;
&lt;li&gt;构建任意一个类的对象&lt;/li&gt;
&lt;li&gt;判断任意一个类的属性和方法&lt;/li&gt;
&lt;li&gt;调用任意一个对象的方法&lt;/li&gt;
&lt;li&gt;生成动态代理
    
    </summary>
    
      <category term="Java" scheme="http://yangxin.online/categories/Java/"/>
    
    
      <category term="【反射机制】" scheme="http://yangxin.online/tags/%E3%80%90%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E3%80%91/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型那些事</title>
    <link href="http://yangxin.online/%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B.html"/>
    <id>http://yangxin.online/泛型那些事.html</id>
    <published>2018-01-29T02:06:54.000Z</published>
    <updated>2018-03-12T07:23:21.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型的目的"><a href="#泛型的目的" class="headerlink" title="泛型的目的"></a>泛型的目的</h2><p>语法糖即糖衣语法，这种语法对语言并没有影响，只是方便了程序员的使用。主要包括：泛型，变长参数，条件编译，自动拆装箱，内部类等。虚拟机并不支持这种语法，在编译期就会被还原为基础语法结构，这个过程被称为解语法糖。<br>泛型的目的：通过泛型使得在编译期间完成类型转换工作，避免运行时强制类型转换而出现ClassCastException，类型转换异常<br><a id="more"></a></p><h2 id="泛型初窥"><a href="#泛型初窥" class="headerlink" title="泛型初窥"></a>泛型初窥</h2><p>JDK1.5之后添加<br>泛型的好处</p><ol><li>类型安全，将类型检测挪到了编译期。</li><li>消除了代码中许多的强制类型转换，增强了代码的可读性</li><li>为较大的优化带来了可能<h2 id="泛型使用"><a href="#泛型使用" class="headerlink" title="泛型使用"></a>泛型使用</h2>泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当做类型使用<br>方法声明定义的形参只能在该方法里使用<br>修饰符<t,s> 返回值类型 方法名（形参列表）{<br> 方法体<br>}<h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2></t,s></li><li>任意通配符：？匹配任意的类型，用作读取不能添加</li><li>上限通配符：使用extends关键字指定这个类型必须是继承某个类，或者是实现某个接口（子类或者本身）</li><li>下限通配符：使用super关键字指定这个类型必须是某个类的父类，或者是某个接口的父类</li></ol><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>作用于编译期间，所以运行期间泛型信息是被擦除的，编译后的Class不包含泛型信息。静态方法，静态初始化或者静态变量声明和初始化不允许使用类型形参。也不能使用instance of运算符</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;泛型的目的&quot;&gt;&lt;a href=&quot;#泛型的目的&quot; class=&quot;headerlink&quot; title=&quot;泛型的目的&quot;&gt;&lt;/a&gt;泛型的目的&lt;/h2&gt;&lt;p&gt;语法糖即糖衣语法，这种语法对语言并没有影响，只是方便了程序员的使用。主要包括：泛型，变长参数，条件编译，自动拆装箱，内部类等。虚拟机并不支持这种语法，在编译期就会被还原为基础语法结构，这个过程被称为解语法糖。&lt;br&gt;泛型的目的：通过泛型使得在编译期间完成类型转换工作，避免运行时强制类型转换而出现ClassCastException，类型转换异常&lt;br&gt;
    
    </summary>
    
      <category term="“JAVA”" scheme="http://yangxin.online/categories/%E2%80%9CJAVA%E2%80%9D/"/>
    
    
      <category term="泛型" scheme="http://yangxin.online/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java集合类分析理解</title>
    <link href="http://yangxin.online/Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%88%86%E6%9E%90%E7%90%86%E8%A7%A3.html"/>
    <id>http://yangxin.online/Java集合类分析理解.html</id>
    <published>2018-01-25T09:32:12.000Z</published>
    <updated>2018-04-22T06:55:26.381Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/csdn_terence/article/details/78379878" title="Optional title" target="_blank" rel="external">Java集合面试总结</a></p><h2 id="Collecton-和-Map"><a href="#Collecton-和-Map" class="headerlink" title="Collecton 和 Map"></a>Collecton 和 Map</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>包括 Set List Queue<br><a id="more"></a></p><h4 id="主要分析"><a href="#主要分析" class="headerlink" title="主要分析"></a>主要分析</h4><ol><li><p>ArrayList</p><ul><li>动态数组</li><li>capacity 扩容机制  1.5倍， 初始 java1.8 : 10 ;android 21 :12</li><li>内部元素变动 System.copyarray();</li><li>线程不安全</li></ul></li><li><p>LinkList<br>双向链表<br>Node()函数，该函数以O(1/2)的性能去获取一个节点<br>链表操作<br>线程不安全</p></li><li><p><a href="http://www.importnew.com/20386.html" title="Optional title" target="_blank" rel="external">HashMap</a></p><ul><li>hash()方法 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) able的长度都是2的幂，因此index仅与hash值的低n位有关 <a href="http://blog.csdn.net/fan2012huan/article/details/51097331&quot;Optional title&quot;" target="_blank" rel="external">计算方式</a></li><li>tableSizeFor() 找到大于等于initialCapacity的最小的2的幂</li><li>Node[] tab哈希桶数组.哈希冲突，开放地址和链地址法</li><li>根据key获取哈希桶数组索引位置</li><li>tab 长度为2的幂次</li><li>threshold 所能容纳的key-value对极限</li><li>Map m = Collections.synchronizeMap(hashMap)实现同步</li><li>初始 capacity 16 loadFactor 0.75</li></ul></li><li><p><a href="http://www.iqiyi.com/v_19rro6v558.html?vfm=m_312_shsp" title="Optional title" target="_blank" rel="external">TreeMap</a></p><ul><li>红黑树的定义，节点非红即黑，根节点为黑色，不能连续的红色，任意节点到末端的路径黑色个数相同</li><li>红黑树的平衡调整，颜色和结构</li><li>继承了SortMap ，put()函数会做比较</li><li>寻找后继节点，中序遍历</li></ul></li><li><p>LinkHashMap</p></li></ol><ul><li>与HashMap类似，不过保证了put顺序</li><li>主要实现了afterNodeAccess(),afterNodeInsert(),afterNoderemoval三个方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/csdn_terence/article/details/78379878&quot; title=&quot;Optional title&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java集合面试总结&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Collecton-和-Map&quot;&gt;&lt;a href=&quot;#Collecton-和-Map&quot; class=&quot;headerlink&quot; title=&quot;Collecton 和 Map&quot;&gt;&lt;/a&gt;Collecton 和 Map&lt;/h2&gt;&lt;h3 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;headerlink&quot; title=&quot;Collection&quot;&gt;&lt;/a&gt;Collection&lt;/h3&gt;&lt;p&gt;包括 Set List Queue&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yangxin.online/categories/Java/"/>
    
    
      <category term="集合" scheme="http://yangxin.online/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>android 线程那些事</title>
    <link href="http://yangxin.online/android-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5.html"/>
    <id>http://yangxin.online/android-线程同步.html</id>
    <published>2018-01-20T14:55:58.000Z</published>
    <updated>2018-01-24T04:22:37.678Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程和线程安全"><a href="#线程和线程安全" class="headerlink" title="线程和线程安全"></a>线程和线程安全</h3><h4 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h4><ol><li>线程为进程的一个实体</li><li>轻量级进程</li><li>是CPU调度和分配的基本单位</li><li>可与同一进程内的线程共享进程内的全部资源</li><li>android 进程通过fork创建，线程通过pthread.creat创建</li></ol><h4 id="并发的优势促使多线程的出现"><a href="#并发的优势促使多线程的出现" class="headerlink" title="并发的优势促使多线程的出现"></a>并发的优势促使多线程的出现</h4><ol><li>资源利用率 ，提高</li><li>公平性，共享资源</li><li>便利性，多任务并发执行比单任务更容易执行</li></ol><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多线程的引入意味着引入了线程安全。当单线程能正确运行的代码，在多线程访问的情况下，不管线程以何种顺序访问，并不添加同步代码都能正确表现行为，则称它为线程安全的</p><h3 id="并发的三大要素"><a href="#并发的三大要素" class="headerlink" title="并发的三大要素"></a>并发的三大要素</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指的是一个或者多个不能再被分割的操作<br>value = 1; //院子操作<br>value++; //复合操作</p><h4 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h4><p>指多进程访问共享资源，不做同步</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>当一个线程对某个变量做出修改时，其他线程可以立刻读取修改后的值</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ol><li>是一种稍弱的同步机制，用来确保变量更新操作同步到其他线程，虚拟机不会指令重排</li><li>锁与volatile不同，锁具有两个特性：互斥性和可见性</li></ol><h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><h4 id="Sychronized关键字"><a href="#Sychronized关键字" class="headerlink" title="Sychronized关键字"></a>Sychronized关键字</h4><p>可作用于class和java对象</p><h4 id="锁的原理"><a href="#锁的原理" class="headerlink" title="锁的原理"></a>锁的原理</h4><ol><li>锁实现了内存可见性和操作原子性</li><li>释放锁时，该线程的本地内存中的共享变量会被刷新到内存中</li><li>锁不会被继承</li><li>同步代码块是使用monitorenter和monitorexit指令实现的，同步方法是通过ACC_SYNCHRONIZED标识符实现</li></ol><h4 id="锁的使用原则"><a href="#锁的使用原则" class="headerlink" title="锁的使用原则"></a>锁的使用原则</h4><ol><li>可能被多个线程同时访问的可变变量，在访问它时都需要持有一个锁，变量由这个锁保护</li><li>每个可变变量都只有一个锁来保护，知道锁的范围</li><li>当锁作用于多个变量时，对每个变量的操作都应该由同一个恶锁保护</li><li>在Android中，工作线程尽量不要和UI线程做同步</li></ol><h4 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h4><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h4 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h4><p>reentrantLock<br>semaphore<br>countDownLatch<br>CyclicBarrier<br>FutureTask</p><h3 id="原子变量和非阻塞算法"><a href="#原子变量和非阻塞算法" class="headerlink" title="原子变量和非阻塞算法"></a>原子变量和非阻塞算法</h3><p>Atomic<br>cas非阻塞算法<br>性能比较</p><p><a href="https://segmentfault.com/l/1500000012849264/play" target="_blank" rel="external">https://segmentfault.com/l/1500000012849264/play</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程和线程安全&quot;&gt;&lt;a href=&quot;#线程和线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程和线程安全&quot;&gt;&lt;/a&gt;线程和线程安全&lt;/h3&gt;&lt;h4 id=&quot;线程是什么&quot;&gt;&lt;a href=&quot;#线程是什么&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
  </entry>
  
</feed>
