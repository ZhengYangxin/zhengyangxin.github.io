<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fighting！</title>
  
  <subtitle>潜行者的沉默</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangxin.online/"/>
  <updated>2020-01-09T15:27:40.997Z</updated>
  <id>http://yangxin.online/</id>
  
  <author>
    <name>Yangcy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重学Java</title>
    <link href="http://yangxin.online/chong-xue-java.html"/>
    <id>http://yangxin.online/chong-xue-java.html</id>
    <published>2020-01-08T14:08:21.000Z</published>
    <updated>2020-01-09T15:27:40.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阿里云Java学习路线"><a href="#阿里云Java学习路线" class="headerlink" title="阿里云Java学习路线"></a><a href="https://developer.aliyun.com/learning/roadmap/java?source=5176.11533457&userCode=r3yteowb&type=copy&spm=5176.12901015.0.i12901015.510b525c9IzVPf" target="_blank" rel="noopener">阿里云Java学习路线</a></h2><h3 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h3><h4 id="Java编程入门"><a href="#Java编程入门" class="headerlink" title="Java编程入门"></a>Java编程入门</h4><h5 id="认识Java"><a href="#认识Java" class="headerlink" title="认识Java"></a>认识Java</h5><ol><li>Java的起源是SUM公司开发的，后来被oracle收购</li><li>Java的开发开发有三种<ul><li>JAVA SE 桌面应用开发</li><li>JAVA ME 嵌入是开发 </li><li>JAVA EE 企业平台开发，即互联网平台开发</li></ul></li></ol><h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ol><li>Java是半开源的项目，可以接触底层代码</li><li>Java是一种编程语言，面向对象的编程思想并且一直在拓展扩充</li><li>提供有方便的内存回收机制</li><li>避免了复杂的指针问题，使用更加简单的引用来代替指针</li><li>Java是支持多线程开发的语言，使得在单位时间内的提升了处理能力</li><li>Java提供了高效的网络处理能力，基于NIO实现了更加高效的网络传输能力</li><li>Java具有良好的可移植性</li><li>足够简单</li></ol><h4 id="Java的可移植性"><a href="#Java的可移植性" class="headerlink" title="Java的可移植性"></a>Java的可移植性</h4><p>在于同一个程序可以在不同的操作系统中执行部署，减少开发难度。依赖于Java虚拟机JVM，不同操作系统拥有不同版本的JVM，实现了移植性。</p><h5 id="Java程序运行机制"><a href="#Java程序运行机制" class="headerlink" title="Java程序运行机制"></a>Java程序运行机制</h5><ul><li>编译型，解释型。Java是两种高级编程语言的结合，先编译成.class文件，再解释成计算机识别的机器指令</li><li>编译命令：Javac.exe</li><li>解释命令：Java.exe</li><li>Java程序的组成：Java源文件，字节码文件，机器码指令</li></ul><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul><li>一台模拟的计算机，可以读取并处理经编译过的与平台无关的字节码class文件</li><li>java编译器针对JVM产生class文件，因此独立于平台</li><li>Java解释器负责将JVM的代码在特定的平台上运行</li></ul><h4 id="JDK的介绍"><a href="#JDK的介绍" class="headerlink" title="JDK的介绍"></a>JDK的介绍</h4><p>是Java的开发工具包,主要版本迭代，其中JRE是运行环境，只提供解释功能不提供程序的开发功能</p><ul><li>1995.05.23，JDK1.0发布， 1996年提供对外</li><li>1998.12.04 JDK1.2，更名为Java2</li><li>2005.05.23 十周年大会，JDK1.5 ，带来了新特性，决定了未来10的核心技术</li><li>2014 JDK1.8，支持了Lambda，可以函数式编程</li><li>2017 JDK1.9,提高了1.8稳定性</li><li>2018 JDK1.10,属于1.9的稳定版</li></ul><h4 id="JDK的安装与配置"><a href="#JDK的安装与配置" class="headerlink" title="JDK的安装与配置"></a>JDK的安装与配置</h4><h4 id="Java编程起步"><a href="#Java编程起步" class="headerlink" title="Java编程起步"></a>Java编程起步</h4><p>创建HelloWorld.java文件，编写源文件，编写输出HelloWord的程序。Java程序是需要经过两次处理之后才能正常执行的</p><ul><li>对源代码进行编译：Javac xxx/HelloWord.java，会出现一个HelloWord.class的字节码文件，利用JVM进行编译，编译出一套与平台无关的字节码文件(*.class)</li><li>在JVM上进行程序的解释执行Java xxx/HelloWord。解释的就是字节码文件，字节码文件的后缀是不需要编写的</li><li>类的定义有两种形式，public class 类名， class 类名。第一种文件名必须与类名一致，第二种可以不一致，生成的*.class文件名与类名一致。一般情况是一个class并且以public修饰，类名是驼峰式</li><li>main方法，程序运行入口主方法</li></ul><h4 id="ClASSPATH环境属性"><a href="#ClASSPATH环境属性" class="headerlink" title="ClASSPATH环境属性"></a>ClASSPATH环境属性</h4><ul><li>PATH: 是操作系统提供的路径配置，定义所有可执行程序的路径</li><li>CLASSPATH: 是JRE提供的，用于定义Java程序解释时类加载路径，默认是源文件的目录</li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>单行注释 //</li><li>多行注释 /* …. */</li><li>文档注释 /** …. */</li></ul><h4 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h4><ul><li>Java语言中有不同的结构：类，方法，变量结构等，对于结构的说明实际上就是标识符，是有命名规则的。</li><li>关键字，是系统对于一些结构的的描述处理，有着特殊含义，public static final 等等</li></ul><h4 id="Java数据类型简介"><a href="#Java数据类型简介" class="headerlink" title="Java数据类型简介"></a>Java数据类型简介</h4><ul><li>数据分类：基本数据类型(数字单元)分三大类，数值型，浮点型，字符型，引用数据类型(内存关系的使用)分数组，类，接口<table><thead><tr><th>类型</th><th>包括</th><th>默认值</th></tr></thead><tbody><tr><td>基本数据类型</td><td></td><td></td></tr><tr><td>整型</td><td>byte,short,int,long</td><td>0</td></tr><tr><td>浮点型</td><td>float，double</td><td>0.0</td></tr><tr><td>布尔型</td><td>boolea</td><td>false</td></tr><tr><td>字符型</td><td>char</td><td>‘\u0000’</td></tr><tr><td>引用类型</td><td>数组，类，接口</td><td>null</td></tr></tbody></table></li><li>使用原则： 如果是描述数字首选int,double；如果要进行数据传输或者文字编码选择byte(二进制处理)；处理中文char;描述内存或者文件大小，表的主键列long</li><li>内存溢出：如果数值的操作超出了数值类型的范围就会陷入循环的现象，通过使用范围更大的数值类型解决</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阿里云Java学习路线&quot;&gt;&lt;a href=&quot;#阿里云Java学习路线&quot; class=&quot;headerlink&quot; title=&quot;阿里云Java学习路线&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.aliyun.com/learning/roadma
      
    
    </summary>
    
      <category term="Java" scheme="http://yangxin.online/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yangxin.online/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 面向切面编程详解</title>
    <link href="http://yangxin.online/android-mian-xiang-qie-mian-bian-cheng-xiang-jie.html"/>
    <id>http://yangxin.online/android-mian-xiang-qie-mian-bian-cheng-xiang-jie.html</id>
    <published>2019-12-27T13:38:50.000Z</published>
    <updated>2020-01-08T13:00:20.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ol><li>什么是AOP（WHAT）</li><li>AOP的使用 (HOW)</li><li>比较主流AOP方案的优缺点 (WHY)</li><li>基于AOP实现的业务开源库 (WHERE)</li></ol><h3 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h3><h4 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h4><ul><li>AOP与OOP一样，是一种程序设计的思想：面向切面编程(Aspect Oritented Programming)，而非技术手段。思想的实现方式是一种技术，即通过预编译方式和运行期动态代理的方式实现程序功能的统一维护</li><li>AOP是OOP的延续，是软件开发中的热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，提高开发效率。</li></ul><h4 id="什么是OOP"><a href="#什么是OOP" class="headerlink" title="什么是OOP"></a>什么是OOP</h4><ul><li>OOP机面向对象编程(Object Oriented Programming)，被理解为是一种将程序分解为封装数据及相关操作的对象的编程思想。它有三大特性：多态，继承，封装。其中封装指：隐藏对象的属性和实现细节，仅对外公开访问方法，控制在程序中属性的读和写的级别，以获得更加清晰高效的逻辑单元划分。这个程序的六大设计原则中的单一职责原则一致：一个类只负责一件事。</li><li>因此针对上面的封装特性，他存在一个问题：当存在关注点聚焦的场景时，他无法很好的解决，因为一个关注点是面向所有而不是一个单一的类，不受类的边界的约束,因此它只能分散到各个类,方法中去。这样的好处是降低了类的复杂性，提高了程序的可维护性，但同时他也使代码变得啰嗦了，例如添加方法的调用日志，那就必须为所有的需要日志的方法添加调用日志的方法。</li></ul><h4 id="AOP和OOP的关系"><a href="#AOP和OOP的关系" class="headerlink" title="AOP和OOP的关系"></a>AOP和OOP的关系</h4><ul><li>面对上述聚焦某个点的问题，AOP可以理解为是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或者阶段，以获得逻辑过程中各个部分之间低耦合性隔离效果。这两种思想在目标上有本质上的差异，但两者不是对立的，AOP是为了弥补OOP的不足。</li><li>OOP解决了竖向的问题，AOP则解决了横向的问题，有了AOP对程序的监控将更加简单清晰</li></ul><h4 id="使用的业务场景"><a href="#使用的业务场景" class="headerlink" title="使用的业务场景"></a>使用的业务场景</h4><p>日志记录，性能统计，安全控制，事务处理，异常处理等等</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="/images/20171016213933903.png" alt></p><a id="more"></a><p>现在实现上图的业务，1.为所有的方法做参数校验，2.添加前置日志，后置日志。</p><ul><li><p>按照传统OOP实现，我们会定义一个参数校验的类Preconditions，及参数校验方法checkNotEmpty</p><pre><code>public final class Preconditions {  public static &lt;T&gt; T checkNotEmpty(T instance, String name) {      if (isEmpty(instance)) {          throw new NullPointerException(name + &quot;不能为空&quot;);      }      return instance;  }  private static boolean isEmpty(Object obj) {      if (obj == null) {          return true;      }      if (obj instanceof String &amp;&amp; obj.toString().length() == 0) {          return true;      }      //  .......      return false;  }}</code></pre><p>  同样我们会定义日志记录的工具类LogDAO及写入日志方法addOpLog。这时候我们就需要找出需要需要校验参数和添加日志的方法进行一一添加。</p></li><li><p>而按照AOP的实现方式，是把这些横跨并嵌入众多模块的类方法集中起来，放到一个统一的地方来控制和管理，而我们只需要在这个唯一的地方进行参数的校验和日志的添加即可。</p></li></ul><table><thead><tr><th>功能</th><th>OOP</th><th>AOP</th></tr></thead><tbody><tr><td>方法参数校验</td><td>所有功能模块单独添加</td><td>能够将同一个关注点聚焦在一处解决</td></tr><tr><td>增加日志</td><td>所有功能模块单独添加</td><td>能够将同一个关注点聚焦在一处解决</td></tr><tr><td>修改日志</td><td>功能代码分散，不方便调试</td><td>能够实现一处修改，处处生效</td></tr></tbody></table><h3 id="实现方式及使用"><a href="#实现方式及使用" class="headerlink" title="实现方式及使用"></a>实现方式及使用</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h4 id="APT（Annotation-Processing-Tool）"><a href="#APT（Annotation-Processing-Tool）" class="headerlink" title="APT（Annotation Processing Tool）"></a>APT（Annotation Processing Tool）</h4><p>是一种编译器注解技术。他通过定义注解和处理器来实现编译期生成代码的功能，并且将生成的代码和源代码一起编译成.class文件。通过APT技术我们可以将横切关注点封装到注解处理器中，从而实现横向切面和业务主体的分离。</p><h5 id="在使用APT之前我们需要了解他的一些相关知识"><a href="#在使用APT之前我们需要了解他的一些相关知识" class="headerlink" title="在使用APT之前我们需要了解他的一些相关知识"></a>在使用APT之前我们需要了解他的一些相关知识</h5><ol><li><p>Element<br>Element是一种在编译期间描述.java文件静态结构的一种类型，它可能表示一个package，一个class，一个filed，一个method。Element的比较应该使用equals，因为编译器间同一个Element可能会用两个对象表示.<br><img src="/images/169dd37cf73b8b6c.png" alt><br>我们通过Element便可以获取所有需要的类结构中的所有信息，十分有用的方法：</p><pre><code>public interface Element extends AnnotatedConstruct { //获取父Element Element getEnclosingElement(); //获取子Element的集合 List&lt;? extends Element&gt; getEnclosedElements(); // 获取语言定义的类型 TypeMirror asType()}</code></pre></li><li><p>TypeMirror<br>Element中有个asType()方法用来返回TypeMirror。TypeMirror表示java编程语言中的类型，这些类型包括基本类型，声明类型(类、接口)，数组类型，类型变量和null类型。还可以表示通配符类型参数，executable的签名和返回类型，以及对应于包和关键字的void的伪类型。我们一般用TypeMirror于类型判断。如下Activity的类型判断：</p><pre><code>public interface TypeMirror extends javax.lang.model.AnnotatedConstruct { // 可获取获取类型，如boolean， byte，short，int等等 TypeKind getKind();}s/*** 类型相关工具类*/private Types typeUtils;/*** 元素相关的工具类*/private Elements elementUtils;private static final String ACTIVITY_TYPE = &quot;android.app.Activity&quot;;private boolean isSubActivity(Element element){ //获取当前元素的TypeMirror TypeMirror elementTypeMirror = element.asType(); //通过工具类Elements获取Activity的Element，并转换为TypeMirror TypeMirror viewTypeMirror = elementUtils.getTypeElement(ACTIVITY_TYPE).asType(); //用工具类typeUtils判断两者间的关系 return typeUtils.isSubtype(elementTypeMirror,viewTypeMirror)}</code></pre></li><li><p>Types, typeUtil是类型相关的工具类，主要用于与TypeMirror结合使用，常用方法有</p><pre><code>public interface Types { // 将类型转化为对应的程序元素 Element asElement(TypeMirror t); // 比较类型是否相同 boolean isSameType(TypeMirror t1, TypeMirror t2); // t1是否是t2子类型 boolean isSubtype(TypeMirror t1, TypeMirror t2); // t1是否是t2的父类型 boolean isAssignable(TypeMirror t1, TypeMirror t2); // t1是否包含t的类型，，如t1是一个类元素的typeMirror,他的内部元素包含属性，方法等 boolean contains(TypeMirror t1, TypeMirror t2); // .....}</code></pre></li><li><p>Elements, elementUtil是元素相关的工具类，常用方法有</p><pre><code>public interface Elements { // 通过全限定名，获取包元素 PackageElement getPackageElement(CharSequence name); // 通过全限定名，获取类元素 TypeElement getTypeElement(CharSequence name); //  获取包元素 PackageElement getPackageOf(Element type); // 获取类元素的所有成员元素 List&lt;? extends Element&gt; getAllMembers(TypeElement type); // ......}</code></pre></li><li><p>具体实战可以参考ButterKnife、Dagger、ARouter、EventBus3、DataBinding、AndroidAnnotation，框架的实现方式可以分几步</p><ul><li>自己定义代码结构</li><li>通过apt生成代码</li><li>定义Manager管理器进行初始化，传入目标对象进行逻辑代码的初始化</li></ul></li><li><p>demo参考,其中代码生的比较繁琐，基于字符拼接容易错，推荐使用Square的<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet</a>库，提供了非常友好的api</p><pre><code>自动生成xxx$$Proxy.java文件public class MainActivity$$Proxy { public static Class&lt;?&gt; findTargetClass(String path) {     if (path.equals(&quot;ddasdas&quot;)) {         return MainActivity.class;     }     return null; }}//代码生成器public class ParamaterCheckApt extends AbstractProcessor { // 操作Element工具类 (类、函数、属性都是Element) private Elements elementUtils; // type(类信息)工具类，包含用于操作TypeMirror的工具方法 private Types typeUtils; // Messager用来报告错误，警告和其他提示信息 private Messager messager; // 文件生成器 类/资源，Filter用来创建新的源文件，class文件以及辅助文件 private Filer filer; // 该方法主要用于一些初始化的操作，通过该方法的参数ProcessingEnvironment可以获取一些列有用的工具类 @Override public synchronized void init(ProcessingEnvironment processingEnvironment) {     super.init(processingEnvironment);     S// .... } /**  * 相当于main函数，开始处理注解  * 注解处理器的核心方法，处理具体的注解，生成Java文件  * @param annotations 使用了支持处理注解的节点集合  * @param roundEnv 当前或是之前的运行环境,可以通过该对象查找找到的注解。  * @return true 表示后续处理器不会再处理（已经处理完成）  */ @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {     if (annotations.isEmpty()) {         return false;     }     Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(Arouter.class);     for (Element element : elements) {         // 通过类节点获取包节点         String packageName = elementUtils.getPackageOf(element).getQualifiedName().toString();         // 获取简单类名         String className = element.getSimpleName().toString();         messager.printMessage(Diagnostic.Kind.NOTE, &quot;被注解的类有：&quot; + className);         String finalClassName = className + &quot;$$Proxy&quot;;         try {             JavaFileObject sourceFile = filer.createSourceFile(packageName + &quot;.&quot; + finalClassName);             // 定义Writer对象，开启写入             Writer writer = sourceFile.openWriter();             // 设置包名             writer.write(&quot;package &quot; + packageName + &quot;;\n&quot;);             writer.write(&quot;public class &quot; + finalClassName + &quot; {\n&quot;);             writer.write(&quot;public static Class&lt;?&gt; findTargetClass(String path) {\n&quot;);             // 获取类之上@ARouter注解的path值             Arouter aRouter = element.getAnnotation(Arouter.class);             writer.write(&quot;if (path.equals(\&quot;&quot; + aRouter.path() + &quot;\&quot;)) {\n&quot;);             writer.write(&quot;return &quot; + className + &quot;.class;\n}\n&quot;);             writer.write(&quot;return null;\n&quot;);             writer.write(&quot;}\n}&quot;);             // 最后结束别忘了             writer.close();         } catch (IOException e) {             e.printStackTrace();         }     }     return false; }}</code></pre></li><li><p>生成的代码可以在project/项目(app)/build/generated/source/apt/ 下面可以找到</p></li></ol><h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><ul><li>是一种编译器，它在Java编译器的基础上增加了关键字的识别和编译方法，因此AspectJ可以织入Java代码。他还提供了AspectJ程序，在编译期间将开发者编写的AspectJ程序织入到目标程序中。它的核心是ajc(aspectjtools编译器)和weaver(织入器aspectjweaver)。</li><li>aspectjtools编译器是基于java编译器之上的，可以编译.aj文件，在java编译器之上加了关键字和方法，因此也可以编译java代码</li><li>weaver织入器：为了在java编译器上使用AspectJ而不依赖于AJC编译器，AspectJ5出现了@AspectJ，使用注解的方式去编写AspectJ代码，可以在任何java编译器上使用。在代码编译期间扫描目标程序，根据切点(PointCut)匹配，将开发者编写的Aspect程序编织到目标程序的.class文件中，对目标程序作了重构（重构的单位是JoinPoint），目的就是建立目标程序的与Aspect程序的连接（获取执行对象，方法，参数等上下文），从而达到Aop的目的</li></ul><h5 id="Aspect的一些术语"><a href="#Aspect的一些术语" class="headerlink" title="Aspect的一些术语"></a>Aspect的一些术语</h5><ol><li><p>切面(Aspectj): 即一个关注点的模块化，这个关注点可能横跨多个对象，其实就是公共功能的实现。如日志切面，权限切面，事物切面等。</p></li><li><p>通知（Advice）：是切面的具体实现。以目标方法为参照点，根据放置的位置不同，可以分为：</p><ul><li>前置通知(before)</li><li>后置通知(after)</li><li>异常通知(AfterThrowing)</li><li>最终通知(AfterReturning)</li><li>环绕通知(Around)</li></ul></li><li><p>在实际应用中通常是切面类中的一个方法，具体哪个则取决于配置。</p><ul><li>切入点（PointCut）： 用于定义通知应该切入到那些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配依赖于切入点的正则表达式定义。连接点JointPoint：就是程序在运行过程中能够切入到切面的地点。列如： 方法调用，异常抛出修改字段等。</li><li>目标对象（Target Object）：包含连接点的对象，也被称作被通知或者被代理的对象，这些对象只剩下干干净净的核心业务逻辑代码，所有共有功能的代码等则是等待Aop的切入</li><li>AOP代理（AOP Proxy）：将通知应用到目标对象之后动态的创建对象。代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能</li><li>织入(Weaving): 将切面应用到目标对象从而创建一个新的代理对象的过程，这个过程可以发生在编译期，类装载期及运行期，不同的时期有着不同的条件。如AspectJ则需要一种支持AOP的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；发生在运行期，则可直接通过java语言的反射机制与动态代理机制来实现</li></ul></li><li><p>AspectJ中的Join Point</p></li></ol><table><thead><tr><th>Join Points</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>method call</td><td>函数调用</td><td>比如Log.e()调用的地方是一个joinPoint</td></tr><tr><td>method execution</td><td>函数执行</td><td>比如Log.e()的内部执行，是一出joinPoint</td></tr><tr><td>constructor call</td><td>构造函数的调用</td><td>s 和method call 类似</td></tr><tr><td>constructor execution</td><td>构造函数的执行</td><td>和method execution类似</td></tr><tr><td>field get</td><td>获取某个变量</td><td>比如读取DemoActivity.debug成员</td></tr><tr><td>field set</td><td>设置某变量</td><td>比如设置DemoActivity.debug变量</td></tr><tr><td>preinitialization</td><td>Object 在构造函数中做一些工作</td><td>很少使用</td></tr><tr><td>initialization</td><td>Object在构造函数中做得工作</td><td>很少使用</td></tr><tr><td>static initialization</td><td>类初始化</td><td>比如类的static{}</td></tr><tr><td>handler</td><td>异常处理</td><td>比如try catch（xxx）中，对应catch内的执行</td></tr><tr><td>advice execution</td><td>AspectJ的内容</td><td>…</td></tr></tbody></table><ol start="5"><li>PointCut基于正则表达式@注解 访问权限 返回值的类型 包名.函数名(参数),call(public  *  <em>.println(..))<br>是匹配一个方法，第一个</em>表示方法的返回值，第二个*表示方法的包名，(..)表示方法的参数的样子，..代表任意个数，任意类型的参数</li></ol><ul><li>*表示任何数量的字符，除了(.)</li><li>..表示任何数量的字符包括任何数量的(.)</li><li>+描述指定类型的任何子类或者子接口</li><li>同java一样，提供了一元和二元的条件表达操作符。<br>s一元操作符：!<br>二元操作符：||和&amp;&amp;</li><li>参考<a href="https://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="noopener">深入理解Android之Aop</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;什么是AOP（WHAT）&lt;/li&gt;
&lt;li&gt;AOP的使用 (HOW)&lt;/li&gt;
&lt;li&gt;比较主流AOP方案的优缺点 (WHY)&lt;/li&gt;
&lt;li&gt;基于AOP实现的业务开源库 (WHERE)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;AOP的概念&quot;&gt;&lt;a href=&quot;#AOP的概念&quot; class=&quot;headerlink&quot; title=&quot;AOP的概念&quot;&gt;&lt;/a&gt;AOP的概念&lt;/h3&gt;&lt;h4 id=&quot;什么是AOP&quot;&gt;&lt;a href=&quot;#什么是AOP&quot; class=&quot;headerlink&quot; title=&quot;什么是AOP&quot;&gt;&lt;/a&gt;什么是AOP&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;AOP与OOP一样，是一种程序设计的思想：面向切面编程(Aspect Oritented Programming)，而非技术手段。思想的实现方式是一种技术，即通过预编译方式和运行期动态代理的方式实现程序功能的统一维护&lt;/li&gt;
&lt;li&gt;AOP是OOP的延续，是软件开发中的热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，提高开发效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;什么是OOP&quot;&gt;&lt;a href=&quot;#什么是OOP&quot; class=&quot;headerlink&quot; title=&quot;什么是OOP&quot;&gt;&lt;/a&gt;什么是OOP&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;OOP机面向对象编程(Object Oriented Programming)，被理解为是一种将程序分解为封装数据及相关操作的对象的编程思想。它有三大特性：多态，继承，封装。其中封装指：隐藏对象的属性和实现细节，仅对外公开访问方法，控制在程序中属性的读和写的级别，以获得更加清晰高效的逻辑单元划分。这个程序的六大设计原则中的单一职责原则一致：一个类只负责一件事。&lt;/li&gt;
&lt;li&gt;因此针对上面的封装特性，他存在一个问题：当存在关注点聚焦的场景时，他无法很好的解决，因为一个关注点是面向所有而不是一个单一的类，不受类的边界的约束,因此它只能分散到各个类,方法中去。这样的好处是降低了类的复杂性，提高了程序的可维护性，但同时他也使代码变得啰嗦了，例如添加方法的调用日志，那就必须为所有的需要日志的方法添加调用日志的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;AOP和OOP的关系&quot;&gt;&lt;a href=&quot;#AOP和OOP的关系&quot; class=&quot;headerlink&quot; title=&quot;AOP和OOP的关系&quot;&gt;&lt;/a&gt;AOP和OOP的关系&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;面对上述聚焦某个点的问题，AOP可以理解为是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或者阶段，以获得逻辑过程中各个部分之间低耦合性隔离效果。这两种思想在目标上有本质上的差异，但两者不是对立的，AOP是为了弥补OOP的不足。&lt;/li&gt;
&lt;li&gt;OOP解决了竖向的问题，AOP则解决了横向的问题，有了AOP对程序的监控将更加简单清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;使用的业务场景&quot;&gt;&lt;a href=&quot;#使用的业务场景&quot; class=&quot;headerlink&quot; title=&quot;使用的业务场景&quot;&gt;&lt;/a&gt;使用的业务场景&lt;/h4&gt;&lt;p&gt;日志记录，性能统计，安全控制，事务处理，异常处理等等&lt;/p&gt;
&lt;h4 id=&quot;对比&quot;&gt;&lt;a href=&quot;#对比&quot; class=&quot;headerlink&quot; title=&quot;对比&quot;&gt;&lt;/a&gt;对比&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/20171016213933903.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="AOP" scheme="http://yangxin.online/tags/AOP/"/>
    
      <category term="Android" scheme="http://yangxin.online/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习</title>
    <link href="http://yangxin.online/shu-ju-ku-xue-xi.html"/>
    <id>http://yangxin.online/shu-ju-ku-xue-xi.html</id>
    <published>2019-10-31T14:21:36.000Z</published>
    <updated>2019-11-06T03:30:47.408Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h3><ol><li>第一：原子性， 即不可拆分</li><li>第二：唯一性， id</li><li>第三：避免冗余性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据库设计的三大范式&quot;&gt;&lt;a href=&quot;#数据库设计的三大范式&quot; class=&quot;headerlink&quot; title=&quot;数据库设计的三大范式&quot;&gt;&lt;/a&gt;数据库设计的三大范式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;第一：原子性， 即不可拆分&lt;/li&gt;
&lt;li&gt;第二：唯一性， i
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="数据库" scheme="http://yangxin.online/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp的学习</title>
    <link href="http://yangxin.online/okhttp-de-xue-xi.html"/>
    <id>http://yangxin.online/okhttp-de-xue-xi.html</id>
    <published>2019-10-29T13:34:11.000Z</published>
    <updated>2019-10-31T14:21:05.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习大纲"><a href="#学习大纲" class="headerlink" title="学习大纲"></a>学习大纲</h3><ol><li>OSI七层模型介绍，TCP/IP模型介绍，Http协议的格式介绍</li><li>OkHttp主线流程的源码阅读</li><li>OkHttp源码阅读之线程池详解</li><li>OkHttp责任链模式/建造者模式</li><li>OkHttp整体框架</li><li>OkHttp之Socket的请求与实现</li></ol><h3 id="1-网路模型"><a href="#1-网路模型" class="headerlink" title="1. 网路模型"></a>1. 网路模型</h3><ol><li>OSI七层模型，数据封装，解封装的过程</li><li>TCP/IP模型， 应用层，传输层，网络层， 主机到网络层</li><li>Http1.0, 请求响应后会马上断开；Http1.1,添加了keepAlive的长连接保持</li><li>get请求，请求行，请求属性集；post请求，请求行，请求属性集，请求体长度，请求体类型</li></ol><h3 id="2-OkHttp主流程源码阅读"><a href="#2-OkHttp主流程源码阅读" class="headerlink" title="2. OkHttp主流程源码阅读"></a>2. OkHttp主流程源码阅读</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>1. 创建OkHttpClient的实例对象client2. 创建请求对象Request的实例对象request3. 通过client.newCall(request)获取到请求对象call4. 通过请求对象call进行同步call.execute()请求或者call.enqueue(new CallBack())的异步请求</code></pre><h4 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h4><pre><code>1. 通过构建者设计模式，创建出OkHttpClient的实例2. 同样通过构建者设计模式，创建出Request的实例3. client.newCall(request)内部通过Call的实现类RealCall，返回call的对象4. 进行异步请求call.enqueue(new CallBack())不能重复请求，会调用分发器dispatcher.enqueue(new AsyncCall(responseCallback))5. 在dispatcher中定义了双端的runningAsyncCalls和readyAsyncCalls及限制了同时访问同一个服务器为最大5个6. 通过线程池调用executor.execute(asyncCall), asyncCall实现了Runnable7. AsyncCall内部执行耗时execute方法，会调用责任链获得响应response8. 成功与失败的回调，并且进行错误责任的划分</code></pre><h3 id="3-OkHttp源码阅读之线程池详解"><a href="#3-OkHttp源码阅读之线程池详解" class="headerlink" title="3. OkHttp源码阅读之线程池详解"></a>3. OkHttp源码阅读之线程池详解</h3><pre><code>public synchronized ExecutorService executorService() {    if (executorService == null) {      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,          new SynchronousQueue&lt;&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));    }    return executorService;  }</code></pre><ol><li>OkHttp中使用的线程池，采用了缓存方案。线程任务60s内执行完毕，则会复用线程。自定义线程工厂</li><li>守护线程的设置</li></ol><h3 id="4-OkHttp责任链模式-建造者模式"><a href="#4-OkHttp责任链模式-建造者模式" class="headerlink" title="4. OkHttp责任链模式/建造者模式"></a>4. OkHttp责任链模式/建造者模式</h3><p>责任链模式关键是，拦截器集合，拦截器的一个管理类，index+1<br>建造者模式关键是构建对象</p><h3 id="OkHttp整体框架"><a href="#OkHttp整体框架" class="headerlink" title="OkHttp整体框架"></a>OkHttp整体框架</h3><ol><li>http的默认端口是80， https是443</li><li>callServerIntercept 建立连接，会做连接池的复用</li><li>网络层是在路由器之间的传输ip数据包，数据链路层是交换机间的传输是帧，最后是物理机的比特流的传输</li><li>OkHttp封装了Socket,对socket进行了复用，缓存机制</li><li>连接池的设计，定义了一个线程池和一个清理连接对象的线程，通过连接对象的空闲时间和允许的最大空闲时间来回收连接池</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;学习大纲&quot;&gt;&lt;a href=&quot;#学习大纲&quot; class=&quot;headerlink&quot; title=&quot;学习大纲&quot;&gt;&lt;/a&gt;学习大纲&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;OSI七层模型介绍，TCP/IP模型介绍，Http协议的格式介绍&lt;/li&gt;
&lt;li&gt;OkHttp主线流程的源码阅
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="OkHttp" scheme="http://yangxin.online/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>组件化总结</title>
    <link href="http://yangxin.online/zu-jian-hua-zong-jie.html"/>
    <id>http://yangxin.online/zu-jian-hua-zong-jie.html</id>
    <published>2019-10-22T13:37:59.000Z</published>
    <updated>2019-10-29T13:33:42.843Z</updated>
    
    <content type="html"><![CDATA[<h4 id="library和phone的区别"><a href="#library和phone的区别" class="headerlink" title="library和phone的区别"></a>library和phone的区别</h4><ol><li>library 是集成化，phone是组件化</li><li>library中是apply plugin: ‘com.android.android’，且没有applicationId，phone是apply plugin: ‘com.android.application’，有applicationId</li><li>library不能单独运行和单独打包，phone可以</li></ol><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>定义config.gradle,统一配置信息及，定义是否为isRelease开关(是否为发布版本)</li><li>在每个模块里做isRelease判断，是否是library，修改组件和集成库的区别</li><li>组件时debug代码的配置</li></ol><h4 id="组件化开发规范"><a href="#组件化开发规范" class="headerlink" title="组件化开发规范"></a>组件化开发规范</h4><p>组件前缀</p><h4 id="module之间的交互"><a href="#module之间的交互" class="headerlink" title="module之间的交互"></a>module之间的交互</h4><ol><li>EventBus 必须一对一，若一对多将混乱不堪难以维护</li><li>反射  维护成本高，容易出现高版本@hide限制</li><li>隐式意图，需要维护manifest</li><li>BroadcastReceiver ，7.0后需要动态注册，需求方发送广播</li><li>类加载，需要准确的全类名，维护成本高容易出错</li></ol><h4 id="注解处理器的APT的应用"><a href="#注解处理器的APT的应用" class="headerlink" title="注解处理器的APT的应用"></a>注解处理器的APT的应用</h4><ol><li>简单来说是一种按一定规则，自动生成代码的工具</li><li>需要了解他的程序元素Element包括：PackageElement包元素，TypeElement类或接口元素，VariableElement属性字段参数元素，ExecutableElement方法(包括构造，静态方法)元素</li><li>Android studio 及 gradle的 版本兼容 1.as3.3.2 gradle 4.10.1(临界版本)  2. as3.4.1 gradle5.1.1(向下兼容)</li><li>定义需扫描的注解类</li><li>创建注解处理器@AutoService(Processor.class)，指定支持的注解，编译的java版本及注解处理器接受内容的参数</li><li>通过获取节点，定义包名及新的class名称，通过filter创建一个JavaFileObject对象</li><li>获取JavaFileObject的Write对象，进行一行一行的写入文件</li></ol><h4 id="JavaPoet的应用"><a href="#JavaPoet的应用" class="headerlink" title="JavaPoet的应用"></a>JavaPoet的应用</h4><p>JavaPoet是square推出的开源的java代码自动生成框架，提供javaApi生成Java文件</p><ol><li>MethodSpec生成方法</li><li>TypeSpec生成类或者接口class</li><li>JavaFile创建java文件</li><li>Element的子类，包括TypeElement, PackageElement等等表示程序可操作的元素，包括类，方法，属性，包等</li><li>TypeMirror,获取类的所有信息，可以判断子类关系</li></ol><h4 id="Arouter的源碼分析"><a href="#Arouter的源碼分析" class="headerlink" title="Arouter的源碼分析"></a>Arouter的源碼分析</h4><h5 id="1-初始化過程ARouter-init-gt-Arouter-init-gt-LogisticsCenter-init"><a href="#1-初始化過程ARouter-init-gt-Arouter-init-gt-LogisticsCenter-init" class="headerlink" title="1. 初始化過程ARouter.init -&gt; Arouter.init -&gt; LogisticsCenter.init()"></a>1. 初始化過程ARouter.init -&gt; <em>Arouter.init -&gt; LogisticsCenter.init()</em></h5><pre><code>* 在该方法中会进行APT生成文件的dex文件的扫码，加载所有的class文件，保存到routerMap对像并保存到sp中（第一次启动比较慢），同时开启了线程池每个dex的加载都会创建一个线程，最后放入缓存对象Warehouse的map中* 在 LogisticsCenter.init() -&gt; _Arouter.afterInit()内部会创建拦截器对象interceptorService</code></pre><h4 id="路由的设计及应用"><a href="#路由的设计及应用" class="headerlink" title="路由的设计及应用"></a>路由的设计及应用</h4><p>参考Arouter</p><ol><li>组件间的跳转</li><li>组件间的值传递</li><li>获取其他组件的资源及实习方法</li><li>对未安装组件的拦截</li></ol><h4 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h4><p>存在问题</p><ol><li>各模块的service耦合度高</li><li>模块间的跳转都类名</li><li>数据的传输是调用方法的</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;library和phone的区别&quot;&gt;&lt;a href=&quot;#library和phone的区别&quot; class=&quot;headerlink&quot; title=&quot;library和phone的区别&quot;&gt;&lt;/a&gt;library和phone的区别&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;library 
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="组件化" scheme="http://yangxin.online/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Binder的学习</title>
    <link href="http://yangxin.online/binder-de-xue-xi.html"/>
    <id>http://yangxin.online/binder-de-xue-xi.html</id>
    <published>2019-10-19T16:02:11.000Z</published>
    <updated>2019-10-20T08:36:55.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程通讯的方式"><a href="#进程通讯的方式" class="headerlink" title="进程通讯的方式"></a>进程通讯的方式</h3><ol><li>管道，耗性能</li><li>共享内存，多进程访问，管理混乱</li><li>Socket适用于网络通讯，进程通讯不适用</li></ol><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><ol><li>binder机制为每个进程都分配了UID和PID来作为鉴别身份的标识，安全性</li><li>对数据只进行了一次拷贝，通过驱动的内核空间拷贝数据，不需要额外的同步处理</li><li>使用简单C/S架构，实现面向对象的调用方式即在使用binder时，就和调用1个本地对象实例一样</li></ol><h4 id="Binder的四个重要角色"><a href="#Binder的四个重要角色" class="headerlink" title="Binder的四个重要角色"></a>Binder的四个重要角色</h4><ol><li>server</li><li>Client</li><li>ServiceMannager</li><li>Binder驱动(存在线程池 16个)，具体实现通过内存映射，内部调用了mmap()函数<br>前三者在用户空间，Binder驱动在内核空间</li></ol><h4 id="AIDL接口定义语言"><a href="#AIDL接口定义语言" class="headerlink" title="AIDL接口定义语言"></a>AIDL接口定义语言</h4><p>是对Binder通讯的封装<br>IBinder代表有能力进行快进程的能力<br>IIterface 拥有了Binder机制的能力，只有一个asBinder的方法<br>Binder<br>Stub 本地对象</p><h4 id="Binder的源码分析"><a href="#Binder的源码分析" class="headerlink" title="Binder的源码分析"></a>Binder的源码分析</h4><ol><li>打开binder设备<pre><code>frameworks /native /cmds /servicemanager /service_manager.cdriver = &quot;/dev/binder&quot;;  //返回文件描述符</code></pre></li><li>buffer的创建(用于进程间数据传递)<pre><code>bs = binder_open(driver, 128*1024); binder，创建128k的那内存映射</code></pre></li><li>开辟内存呢映射128k<pre><code>frameworks /native /cmds /servicemanager /binder.cbs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);mmap()命令device /google /cuttlefish_kernel /4.4-x86_64 /System.map在系统启动的时候开辟了内存映射</code></pre></li><li>serviceManager的启动<pre><code>system /core /rootdir /init.rcstart servicemanager在系统启动的时候做了启动服务</code></pre></li><li>打包Parcel,数据写入binder驱动，copy_from_user<pre><code>打包Parcelframeworks native libs binder IServiceManager.cppaddService</code></pre></li></ol><p>数据写入binder驱动<br>frameworks native libs binder IPCThreadState.cpp<br>writeTransactionData</p><pre><code>6. 服务注册，添加到链表SVClist中7. 定义主线程中的线程池8. 循环从mIn和mOut中读和写数据请求，发到binder设备中### 三方登录实例A应用client端，B应用为Server端。A调用B进行登录。两应用aidl文件的包名必须一致#### A应用1. 创建ILoginInterface.aidl</code></pre><p>// ILoginInterface.aidl<br>package com.netease.binder;</p><p>// Declare any non-default types here with import statements</p><p>interface ILoginInterface {</p><pre><code>// 登录void login();// 登录返回void loginCallback(boolean loginStatus, String loginUser);</code></pre><p>}</p><pre><code>2. 在A应用中建立Binder连接,记得销毁</code></pre><p>public void initBindService() {<br>        Intent intent = new Intent();<br>        // 设置Server应用Action<br>        intent.setAction(“BinderB_Action”);<br>        // 设置Server应用包名（5.1+要求）<br>        intent.setPackage(“com.netease.binder.b”);<br>        // 开始绑定服务<br>        bindService(intent, conn, BIND_AUTO_CREATE);<br>        // 标识跨进程绑定<br>        isStartRemote = true;<br>    }</p><pre><code>// 服务连接private ServiceConnection conn = new ServiceConnection() {    @Override    public void onServiceConnected(ComponentName name, IBinder service) {        iLogin = ILoginInterface.Stub.asInterface(service);    }    @Override    public void onServiceDisconnected(ComponentName name) {    }};</code></pre><pre><code>3. 因为需要接受B进程返回的数据，需要同样创建一个服务，</code></pre><p>package com.netease.binder.a.service;</p><p>import android.app.Service;<br>import android.content.Intent;<br>import android.os.IBinder;<br>import android.os.RemoteException;<br>import android.util.Log;</p><p>import com.netease.binder.ILoginInterface;</p><p>public class MyService extends Service {</p><pre><code>@Overridepublic IBinder onBind(Intent intent) {    return new ILoginInterface.Stub() {        @Override        public void login() throws RemoteException {        }        @Override        public void loginCallback(boolean loginStatus, String loginUser) throws RemoteException {            Log.e(&quot;netease &gt;&gt;&gt; &quot;, &quot;loginStatus: &quot; + loginStatus + &quot; / loginUser: &quot; + loginUser);        }    };}</code></pre><p>}</p><pre><code>#### B应用1. 创建ILoginInterface.aidl2. 创建对应的service服务</code></pre><p>public class MyService extends Service {</p><pre><code>@Overridepublic IBinder onBind(Intent intent) {    return new ILoginInterface.Stub() {        @Override        public void login() throws RemoteException {            Log.e(&quot;netease &gt;&gt;&gt; &quot;, &quot;BinderB_MyService&quot;);            // 单项通信有问题，真实项目双向通信，双服务绑定            serviceStartActivity();        }        @Override        public void loginCallback(boolean loginStatus, String loginUser) throws RemoteException {        }    };}/** * 在Service启动Activity，需要配置：.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); */private void serviceStartActivity() {    Intent intent = new Intent(this, MainActivity.class);    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);    startActivity(intent);}</code></pre><p>}</p><pre><code>3. 在AndroidManifest配置文件中注册服务</code></pre><!--                 代表在应用程序里，当需要该service时，会自动创建新的进程。                 android:process=":remote"                 是否可以被系统实例化                 android:enabled="true"                 代表是否能被其他应用隐式调用                 android:exported="true"        --><pre><code>    &lt;service        android:name=&quot;.service.MyService&quot;        android:enabled=&quot;true&quot;        android:exported=&quot;true&quot;        android:process=&quot;:remote_service&quot;&gt;        &lt;intent-filter&gt;            &lt;!-- 激活 MyService 唯一name，不能重名--&gt;            &lt;action android:name=&quot;BinderB_Action&quot; /&gt;        &lt;/intent-filter&gt;    &lt;/service&gt;</code></pre><pre><code>4. 当A请求登录时，会唤起B应用打开登录界面，当输入完登录信息后需要将登录结果返回给A应用，因此同样需要A应用有一个跨进程服务接受B进程的登录结果，所以同样在B中创建Ade服务连接</code></pre><p>public void initBindService() {<br>        Intent intent = new Intent();<br>        // 设置Server应用Action<br>        intent.setAction(“BinderA_Action”);<br>        // 设置Server应用包名（5.1+要求）<br>        intent.setPackage(“com.netease.binder.a”);<br>        // 开始绑定服务<br>        bindService(intent, conn, BIND_AUTO_CREATE);<br>        // 标识跨进程绑定<br>        isStartRemote = true;<br>    }</p><pre><code>// 服务连接private ServiceConnection conn = new ServiceConnection() {    @Override    public void onServiceConnected(ComponentName name, IBinder service) {        iLogin = ILoginInterface.Stub.asInterface(service);    }    @Override    public void onServiceDisconnected(ComponentName name) {    }};</code></pre><p>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程通讯的方式&quot;&gt;&lt;a href=&quot;#进程通讯的方式&quot; class=&quot;headerlink&quot; title=&quot;进程通讯的方式&quot;&gt;&lt;/a&gt;进程通讯的方式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;管道，耗性能&lt;/li&gt;
&lt;li&gt;共享内存，多进程访问，管理混乱&lt;/li&gt;
&lt;li&gt;Soc
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="Binder" scheme="http://yangxin.online/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Handler解析</title>
    <link href="http://yangxin.online/handler-jie-xi.html"/>
    <id>http://yangxin.online/handler-jie-xi.html</id>
    <published>2019-10-19T13:27:32.000Z</published>
    <updated>2019-10-19T16:01:37.174Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Handler的几个问题"><a href="#Handler的几个问题" class="headerlink" title="Handler的几个问题"></a>Handler的几个问题</h4><ol><li>Handler内存泄漏的测试<br>在消息未发送之前，将activity销毁，需要remove消息及将handler赋值为null</li><li>为什么不能在子线程创建Handler<br>在子线程中直接new Handler，会获取当前线程的Looper，但我们并没有穿件Looper</li><li>textView.setText()只能在主线程执行？<br>是的，因为setText()会刷新界面，调用requestLayout及invalidate，内部会做是否为主线程的检查</li><li>new Handler()两种写法有什么区别？<br>直接new Handler 重写他的handlerMessage()方法不推荐，通过new Handler(new Handler.CallBack)是推荐做法 CallBack接口的handlerMessage方法应返回为true</li><li>ThreadLocal用法和原理<br>ThreadLocal 内部是一个Map对象，保存着key和value，可以为当前的线程，value为线程保存的值</li></ol><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ol><li>从应用的创建：ActivityThread.main() -&gt; Looper.preMainLooper-&gt; 这时候ThreadLocal.get() = null -&gt;会创建主线程的Looper对象及唯一关联的MessageQueue</li><li>当在主线程中new Handler()时 -&gt; 内部回调Looper.myLooper获取到主线程的Looper-&gt; 将looper的messagequeue赋值给Handler的变量 -&gt; 当handler调用sendMessage -&gt; queue.enqueueMessage()</li><li>在ActivityThread.main() -&gt; 会调用Looper.loop()方法 -&gt; 从消息队列中获取消息 -&gt;</li><li>调用message.target.dispachMessage -&gt; target即Handler，则会调用handler中的dispatch方法 -&gt; 最终掉用handler的handlerMessage方法</li></ol><h4 id="解决几个问题"><a href="#解决几个问题" class="headerlink" title="解决几个问题"></a>解决几个问题</h4><ol><li>为什么主线程用Looper死循环不会引发ANR异常<br>因为Looper.next开启死循环的时候，一旦需要等待时或者还没有执行到执行的时候，会调用NDK里的JNI方法，释放当前的时间片，这样就不会引发ANR异常</li><li>为什么Handler构造方法里面的Looper不是直接new？<br>因为直接new出来不一定能保证唯一，只有用Looper.prepare才能保证唯一性</li><li>MessageQueue为什么要放在Looper的私有构造方法里初始化<br>因为一个线程只能由一个Looper，所以在构造方法里初始化也就能保证MessageQueue的唯一性</li><li>主线程里的Looper.prepare/Looper.loop,是一直在无限循环里面的吗<br>是的</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Handler的几个问题&quot;&gt;&lt;a href=&quot;#Handler的几个问题&quot; class=&quot;headerlink&quot; title=&quot;Handler的几个问题&quot;&gt;&lt;/a&gt;Handler的几个问题&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Handler内存泄漏的测试&lt;br&gt;在消息未发送
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="Handler" scheme="http://yangxin.online/tags/Handler/"/>
    
      <category term="源码分析" scheme="http://yangxin.online/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Android架构MVX</title>
    <link href="http://yangxin.online/android-jia-gou-mvx.html"/>
    <id>http://yangxin.online/android-jia-gou-mvx.html</id>
    <published>2019-10-18T14:40:23.000Z</published>
    <updated>2019-10-19T13:27:04.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MVC架构设计"><a href="#MVC架构设计" class="headerlink" title="MVC架构设计"></a>MVC架构设计</h3><h4 id="流程关系"><a href="#流程关系" class="headerlink" title="流程关系"></a>流程关系</h4><ol><li>View接受用户交互事件</li><li>View将用户的操作，交给Controller</li><li>Controller完成具体业务逻辑</li><li>得到封装好的Model,再进行View的更新</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Controller是作为媒介，处于Model和View之前，Model和View之间有紧密的联系，耦合性强<br>Controller做的事情过多，违反了面向对象的单一职责原则 </p><h3 id="MVP架构设计"><a href="#MVP架构设计" class="headerlink" title="MVP架构设计"></a>MVP架构设计</h3><h4 id="流程关系-1"><a href="#流程关系-1" class="headerlink" title="流程关系"></a>流程关系</h4><ol><li>View接受用户交互事件</li><li>View把用户的操作交给了Presenter</li><li>presenter控制Model进行业务逻辑的处理</li><li>presenter处理完毕后，数据封装进Model</li><li>presenter收到通知后，再更新数据</li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>双向通信方式</p><ol><li>View层与Model层完全解耦</li><li>所有的逻辑都交给Presenter处理</li><li>MVP分层较为严谨</li></ol><h4 id="MVVM架构设计"><a href="#MVVM架构设计" class="headerlink" title="MVVM架构设计"></a>MVVM架构设计</h4><h4 id="流程关系-2"><a href="#流程关系-2" class="headerlink" title="流程关系"></a>流程关系</h4><ol><li>View接受用户数据</li><li>View把用户的操作交给了ViewModel</li><li>ViewModel控制Model进行业务处理</li><li>ViewModel处理完毕后，数据封装进Model，刷新View</li></ol><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>降低耦合度：一个ViewModel层可以绑定不同的View层，当Model变化时View可以不变</li><li>可以把一些视图逻辑放在ViewModel层中，让很多View可以重用这些视图逻辑</li></ol><h4 id="dataBinding的使用"><a href="#dataBinding的使用" class="headerlink" title="dataBinding的使用"></a>dataBinding的使用</h4><p>1.gradle文件添加，支持</p><pre><code>// 添加DataBinding依赖    dataBinding{        enabled = true    }</code></pre><ol start="2"><li>布局文件中，添加最外层layout根布局<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;/layout&gt;</code></pre></li><li>添加定义data标签，定义数据及数据来源<pre><code>&lt;!-- 定义该View（布局）需要绑定的数据来源 --&gt; &lt;data&gt;     &lt;variable             name=&quot;user&quot;             type=&quot;com.zyx.cherish.mvp.bean.UserInfo&quot; /&gt; &lt;/data&gt;</code></pre></li><li>在正常布局中用data中定义的name去使用“@=”是为了实现双向绑定（v -&gt; model）<pre><code>&lt;EditText             android:layout_width=&quot;wrap_content&quot;             android:layout_height=&quot;wrap_content&quot;             android:text=&quot;@={user.name}&quot; /&gt;</code></pre></li><li>build之后在activity中通过DatabindinngUtils绑定类与布局,然后就可以设置数据<pre><code>ActivityLoginLayoutBinding viewDataBinding = DataBindingUtil.setContentView(this, R.layout.activity_login_layout);</code></pre></li></ol><p>viewDataBinding.setUser(userInfo);</p><pre><code>#### 源码分析**内存消耗的缺点**1. 会生成大量的object的对象，用到了数组保存数组2. 每个View会监听数据变化，创建了线程3. 在刷新时会轮训发送handler消息在定义布局后通过rebuild，会生成额外的文件，这个是系统通过APT生成的主要有1. activity_login_layout-layout.xml 配置文件，可以让dataBing方便查找View2. activity_login_layout 为每个View添加了Tag如binding_13. DataBinderMapperImpl 这个是具体实现绑定类4. 在DataBindingUtil.setContentView(this, R.layout.activity_login_layout)后会对布局中的控件进行绑定5. 线程 mRebindRunnable  控件会对M数据修改做监听，来更新V的数据6. InverseBindingListener 控件自身数据修改即V数据修改，会更新M的数据</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MVC架构设计&quot;&gt;&lt;a href=&quot;#MVC架构设计&quot; class=&quot;headerlink&quot; title=&quot;MVC架构设计&quot;&gt;&lt;/a&gt;MVC架构设计&lt;/h3&gt;&lt;h4 id=&quot;流程关系&quot;&gt;&lt;a href=&quot;#流程关系&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="MVC" scheme="http://yangxin.online/tags/MVC/"/>
    
      <category term="MVP" scheme="http://yangxin.online/tags/MVP/"/>
    
      <category term="MVVM" scheme="http://yangxin.online/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>切面编程</title>
    <link href="http://yangxin.online/qie-mian-bian-cheng.html"/>
    <id>http://yangxin.online/qie-mian-bian-cheng.html</id>
    <published>2019-10-14T11:11:24.000Z</published>
    <updated>2019-10-16T11:52:53.230Z</updated>
    
    <content type="html"><![CDATA[<h4 id="AspectJ-的几个注意"><a href="#AspectJ-的几个注意" class="headerlink" title="AspectJ 的几个注意"></a>AspectJ 的几个注意</h4><ol><li>as3.0.1 gradle4.4-all  需要r17(NDK)</li><li>as3.2.1 gradle4.6-all</li><li>as3.4.0 gradle5.1.1-all 存在过时的api</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;AspectJ-的几个注意&quot;&gt;&lt;a href=&quot;#AspectJ-的几个注意&quot; class=&quot;headerlink&quot; title=&quot;AspectJ 的几个注意&quot;&gt;&lt;/a&gt;AspectJ 的几个注意&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;as3.0.1 gradle4.4-al
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="AOP" scheme="http://yangxin.online/tags/AOP/"/>
    
      <category term="Aspectj" scheme="http://yangxin.online/tags/Aspectj/"/>
    
  </entry>
  
  <entry>
    <title>几个问题</title>
    <link href="http://yangxin.online/ji-ge-wen-ti.html"/>
    <id>http://yangxin.online/ji-ge-wen-ti.html</id>
    <published>2019-10-11T12:33:40.000Z</published>
    <updated>2019-10-16T11:52:49.366Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-fragment的切换有多少种方式，有区别吗"><a href="#1-fragment的切换有多少种方式，有区别吗" class="headerlink" title="1. fragment的切换有多少种方式，有区别吗"></a>1. fragment的切换有多少种方式，有区别吗</h4><ol><li>add/remove，replace（remove后add，只有一个），hide/show(较耗性能), attach/detach(不会回收fragment,但会回收里面的View)</li><li>只要我们创建了activity一定要在manifest中声明吗<h4 id="3-activity有几种启动模式，各自的使用场景"><a href="#3-activity有几种启动模式，各自的使用场景" class="headerlink" title="3. activity有几种启动模式，各自的使用场景"></a>3. activity有几种启动模式，各自的使用场景</h4></li><li>共有四种启动模式</li><li>应用的首页，通常是singleTask <h4 id="4-实际开发中文件命名有何规范"><a href="#4-实际开发中文件命名有何规范" class="headerlink" title="4.实际开发中文件命名有何规范"></a>4.实际开发中文件命名有何规范</h4></li><li>java文件以系统名结尾，XXXActivity,XXXFragment,XXXApplication</li><li>布局名以系统名+业务名+类型， activity_home_layout ,Layout布局文件</li><li>类或者方法添加注释<h4 id="5-如何封装框架"><a href="#5-如何封装框架" class="headerlink" title="5. 如何封装框架"></a>5. 如何封装框架</h4></li><li>从调用时可变参数的封装</li><li>核心部分不变参数及通用方法的设计</li><li>回调函数处理，异常处理，线程切换，数据转化的通用设计<h4 id="6-Charles的使用"><a href="#6-Charles的使用" class="headerlink" title="6.Charles的使用"></a>6.Charles的使用</h4></li><li>请求拦截，查看请求及响应信息</li><li>请求地址的映射(Map),主要用于接口调试</li><li>请求参数设置，模拟慢网，超时等情况</li><li><h4 id="7-如何有序地做内存分析与优化"><a href="#7-如何有序地做内存分析与优化" class="headerlink" title="7. 如何有序地做内存分析与优化"></a>7. 如何有序地做内存分析与优化</h4><a href="https://juejin.im/post/5b1b5e29f265da6e01174b84" target="_blank" rel="noopener">https://juejin.im/post/5b1b5e29f265da6e01174b84</a><h4 id="8-启动优化"><a href="#8-启动优化" class="headerlink" title="8. 启动优化"></a>8. 启动优化</h4><a href="https://juejin.im/post/5d95f4a4f265da5b8f10714b" target="_blank" rel="noopener">https://juejin.im/post/5d95f4a4f265da5b8f10714b</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-fragment的切换有多少种方式，有区别吗&quot;&gt;&lt;a href=&quot;#1-fragment的切换有多少种方式，有区别吗&quot; class=&quot;headerlink&quot; title=&quot;1. fragment的切换有多少种方式，有区别吗&quot;&gt;&lt;/a&gt;1. fragment的切
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="问题" scheme="http://yangxin.online/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Material Design</title>
    <link href="http://yangxin.online/material-design.html"/>
    <id>http://yangxin.online/material-design.html</id>
    <published>2019-10-08T03:27:37.000Z</published>
    <updated>2019-10-09T05:19:45.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a>Material Design</h3><p>它是一种Google官方推荐的设计规范。正如Android的碎片化，基于Android系统自研发的，拥有独特的交互和视觉效果的手机品牌在国内也是层出不穷，如小米的MIUI，魅族的flyme，锤子的Smartisan等等，这种开发被叫做ROM开发。对于App应用，按照安卓最新的MaterialDesign规范来进行单独的安卓版界面设计，这个是最花时间的，但是是最规范的</p><h4 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h4><ol><li>FloatActionBar</li><li>bottomBar</li><li>topBar</li><li>Bottom navigation</li><li>Navigation drawer</li><li>Snackbars<br>…等等</li></ol><h3 id="CoordinatorLayout的原理"><a href="#CoordinatorLayout的原理" class="headerlink" title="CoordinatorLayout的原理"></a>CoordinatorLayout的原理</h3><p>依赖于NestedScroll的实现，CoordinatorLayout必须实现NestedScrollingParent,滚动对象如RecycleView必须实现NestedScrollingChild，</p><h4 id="CardView的原理"><a href="#CardView的原理" class="headerlink" title="CardView的原理"></a>CardView的原理</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Material-Design&quot;&gt;&lt;a href=&quot;#Material-Design&quot; class=&quot;headerlink&quot; title=&quot;Material Design&quot;&gt;&lt;/a&gt;Material Design&lt;/h3&gt;&lt;p&gt;它是一种Google官方推荐的设计规
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="Material Design" scheme="http://yangxin.online/tags/Material-Design/"/>
    
  </entry>
  
  <entry>
    <title>Android屏幕适配</title>
    <link href="http://yangxin.online/android-ping-mu-gua-pei.html"/>
    <id>http://yangxin.online/android-ping-mu-gua-pei.html</id>
    <published>2019-09-30T06:33:56.000Z</published>
    <updated>2019-10-08T03:26:29.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android的碎片化"><a href="#Android的碎片化" class="headerlink" title="Android的碎片化"></a>Android的碎片化</h3><p>android的碎片化严重，屏幕尺寸不同，分辨率密度，决定了做适配的重要性</p><h4 id="常见方式"><a href="#常见方式" class="headerlink" title="常见方式"></a>常见方式</h4><ol><li>避免写死控件，使用wrap_content,match_parent</li><li>LinearLayout线性布局：权重</li><li>RelativeLayout绝对布局</li><li>ContrainLayout 约束布局</li><li>Percent-support-lib 百分比布局</li></ol><h4 id="图片资源释放"><a href="#图片资源释放" class="headerlink" title="图片资源释放"></a>图片资源释放</h4><ol><li>.9图片或者SVG实现缩放</li><li>备用位图匹配不同的分辨率</li></ol><h4 id="用户流程匹配"><a href="#用户流程匹配" class="headerlink" title="用户流程匹配"></a>用户流程匹配</h4><ol><li>根据业务逻辑不同执行不同的跳转</li><li>根据别名展示不同的界面</li></ol><h4 id="限定符适配"><a href="#限定符适配" class="headerlink" title="限定符适配"></a>限定符适配</h4><ol><li>分辨率</li><li>尺寸</li><li>最小屏</li><li>横竖屏</li></ol><h4 id="刘海屏的适配"><a href="#刘海屏的适配" class="headerlink" title="刘海屏的适配"></a>刘海屏的适配</h4><ol><li>Android 9.0官方适配</li><li>华为，OPPO，vivo </li></ol><h3 id="适配方式"><a href="#适配方式" class="headerlink" title="适配方式"></a>适配方式</h3><h4 id="限定符适配-1"><a href="#限定符适配-1" class="headerlink" title="限定符适配"></a>限定符适配</h4><p><strong>优点</strong></p><ol><li>使用简单，无需开发者手动指定</li><li>Google推荐使用方式，有系统自行判断</li><li>适配通过不同的xml实现，无需代码加逻辑</li></ol><p><strong>缺点</strong></p><ol><li>增加APK大小，适配机型越多，xml越多</li><li>适配所以，大概增加近3m</li><li>不能适配奇葩机型，如手表<h4 id="百分比适配"><a href="#百分比适配" class="headerlink" title="百分比适配"></a>百分比适配</h4></li></ol><p><strong>优点</strong></p><ol><li>通过百分比定义宽高，比较方便</li><li>彻底抛弃px,dp</li><li>开发量小</li></ol><p><strong>缺点</strong></p><ol><li>自定义不支持</li><li>对代码侵入强<h4 id="修改系统density-densityScale-densityDpi"><a href="#修改系统density-densityScale-densityDpi" class="headerlink" title="修改系统density, densityScale, densityDpi"></a>修改系统density, densityScale, densityDpi</h4><h4 id="代码动态适配"><a href="#代码动态适配" class="headerlink" title="代码动态适配"></a>代码动态适配</h4></li></ol><h3 id="网易云音乐歌单页面"><a href="#网易云音乐歌单页面" class="headerlink" title="网易云音乐歌单页面"></a>网易云音乐歌单页面</h3><h4 id="Toolbar的使用"><a href="#Toolbar的使用" class="headerlink" title="Toolbar的使用"></a>Toolbar的使用</h4><ol><li>4.4之前是使用ActionBar，之后推荐使用Toolbar</li><li>Toolbar不符合设计要求，通过反射修改子元素的属性(left,pading等)<h4 id="沉浸式设计"><a href="#沉浸式设计" class="headerlink" title="沉浸式设计"></a>沉浸式设计</h4></li><li>沉浸式与非沉浸式的区别是状态栏是否透明，是否与App主题是否一致.<br>通过属性，开启沉浸式后状态栏就会变成浮动的，导致Toolbar向上移动<pre><code>     &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;     &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;</code></pre>通过代码控制，同样会导致Toolbar向上移动，内容延伸进状态栏</li><li>通过自定义设置一个透明的statusBarView，用于定义statusBar的颜色</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android的碎片化&quot;&gt;&lt;a href=&quot;#Android的碎片化&quot; class=&quot;headerlink&quot; title=&quot;Android的碎片化&quot;&gt;&lt;/a&gt;Android的碎片化&lt;/h3&gt;&lt;p&gt;android的碎片化严重，屏幕尺寸不同，分辨率密度，决定了做适配的
      
    
    </summary>
    
      <category term="“Android”" scheme="http://yangxin.online/categories/%E2%80%9CAndroid%E2%80%9D/"/>
    
    
      <category term="屏幕适配" scheme="http://yangxin.online/tags/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>属性动画</title>
    <link href="http://yangxin.online/shu-xing-dong-hua.html"/>
    <id>http://yangxin.online/shu-xing-dong-hua.html</id>
    <published>2019-09-29T14:51:12.000Z</published>
    <updated>2019-10-08T02:21:07.756Z</updated>
    
    <content type="html"><![CDATA[<h4 id="动画的种类"><a href="#动画的种类" class="headerlink" title="动画的种类"></a>动画的种类</h4><ol><li>平移</li><li>透明</li><li>旋转</li><li>缩放</li><li>帧动画</li></ol><h4 id="动画的设计考虑"><a href="#动画的设计考虑" class="headerlink" title="动画的设计考虑"></a>动画的设计考虑</h4><ol><li>面向用户为开发者，因此API尽量简单</li><li>一个View有多个动画，但同时只能由一个运行</li><li>动画执行不能依赖于自身for循环</li><li>如何让动画动起来</li></ol><h4 id="动画任务"><a href="#动画任务" class="headerlink" title="动画任务"></a>动画任务</h4><ol><li>控件</li><li>时长</li><li>起始值</li><li>差值器  </li></ol><h4 id="在属性动画初始化的的过程中"><a href="#在属性动画初始化的的过程中" class="headerlink" title="在属性动画初始化的的过程中"></a>在属性动画初始化的的过程中</h4><ol><li>创建ObjectAnimator对象，保存控件及属性名，</li><li>设置关键帧的值，创建PropertyValueHolder, 通过KeyframeSet的ofInt方法将动画分解成不同的关键帧</li><li>创建关键帧，Keyframe保存了关键帧的mFraction比例，值没Value及值类型mValueType</li><li>估值器的设置，是用来计算关键帧之间具体的值，</li><li>差值器的设置是修改某个时间点动画的百分比</li></ol><h4 id="自定义控件开发思路"><a href="#自定义控件开发思路" class="headerlink" title="自定义控件开发思路"></a>自定义控件开发思路</h4><ol><li>观察有哪些动画</li><li>哪些元素比较特别，后面有没有可能变更需求</li><li>看是否有事件交互</li><li>如何设置自定义控件较为合理</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;动画的种类&quot;&gt;&lt;a href=&quot;#动画的种类&quot; class=&quot;headerlink&quot; title=&quot;动画的种类&quot;&gt;&lt;/a&gt;动画的种类&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;平移&lt;/li&gt;
&lt;li&gt;透明&lt;/li&gt;
&lt;li&gt;旋转&lt;/li&gt;
&lt;li&gt;缩放&lt;/li&gt;
&lt;li&gt;帧动画&lt;
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="属性动画" scheme="http://yangxin.online/tags/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android事件分发源码分析</title>
    <link href="http://yangxin.online/android-shi-jian-fen-fa-yuan-ma-fen-xi.html"/>
    <id>http://yangxin.online/android-shi-jian-fen-fa-yuan-ma-fen-xi.html</id>
    <published>2019-09-29T05:18:15.000Z</published>
    <updated>2019-09-29T14:50:30.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="事件分发的类型"><a href="#事件分发的类型" class="headerlink" title="事件分发的类型"></a>事件分发的类型</h4><p>down，move， up，cancel</p><h4 id="事件分发序列"><a href="#事件分发序列" class="headerlink" title="事件分发序列"></a>事件分发序列</h4><p>down -&gt; up<br>down -&gt; move -&gt; up</p><h4 id="事件分发的对象"><a href="#事件分发的对象" class="headerlink" title="事件分发的对象"></a>事件分发的对象</h4><p>Activity  ViewGroup  View</p><h4 id="事件分发的方法"><a href="#事件分发的方法" class="headerlink" title="事件分发的方法"></a>事件分发的方法</h4><p>dispatchTouchEvent()<br>onInterceptTouchEvent()<br>onTouchEvent()</p><h4 id="Activity的事件分发"><a href="#Activity的事件分发" class="headerlink" title="Activity的事件分发"></a>Activity的事件分发</h4><ol><li>dispatchTouchEvent</li><li>PhoneWindow.superDispatchTouchEvent()</li><li>DecorView.superDispatchTouchEvent</li><li>ViewGroup.dispatchTouchEvent<br>事件由Activity到了ViewGroup，如果View没有消费掉，会调用Activity的onTouchEvent</li></ol><h4 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h4><ol><li>事件从Down开始，接收到Down事件时会做取消并清除touch事件，置空mFistTouchTarget对象，清空Touch标记位</li><li>是否拦截判断(除Down时间以外），通过onIntercept，子类可以通过修改requestDisallowInteceptTouchEvent使父容器不拦截事件.默认都会走onInterceptTouchEvent方法，默认返回false</li><li>会调用dispatchTranseformdTouchEvent方法,内部会调用子类的dispatchTouchEvent方法或者父类的dispatchTouchEvent的方法</li></ol><h4 id="View中的事件处理"><a href="#View中的事件处理" class="headerlink" title="View中的事件处理"></a>View中的事件处理</h4><ol><li>事件传递到中，会先发判断TouchListener,如果设置了TouchListener,根据回调方法onTouch方法的返回值，做响应处理，若返回true则进行第二步，否则第三步</li><li>onTouch中返回true，则意味着事件被消费，onTouchEvent的方法将不再执行，事件结束</li><li>onTouch中返回false,则意味着事件没有消费，将继续执行onTouchEvent方法</li><li>onTouchEvent会更具事件类型执行不同的逻辑</li><li>当事件时down时，会判断是否设置了longClick事件，设置了则会更具到up的时长和longClick方法的返回值去决定是否执行onClickListener方法，修改OnLongClickListener方法的返回值可以使两个方法都执行</li></ol><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><h4 id="架构设计思想的需求点"><a href="#架构设计思想的需求点" class="headerlink" title="架构设计思想的需求点"></a>架构设计思想的需求点</h4><ol><li>每个界面上的元素都需要有事件响应，那意味着事件的核心处理类不能太多</li><li>事件传递的工作不能丢给开发者，只暴露接口</li><li>每个控件都可以接受事件和消费事件，如果控件消费了，你那后续事件就交给这个事件了</li><li>如何查找会消费事件的控件</li><li>如何更具坐标查找该控件的范围</li><li>每次发生事件，都需要遍历每个子元素吗？</li></ol><h5 id="为什么所有的控件都继承字View"><a href="#为什么所有的控件都继承字View" class="headerlink" title="为什么所有的控件都继承字View"></a>为什么所有的控件都继承字View</h5><p>View是事件处理和传递的抽象类，还包括绘制，测量其他代码</p><h4 id="事件分发的思考"><a href="#事件分发的思考" class="headerlink" title="事件分发的思考"></a>事件分发的思考</h4><ol><li>容器包含很多子控件</li><li>子控件和容器都能消费事件</li><li>子控件不能进行分发给其他子控件</li><li>分发功能只能由容器分发给子控件</li></ol><h4 id="如何快速查找能响应的控件"><a href="#如何快速查找能响应的控件" class="headerlink" title="如何快速查找能响应的控件"></a>如何快速查找能响应的控件</h4><p>TouchTarget消费对象的缓存队列的设计，利用链表及缓存池，通过链表操作达到复用的效果<br>obtain()方法，内部操作加锁，判断静态变量recycleBin缓存对象TouchTarget是否为空，不为空则取出第一个，否则new出一个TouchTarget.当一系列事件消费完后 ，释放这个对象加入缓存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h3&gt;&lt;h4 id=&quot;事件分发的类型&quot;&gt;&lt;a href=&quot;#事件分发的类型&quot; class=&quot;headerlink&quot; title=&quot;事件分
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="源码分析及架构" scheme="http://yangxin.online/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>自定义UI之Canvas</title>
    <link href="http://yangxin.online/zi-ding-yi-ui-zhi-canvas.html"/>
    <id>http://yangxin.online/zi-ding-yi-ui-zhi-canvas.html</id>
    <published>2019-09-27T04:12:26.000Z</published>
    <updated>2019-10-20T06:54:56.279Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Canvas绘制几何图形，文本，位图等"><a href="#Canvas绘制几何图形，文本，位图等" class="headerlink" title="Canvas绘制几何图形，文本，位图等"></a>Canvas绘制几何图形，文本，位图等</h4><ol><li>drawBitmap() 在指定坐标绘制位图</li><li>drawLine()根据起始点绘制连线</li><li>drawPath()根据给定的路径，绘制连线</li><li>drawPoint()根据给定的坐标，绘制点</li><li>drawText()根据给定的坐标和文本绘制文字<br>…..</li></ol><h4 id="位置，形状变化等"><a href="#位置，形状变化等" class="headerlink" title="位置，形状变化等"></a>位置，形状变化等</h4><ol><li>void translate(float x, float y) 平移操作</li><li>void scale() 缩放</li><li>void rotate() 旋转</li><li>void skew() 倾斜</li><li>void clipXXX()剪切</li><li>void clipOutXXX()反向剪切</li><li>setMatrix(Matrix matrix) 通过matrix实现以上效果</li></ol><h4 id="Canvas的状态保存"><a href="#Canvas的状态保存" class="headerlink" title="Canvas的状态保存"></a>Canvas的状态保存</h4><p>Canvas内部维护着状态栈，通过save和restore保存恢复<br>离屏绘制saveLayer</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Canvas绘制几何图形，文本，位图等&quot;&gt;&lt;a href=&quot;#Canvas绘制几何图形，文本，位图等&quot; class=&quot;headerlink&quot; title=&quot;Canvas绘制几何图形，文本，位图等&quot;&gt;&lt;/a&gt;Canvas绘制几何图形，文本，位图等&lt;/h4&gt;&lt;ol&gt;

      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="canvas" scheme="http://yangxin.online/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>插件化学习</title>
    <link href="http://yangxin.online/cha-jian-hua-xue-xi.html"/>
    <id>http://yangxin.online/cha-jian-hua-xue-xi.html</id>
    <published>2019-09-26T09:03:34.000Z</published>
    <updated>2019-10-16T04:31:24.740Z</updated>
    
    <content type="html"><![CDATA[<h4 id="插件化的目的"><a href="#插件化的目的" class="headerlink" title="插件化的目的"></a>插件化的目的</h4><ol><li><p>自解耦</p></li><li><p>免安装</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;插件化的目的&quot;&gt;&lt;a href=&quot;#插件化的目的&quot; class=&quot;headerlink&quot; title=&quot;插件化的目的&quot;&gt;&lt;/a&gt;插件化的目的&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自解耦&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;免安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="插件化学习" scheme="http://yangxin.online/tags/%E6%8F%92%E4%BB%B6%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>自定义UI之Paint</title>
    <link href="http://yangxin.online/zi-ding-yi-ui.html"/>
    <id>http://yangxin.online/zi-ding-yi-ui.html</id>
    <published>2019-09-26T04:24:40.000Z</published>
    <updated>2019-09-27T04:13:33.229Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Paint画笔"><a href="#Paint画笔" class="headerlink" title="Paint画笔"></a>Paint画笔</h4><p>画笔的实现内部都是调用native方法的，画笔的基础Api</p><ol><li>setColor(Color.RED)</li><li>setARGB(),setAlpha  设置颜色及透明度</li><li>setAntiAlias(true) 抗锯齿</li><li>setStyle() Paint.Style.STROKE/FILL/FILL_AND_STROKE  描边，填充效果</li><li>setStrokeWidth() 描边宽度</li><li>setStrokeCap() Paint.Cap.BUTT/ROUND/SQUARE  线尾部形状 默认BUTT,round圆角效果，方形</li><li>setStrokeJoin() 拐角效果，MITER/ROUND/BEVEL 默认MITER尖角，圆角，折角</li><li>setShader(Shader shader) 设置环形渲染器</li><li>setXfermode() 设置图层混合模式</li><li>setColorFilter()设置颜色过滤器</li><li>setFilterBitmap(true) 设置双线性过滤，使图片更加平滑</li><li>setMaskFilter() 设置画笔的遮罩滤镜</li><li>setTextScalX(2) 设置缩放文本倍数</li><li>setTextSize(38) 设置文本字体大小</li><li>setTextAlign() 对齐方式</li><li>setUnderLineText(true) 设置下划线</li><li>getTextBounds(str, 0, str.length(), rect) 测量文本大小，将文本大小信息存放在rect中</li><li>measureText(str) 测量文本的宽</li><li>getFontMetrics()获取字体度量对象, 变量包括ascent,descent,top,bottom,leading ,字体的高度为descent - ascennt, leading为行间距是当前字的ascent - 上一个字的descent</li></ol><h4 id="setShader-Shader-shader-设置环形渲染器-着色器"><a href="#setShader-Shader-shader-设置环形渲染器-着色器" class="headerlink" title="setShader(Shader shader) 设置环形渲染器(着色器)"></a>setShader(Shader shader) 设置环形渲染器(着色器)</h4><ol><li>LinearGradient 线性渲染</li><li>RadilGradient 环形渲染</li><li>SweepGradient 扫描渲染</li><li>BitmapGradient 位图渲染</li></ol><h5 id="TileMode-平铺模式"><a href="#TileMode-平铺模式" class="headerlink" title="TileMode 平铺模式"></a>TileMode 平铺模式</h5><ol><li>CLAMP 超出后 以最后像素拉升填充  </li><li>REPEAT 超出后重复平铺</li><li>MIRROR 镜像填充</li></ol><h4 id="组合渲染器，图层混合模式Xfermode"><a href="#组合渲染器，图层混合模式Xfermode" class="headerlink" title="组合渲染器，图层混合模式Xfermode"></a>组合渲染器，图层混合模式Xfermode</h4><p><strong>PortorDuff.Mode</strong></p><ol><li>使用场景<ul><li>ComposeShader 组合渲染器</li><li>Paint.setXfermode()</li><li>porterDuffColorFilter 颜色过滤器</li></ul></li><li>使用注意<ul><li>静止硬件加速，14之后图层混合不支持硬件加速，但系统是默认打开的setLayerType(View.LAYER_SOFTWARE, null)</li><li>离屏绘制，去除背景等其他干扰,保证xfermode不会出现错误结果saveLayer  ,restoreToCount,<h4 id="setColorFilter"><a href="#setColorFilter" class="headerlink" title="setColorFilter"></a>setColorFilter</h4></li></ul></li></ol><p><strong>LightColorFilter</strong><br>颜色过滤器，可以过滤掉指定颜色<br><strong>PorterDuffFilter</strong><br>颜色和其他的图层混合<br><strong>颜色矩阵ColorMatrixColorFilter</strong><br>通过修改颜色矩阵Matrix数组中的值</p><h4 id="画笔滤镜总结"><a href="#画笔滤镜总结" class="headerlink" title="画笔滤镜总结"></a>画笔滤镜总结</h4><ol><li>简单的模拟光照效果，可以使用LightColorFilter</li><li>图像与颜色的，图层混合的实现，PorterDuffColorFilter</li><li>颜色数组及颜色举证实现滤镜效果</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Paint画笔&quot;&gt;&lt;a href=&quot;#Paint画笔&quot; class=&quot;headerlink&quot; title=&quot;Paint画笔&quot;&gt;&lt;/a&gt;Paint画笔&lt;/h4&gt;&lt;p&gt;画笔的实现内部都是调用native方法的，画笔的基础Api&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;setColo
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="自定义UI" scheme="http://yangxin.online/tags/%E8%87%AA%E5%AE%9A%E4%B9%89UI/"/>
    
      <category term="shader" scheme="http://yangxin.online/tags/shader/"/>
    
      <category term="colorFilter" scheme="http://yangxin.online/tags/colorFilter/"/>
    
      <category term="xfermode" scheme="http://yangxin.online/tags/xfermode/"/>
    
  </entry>
  
  <entry>
    <title>PPT 制作学习</title>
    <link href="http://yangxin.online/ppt-zhi-zuo-xue-xi.html"/>
    <id>http://yangxin.online/ppt-zhi-zuo-xue-xi.html</id>
    <published>2019-09-25T13:00:18.000Z</published>
    <updated>2019-09-26T04:20:17.043Z</updated>
    
    <content type="html"><![CDATA[<h5 id="PPT的学习记录"><a href="#PPT的学习记录" class="headerlink" title="PPT的学习记录"></a>PPT的学习记录</h5><h4 id="PPT学习之剪切"><a href="#PPT学习之剪切" class="headerlink" title="PPT学习之剪切"></a>PPT学习之剪切</h4><p>通过剪切可以得到一组图片，作为PPT的背景样式即板式，做到风格统一</p><h4 id="PPT之基本四步骤"><a href="#PPT之基本四步骤" class="headerlink" title="PPT之基本四步骤"></a>PPT之基本四步骤</h4><ol><li>字体统一</li><li>突出标题</li><li>颜色取巧</li><li>配图</li></ol><h4 id="PPT之四大技能"><a href="#PPT之四大技能" class="headerlink" title="PPT之四大技能"></a>PPT之四大技能</h4><ol><li>复制</li><li>清除格式</li><li>更改图片</li><li>PPT草稿</li></ol><h4 id="PPT之人物图片处理"><a href="#PPT之人物图片处理" class="headerlink" title="PPT之人物图片处理"></a>PPT之人物图片处理</h4><ol><li>聚焦脸部</li><li>圆形剪裁</li><li>图片装饰</li><li>去掉颜色</li></ol><h4 id="PPT之风格迥异的处理"><a href="#PPT之风格迥异的处理" class="headerlink" title="PPT之风格迥异的处理"></a>PPT之风格迥异的处理</h4><ol><li>调节大小，基准线</li><li>等比裁剪</li><li>横向分布</li><li>更换背景</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;PPT的学习记录&quot;&gt;&lt;a href=&quot;#PPT的学习记录&quot; class=&quot;headerlink&quot; title=&quot;PPT的学习记录&quot;&gt;&lt;/a&gt;PPT的学习记录&lt;/h5&gt;&lt;h4 id=&quot;PPT学习之剪切&quot;&gt;&lt;a href=&quot;#PPT学习之剪切&quot; class=&quot;head
      
    
    </summary>
    
      <category term="技能" scheme="http://yangxin.online/categories/%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="PPT制作" scheme="http://yangxin.online/tags/PPT%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>AndroidUI 加载和绘制流程</title>
    <link href="http://yangxin.online/androidui-jia-zai-he-hui-zhi-liu-cheng.html"/>
    <id>http://yangxin.online/androidui-jia-zai-he-hui-zhi-liu-cheng.html</id>
    <published>2019-09-25T05:24:26.000Z</published>
    <updated>2019-09-26T04:19:54.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码总结"><a href="#源码总结" class="headerlink" title="源码总结"></a>源码总结</h3><h4 id="View是如何被添加到屏幕窗口上去的"><a href="#View是如何被添加到屏幕窗口上去的" class="headerlink" title="View是如何被添加到屏幕窗口上去的"></a>View是如何被添加到屏幕窗口上去的</h4><ol><li>在Activity的onCreate方法中调用setContentView将我们的布局传入</li><li>内部调用了Window的唯一实例对象PhoneWindow的setContentView方法</li><li>内部创建了顶层布局容器DecorView</li><li>在DecorView中加载了基础布局ViewGroup(主题布局)，</li><li>将我们的布局添加到基础布局的FrameLayout中 </li></ol><h4 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h4><ol><li>绘制入口<ul><li>ActivityThread.handlerResumeActivity</li><li>WindowManagerImpl.addView(decorView, layoutParams)</li><li>WindowManagerGlobal.addView()</li></ul></li><li>绘制的类及方法<ul><li>ViewRootImpl.addView(decorView, layoutParams, parentView)</li><li>ViewRootImpl.requestLayout()-&gt;scheduleTraversals()-&gt;doTraversals()-&gt;performTraversals()</li></ul></li><li>绘制流程的三大步骤<ul><li>ViewRootImpl.performMeasure()</li><li>ViewRootImpl.performLayout()</li><li>ViewRootImpl.performDraw</li></ul></li><li>绘制中的测量<ul><li>MeasureSpec的确定及计算: 顶层DecoView和其他View</li><li>DecorView通过窗口大小和DecoView本身大小确定</li><li>其他View通过父View的MeasureSpec和本身的大小确定</li></ul></li><li>绘制中的布局<ul><li>view.layout的方法确定自身的位置</li><li>若是ViewGroup类型，需要调用onLayout的方法确定子View的位置</li></ul></li><li>绘制中的绘制<ul><li>绘制背景drawableBackground</li><li>绘制自己onDraw</li><li>绘制子View  dispatchDraw</li><li>绘制前景，滚动条装等饰</li></ul></li></ol><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>onMeasure -&gt; onLayout(ViewGroup要实现) -&gt; onDraw(可选，系统控件不用实现)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;源码总结&quot;&gt;&lt;a href=&quot;#源码总结&quot; class=&quot;headerlink&quot; title=&quot;源码总结&quot;&gt;&lt;/a&gt;源码总结&lt;/h3&gt;&lt;h4 id=&quot;View是如何被添加到屏幕窗口上去的&quot;&gt;&lt;a href=&quot;#View是如何被添加到屏幕窗口上去的&quot; class=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="AndroidUI" scheme="http://yangxin.online/tags/AndroidUI/"/>
    
  </entry>
  
  <entry>
    <title>插件化</title>
    <link href="http://yangxin.online/cha-jian-hua.html"/>
    <id>http://yangxin.online/cha-jian-hua.html</id>
    <published>2019-09-21T02:33:35.000Z</published>
    <updated>2019-09-23T01:02:34.050Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VirtualAPK"><a href="#VirtualAPK" class="headerlink" title="VirtualAPK"></a>VirtualAPK</h3><p>是滴滴开源的插件化项目，实现动态加载和运行apk的功能。<br>支持任何class的加载，资源的加载及四大组件<br><img src="https://github.com/didi/VirtualAPK/raw/master/imgs/va.png" alt="架构图"><br>android 插件化框架VitualAPK解析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;VirtualAPK&quot;&gt;&lt;a href=&quot;#VirtualAPK&quot; class=&quot;headerlink&quot; title=&quot;VirtualAPK&quot;&gt;&lt;/a&gt;VirtualAPK&lt;/h3&gt;&lt;p&gt;是滴滴开源的插件化项目，实现动态加载和运行apk的功能。&lt;br&gt;支持任何cl
      
    
    </summary>
    
    
  </entry>
  
</feed>
