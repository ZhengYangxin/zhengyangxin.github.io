<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fighting！</title>
  
  <subtitle>潜行者的沉默</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangxin.online/"/>
  <updated>2020-04-02T22:33:32.056Z</updated>
  <id>http://yangxin.online/</id>
  
  <author>
    <name>Yangcy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跟我学：Android高级面试之说说Android系统的启动流程</title>
    <link href="http://yangxin.online/gen-wo-xue-android-gao-ji-mian-shi-zhi-shuo-shuo-android-xi-tong-de-qi-dong-liu-cheng.html"/>
    <id>http://yangxin.online/gen-wo-xue-android-gao-ji-mian-shi-zhi-shuo-shuo-android-xi-tong-de-qi-dong-liu-cheng.html</id>
    <published>2020-04-02T22:31:29.000Z</published>
    <updated>2020-04-02T22:33:32.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>本人从事Android客户端开发，最近在在深入Framwork学习，希望我的学习分享能帮到你。首先我们看一下关于Zygote我们应该如何去分析，这里通过一张思维导图帮助大家整理思路。思维导图一方面罗列了本文的大纲，另一方面也是希望读者朋友可以保存图片至自己的复习资料里。以便随时通过该大纲去复习，可以关注我，收藏文章进一步沟通学习！</p><p><img src="http://p1.pstatp.com/large/pgc-image/09c554f2e27f45639de7b22005dc7389" alt="跟我学：Android高级面试之说说Android系统的启动流程"></p><h3 id="说说Android系统的启动流程"><a href="#说说Android系统的启动流程" class="headerlink" title="说说Android系统的启动流程"></a>说说Android系统的启动流程</h3><p>面对这道面试题，面试官试想考察什么呢？</p><ul><li>Android中有哪些主要的系统进程</li><li>这些系统进程是怎么启动的</li><li>进程启动之后主要做了什么事</li></ul><h3 id="系统进程"><a href="#系统进程" class="headerlink" title="系统进程"></a>系统进程</h3><p>Android中有哪些系统进程，具体我们可以在init.rc的配置找到相应的启动代码</p><pre><code>start zygotestart servicemanagerstart surfaceflinger....</code></pre><p>上面几个熟悉的服务进程都是通过init单独创建启动的，还有 一个我们熟悉的SystemServer，这个服务进程是通过Zygote进程创建而不是init进程。</p><h3 id="Zygote的启动流程"><a href="#Zygote的启动流程" class="headerlink" title="Zygote的启动流程"></a>Zygote的启动流程</h3><p>关于Zygote的的相关知识可以参考<a href="https://www.toutiao.com/i6810136009775251975/?group_id=6810136009775251975" target="_blank" rel="noopener">跟我学：Android面试之深入Android Framework谈谈对Zygot的理解</a></p><p>它的启动流程是</p><ol><li>init进程fork出zygote进程</li><li>zygote创建虚拟机，注册jni函数</li><li>预加载系统资源</li><li>启动SystemServer</li><li>进入 Socket LOOP循环（工作原理）</li></ol><h3 id="SystemServer的启动"><a href="#SystemServer的启动" class="headerlink" title="SystemServer的启动"></a>SystemServer的启动</h3><p>在ZygoteInit.java的代码逻辑中，可以看到启动的关键代码</p><pre><code>int pid = Zygote.forkSystemServer(...) // 通过Zygote创建子线程handleSystemServerProcess(...)  // 然后初始化SystemServerZygoteInit.zygoteInit(...)ZygoteInit.nativeZygoteInit(...); // 这里面会启动启动binder机制，创建了Binder线程RuntimeInit.applicationInit(...) // 调用SystemServer.java类的入口函数main。内部基于反射实现// SystemServer的main方法public static void main(String[] args) {        new SystemServer().run();}run方法中主要以下几件事1. Looper.prepareMainLooper(); // 为主线程创建loop2. System.loadLibrary(&quot;android_servers&quot;); // 加载android的共享库，native层的代码3. createSystemContext(); // 创建系统上下文4. 分批启动服务startBootstrapServices();startCoreServices();startOtherServices();5. Looper.loop(); // 进入loop循环，主线程不会退出</code></pre><h3 id="系统服务的启动"><a href="#系统服务的启动" class="headerlink" title="系统服务的启动"></a>系统服务的启动</h3><p>系统服务的启动指startBootstrapServices();startCoreServices();startOtherServices();内部的服务启动。启动startBootstrapServices()中包括了熟悉的AMS，PMS，StartPowerManager等等。startCoreServices()包含了BatteryService，UsageStatsService，WebViewUpdateService等等。以及startOtherServices()中的其他服务。</p><h4 id="系统服务如何房补，让应用程序可见"><a href="#系统服务如何房补，让应用程序可见" class="headerlink" title="系统服务如何房补，让应用程序可见"></a>系统服务如何房补，让应用程序可见</h4><p>通过源码的阅读，我们可以发现最终服务是通过ServiceManager.addService(…) 将服务进行注册，然后才可以可被其他进程可见和使用</p><h4 id="系统服务运行在什么线程中？"><a href="#系统服务运行在什么线程中？" class="headerlink" title="系统服务运行在什么线程中？"></a>系统服务运行在什么线程中？</h4><p>主线程：并没有找到哪个系统服务是在主线程的中的</p><p>工作线程： AMS，PMS运行在自己的工作线程，或者在公用的工作线程DisplayThread，FgThread, IoThread, UiThread。</p><p>Binder线程：应用在跨进程调用时肯定是在binder线程里的，然后再去切换线程</p><h3 id="如何解决系统服务启动的相互依赖"><a href="#如何解决系统服务启动的相互依赖" class="headerlink" title="如何解决系统服务启动的相互依赖"></a>如何解决系统服务启动的相互依赖</h3><p>从上小结的startBootstrapServices();startCoreServices();startOtherServices();我们可以看出解决方式为</p><ul><li>分批启动：先启动AMS，PMS等，因为很多其他service都需要依赖他们</li><li>分阶段启动：在每个阶段去启动相应需要的服务</li></ul><h3 id="桌面启动"><a href="#桌面启动" class="headerlink" title="桌面启动"></a>桌面启动</h3><p>当AMS等其他服务都启动完毕，会调用mActivityManagerService.systemReady(()，在这里面会通过startHomeActivityLocked(currentUserId, “systemReady”);启动桌面应用的activity， Launcher.java。启动后会通过PMS查找所有的已安装的应用，然后显示在界面上</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>看到最后，我相信你一定对Zygote有一定了解了吧。回头看看第一部分的考查内容讲讲呗，对于每一个点的重点我都细心的为你做了高亮。还有纸上得来终觉浅，绝知此事要躬行。本文参考了Android api28的源码，希望你也去踩着点过一遍源码，肯定能加深理解！</p><p>我是Yangcy，该吃吃该喝喝，该学还得学，我们一起加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h3&gt;&lt;p&gt;本人从事Android客户端开发，最近在在深入Framwork学习，希望我的学习分享能帮到你。首先我们看一下关于Zygote我们应该如何去分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跟我学：LeetCode刷题之3. 无重复字符的最长子串</title>
    <link href="http://yangxin.online/gen-wo-xue-leetcode-shua-ti-zhi-3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan.html"/>
    <id>http://yangxin.online/gen-wo-xue-leetcode-shua-ti-zhi-3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan.html</id>
    <published>2020-04-02T22:28:50.000Z</published>
    <updated>2020-04-02T22:30:53.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>刷算法题需要一定的节奏，同样对待每一道算法题也需要认真的对待不可操之过急，否则会导致：算法虐我千万遍，我待算法如初恋！如果这句话是从对算法态度上说爱如初恋那必须得肯定你的态度，但如果是每一道算法题，反复都能虐你千万遍，那这个初恋的滋味肯定不好受。我们应该是面对新题对待如初恋，对待已经做过的题应该是勾勾手指，手到擒来的老司机，否则就是白刷。不仅浪费时间而且浪费精力，所以刷题必须讲究方式方法，建议反复阅读此文<a href="https://www.toutiao.com/i6809940499399442956/?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956" target="_blank" rel="noopener">跟我学：LeetCode刷题大法</a>。下面这里通过一张思维导图帮助大家整理这道题的思路。思维导图一方面罗列了本文的大纲，另一方面也是希望读者朋友可以保存图片至自己的复习资料里，以便随时通过该大纲去复习，<strong>注意关注标红的重点解法</strong>。</p><p><img src="http://p9.pstatp.com/large/pgc-image/cb03725f67104f17a800904dea296695" alt="跟我学：LeetCode刷题之3. 无重复字符的最长子串"></p><h3 id="看题总结"><a href="#看题总结" class="headerlink" title="看题总结"></a>看题总结</h3><p>给定一个字符串，请你找出其中<strong>不含有重复字符的 最长子串 的长度</strong>。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><p>Related Topics</p><p>哈希表</p><p>双指针</p><p>字符串</p><p>Sliding Window</p><p>通过对题目的阅读，我们可以得出以下几个结论</p><ol><li>题目类型为数组</li><li>要求是返回最长的不含重复字母的子串长度</li><li>输入的字符串可能为空串，输入判断</li></ol><h3 id="多解法及复杂度分析"><a href="#多解法及复杂度分析" class="headerlink" title="多解法及复杂度分析"></a>多解法及复杂度分析</h3><h4 id="解法一：暴力法，多重循环"><a href="#解法一：暴力法，多重循环" class="headerlink" title="解法一：暴力法，多重循环"></a>解法一：暴力法，多重循环</h4><p>首先希望读者能写出双重循环的模板代码，在此再次强调此代码是数组问题暴力法的套路<strong>墙裂建议背诵默写</strong>，如果还是不能随手写出回过头看一下此文<a href="https://www.toutiao.com/i6810353091251012108/?group_id=6810353091251012108" target="_blank" rel="noopener">跟我学：LeetCode刷题之1.两数之和</a>，好了继续此问题的暴力解决法就是通过双重循环，加内部一层循环判断[i,j]之间的元素是否是唯一的，然后做相应的移动和记录最大值。<strong>注意此处的双重循环的i，j范围</strong>，是由于allUnique()方法的for循环范围。</p><pre><code>public int lengthOfLongestSubstring(String s) {        int n = s.length();        int ans = 0;        for (int i = 0; i &lt; n; i++)            for (int j = i + 1; j &lt;= n; j++)                if (allUnique(s, i, j)) ans = Math.max(ans, j - i);        return ans;    }    public boolean allUnique(String s, int start, int end) {        Set&lt;Character&gt; set = new HashSet&lt;&gt;();        for (int i = start; i &lt; end; i++) {            Character ch = s.charAt(i);            if (set.contains(ch)) return false;            set.add(ch);        }        return true;    }</code></pre><p>复杂度分析</p><p>时间复杂度：O(n^3)，三重循环</p><p>空间复杂度：O(min(n, m))O(min(n,m))，我们需要 O(k)的空间来检查子字符串中是否有重复字符，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集/字母 m 的大小。</p><hr><h4 id="解法二：双指针-滑动串口"><a href="#解法二：双指针-滑动串口" class="headerlink" title="解法二：双指针+滑动串口"></a>解法二：双指针+滑动串口</h4><p>该题的实现思路主要是基于：滑动窗口。</p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！如左出右进变为bca</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p><ul><li>哈希法的实现可以基于Map定义key为字符串的中的每个字符，value为该字符的位置i+1(方便计算长度）</li><li>通过数组实现，应为字符串由字母组成所以可以根据ASCII码的字符大小128，存放字符的位置i+1。</li></ul><p>这里推荐使用数组，数组的存取都是O(1)的实现，当然Map在此种情况下也是的。代码如下</p><pre><code>public int lengthOfLongestSubstring(String s) {        if (s == null || s.length() == 0) {            return 0;        }        int[] hash = new int[128];        int start = 0;        int ans = 0;        for (int i = 0; i &lt; s.length(); i++) {            start = Math.max(ans, hash[s.charAt(i)]);            ans = Math.max(ans, i - start + 1);            hash[s.charAt(i)] = i + 1;        }        return ans;    }</code></pre><p>复杂度分析</p><p>时间复杂度：O(n)，只进行一次遍历</p><p>空间复杂度：O(m)，m 是字符集的大小128</p><hr><p>两种解法，充分体现了以<strong>空间换时间思想</strong>的，来一次加快算法处理速度。所以在算法题中哈希表数组和Map的代码也需要背诵记忆，才能游刃有余。</p><h3 id="同类题相关"><a href="#同类题相关" class="headerlink" title="同类题相关"></a>同类题相关</h3><h4 id="992-K-个不同整数的子数组"><a href="#992-K-个不同整数的子数组" class="headerlink" title="992. K 个不同整数的子数组"></a>992. K 个不同整数的子数组</h4><p>若你反复AC，且充分理解了本题解法，可以尝试去解答同类题992该题是困难题不过无妨，同类题的意思就是变形，往往是增加了特定的条件或者是针对不同的场景。所以同类题的目的是，透过现象看本质，一时的解不出不碍事，按我说的方法<a href="https://www.toutiao.com/i6809940499399442956/?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956" target="_blank" rel="noopener">跟我学：LeetCode刷题大法</a>，通过此种方法一定是越来越自信的刷题。</p><h1 id="技巧与心得"><a href="#技巧与心得" class="headerlink" title="技巧与心得"></a>技巧与心得</h1><ol><li>开一个github仓库用来记录各种题解</li><li>在idea或者vscode中都提供了leecode的插件刷题，方便调试断走流程</li><li>遇到不会的题不要慌，稳住心态直接看题解</li><li>文字类的表述不如视图类的直观，图文并茂精选图解优先或者参考leetcode国际站的大牛题解</li><li>图解依旧看着吃力也无妨，可以在哔哩哔哩或者YouTube上，通过leecode + 题号，搜索高收视率的视频观看</li><li>多看几次本文跟我学：<a href="https://www.toutiao.com/i6809940499399442956/?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956" target="_blank" rel="noopener">跟我学：LeetCode刷题大法</a>，相信我你肯定能越刷越自信</li></ol><h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>看到最后，我相信你对本题应该有不一样的感受了吧！在此若有不对之处或建议等，留言告诉我；若有疑惑或者不一样的看法，也请告诉我，我们可以一起探讨学习！</p><p>我是Yangcy，该吃吃该喝喝，该学还得学，我们一起加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h3&gt;&lt;p&gt;刷算法题需要一定的节奏，同样对待每一道算法题也需要认真的对待不可操之过急，否则会导致：算法虐我千万遍，我待算法如初恋！如果这句话是从对算法态
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://yangxin.online/categories/Algorithm/"/>
    
    
      <category term="Leetcode，无重复字符的最长子串" scheme="http://yangxin.online/tags/Leetcode%EF%BC%8C%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>跟我学：LeetCode刷题之2.两数相加</title>
    <link href="http://yangxin.online/gen-wo-xue-leetcode-shua-ti-zhi-2-liang-shu-xiang-jia.html"/>
    <id>http://yangxin.online/gen-wo-xue-leetcode-shua-ti-zhi-2-liang-shu-xiang-jia.html</id>
    <published>2020-04-02T22:23:47.000Z</published>
    <updated>2020-04-02T22:28:05.197Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>本题是LeetCode第二题，难度标记为中等。此题为链表题，不出意外遇到链表题都是画图解题，因为链表题的核心是在符合条件下的链表next指针的变化，除了链表的增删改查之外，如何<strong>反转链表的代码，</strong>我<strong>墙裂建议你先</strong>理解背诵，刷链表题基础必备代码，如下</p><pre><code>pubic ListNode reverse(ListNode head) {    ListNode pre = null;    ListNode cur = head;    while(cur != null){        ListNode next = cur.next;        cur.next = pre;        pre = cur;        cur = next;    }}</code></pre><p>这里通过一张思维导图帮助大家整理思路。思维导图一方面罗列了本文的大纲，另一方面也是希望读者朋友可以保存图片至自己的复习资料里，以便随时通过该大纲去复习。</p><p><img src="http://p1.pstatp.com/large/pgc-image/f6834647753d4094b9ac461b3ba45cc6" alt="跟我学：LeetCode刷题之2.两数相加"></p><h3 id="看题总结"><a href="#看题总结" class="headerlink" title="看题总结"></a>看题总结</h3><p>给出<strong>两个 非空 的链表</strong>用来表示<strong>两个非负的整数</strong>。其中，它们各自的位数是按照 <strong>逆序 的方式存储的</strong>，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，<strong>这两个数都不会以 0 开头</strong>。</p><p><strong>示例：</strong></p><pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><p>Related Topics</p><p>链表</p><p>数学</p><p>通过对题目的阅读，我们可以得出以下几个结论</p><ul><li>题目类型为链表</li><li>用两个链表表示两个整数，整数在链表中的存储方式是逆序的，通过链表实现两整数的相加操作，返回值也是用逆序的链表存储的整数。</li><li>非空链表，非负数整数，除了0之外整数不会以0开头，输入是合法的</li></ul><h3 id="多解法及复杂度分析"><a href="#多解法及复杂度分析" class="headerlink" title="多解法及复杂度分析"></a>多解法及复杂度分析</h3><h4 id="解法一：非递归实现"><a href="#解法一：非递归实现" class="headerlink" title="解法一：非递归实现"></a>解法一：非递归实现</h4><ol><li>定义一个哑结点dummy（可以避免对头结点的处理），指向当前节点cur，然后定义一个保存进位数值的 carry（因为两数相加可能会产生进位，便用 carry 来保存）</li><li>当 l1 或 l2 不为空时进行遍历，即二者都为空时才退出循环，</li><li>通过设置默认值为 0 的 x和 y，使得当二者中有一个为空时，使用 0 来与另一位相加</li><li>得到 sum 后，将 sum 的个位数连接到链表中，并将十位数赋给 carry,</li><li>移动 cur 使其一直指向链表的尾部</li></ol><p>最后要判断 carry 是否大于 0，因为例如 (1 -&gt; 2 -&gt; 3) + (7 -&gt; 8 -&gt; 9) 会得到结果 8 -&gt; 0 -&gt; 3 -&gt; 1，所以在最后判断 l1 和 l2 都已经为空了，但是此时 carry 大于 0，所以要将这最后一位数加入到链表尾部</p><pre><code>public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        ListNode dummy = new ListNode(0);        ListNode curr = dummy;        int carry = 0; // 保存进位数值的 carry        while (l1 != null || l2 != null) {              // 用0补齐，链表长度            int x = l1 != null ? l1.val : 0;            int y = l2 != null ? l2.val : 0;            int sum = x + y + carry;            carry = sum / 10;            ListNode newNode = new ListNode(sum % 10);            curr.next = newNode;            l1 = l1 != null ? l1.next : null;            l2 = l2 != null ? l2.next : null;        }              // 存在两链表长度相等，且最高位计算和大于10，需进位创建新节点        if (carry &gt; 0) {            curr.next = new ListNode(carry);        }        return dummy.next;    }</code></pre><hr><h4 id="解法二：递归实现"><a href="#解法二：递归实现" class="headerlink" title="解法二：递归实现"></a>解法二：递归实现</h4><p>首先我们需要理解递归，<strong>墙裂建议背诵默写</strong>递归的模板代码，递归解法的套路如下</p><pre><code>public void recur(int level, Param param) {      // 递归终止条件    if (level &gt; MAX_VALUE) {        //process result        return;    }    // 当前层处理处理    process(param);    // 进入下一层递归    recur(level, newParam);    // 非必要的数据恢复}</code></pre><p>这题使用递归很好理解，两链表的节点从左往右进行相加，进位，直到两链表都到达尾部。</p><ol><li>递归终止条件：两链表都到达尾部</li><li>当前层处理：链表节点相加计算和，得到余数，及carry进位</li><li>进入下一次递归：传入新节点及进位值。</li></ol><p>最后代码如下</p><pre><code>public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        return add(l1, l2, 0);    }    private ListNode add(ListNode a, ListNode b, int carry) {        // terminator 终止条件        if (a == null &amp;&amp; b == null) {            return carry &gt; 0 ? new ListNode(1) : null;        }        // current logic  当前层逻辑处理        // 如果当前节点a,b其中一个为null，则赋值为ListNode(0)，方便计算        a = a == null ? new ListNode(0) : a;        b = b == null ? new ListNode(0) : b;        // 当前两链表节点的和        int sum = a.val + b.val + carry;        carry = sum / 10;        // 将取模结果保存在第一个链表中        a.val = sum % 10;        // driil down   进入下一层递归        a.next = add(a.next, b.next, carry);        return a;    }</code></pre><h3 id="同类型题相关"><a href="#同类型题相关" class="headerlink" title="同类型题相关"></a>同类型题相关</h3><p>若你反复AC，且充分理解了本题的两种题解，我敢保证下面这题解出来只是时间长短问题。</p><p>在这里还是提醒刷题的朋友，多看几次本文<a href="https://www.toutiao.com/i6809940499399442956/?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956" target="_blank" rel="noopener">跟我学：LeetCode刷题大法</a></p><p>LeetCode 445. 两数相加 II</p><h3 id="技巧与心得"><a href="#技巧与心得" class="headerlink" title="技巧与心得"></a>技巧与心得</h3><ol><li>开一个github仓库用来记录各种题解</li><li>在idea或者vscode中都提供了leecode的插件刷题，方便调试断走流程</li><li>遇到不会的题不要慌，稳住心态直接看题解</li><li>文字类的表述不如视图类的直观，图文并茂精选图解优先或者参考leetcode国际站的大牛题解</li><li>图解依旧看着吃力也无妨，可以在哔哩哔哩或者YouTube上，通过leecode + 题号，搜索高收视率的视频观看</li><li>多看几次本文<a href="https://www.toutiao.com/i6809940499399442956/?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956?group_id=6809940499399442956" target="_blank" rel="noopener">跟我学：LeetCode刷题大法</a>，相信我你肯定能越刷越自信</li></ol><h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>看到最后，我相信你对本题应该有不一样的感受了吧！在此若有不对之处或建议等，留言告诉我；若有疑惑或者不一样的看法，也请告诉我，我们可以一起探讨学习！</p><p>我是Yangcy，该吃吃该喝喝，该学还得学，我们一起加油！</p><img src="/images/follow_end_blog.jpg" style="zoom:30%;" />]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h3&gt;&lt;p&gt;本题是LeetCode第二题，难度标记为中等。此题为链表题，不出意外遇到链表题都是画图解题，因为链表题的核心是在符合条件下的链表next指针
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://yangxin.online/categories/Algorithm/"/>
    
    
      <category term="Leetcode，两数相加" scheme="http://yangxin.online/tags/Leetcode%EF%BC%8C%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    
  </entry>
  
  <entry>
    <title>跟我学：LeetCode刷题大法</title>
    <link href="http://yangxin.online/gen-wo-xue-leetcode-shua-ti-da-fa.html"/>
    <id>http://yangxin.online/gen-wo-xue-leetcode-shua-ti-da-fa.html</id>
    <published>2020-03-31T22:22:00.000Z</published>
    <updated>2020-03-31T22:27:56.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h3><p>不想赘述算法与数据结构本身存在的重要性以及对工作面试的重要性。我只想谈谈如何通过解决一道道算法题，慢慢的改变自己对算法的态度，并且从算法中获得自信，如果以下论述我们产生了些许共鸣！请关注我，让我们一起努力，一起刷爆leetcode吧。</p><h3 id="坚定想法"><a href="#坚定想法" class="headerlink" title="坚定想法"></a>坚定想法</h3><p>曾几何时，在无数个瞬间。可曾遇到过这些情况</p><ul><li>算法很重要，我要刷一刷算法；</li><li>背了几题，但不刷刷算法我还是慌的；</li><li>算法虽很重要，但我工作上没怎么用上；</li><li>我刷过了，但面试我怎么打不出来；</li><li>刷了几题，太难了，我放弃；</li><li>….</li></ul><p><img src="http://p9.pstatp.com/large/dfic-imagehandler/2ddb935a-9d24-4b0e-b9aa-b2972a4dec56" alt="跟我学：LeetCode刷题大法"></p><p>放弃的理由千千万万</p><p>讲真放弃的理由千千往往，坚持的理由我觉得只有兴趣和生存。只要是抱着生存的理由，那放弃的理由分分钟淹没他，除非真的找不到工作活不下去，就算如此，还能转行，直接逃避……，说这些就是想让自己和大家认清本质，坚定一下刷算法的的信念，走出第一步告诉自己：我需要刷题，我要刷题！</p><h3 id="如何刷题到自信"><a href="#如何刷题到自信" class="headerlink" title="如何刷题到自信"></a>如何刷题到自信</h3><p>当看到这里，我相信刷过题的人都有过类似经验</p><ol><li>第一次平静的打开某算法库官网(这个主要是LeetCode)，</li><li>然后打开第一个题，看了题目有点思路，一写代码结果各种输入判断，代码编译上的错误都会遇到</li><li>千辛万苦ac后发现只打败了30%的人。完全没有考虑过时间复杂度，空间复杂度，不过好歹过了</li><li>然后继续刷，没过多久就遇到了一题懵逼或者死磕磕不出的题，然后看题解</li><li>看懂的题解我们会惊呼怎么想到的，没看懂的题解会沮丧这也太难了，半天看不懂的题解完全就打击到了自信心</li><li>最终刷题结束，然后可能没有然后了，或者过几天再来挣扎一下。</li><li>那些挣扎过并坚持下来的人，我相信算法面试稳了但不一定自信，除非养成了刷题的习惯</li></ol><hr><p>这经历完全是自我打击的过程，说到底还是打开的姿势不对。没有找准<strong>刷题的基本思想和步骤，试试下面的刷题步骤</strong></p><ol><li>打开一题算法，先看题目，5-10分钟毫无思绪或者无法解决，</li><li>直接看题解，题解一般会有多种解法，找最优解看懂了背下来</li><li>然后不看题解去解题，ac后不急，多默写几遍ac几遍，直到相信自己明天起床也能稳稳的ac</li><li>接着可以再去看题解，去比较其他解法，分析他们的时间复杂度和空间复杂度，看最优解做的优化</li><li>通过比较，肯定是可以加深最优解的印象。<strong>最后重新打开这道题</strong></li><li>看题，思考给出各种解法的思路以及复杂度，最后选出最优解，把它写下来。</li><li>ac的那一刻，你的自信就来了。</li><li>当隔了一星期，你再来解这道题一次ac，稳如狗就更自信了。否则也不会沮丧，只是查漏补缺而已，几分钟后依旧ac。</li></ol><p><img src="http://p3.pstatp.com/large/dfic-imagehandler/cb0f3594-fa4d-4164-8340-9a598e976a65" alt="跟我学：LeetCode刷题大法"></p><h3 id="技巧与心得"><a href="#技巧与心得" class="headerlink" title="技巧与心得"></a>技巧与心得</h3><ol><li>遇到不会的题不要慌，看题解</li><li>文字类的表述不如视图类的直观，尽量找图文并茂精选图解，或者看leetcode国际站的大牛题解</li><li>图解依旧看着吃力，可以在哔哩哔哩或者YouTube上，通过leecode + 题号，搜索高收视率的视频观看</li><li>反复研读观看，相信我你最终会懂的</li></ol><h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>我想说且是重点的，未来我将带领各位盆友一起刷算法题，后续我会通过视频+图文的方式来分享每一题的思路和多种解法代码。同时教会大家更方便，高效的刷题。</p><p>我是Yangcy，该吃吃该喝喝，该学还得学，我们一起加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;闲聊&quot;&gt;&lt;a href=&quot;#闲聊&quot; class=&quot;headerlink&quot; title=&quot;闲聊&quot;&gt;&lt;/a&gt;闲聊&lt;/h3&gt;&lt;p&gt;不想赘述算法与数据结构本身存在的重要性以及对工作面试的重要性。我只想谈谈如何通过解决一道道算法题，慢慢的改变自己对算法的态度，并且从算法中获
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://yangxin.online/categories/Algorithm/"/>
    
    
      <category term="Leetcode" scheme="http://yangxin.online/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>跟我学：LeetCode刷题之1.两数之和</title>
    <link href="http://yangxin.online/gen-wo-xue-leetcode-shua-ti-zhi-1-liang-shu-zhi-he.html"/>
    <id>http://yangxin.online/gen-wo-xue-leetcode-shua-ti-zhi-1-liang-shu-zhi-he.html</id>
    <published>2020-03-31T21:56:50.000Z</published>
    <updated>2020-03-31T22:04:22.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>该题是leetcode的第一题，也是简单题。但无论题目简单难否，答案却是各式各样。有些题解代码精简明了，有些却是又臭又长；有些题解另辟蹊径，有些却是奇技淫巧，前者代码是需要我们学习，而后者是我们需要知道然后避免的。在本文我将为大家讲解该题前者代码的几种解法，后者代码解法大家充分理解本题后可以去官网逛逛评论或者题解，没准能博君一笑。这里通过一张思维导图帮助大家整理思路。思维导图一方面罗列了本文的大纲，另一方面也是希望读者朋友可以保存图片至自己的复习资料里。以便随时通过该大纲去复习。</p><p><img src="http://pb3.pstatp.com/large/pgc-image/fe2040e1de044c21aa76abf10e084544" alt="img"></p><h4 id="看题总结"><a href="#看题总结" class="headerlink" title="看题总结"></a>看题总结</h4><p>给定一个<strong>整数数组 nums</strong> 和一个目标值 target，请你在该数组中找出和<strong>为目标值的那 两个 整数</strong>，并返回他们的<strong>数组下标</strong>。</p><p><strong>你可以假设每种输入只会对应一个答案</strong>。但是，你<strong>不能重复利用</strong>这个数组中同样的元素。</p><p><strong>示例:</strong></p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><p>Related Topics</p><p>数组</p><p>哈希表</p><p>通过对题目的阅读，我们可以得出以下几个结论</p><ol><li>题目类型是数组类型</li><li>题意在数组中找到和为目标值的两个元素，并返回数组下标。例如num[i] + nums[j] = target。</li><li>每种输入都会有对应的一个答案，意味着输入数组nums肯定是有效的，输入是合法的</li><li>不能重复利用数组中的元素，即满足条件的量元素数组下标不同 i != j，输出要排除i==j的答案</li></ol><h3 id="多解法及复杂度分析"><a href="#多解法及复杂度分析" class="headerlink" title="多解法及复杂度分析"></a>多解法及复杂度分析</h3><h4 id="解法一：暴力法：双重循环"><a href="#解法一：暴力法：双重循环" class="headerlink" title="解法一：暴力法：双重循环"></a>解法一：暴力法：双重循环</h4><p>从题意分析得出的结论,我们只需要在数组中找到下标i，j两个元素。最简单直接的方法就是通过双重循坏，第一重循环确定元素nums[i], 第二重循坏在[i+1, nums.length)中找num[j], 符合条件为nums[j] = target - nums[i];<strong>别忘了i ！= j因为j的最大值是nums.length-1, 所以i的最大值为num.length-2</strong></p><p>针对下面的模板代码<strong>墙裂建议</strong>理解背诵默写，能通过双重循环暴力法解决的题目都可以套用</p><pre><code>  for (int i = 0; i &lt; nums.length - 1; i++) {    for (int j = i + 1; j &lt; nums.length; j++) {      // 条件      .....    }  }</code></pre><p>完整代码如下</p><pre><code>public int[] twoSum(int[] nums, int target) {  if (nums == null || nums.length &lt; 2) {    return new int[0];  }  for (int i = 0; i &lt; nums.length - 1; i++) {    for (int j = i + 1; j &lt; nums.length; j++) {      int num = target - nums[i];      if (num == nums[j]) {        return new int[]{i, nums[j]};      }    }  }  return new int[0];}</code></pre><p><strong>复杂度分析：</strong></p><p>时间复杂度为O(n^2)：对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。</p><p>空间复杂度为O(1)：没有使用辅助空间</p><hr><h4 id="解法二：哈希表-双指针"><a href="#解法二：哈希表-双指针" class="headerlink" title="解法二：哈希表 + 双指针"></a>解法二：哈希表 + 双指针</h4><p>针对这种方法只要哈希表和双指针各自的作用</p><ol><li>哈希表，该题通过Map&lt;Integer, List<Integer>&gt; map存储key为元素值，value为元素值相同的数组下标的集合。</li><li>双指针，针对<strong>有序数组</strong>，定义左右头尾指针left = 0，right = nums.length - 1。通过条件nums[left] + nums[right] 与 target的比较大小，因为是有序数组，若nums[left] + nums[right] &lt; target则left++，否则right–。直到两者相等则存在解。</li><li>因为双指针的是针对有序组求目标值， 所以我们需要对输入数组排序，排序后的元素下标会发生改变，所以我们需要提前用哈希表记录元素下标，元素可能相同所以需要用集合存储。</li></ol><p>理解了上面步骤代码遍不难写出</p><p>哈希表部分</p><pre><code>Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; nums.length; i++) {  if (map.containsKey(nums[i])) {    map.get(nums[i]).add(i);  } else {    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    list.add(i);    map.put(nums[i], list);  }}</code></pre><p>双指针部分，划个重点双指针代码<strong>墙裂建议背诵默写</strong>，数组问题必备结题法</p><pre><code>        Arrays.sort(nums);        int left = 0, right = nums.length - 1;        while (left &lt; right) {            if (nums[left] + nums[right] == target) {                return new int[]{map.get(nums[left]).get(0), nums[left] == nums[right] ? map.get(nums[right]).get(1) : map.get(nums[right]).get(0)};            } else if (nums[left] + nums[right] &gt; target) {                right--;            } else {                left++;            }        }</code></pre><p>复杂度分析：</p><p>时间复杂度O(nlogn)：双指针是基于有序数组从两端查找结果时间复杂度为O(n)，<strong>在这里需要注意</strong>数组的排序是通过Arrays.sort(nums)内部会根据数据大小选择插入排序或者双轴快速排序实现，具体可参考源码，也就是说在某些条件下,可以按线性时间对数据进行排序时间复杂度为O(nlogn)，因此最最终的时间复杂度为O(nlogn)</p><p>空间复杂度O(m)：使用了额外的map辅助空间，其中m为nums数组中不同元素的数量。</p><hr><h4 id="解答三：一次遍历哈希表"><a href="#解答三：一次遍历哈希表" class="headerlink" title="解答三：一次遍历哈希表"></a>解答三：一次遍历哈希表</h4><p>该方法为本题的最优解，<strong>需多记多背。</strong>思路很简单很实用，类似于签到找人。如在大型网恋线下见面会上，到场的男男女女第一步是先问一下前台签到人员：我的网恋对象到了吗？前台签到人员查了下签到表，发现他的网恋对象到了则由工作人员带他到对方处，找人成功，否则进行签到安排就做。当他的对象到了就能直接通过签到表由工作人员直接带到他面前。</p><p>签到表即为哈希表用于记录，遍历元素，int num = target - nums[i];若num在map表中则找人成功，否则加入哈希表map.put(nums[i], i);</p><pre><code>    public int[] twoSum(int[] nums, int target) {        if (nums == null || nums.length &lt; 2) {            return new int[0];        }        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            int num = target - nums[i];            if (map.containsKey(num)) {                return new int[]{map.get(num), i};            }            map.put(nums[i], i);        }        return new int[0];    }</code></pre><p>复杂度分析</p><p>时间复杂度O(n)：针对n长度的数组只进行了一次遍历，且在表中进行的每次查找只花费O(1) 的时间。</p><p>空间复杂度O(n)：所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</p><h3 id="同类题相关"><a href="#同类题相关" class="headerlink" title="同类题相关"></a>同类题相关</h3><p>若你反复AC，且充分理解了本题的3种解法，我敢保证下面三题解出来只是时间长短问题。</p><p>在这里还是提醒刷题的朋友，多看几次本文<a href="https://www.toutiao.com/i6809940499399442956/?group_id=6809940499399442956" target="_blank" rel="noopener">跟我学：LeetCode刷题大法</a></p><p>LeetCode 15. 三数之和</p><p>LeetCode 16. 最接近的三树之和</p><p>LeetCode 18. 四数之和</p><h3 id="技巧与心得"><a href="#技巧与心得" class="headerlink" title="技巧与心得"></a>技巧与心得</h3><p>开一个github仓库用来记录各种题解，例如本人的<a href="https://github.com/ZhengYangxin/LeetCode" target="_blank" rel="noopener">https://github.com/ZhengYangxin/LeetCode</a></p><p>刷题不建议直接在网页上刷，在idea或者vscode中都提供了leecode的插件，谁用谁知道</p><p>遇到不会的题不要慌，直接看题解</p><p>文字类的表述不如视图类的直观，尽量找图文并茂精选图解，或者看leetcode国际站的大牛题解</p><p>图解依旧看着吃力，可以在哔哩哔哩或者YouTube上，通过leecode + 题号，搜索高收视率的视频观看</p><p>反复研读观看，相信我你最终会懂的</p><h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>看到最后，我相信你对本题应该有不一样的感受了吧！come on 动起来，就是干！在此若有不对之处或建议等，留言告诉我；若有疑惑或者不一样的看法，也请告诉我，我们可以一起探讨学习！</p><p>我是Yangcy，该吃吃该喝喝，该学还得学，我们一起加油！</p><img src="/images/follow_end_blog.jpg" style="zoom:30%;" />]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h3&gt;&lt;p&gt;该题是leetcode的第一题，也是简单题。但无论题目简单难否，答案却是各式各样。有些题解代码精简明了，有些却是又臭又长；有些题解另辟蹊径，
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://yangxin.online/categories/Algorithm/"/>
    
    
      <category term="Leetcode，两数之和" scheme="http://yangxin.online/tags/Leetcode%EF%BC%8C%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>跟我学：深入Android Framework之谈谈对Zygote的理解</title>
    <link href="http://yangxin.online/gen-wo-xue-shen-ru-android-framework-zhi-tan-tan-dui-zygot-de-li-jie.html"/>
    <id>http://yangxin.online/gen-wo-xue-shen-ru-android-framework-zhi-tan-tan-dui-zygot-de-li-jie.html</id>
    <published>2020-03-31T04:59:49.000Z</published>
    <updated>2020-03-31T21:54:45.689Z</updated>
    
    <content type="html"><![CDATA[<p>最近在在深入Framwork学习，希望我的学习分享能帮到你。首先我们看一下关于Zygote我们应该如何去分析，这里通过一张思维导图帮助大家整理思路。思维导图一方面罗列了本文的大纲，另一方面也是希望读者朋友可以保存图片至自己的复习资料里。以便随时通过该大纲去复习！</p><img src="/images/image-F8C39DF903A8-1.png" style="zoom:14%;" /><h3 id="谈谈对Zygote的理解"><a href="#谈谈对Zygote的理解" class="headerlink" title="谈谈对Zygote的理解"></a>谈谈对Zygote的理解</h3><p>当遇到这样一道面试题，我们应该分析面试官想考察的是什么？</p><ul><li>了解Zygote的作用，初级的要求，答出来后方能深入</li><li>熟悉Zygote的启动流程，中级要求，主要是启动中做的事有哪些关键步骤</li><li>深刻理解Zygote的工作原理，高级要求，主要是怎么启动进程的，怎么与其他进程通讯</li></ul><h3 id="Zygote的作用"><a href="#Zygote的作用" class="headerlink" title="Zygote的作用"></a>Zygote的作用</h3><p>他的作用非常简单就两点</p><ul><li>启动SystemServer</li><li>孵化应用进程</li></ul><p>如果答出了这两点那就是及格了。但可能大部分朋友只知道第二点，第一点就不是那么清楚。其实SystemServer也是Zygote启动的，因为SystemServer需要用到Zygote准备好的系统资源：包括我们常用的一些类、注册的JNI函数、主题资源及一些共享库等等，直接从Zygote继承过来自己就不需要重新加载过来，那么对性能将会有很大的提升。</p><h3 id="Zygote的启动流程"><a href="#Zygote的启动流程" class="headerlink" title="Zygote的启动流程"></a>Zygote的启动流程</h3><p>在说Zygote启动流程之前，我们可以明确一个概念：<strong>启动三段式</strong>，这个可以理解为Android中进程启动的常用套路，分为三步骤</p><ol><li>进程启动</li><li>准备工作</li><li>LOOP循环</li></ol><p>其中LOOP作用是<strong>不停的接受消息，处理消息</strong>，消息的来源可以是Soket、MessageQueue、Binder驱动发过来的消息，但无论消息从哪里来，它总的流程都是去接受消息，处理消息。</p><p>这个启动三段式，他不光是Zygote进程是这样的，只要是有独立进程的，比如说系统服务进程，自己的应用进程都是这样的。</p><h4 id="Zygote进程是怎么启动的？"><a href="#Zygote进程是怎么启动的？" class="headerlink" title="Zygote进程是怎么启动的？"></a>Zygote进程是怎么启动的？</h4><p>Zygote进程的启动，得感谢init进程。init进程是它是linux启动之后用户空间的第一个进程。下面看一下<strong>启动流程</strong></p><ol><li>linux启动init进程</li><li>加载init.rc配置文件</li><li>启动配置文件中定义的系统服务，其中Zygote服务就是定义在配置中的</li><li>init进程通过fork + execve 系统调用启动Zygote</li></ol><p>在分析具体系统源码实现之前，我分享一个看源码很方便网站Android社区：<a href="http://www.androidos.net.cn" target="_blank" rel="noopener">www.androidos.net.cn</a></p><p>下面列举了本文需要阅读的源码文件路径，供大家方便查找。</p><pre><code>platform/system/core/rootdir/init.zygoteXX.rcplatform/system/core/rootdir/init.rcplatform/frameworks/base/cmds/app_process/app_main.cppplatform/frameworks/base/core/jni/AndroidRuntime.cppplatform/libnativehelper/JniInvocation.cppplatform/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></pre><h4 id="加载Zygot的启动配置"><a href="#加载Zygot的启动配置" class="headerlink" title="加载Zygot的启动配置"></a>加载Zygot的启动配置</h4><p>在init.rc 文件中会import /init.${ro.zygote}.rc，init.zygoteXX,XX指的是32或者64，对我们没差我们直接看init.zygote32.rc即可。配置文件比较长，我这里做了截取保留了Zygot相关的部分。</p><pre><code>service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server    class main    socket zygote stream 660 root system    onrestart write /sys/android_power/request_state wake    onrestart write /sys/power/state on    onrestart restart audioserver    writepid /dev/cpuset/foreground/tasks</code></pre><ul><li>service zygote：是进程名称， </li><li>/system/bin/app_process：可执行程序的路径，用于init进程fork，execve调用</li><li>-Xzygote /system/bin –zygote –start-system-server 为它的参数</li></ul><h4 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h4><p>获取到启动配置后才会进行正式启动，启动方式有两种</p><ul><li>fork + handle </li><li>fork + execve</li></ul><p>首先都会调用fork创建新的进程，比较奇特的是它会返回两次。</p><ul><li>子进程一次，返回的pid是0 父进程一次，返回的pid是子进程的pid</li><li>对于handle默认的情况，子进程会继承父进程的所有资源，但当通过execve去加载二进制程序时，那父进程的资源则会被清除</li></ul><h4 id="信号处理-SIGCHLD。"><a href="#信号处理-SIGCHLD。" class="headerlink" title="信号处理-SIGCHLD。"></a>信号处理-SIGCHLD。</h4><p>当父进程fork子进程后，父进程需要关注这个信号。当子进程挂了，父进程就会收到SIGCHLD，这时候父进程就可以做一些处理。例如Zygote进程如果挂了，那父进程init进程就会收到信号将Zygote进程重启</p><h4 id="Zygote进程启动后做了什么"><a href="#Zygote进程启动后做了什么" class="headerlink" title="Zygote进程启动后做了什么"></a>Zygote进程启动后做了什么</h4><p>主要分为两部分Native层处理和Java层处理。</p><p>先来看一下Native层的处理</p><ul><li>启动Android虚拟机</li><li>注册Android的JNI函数</li><li>进入Java层</li></ul><p>在app_main.cpp文件，AndroidRuntime.cpp文件。我们可以找到几个主要函数名</p><pre><code>JNI_CreateJavaVM   // 创建启动虚拟机jniRegisterNativeMethods(env, &quot;com/android/internal/os/ZygoteInit&quot;,        methods, NELEM(methods)) // 通过反射获取ZygoteInit对象env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);//调用main函数,进入Java层</code></pre><p>在应用进程中并不需要创建虚拟机，因为应用进程是Zygote进程孵化出来的，继承了父进程的拥有虚拟机，只需要重置数据即可。</p><p>接着看一下Java层的处理，具体可参考ZygoteInit文件的main方法</p><ul><li>预加载资源，常用类库、主题资源及一些共享库等</li><li>启动SystemServer进程</li><li>进入Socket 的Loop循环 会看到的ZygoteServer.runSelectLoop(…)调用</li></ul><h3 id="Zygote的工作原理"><a href="#Zygote的工作原理" class="headerlink" title="Zygote的工作原理"></a>Zygote的工作原理</h3><p>Zygote的LOOP循环会一直监听Socket中的内容，所以Zygote与其他进程的通信是通过Socket的，工作原理举个例子</p><ol><li>桌面应用点击某应用图标，若应用没有启动进程</li><li>AMS会通过Socket通知Zygote进程</li><li>Zygote进程接受到消息后fork出一个应用进程</li><li>执行应用进程的ActivityThread的main方法</li></ol><h3 id="要注意的细节"><a href="#要注意的细节" class="headerlink" title="要注意的细节"></a>要注意的细节</h3><p>Zygote fork要单线程进行，在fork时Zygote会将除主进程外的所有线程都停了成功后重启，因为对于新创建的子进程而言只有主线程，避免多线程的死锁问题</p><p>Zygote的IPC没有采用binder，而是本地Socket</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>看到最后，我相信你一定对Zygote有一定了解了吧。回头看看第一部分的考查内容讲讲呗，对于每一个点的重点我都细心的为你做了高亮。还有纸上得来终觉浅，绝知此事要躬行。本文参考了Android api28的源码，希望你也去踩着点过一遍源码，肯定能加深理解！</p><img src="/images/follow_end_blog.jpg" style="zoom:30%;" /><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在在深入Framwork学习，希望我的学习分享能帮到你。首先我们看一下关于Zygote我们应该如何去分析，这里通过一张思维导图帮助大家整理思路。思维导图一方面罗列了本文的大纲，另一方面也是希望读者朋友可以保存图片至自己的复习资料里。以便随时通过该大纲去复习！&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Framework" scheme="http://yangxin.online/categories/Framework/"/>
    
    
      <category term="Zygote" scheme="http://yangxin.online/tags/Zygote/"/>
    
  </entry>
  
  <entry>
    <title>网络知识</title>
    <link href="http://yangxin.online/wang-luo-zhi-shi.html"/>
    <id>http://yangxin.online/wang-luo-zhi-shi.html</id>
    <published>2020-03-09T05:04:47.000Z</published>
    <updated>2020-03-09T05:05:54.691Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OSI-七层网络模型"><a href="#OSI-七层网络模型" class="headerlink" title="OSI 七层网络模型"></a>OSI 七层网络模型</h4><ol><li>应用层： 为用户进程提供网络服务</li><li>表示层：负责数据的转化，数据的压缩/解压，数据的加密/解密等</li><li>会话层：负责会话的建立，管理，销毁等服务</li><li>传输层：基于TCP/UDP进行 端口对端口的传输</li><li>IP层：数据打包成IP数据报，在路由器/交换机上传输</li><li>数据链路层: </li><li>物理层：</li></ol><h4 id="TCP-IP-网络模型"><a href="#TCP-IP-网络模型" class="headerlink" title="TCP/IP 网络模型"></a>TCP/IP 网络模型</h4><ol><li>应用层</li><li>传输层</li><li>IP层</li><li>数据链路层</li></ol><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><h4 id="HTTPDNS优化"><a href="#HTTPDNS优化" class="headerlink" title="HTTPDNS优化"></a>HTTPDNS优化</h4><h3 id="HTTP-的版本区别"><a href="#HTTP-的版本区别" class="headerlink" title="HTTP 的版本区别"></a>HTTP 的版本区别</h3><h5 id="HTTP1-0与-HTTP1-1"><a href="#HTTP1-0与-HTTP1-1" class="headerlink" title="HTTP1.0与 HTTP1.1"></a>HTTP1.0与 HTTP1.1</h5><ol><li>缓存优化</li><li>网络带宽及网络连接都优化</li><li>host请求头添加</li><li>支持长连接（串行单线程处理请求，可以同时发起多个请求，但必须等待前一个请求处理完，才会处理新的请求，否则只能被阻塞）</li></ol><h5 id="HTTP1-1与HTTP2-0"><a href="#HTTP1-1与HTTP2-0" class="headerlink" title="HTTP1.1与HTTP2.0"></a>HTTP1.1与HTTP2.0</h5><ol><li>新的二进制文件</li><li>多路复用（多个请求可以在一个连接上并行执行，某个请求耗时严重，不会影响到其他连接的正常执行）<ol><li>做到了延迟的优化，TCP连接是慢启动，因此突发性和短时性的http连接不高效，通过复用连接可以更有效的使用TCP</li></ol></li><li>Header压缩 （一个页面有100个资源要加载，而每次请求都有1kb的消息头，则至少要消耗100kb获取请求头，http2.0，维护了一个字典，用以差量更新http头部）</li><li>服务端推送（服务端会主动把客户端所需要的资源一起发给客户端）</li></ol><h3 id="TCP-与UDP"><a href="#TCP-与UDP" class="headerlink" title="TCP 与UDP"></a>TCP 与UDP</h3><p>TCP 是面向连接的，可靠，慢，占用头部字节20多</p><p>UDP是无连接的，尽最大交付，快，占用头部字节少8</p><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><h4 id="TCP与UDP比较"><a href="#TCP与UDP比较" class="headerlink" title="TCP与UDP比较"></a>TCP与UDP比较</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;OSI-七层网络模型&quot;&gt;&lt;a href=&quot;#OSI-七层网络模型&quot; class=&quot;headerlink&quot; title=&quot;OSI 七层网络模型&quot;&gt;&lt;/a&gt;OSI 七层网络模型&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;应用层： 为用户进程提供网络服务&lt;/li&gt;
&lt;li&gt;表示层：负责
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Algorithm 系列</title>
    <link href="http://yangxin.online/algorithm-xi-lie.html"/>
    <id>http://yangxin.online/algorithm-xi-lie.html</id>
    <published>2020-03-03T06:11:28.000Z</published>
    <updated>2020-04-02T22:37:49.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法的学习"><a href="#算法的学习" class="headerlink" title="算法的学习"></a>算法的学习</h3><h4 id=""><a href="#" class="headerlink" title=""></a><a href="/gen-wo-xue-leetcode-shua-ti-da-fa.html" title="跟我学：LeetCode刷题大法">跟我学：LeetCode刷题大法</a></h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/shi-me-shi-suan-fa.html" title="什么是算法">什么是算法</a></h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/suan-fa-mian-shi-zhun-bei.html" title="算法面试准备">算法面试准备</a></h4><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><h4 id="自己的LeetCode代码库"><a href="#自己的LeetCode代码库" class="headerlink" title="自己的LeetCode代码库"></a><a href="https://github.com/ZhengYangxin/LeetCode" target="_blank" rel="noopener">自己的LeetCode代码库</a></h4><h4 id="比较好的算法总结"><a href="#比较好的算法总结" class="headerlink" title="比较好的算法总结"></a><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">比较好的算法总结</a></h4><h3 id="题目索引"><a href="#题目索引" class="headerlink" title="题目索引"></a>题目索引</h3><h4 id="-3"><a href="#-3" class="headerlink" title=""></a><a href="/gen-wo-xue-leetcode-shua-ti-zhi-1-liang-shu-zhi-he.html" title="跟我学：LeetCode刷题之1.两数之和">跟我学：LeetCode刷题之1.两数之和</a></h4><h4 id="-4"><a href="#-4" class="headerlink" title=""></a><a href="/gen-wo-xue-leetcode-shua-ti-zhi-2-liang-shu-xiang-jia.html" title="跟我学：LeetCode刷题之2.两数相加">跟我学：LeetCode刷题之2.两数相加</a></h4><h4 id="-5"><a href="#-5" class="headerlink" title=""></a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法的学习&quot;&gt;&lt;a href=&quot;#算法的学习&quot; class=&quot;headerlink&quot; title=&quot;算法的学习&quot;&gt;&lt;/a&gt;算法的学习&lt;/h3&gt;&lt;h4 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;a href
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://yangxin.online/categories/Algorithm/"/>
    
    
      <category term="Leetcode，算法数据结构" scheme="http://yangxin.online/tags/Leetcode%EF%BC%8C%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Android系列</title>
    <link href="http://yangxin.online/android-xi-lie.html"/>
    <id>http://yangxin.online/android-xi-lie.html</id>
    <published>2020-03-03T05:58:57.000Z</published>
    <updated>2020-04-02T22:38:24.646Z</updated>
    
    <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a><a href="/protocol-buffer-shi-yong-he-yuan-li.html" title="protocol buffer 使用和原理">protocol buffer 使用和原理</a></h4><h3 id="深入学习Android-Framework"><a href="#深入学习Android-Framework" class="headerlink" title="深入学习Android Framework"></a>深入学习Android Framework</h3><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/gen-wo-xue-shen-ru-android-framework-zhi-tan-tan-dui-zygot-de-li-jie.html" title="跟我学：深入Android Framework之谈谈对Zygote的理解">跟我学：深入Android Framework之谈谈对Zygote的理解</a></h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/gen-wo-xue-android-gao-ji-mian-shi-zhi-shuo-shuo-android-xi-tong-de-qi-dong-liu-cheng.html" title="跟我学：Android高级面试之说说Android系统的启动流程">跟我学：Android高级面试之说说Android系统的启动流程</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;a href=&quot;/protocol-buffer-shi-yong-he-yuan-li.html&quot; title=&quot;protocol buffer 使用和原理&quot;&gt;prot
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yangxin.online/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>protocol buffer 使用和原理</title>
    <link href="http://yangxin.online/protocol-buffer-shi-yong-he-yuan-li.html"/>
    <id>http://yangxin.online/protocol-buffer-shi-yong-he-yuan-li.html</id>
    <published>2020-03-01T11:08:10.000Z</published>
    <updated>2020-03-03T05:52:53.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Protocol-Buffer-介绍"><a href="#Protocol-Buffer-介绍" class="headerlink" title="Protocol Buffer 介绍"></a>Protocol Buffer 介绍</h3><p>Protocol Buffer 是一种轻便高效的结构化数据格式，可以用于结构化数据的序列号，适合做数据存储和RPC数据交换格式，他是平台无关，语言无关，可扩展的序列号结构数据格式</p><h4 id="结构化数据格式"><a href="#结构化数据格式" class="headerlink" title="结构化数据格式"></a>结构化数据格式</h4><ol><li>XML, 通过标签定义的</li><li>JSON，通过键值对定义的</li><li>DB，数据库</li></ol><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ol><li>Serilizable</li><li>Parseable</li></ol><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li>RPC数据交换格式 即网络通讯</li><li>数据存储</li></ol><h4 id="跨平台，语言"><a href="#跨平台，语言" class="headerlink" title="跨平台，语言"></a>跨平台，语言</h4><p>如json，不限操作平台和编程语言同可以使用json</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>序列化后的体积相比json和xml很小，适合网络传输  40M的json数据  17M Protobuffer</li><li>支持跨平台，多语言</li><li>消息格式升级和兼容性不错</li><li>序列化反序列化快   40M的json数据  10s, Protobuffer 0.8s</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Android studio 环境配置</p><h4 id="配置应用build"><a href="#配置应用build" class="headerlink" title="配置应用build"></a>配置应用build</h4><pre><code>buildscript {    repositories {        jcenter()    }    dependencies {        classpath &#39;com.android.tools.build:gradle:3.1.0&#39;        classpath &#39;com.google.protobuf:protobuf-gradle-plugin:0.8.10&#39;    }}</code></pre><h4 id="配置module-build-gradle"><a href="#配置module-build-gradle" class="headerlink" title="配置module build.gradle"></a>配置module build.gradle</h4><pre><code>apply plugin: &#39;com.android.application&#39;apply plugin: &#39;com.google.protobuf&#39;protobuf {    protoc {        artifact = &#39;com.google.protobuf:protoc:3.8.0&#39;    }    generateProtoTasks {        all().each { task -&gt;            task.builtins {                java {                    option &quot;lite&quot;                }            }        }    }}dependencies {    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    implementation &#39;com.google.protobuf:protobuf-javalite:3.9.1&#39;    ...}</code></pre><h4 id="构建消息"><a href="#构建消息" class="headerlink" title="构建消息"></a>构建消息</h4><p>消息由至少一个字段组合而成：字段 = 字段修饰符 + 字段类型 + 字段名 + 标识符<br>标识符TAG：每个字段的唯一标识数字，用于说明二进制文件的对应关系，不能修改，</p><pre><code>syntax = &quot;proto3&quot;;//option java_package = &quot;www.dcf.com.vo&quot;;package tutorial;option java_package = &quot;com.zyx.proto&quot;;option java_outer_classname = &quot;TestProto&quot;;message test {     int32     id = 1;  // ID     string    str = 2;  // str     int32     opt = 3;  //optional field}</code></pre><h4 id="Studio-自动生成代码"><a href="#Studio-自动生成代码" class="headerlink" title="Studio 自动生成代码"></a>Studio 自动生成代码</h4><p>通过Android Studio build，Protobuf插件会帮助我们自动生成TestProto类，类结构如下</p><p><img src="/Users/zhengyangxin/Documents/Blog/zhengyangxin.github.io/source/images/proto_generate_code.png" alt=""></p><p>Protobuf帮助我们自动生成了testOrBuilder接口，主要定义了个字段的get，set方法，并生成了test类，核心逻辑，通过writeTo（CodedOutputStream）接口序列化到CodedOutputStream，通过parseFrom(InputStream) 接口从InputStream中反序列化</p><p><img src="/Users/zhengyangxin/Documents/Blog/zhengyangxin.github.io/source/images/protobuffer_struct.png" alt=""></p><h3 id="ProtoBuffer-原理"><a href="#ProtoBuffer-原理" class="headerlink" title="ProtoBuffer 原理"></a>ProtoBuffer 原理</h3><p>ProtoBuffer不管在时间还是空间上更加高效，是怎么做到的？</p><p>消息经过ProtoBuffer序列化后会成为二进制数据流，通过key-Value组成方式写入到二进制数据流。</p><h4 id="编码机制"><a href="#编码机制" class="headerlink" title="编码机制"></a>编码机制</h4><h5 id="Base-128-Varints"><a href="#Base-128-Varints" class="headerlink" title="Base 128 Varints"></a>Base 128 Varints</h5><p>是一种可变字节序列化整形的方法</p><ol><li>每个byte的最高位是标志位(msb), 如果是1，则表示后面还有byte，否则为结束byte</li><li>每个byte的低7位用来存储数值的位</li><li>Varints方法用Litte-Endian(小端)字节序列</li></ol><h4 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h4><h5 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h5><table><thead><tr><th align="center">Type</th><th align="center">Meaning</th><th align="center">Used For</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">Varint</td><td align="center">int32,int64,uinit32,uint64,sint32,sint64,bool,enum</td></tr><tr><td align="center">1</td><td align="center">64-bit</td><td align="center">fixed64,sfixed64,double</td></tr><tr><td align="center">2</td><td align="center">Length-delimited</td><td align="center">string,bytes,embedded messages</td></tr><tr><td align="center">3</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">32-bit</td><td align="center">fixed32,sfixed32,float</td></tr></tbody></table><h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>key的具体值为   (field_number &lt;&lt; 3) | wire_type，</p><p>以上面的例子来说，如字段id定义：</p><pre><code> int32 id = 2; // 150</code></pre><p>在序列化时，并不会把字段id写进二进制流中，而是把<code>field_number=2</code>通过上述<code>Key</code>的定义计算后写进二进制流中，这就是Protobuf可读性差的原因，也是其高效的主要原因。</p><pre><code>key = (field_number &lt;&lt; 3) | wire_type = 2 &lt;&lt; 3 | 0 = 10000 |0 = 16  = 0x10value 150 二进制位1001 0110  最高位 为msb，将它分为一个一组1 0010110 进行补齐 0000001 0010110小端序存储则为0010110  0000001补齐 表示为msb   10010110 00000001 = 0x96  0x01则最后的存储为 10 96 01如果value 300 二进制为 100101100最高位为msb， 进行7位一组分组10  0101100  进行补齐0000010 0101100小端序存储 10101100 00000010  = 0xac 0x2则最后存储为 10 ac 02</code></pre><p>key的范围：wire_type只有六种类型，用3bit表示，在一个byte里，去掉mbs，以及3bit的wire_type,只剩下4bit来表示field_number,因此一个Byte里，field_number只能表达0-15，超过15个需要多个byte表示</p><h5 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h5><p>所谓ZigZag编码即将负数转换成正数，而所有正数都乘2，如0编码成0，-1编码成1，1编码成2，-2编码成3，以此类推，因而它对负数的编码依然保持比较高的效率。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li>Varint适用于表达比较小的整形，当数字很大时，采用定长编码类型(64bit,32bit)</li><li>不利于表达负数，负数采用补码表示，会占用更多字节，确定出现负数用sint32,sint64,他会采用ZigZig编码将负数映射成整数，之后再使用Varint编码</li></ul><p>Length-delimited</p><ul><li><p>Length-delimited编码格式会将数据的length也编码进最终的数据，编码格式有string，bytes，自定义消息</p></li><li><p>在消息中将str = “testing”, </p><p>序列化的打印结果 为</p><pre><code> private void test() {        TestProto.test.Builder test = TestProto.test.newBuilder();        TestProto.test test1 = test.setStr(&quot;testing&quot;).build();        // 序列化        byte[] bytes = test1.toByteArray();        for (byte aByte : bytes) {            System.out.print(aByte +&quot; &quot;);        }}// 18 7 116 101 115 116 105 110 103str 的field_number = 2; str = &quot;testing&quot;key = (field &lt;&lt; 3) | wire_type = 2 &lt;&lt; 3 | 2 = 10000 | 10 = (十进制) 18 = (16进制)0x127 为 value的长度testing长度为7然后计算value的每个字母 t 在ASCII中的 十进制数是 116， e 为101， s为115 以此类推发现每个byte存储的是计算后的10进制数字，和网上说16进制 byte存储方式不一致 12 07 74 65 73 74 69 6e 67现在按照16进制存储计算key = 12 已经确定t 的二进制为 0111 0100 16 进制为74e 则为65 ..所以string的转换方式是 key的16进制 + 字符串长度16进制 + 字符串的每个字母的16进制</code></pre><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>通过原理破解，在通过观察源码Protobuffer的序列化和反序列化同时通过几个位运算实现的，所以他的效率高，体积小</p></li></ul><h4 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h4><ul><li>尽量不要修改tag</li><li>字段数量不要超过16个，否则会采用2个字节编码, (1个字节最大值为128， key的计算会通过field_number &lt;&lt; 3 | wire_type, 当field_number 为16时刚好使用了1个字节计算，否则就需要两个字节计算)</li><li>如果确定使用负数，采用sint32/sint64</li></ul><h3 id="FastJson对比"><a href="#FastJson对比" class="headerlink" title="FastJson对比"></a>FastJson对比</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Protocol-Buffer-介绍&quot;&gt;&lt;a href=&quot;#Protocol-Buffer-介绍&quot; class=&quot;headerlink&quot; title=&quot;Protocol Buffer 介绍&quot;&gt;&lt;/a&gt;Protocol Buffer 介绍&lt;/h3&gt;&lt;p&gt;Protoc
      
    
    </summary>
    
      <category term="Android" scheme="http://yangxin.online/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yangxin.online/tags/Android/"/>
    
      <category term="数据存储" scheme="http://yangxin.online/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="Protocol Buff" scheme="http://yangxin.online/tags/Protocol-Buff/"/>
    
  </entry>
  
  <entry>
    <title>flutter之性能测试和理论</title>
    <link href="http://yangxin.online/flutter-zhi-xing-neng-ce-shi-he-li-lun.html"/>
    <id>http://yangxin.online/flutter-zhi-xing-neng-ce-shi-he-li-lun.html</id>
    <published>2020-01-28T07:07:54.000Z</published>
    <updated>2020-03-23T04:43:41.089Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Flutter的渲染阶段"><a href="#Flutter的渲染阶段" class="headerlink" title="Flutter的渲染阶段"></a>Flutter的渲染阶段</h4><p><strong>VSync-&gt;Animation-&gt;Build-&gt;Layout-&gt;Paint-&gt;Display List(GPU)</strong></p><ul><li>Build ： Widget，Element树</li><li>Layout，Paint： RenderObject树的创建</li><li>Display List(GPU)，是对Layer图层的创建</li></ul><h4 id="检查Flutter的渲染"><a href="#检查Flutter的渲染" class="headerlink" title="检查Flutter的渲染"></a>检查Flutter的渲染</h4><p>Debug模式和最终的生产模式，有很大的性能特点，所以在做真实的测量之前都用Profile模式</p><ul><li>Debug模式</li><li>Profile模式</li></ul><h4 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h4><p>它不是一个顶层Api，并且充分利用了组合的性质，所以他的公共方法比Android的View少</p><ul><li>是Flutter的UI单位，有很长的生命周期和状态</li><li>主要方法<ul><li>createRenderObject、updateRenderObject</li><li>performLayout</li><li>paint</li></ul></li></ul><h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><ul><li>ComponentElement，主要是做组合的，不直接参与布局绘制<ul><li>StatelessElement</li><li>StatefulElement</li></ul></li><li>RenderObjectElement，会对RenderObject树上的RenderObject做连接</li></ul><h4 id="同类型更新"><a href="#同类型更新" class="headerlink" title="同类型更新"></a>同类型更新</h4><p>修改某个Text的值</p><ul><li>Build<ul><li>在Flutter中Widget树是不可改变的，这也包括树节点之间的父子关系</li><li>在开始build时，会创造一个新的树</li><li>遍历Element，通过Element.updateChild(),观察子节点，若子节点类型发生改变，则会扔掉老节点，创造一个新的节点</li><li>更新过程中，若Element是Component则build即可，若是RenderObjectElement则会updateRenderObject</li><li>若内容发生改变会进行标脏处理</li></ul></li></ul><h4 id="Buid性能测试工具"><a href="#Buid性能测试工具" class="headerlink" title="Buid性能测试工具"></a>Buid性能测试工具</h4><ul><li>观望台，TimeLine，类似安卓的systrace,设置debugProfileBuildsEnable = true,检查build过程的性能损耗</li><li>遍历的触发 <ul><li>setState方法</li><li>依赖了InHeritedWidget,当InHeritedWidget发生改变会影响其他</li><li>热重载，所有节点都会被更新</li></ul></li><li>提高build效率<ul><li>通过Extra单独的Widget，减少遍历的节点</li><li>停止遍历</li></ul></li></ul><h4 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h4><p>在工程完成后会对RenderObject的某些节点进行标脏，让他重新绘制。<br>debugProfileBuildsEnabled = true;<br>debugProfilePaintsEnabled = true;<br>debugPaintLayerBordersEnabled = true;</p><ul><li>如何知道多少其他节点需要跟被标脏的树一起被更新呢？<ul><li>基于图层树Layer</li><li>更新指定图层</li></ul></li><li>Layer种类<ul><li>PictureLayer</li><li>ContainerLayer:主要用于做PictureLayer的连接</li></ul></li></ul><p>yum -y install wget<br>wget -N –no-check-certificate <a href="https://softs.fun/Bash/ssr.sh" target="_blank" rel="noopener">https://softs.fun/Bash/ssr.sh</a> &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Flutter的渲染阶段&quot;&gt;&lt;a href=&quot;#Flutter的渲染阶段&quot; class=&quot;headerlink&quot; title=&quot;Flutter的渲染阶段&quot;&gt;&lt;/a&gt;Flutter的渲染阶段&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;VSync-&amp;gt;Animation-&amp;g
      
    
    </summary>
    
      <category term="Flutter" scheme="http://yangxin.online/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://yangxin.online/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter之平台集成</title>
    <link href="http://yangxin.online/flutter-zhi-ping-tai-ji-cheng.html"/>
    <id>http://yangxin.online/flutter-zhi-ping-tai-ji-cheng.html</id>
    <published>2020-01-26T10:37:22.000Z</published>
    <updated>2020-03-23T04:43:30.144Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Flutter" scheme="http://yangxin.online/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://yangxin.online/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter之手势</title>
    <link href="http://yangxin.online/flutter-zhi-shou-shi.html"/>
    <id>http://yangxin.online/flutter-zhi-shou-shi.html</id>
    <published>2020-01-25T14:11:11.000Z</published>
    <updated>2020-03-23T04:43:35.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>描述屏幕上由触摸板，鼠标，指示笔等触发的指针的位置和移动</p><h4 id="指针事件"><a href="#指针事件" class="headerlink" title="指针事件"></a>指针事件</h4><ul><li>PointerDownEvent：指针在特定位置与屏幕接触</li><li>PointerMoveEvent：指针从屏幕的一个尾椎移动到另一个位置</li><li>PointerUpEvent：指针与屏幕停止接触</li><li>PointerCancelEvent：指针的输入已经不在指向此应用</li></ul><h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><pre><code>const Listener({    Key key,    this.onPointerDown,    this.onPointerMove,    // We have to ignore the lint rule here in order to use deprecated    // parameters and keep backward compatibility.    // TODO(tongmu): After it goes stable, remove these 3 parameters from Listener    // and Listener should no longer need an intermediate class _PointerListener.    // https://github.com/flutter/flutter/issues/36085    @Deprecated(      &#39;Use MouseRegion.onEnter instead. See MouseRegion.opaque for behavioral difference. &#39;      &#39;This feature was deprecated after v1.10.14.&#39;    )    this.onPointerEnter, // ignore: deprecated_member_use_from_same_package    @Deprecated(      &#39;Use MouseRegion.onExit instead. See MouseRegion.opaque for behavioral difference. &#39;      &#39;This feature was deprecated after v1.10.14.&#39;    )    this.onPointerExit, // ignore: deprecated_member_use_from_same_package    @Deprecated(      &#39;Use MouseRegion.onHover instead. See MouseRegion.opaque for behavioral difference. &#39;      &#39;This feature was deprecated after v1.10.14.&#39;    )    this.onPointerHover, // ignore: deprecated_member_use_from_same_package    this.onPointerUp,    this.onPointerCancel,    this.onPointerSignal,    this.behavior = HitTestBehavior.deferToChild,    Widget child,  })</code></pre><h4 id="HitTestBehavior"><a href="#HitTestBehavior" class="headerlink" title="HitTestBehavior"></a>HitTestBehavior</h4><ul><li><p>translucent：层叠布局时，可以使布局都收到事件</p></li><li><p>opaque: 布局透明也可以收到事件</p></li><li><p>deferToChild：当布局透明时收不到事件</p><pre><code>enum HitTestBehavior {/// Targets that defer to their children receive events within their bounds/// only if one of their children is hit by the hit test.deferToChild, // 子组件会一个接一个的进行命中测试，如果子组件收到，那父组件也能收到该事件/// Opaque targets can be hit by hit tests, causing them to both receive/// events within their bounds and prevent targets visually behind them from/// also receiving events.opaque, // 在命中测试中，将当前组件当成不透明处理/// Translucent targets both receive events within their bounds and permit/// targets visually behind them to also receive events.translucent, // 当点击组件透明区域时，可以对自身边界内及底部可视区域，都进行命中测试}</code></pre></li></ul><h4 id="忽略指针事件"><a href="#忽略指针事件" class="headerlink" title="忽略指针事件"></a>忽略指针事件</h4><ul><li>IgnorePointer：阻止子树接受指针事件，本身不会参与命中测试</li><li>AbsorbPointer：阻止子树接受指针事件，本身参与命中测试</li></ul><h3 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h3><p>Gesture代表的是语义操作（比如点击，拖动，缩放），通过一系列单独的指针事件组成，甚至是一系列指针组成。Gesture可以分发多种事件，对应着指针的生命周期（比如开始拖动，拖动更新，结束拖动）</p><h4 id="手势类别"><a href="#手势类别" class="headerlink" title="手势类别"></a>手势类别</h4><ul><li>GestureDetector：用于手势识别的功能性组件，可以识别各种手势，是指针事件的语义分装，内部使用了一个或者多个GestureRecognizer</li><li>GestureRecognizer：通过Listener将原始指针事件转化为语义手势</li></ul><h4 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h4><ul><li>点击：onTapDown，onTapUp，onTap，onTapCancel</li><li>双击：onDoubleTap</li><li>长按：onLongPress</li><li>纵向拖动：onVerticalDragStart，onVerticalDragUpdate，onVerticalDragEnd</li><li>横向拖动：onHorizontalDragStart，onHorizontalDragUpdate，onHorizontalDragEnd</li><li>移动：onPanStart,onPanUpdate,onPanEnd</li><li>移动和横向，纵向拖动互斥</li></ul><h4 id="手势消歧处理"><a href="#手势消歧处理" class="headerlink" title="手势消歧处理"></a>手势消歧处理</h4><ul><li>在屏幕的指定位置上，可能有多个手势捕捉器。所有的手势捕捉器监听了指针输入流事件并判断出特定的手势</li><li>在任何时候，识别器都可以宣告失败并离开竞技场。如果竞技场中只有一个识别器，那么这个识别器就是胜者。</li><li>在任何时候，任何识别器都可以宣告胜利，这将导致这个识别器胜出，其他识别器失败</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;/h3&gt;&lt;p&gt;描述屏幕上由触摸板，鼠标，指示笔等触发的指针的位置和移动&lt;/p&gt;
&lt;h4 id=&quot;指针事件&quot;&gt;&lt;a href=&quot;#指针事件&quot; class=&quot;
      
    
    </summary>
    
      <category term="Flutter" scheme="http://yangxin.online/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://yangxin.online/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter之动画</title>
    <link href="http://yangxin.online/flutter-zhi-dong-hua.html"/>
    <id>http://yangxin.online/flutter-zhi-dong-hua.html</id>
    <published>2020-01-23T13:53:59.000Z</published>
    <updated>2020-03-23T04:43:08.854Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>Animation：Flutter动画库中的核心类，插入用于指导动画的值</li><li>AnimationController:管理Animation</li><li>CurvedAnimation:定义动画的曲线</li><li>Tween:为动画对象插入一个范围值</li></ul><h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><ul><li>提供了每一帧动画变化的监听事件和移除事件，VoidCallback<ul><li>addListener</li><li>removeListener</li></ul></li><li>提供了动画状态的监听和移除事件，AnimationStatusListener<ul><li>addStatusListener</li><li>removeStatusListener</li></ul></li><li>动画的四种状态<ul><li>dismiss，在动画开始时停止</li><li>forward，动画从开始向结束运行</li><li>reverse，动画从结束向开始运行</li><li>completed，动画在结束时运行完成</li></ul></li><li>获取动画的状态</li><li>泛型参数为范围值，一般是double类型</li></ul><h4 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h4><ul><li>继承自Animation，是一个特殊的Animation，当硬件准备新帧时，它都会生成一个新值</li><li>需要一个vsync参数，vsync的存在防止后台动画消耗不必要的资源<pre><code>AnimationController({  double value,  this.duration, // 动画时长  this.reverseDuration,  this.debugLabel,   this.lowerBound = 0.0,  // 最小值  this.upperBound = 1.0, // 最大值  this.animationBehavior = AnimationBehavior.normal,  @required TickerProvider vsync,  // 每一帧同步时的回调})</code></pre></li></ul><h4 id="CurvedAnimation"><a href="#CurvedAnimation" class="headerlink" title="CurvedAnimation"></a>CurvedAnimation</h4><p>怎么运动，运动的过程，动画运行的曲线，可以继承Curve,重写transformInternal</p><ul><li>Curve曲线分类<ul><li>linear:匀速的</li><li>decelerate：匀减速</li><li>ease：开始加速后面减速</li><li>easeIn：开始慢后面快</li><li>easeOut：开始快，后面慢</li><li>easeInOut：开始慢，先加速，后减速</li></ul></li></ul><h4 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h4><p>可以自定义移动的类型，如移动像素等</p><ul><li>配置动画插入不同的范围和数据类型</li></ul><h4 id="AnimatedBuilder"><a href="#AnimatedBuilder" class="headerlink" title="AnimatedBuilder"></a>AnimatedBuilder</h4><p>动画的构建器</p><pre><code>const AnimatedBuilder({    Key key,    @required Listenable animation, // 具体动画    @required this.builder, // 实现动画的对象    this.child,  })</code></pre><h4 id="路由切换动画"><a href="#路由切换动画" class="headerlink" title="路由切换动画"></a>路由切换动画</h4><ul><li>Android提供默认的MaterialPageRoute</li><li>IOS提供默认的CupertionPageRoute</li><li>自定义实现采用PageRouteBuilder<pre><code>Navigator.push(context, PageRouteBuilder(pageBuilder: (context, animation, econdaryAnimation){return FadeTransition(opacity: animation, child: SyncAnim(),);}));</code></pre></li></ul><h4 id="Hero动画"><a href="#Hero动画" class="headerlink" title="Hero动画"></a>Hero动画</h4><p>指在页面之间飞行的Widget，相当于转场动画，Hero在动画切换的时候，有一个共享的Widget可以在新旧路由之间切换</p><ul><li>InkWell:水波纹效果的widget</li><li>将需要共享的元素放入Hero Widget中</li><li>需要指定相同的tag<pre><code>InkWell(          child: Hero(tag: &quot;avator&quot;, child: ClipOval(            child: Image.network(&quot;http://yangxin.online/images/head.jpeg&quot;, width: 50, height: 50 , ),          )),          onTap: (){            Navigator.of(context).push(MaterialPageRoute(builder: (context){              return Scaffold(                body: Center(                  child: Hero(tag: &quot;avator&quot;, child: Image.network(&quot;http://yangxin.online/images/head.jpeg&quot;, width: 300, height: 300 , ),                ),              ));            }));          },        )</code></pre></li></ul><h4 id="交织动画"><a href="#交织动画" class="headerlink" title="交织动画"></a>交织动画</h4><p>设计复杂动画，动画序列，重叠动画</p><ul><li><p>使用多个动画对象</p></li><li><p>一个AnimationControl控制所有的动画</p></li><li><p>每个动画对象指定间隔时间</p><pre><code>class Stagger extends StatelessWidget {final AnimationController controller;final Animation&lt;double&gt; opacity, width, height;final Animation&lt;EdgeInsets&gt; padding;final Animation&lt;BorderRadius&gt; borderRadius;final Animation&lt;Color&gt; color;Stagger({Key key, this.controller})    : opacity = Tween(begin: 0.0, end: 1.0).animate(CurvedAnimation(          parent: controller,          curve: Interval(0.0, 0.1000, curve: Curves.linear))),      width = Tween(begin: 50.0, end: 150.0).animate(CurvedAnimation(          parent: controller,          curve: Interval(0.125, 0.250, curve: Curves.linear))),      height = Tween(begin: 50.0, end: 150.0).animate(CurvedAnimation(          parent: controller,          curve: Interval(0.250, 0.375, curve: Curves.linear))),      padding = EdgeInsetsTween(              begin: EdgeInsets.only(bottom: 10),              end: EdgeInsets.only(bottom: 50))          .animate(CurvedAnimation(              parent: controller,              curve: Interval(0.250, 0.375, curve: Curves.linear))),      borderRadius = BorderRadiusTween(              begin: BorderRadius.circular(5), end: BorderRadius.circular(15))          .animate(CurvedAnimation(              parent: controller,              curve: Interval(0.375, 0.500, curve: Curves.linear))),      color = ColorTween(begin: Colors.blue, end: Colors.red).animate(          CurvedAnimation(              parent: controller,              curve: Interval(0.500, 0.750, curve: Curves.linear))),      super(key: key);@overrideWidget build(BuildContext context) {  return AnimatedBuilder(    animation: controller,    builder: (context, child) {      return Container(        padding: padding.value,        alignment: Alignment.bottomCenter,        child: Opacity(          opacity: opacity.value,          child: Container(            width: width.value,            height: height.value,            decoration: BoxDecoration(                color: color.value,                border: Border.all(color: Colors.blue, width: 3),                borderRadius: borderRadius.value),          ),        ),      );    },  );}}</code></pre></li></ul><p>class StaggerF extends StatefulWidget {<br>  @override<br>  State<StatefulWidget> createState() {<br>    // TODO: implement createState<br>    return StaggerS();<br>  }<br>}</p><p>class StaggerS extends State<StaggerF> with TickerProviderStateMixin {<br>  AnimationController _controller;</p><p>  _play() async {<br>    await _controller.forward().orCancel;<br>    await _controller.reverse().orCancel;<br>  }</p><p>  @override<br>  void initState() {<br>    super.initState();<br>    _controller =<br>        AnimationController(duration: Duration(seconds: 10), vsync: this);<br>    _controller.addStatusListener((status) {<br>      switch (status) {<br>        case AnimationStatus.dismissed:<br>          _controller.forward();<br>          break;<br>        case AnimationStatus.completed:<br>          _controller.reverse();<br>          break;<br>        case AnimationStatus.forward:<br>        case AnimationStatus.reverse:<br>          break;<br>      }<br>    });<br>  }</p><p>  @override<br>  Widget build(BuildContext context) {<br>    // TODO: implement build<br>    return Scaffold(<br>      body: GestureDetector(<br>        onTap: () {<br>          _play();<br>        },<br>        child: Center(<br>          child: Container(<br>            width: 300,<br>            height: 300,<br>            color: Colors.yellow,<br>            child: Stagger(<br>              controller: _controller,<br>            ),<br>          ),<br>        ),<br>      ),<br>    );<br>  }<br>}</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Animation：Flutter动画库中的核心类，插入用于指导动画的值&lt;/li&gt;
&lt;li&gt;AnimationC
      
    
    </summary>
    
      <category term="Flutter" scheme="http://yangxin.online/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://yangxin.online/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter之路由</title>
    <link href="http://yangxin.online/flutter-zhi-lu-you.html"/>
    <id>http://yangxin.online/flutter-zhi-lu-you.html</id>
    <published>2020-01-23T10:39:12.000Z</published>
    <updated>2020-03-23T04:43:25.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h3><p>在Flutter中，屏于页面都叫做路由。路由管理，就是管理页面之间如何跳转，在Flutter中维护一个路由栈，路由入栈操作对应着就是打开一个新页面，路由出栈操作就是对应页面的关闭操作</p><ul><li>Navigator.push()跳转到第二个页面</li><li>Navigator.pop()退回到第一个页面<pre><code>Navigator.push(context, MaterialPageRoute(builder: (context) {  return SecondRoute2(&quot;hello word&quot;);}));</code></pre></li></ul><p>Navigator.pop(context);</p><pre><code>#### 路由传值* Navigator.push()返回Flutter对象，用以接收新路由出栈时的返回数据* Navigator.pop()将栈顶路由出栈，参数Result为页面关闭时返回给上一个页面的数据</code></pre><p> Scaffold(<br>      appBar: AppBar(<br>        title: Text(“SendRoute route”),<br>      ),<br>      body: Center(<br>        child: Column(<br>          children: <Widget>[<br>            Text(arg),<br>            RaisedButton(<br>              child: Text(<br>                “go back”,<br>              ),<br>              onPressed: () {<br>                Navigator.pop(context, “hello world”);<br>              },<br>            ),<br>          ],<br>        ),<br>      ),<br>    );</p><pre><code>#### 命名路由* 注册路由表* Navigator.pushNamed()跳转到第二个界面。* Navigator.pop()回退到第一个路由</code></pre><p>class MyApp2 extends StatelessWidget{<br>  @override<br>  Widget build(BuildContext context) {<br>    // TODO: implement build<br>    return MaterialApp(<br>      title: ‘Flutter Demo’,<br>      theme: ThemeData(<br>        primarySwatch: Colors.blue,<br>      ),<br>      routes: {<br>        ‘/‘: (context) =&gt; FirstRoute(),<br>        ‘/second_route’: (context) =&gt; SecondRoute()<br>      },<br>      initialRoute: ‘/‘,<br>    );<br>  }<br>}</p><p>// 跳转<br>Navigator.pushNamed(context, ‘/second_route’, arguments: ‘卡啦啦啦’);</p><p>// 获取命名跳转的传值<br>final String arg = ModalRoute.of(context).settings.arguments;</p><p>// 优先级最低路由列表<br>onGenerateRoute: (settings) {<br>        if(settings.name == ‘/second_route4’){<br>          var arg = settings.arguments;<br>          return MaterialPageRoute(builder: (context) =&gt; SecondRoute4(arg), settings: settings);<br>        }<br>      },</p><pre><code>#### 路由动画* MaterialPageRoute：继承自PageRoute，是MaterIAL组件库提供的组件，它可以针对不同的平台，实现与平台页面切换动画一致的路由切换动画* PageRouteBuilder</code></pre><p>  Navigator.push(context, PageRouteBuilder(<br>    transitionDuration: Duration(milliseconds: 800),<br>    pageBuilder: (BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation){<br>      return FadeTransition(opacity: animation, child: SecondRoute5(),);<br>    }<br>  ));</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;路由管理&quot;&gt;&lt;a href=&quot;#路由管理&quot; class=&quot;headerlink&quot; title=&quot;路由管理&quot;&gt;&lt;/a&gt;路由管理&lt;/h3&gt;&lt;p&gt;在Flutter中，屏于页面都叫做路由。路由管理，就是管理页面之间如何跳转，在Flutter中维护一个路由栈，路由入栈操作对
      
    
    </summary>
    
      <category term="Flutter" scheme="http://yangxin.online/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://yangxin.online/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter之列表控件</title>
    <link href="http://yangxin.online/flutter-zhi-lie-biao-kong-jian.html"/>
    <id>http://yangxin.online/flutter-zhi-lie-biao-kong-jian.html</id>
    <published>2020-01-23T07:27:57.000Z</published>
    <updated>2020-03-23T04:43:19.900Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h4><ul><li><p>少量数据</p><pre><code>ListView({  Key key,  Axis scrollDirection = Axis.vertical, // 滚动方向  bool reverse = false, // 是否反向展示数据  ScrollController controller,  bool primary,  ScrollPhysics physics, // 物理滚动，默认根据不同平台采用不同对象  bool shrinkWrap = false,  EdgeInsetsGeometry padding,  this.itemExtent, // item 有效范围  bool addAutomaticKeepAlives = true, // 自动保存视图缓存  bool addRepaintBoundaries = true, // 添加重绘边界  bool addSemanticIndexes = true,  double cacheExtent,  List&lt;Widget&gt; children = const &lt;Widget&gt;[],  int semanticChildCount,  DragStartBehavior dragStartBehavior = DragStartBehavior.start,})</code></pre></li><li><p>长列表数据</p><ul><li>itemBuilder:它是列表项的的构造器，返回值是一个Wideget，当列表滚动到具体的index时，会调用改构造器构建列表</li><li>itemCount：列表项的数量，数量为null，则为无限列表<pre><code>ListView.builder({Key key,Axis scrollDirection = Axis.vertical,bool reverse = false,ScrollController controller,bool primary,ScrollPhysics physics,bool shrinkWrap = false,EdgeInsetsGeometry padding,this.itemExtent,@required IndexedWidgetBuilder itemBuilder,int itemCount,bool addAutomaticKeepAlives = true,bool addRepaintBoundaries = true,bool addSemanticIndexes = true,double cacheExtent,int semanticChildCount,DragStartBehavior dragStartBehavior = DragStartBehavior.start,})</code></pre></li></ul></li><li><p>分割组件生成器</p><pre><code>ListView.separated({  Key key,  Axis scrollDirection = Axis.vertical,  bool reverse = false,  ScrollController controller,  bool primary,  ScrollPhysics physics,  bool shrinkWrap = false,  EdgeInsetsGeometry padding,  @required IndexedWidgetBuilder itemBuilder,  @required IndexedWidgetBuilder separatorBuilder,  @required int itemCount,  bool addAutomaticKeepAlives = true,  bool addRepaintBoundaries = true,  bool addSemanticIndexes = true,  double cacheExtent,})</code></pre></li></ul><h4 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h4><pre><code>GridView({    Key key,    Axis scrollDirection = Axis.vertical,    bool reverse = false,    ScrollController controller,    bool primary,    ScrollPhysics physics,    bool shrinkWrap = false,    EdgeInsetsGeometry padding,    @required this.gridDelegate,  // 表格处理类，SliverGridDelegateWithFixedCrossAxisCount，SliverGridDelegateWithMaxCrossAxisExtent    bool addAutomaticKeepAlives = true,    bool addRepaintBoundaries = true,    bool addSemanticIndexes = true,    double cacheExtent,    List&lt;Widget&gt; children = const &lt;Widget&gt;[],    int semanticChildCount,  })</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ListView&quot;&gt;&lt;a href=&quot;#ListView&quot; class=&quot;headerlink&quot; title=&quot;ListView&quot;&gt;&lt;/a&gt;ListView&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;少量数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ListView({
  Key 
      
    
    </summary>
    
      <category term="Flutter" scheme="http://yangxin.online/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://yangxin.online/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter之布局组件</title>
    <link href="http://yangxin.online/flutter-zhi-bu-ju-zu-jian.html"/>
    <id>http://yangxin.online/flutter-zhi-bu-ju-zu-jian.html</id>
    <published>2020-01-23T05:33:34.000Z</published>
    <updated>2020-03-23T04:43:03.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h3><p>线性布局，指的是沿水平或者垂直方向排布子组件。Flutter中通过Row和Column来实现线性布局。</p><ul><li>主轴和纵轴的区分，依赖于布局方向<ul><li>布局是水平方向，主轴就是水平方向(Main Axis)</li><li>反之，主轴就是竖直方向</li></ul></li></ul><h4 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h4><pre><code>  Row({    Key key,    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,  // 子组件在水平方向上的对齐方式    MainAxisSize mainAxisSize = MainAxisSize.max,  // 主轴占用的空间    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, //纵轴方向上的对齐方式    TextDirection textDirection,  // 文字方向    VerticalDirection verticalDirection = VerticalDirection.down, // 表示row纵轴的对齐方式,down:自上而下，up:自下而上    TextBaseline textBaseline,    List&lt;Widget&gt; children = const &lt;Widget&gt;[],  })</code></pre><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h3><p>弹性布局允许子组件按照一定比例来分配父容器空间。Flutter中的弹性布局主要通过Flex和Expanded来配合实现</p><h4 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h4><p>Flex组件可以沿着水平或者垂直方向排列子组件</p><pre><code>Flex({    Key key,    @required this.direction,    this.mainAxisAlignment = MainAxisAlignment.start,    this.mainAxisSize = MainAxisSize.max,    this.crossAxisAlignment = CrossAxisAlignment.center,    this.textDirection,    this.verticalDirection = VerticalDirection.down,    this.textBaseline,    List&lt;Widget&gt; children = const &lt;Widget&gt;[],  })</code></pre><h4 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h4><p>可以按照比例”扩伸”，Row、Column和Flex子组件所占空间</p><pre><code>const Expanded({    Key key,    int flex = 1,    @required Widget child,  }) </code></pre><h3 id="层叠布局"><a href="#层叠布局" class="headerlink" title="层叠布局"></a>层叠布局</h3><p>层叠布局能够将子控件层叠排列。Flutter中Stack允许子控件堆叠，而positioned用于根据Stack的四个角来确定子组件的位置</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><pre><code>  Stack({    Key key,    this.alignment = AlignmentDirectional.topStart, // 对齐方式    this.textDirection,    this.fit = StackFit.loose, // 如何占满Stack    this.overflow = Overflow.clip, // 超出部分的显示    List&lt;Widget&gt; children = const &lt;Widget&gt;[],  })</code></pre><h4 id="Positioned"><a href="#Positioned" class="headerlink" title="Positioned"></a>Positioned</h4><p>分别表示离Stack的 上下左右的的间距， 以及指定元素的大小</p><pre><code>const Positioned({    Key key,    this.left,    this.top,    this.right,    this.bottom,    this.width,    this.height,    @required Widget child,  })</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线性布局&quot;&gt;&lt;a href=&quot;#线性布局&quot; class=&quot;headerlink&quot; title=&quot;线性布局&quot;&gt;&lt;/a&gt;线性布局&lt;/h3&gt;&lt;p&gt;线性布局，指的是沿水平或者垂直方向排布子组件。Flutter中通过Row和Column来实现线性布局。&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="Flutter" scheme="http://yangxin.online/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://yangxin.online/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter之基础组件</title>
    <link href="http://yangxin.online/flutter-zhi-ji-chu-zu-jian.html"/>
    <id>http://yangxin.online/flutter-zhi-ji-chu-zu-jian.html</id>
    <published>2020-01-22T10:47:41.000Z</published>
    <updated>2020-03-23T04:43:15.309Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><h4 id="什么是widget"><a href="#什么是widget" class="headerlink" title="什么是widget"></a>什么是widget</h4><p>一切皆是widget，是flutter应用用户界面的基本构建单元，每个widget都与最终的用户界面有密切相关</p><ul><li>抽象类继承了可诊断树(DiagnosticableTree)</li><li>一个常量构造函数，可选参数key</li><li>抽象方法createElement</li><li>静态方法canUpdate，通过runtimeType和key判断</li></ul><h4 id="一个widget的定义如下"><a href="#一个widget的定义如下" class="headerlink" title="一个widget的定义如下"></a>一个widget的定义如下</h4><ul><li>一个结构元素(按钮，菜单)</li><li>一个风格元素(字体，配色方案等)</li><li>布局(padding)</li><li>等等</li></ul><h4 id="widget的分类"><a href="#widget的分类" class="headerlink" title="widget的分类"></a>widget的分类</h4><p>主要需要了解的是StatelessWidget和StatefullWidget</p><ul><li>StatelessWidget:无状态的，AssetImage,Text…</li><li>StatefulWidget:有状态的，Scrollable,Animatable..</li><li>Widget的介绍<ul><li>用于描述Element的配置</li><li>Widge他作为用户界面的一部分是不会改变的，被加载进Element(控制底层的渲染树)</li><li>Widget本身不包含状态或者可变数据，通过StatefulWidget.createState可以关联一个State</li><li>一个Widget可以被多次插入视图树中，并被加载进Element中</li><li>变量key和runtimeType用来判断Widget是否改变，是则重新加载</li></ul></li><li>构建 widget 的过程并不耗费资源，因为 Wiget 只是用来保存属性的容器。</li><li>无法获取Widget在屏幕上的位置和大小，因为Widget就是一张蓝图，他只是描述了底层渲染对象应该具有的属性</li></ul><h4 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h4><ul><li>继承自Widget的抽象类</li><li>重写了createElement方法名创建了StatelessElement对象</li><li>一个build方法，创建一个Widget</li><li>内部没有保存状态，UI界面创建后不会发生改变</li></ul><h4 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h4><ul><li>继承自Widget的抽象类</li><li>重写了createElement方法名创建了StatefulElement对象</li><li>一个createState方法，创建一个State</li><li>内部保存状态，调用setState方法，变更UI</li></ul><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><ul><li>泛型抽象类 T extend StatefulWidget</li><li>State的流程<ul><li>launch-&gt;initState-&gt;didChangeDependencies-&gt;build-&gt;deactive-&gt;dispose-&gt;destroy</li><li>didUpdateWidget-&gt;build</li><li>initState：被插入到Widget树中被调用一次</li><li>didChangeDependencies:当state的依赖对象发生变化时调用</li><li>build:构建Widget时调用</li><li>didUpdateWidget:Widget重新构建时调用</li><li>deactive:当state对象被从树中移除调用</li><li>dispose:当state对象从树中被永久移除时调用，一般在此回调时释放资源</li></ul></li></ul><h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><ul><li>Element是控件树上的实例</li><li>Element 通过 mount 方法插入到 Element Tree 中，创建了RenderObject对象</li><li></li></ul><h4 id="树-Widget-Tree-Element-Tree-RenderObject-Tree"><a href="#树-Widget-Tree-Element-Tree-RenderObject-Tree" class="headerlink" title="树 Widget Tree, Element Tree ,RenderObject Tree"></a>树 Widget Tree, Element Tree ,RenderObject Tree</h4><ul><li>Widget Tree -(createElement)&gt; Element Tree -(createRenderObject)&gt; RenderObject Tree</li><li>Widget是为了描述Element需要的配置，负责创建Element,决定Element是否需要被更新</li><li>Element表示Widget配置树的特定位置的一个实例，同时持有Widget和RenderObject，负责管理Widget的配置和RenderObject的渲染。Widget发生改变，didUpdateWidget-&gt;build不会重建E，Element，只会更新</li><li>RenderObject表示渲染树的一个对象，负责真正的渲染工作，比如测量大小，位置绘制等都是由RendeObject完成</li></ul><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><ul><li>使用Key可以控制框架在Widget重建时与哪些其他Widget进行匹配</li><li>包含有LocalKey和globalKey<ul><li>LocalKey：ObjectKey，UniqueKey，ValueKey(PageStrageKey)</li><li>GlobalKey:LabeledGlobalKey,GlobalObjectKey</li></ul></li></ul><h3 id="MaterialApp"><a href="#MaterialApp" class="headerlink" title="MaterialApp"></a>MaterialApp</h3><p>Material应用是以MaterialApp Widget开始，主要封装了应用程序实现Material Design所需要的配置</p><ul><li>构造函数<ul><li>路由</li><li>主题</li><li>本地化</li><li>性能监控，调试</li></ul></li></ul><h4 id="Scaffold（脚手架）"><a href="#Scaffold（脚手架）" class="headerlink" title="Scaffold（脚手架）"></a>Scaffold（脚手架）</h4><p>在构造函数中，可以看出有App头布局，body内容,抽屉栏等元素控件，与原生Android有相似</p><pre><code>const Scaffold({    Key key,    this.appBar,    this.body,    this.floatingActionButton,    this.floatingActionButtonLocation,    this.floatingActionButtonAnimator,    this.persistentFooterButtons,    this.drawer,    this.endDrawer,    this.bottomNavigationBar,    this.bottomSheet,    this.backgroundColor,    this.resizeToAvoidBottomPadding,    this.resizeToAvoidBottomInset,    this.primary = true,    this.drawerDragStartBehavior = DragStartBehavior.start,    this.extendBody = false,    this.extendBodyBehindAppBar = false,    this.drawerScrimColor,    this.drawerEdgeDragWidth,  })</code></pre><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><pre><code>const Text(    this.data, { // 必要参数    Key key,    this.style,  // 文字样式    this.strutStyle,    this.textAlign, // 文字居中    this.textDirection,    this.locale,    this.softWrap,    this.overflow,    this.textScaleFactor,    this.maxLines,  // 最初    this.semanticsLabel,    this.textWidthBasis,  })</code></pre><h4 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h4><p>表单操作，输入用户名密码</p><pre><code>const TextField({    Key key,    this.controller,    this.focusNode,  // 焦点    this.decoration = const InputDecoration(), // 设置输入样式    TextInputType keyboardType,    this.textInputAction,    this.textCapitalization = TextCapitalization.none,    this.style,    this.strutStyle,    this.textAlign = TextAlign.start,    this.textAlignVertical,    this.textDirection,    this.readOnly = false,    ToolbarOptions toolbarOptions,    this.showCursor,    this.autofocus = false,    this.obscureText = false,  // 密码输入    this.autocorrect = true,    this.enableSuggestions = true,    this.maxLines = 1,    this.minLines,    this.expands = false,    this.maxLength,    this.maxLengthEnforced = true,    this.onChanged,    this.onEditingComplete,    this.onSubmitted,    this.inputFormatters,  // 输入限制，手机号，数字 11位等    this.enabled,    this.cursorWidth = 2.0,    this.cursorRadius,    this.cursorColor,    this.keyboardAppearance,    this.scrollPadding = const EdgeInsets.all(20.0),    this.dragStartBehavior = DragStartBehavior.start,    this.enableInteractiveSelection = true,    this.onTap,    this.buildCounter,    this.scrollController,    this.scrollPhysics,  }) </code></pre><h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><ul><li>AssetsImage:需要配置pubspec.yaml</li></ul><h4 id="BoxFit"><a href="#BoxFit" class="headerlink" title="BoxFit"></a>BoxFit</h4><p>图片的拉伸，填充控制</p><h4 id="Icon"><a href="#Icon" class="headerlink" title="Icon"></a>Icon</h4><pre><code>  const Icon(    this.icon, {  // 设置Icons.add 系统提供    Key key,    this.size,    this.color,    this.semanticLabel,    this.textDirection,  })</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Widget&quot;&gt;&lt;a href=&quot;#Widget&quot; class=&quot;headerlink&quot; title=&quot;Widget&quot;&gt;&lt;/a&gt;Widget&lt;/h3&gt;&lt;h4 id=&quot;什么是widget&quot;&gt;&lt;a href=&quot;#什么是widget&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Flutter" scheme="http://yangxin.online/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://yangxin.online/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>dart基本语法</title>
    <link href="http://yangxin.online/dart-ji-ben-yu-fa.html"/>
    <id>http://yangxin.online/dart-ji-ben-yu-fa.html</id>
    <published>2020-01-21T05:04:23.000Z</published>
    <updated>2020-03-23T04:43:47.237Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dart的开发环境安装"><a href="#Dart的开发环境安装" class="headerlink" title="Dart的开发环境安装"></a>Dart的开发环境安装</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li>Dart可以用来开发移动应用，web应用，开发命令行应用和服务端应用，主要有以下IDE可供选择</li><li>VS Code:在其中安装Dart插件进行开发</li><li>Android Studio：主要用于移动开发</li><li>Web Storm,IntelliJ, DartPad在线运行</li></ol><h4 id="Dart-SDK概要"><a href="#Dart-SDK概要" class="headerlink" title="Dart SDK概要"></a>Dart SDK概要</h4><ol><li>Dart SDK包含开发web，命令行和服务端应用所需要的库和命令行工具。如果是需要开发移动应用，只需要安装flutter即可</li></ol><h4 id="Dart-SDK安装（homebrew）"><a href="#Dart-SDK安装（homebrew）" class="headerlink" title="Dart SDK安装（homebrew）"></a>Dart SDK安装（homebrew）</h4><ol><li>install<pre><code>brew tap dart-lang/dartbrew install dart</code></pre></li></ol><h4 id="Dart-SDK升级"><a href="#Dart-SDK升级" class="headerlink" title="Dart SDK升级"></a>Dart SDK升级</h4><ol><li>update<pre><code>brew upgrade dart</code></pre></li><li>检查是否安装成功<pre><code>dart --version</code></pre></li></ol><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><pre><code>vi .bash_profile// click e 进入编辑模式export Path=${PATH}:dart的安装目录</code></pre><h4 id="VS-Code的开发环境"><a href="#VS-Code的开发环境" class="headerlink" title="VS Code的开发环境"></a>VS Code的开发环境</h4><ol><li>VS Code的下载进行安装</li><li>Dart的环境配置,在VS extesion中搜索并下载dart插件</li></ol><h4 id="DartPad-在线运行"><a href="#DartPad-在线运行" class="headerlink" title="DartPad 在线运行"></a>DartPad 在线运行</h4><ol><li>打开dartpad.cn可以直接运行代码，但是如果有外部包导入，则需要VS Code</li></ol><h3 id="Dart基本概念"><a href="#Dart基本概念" class="headerlink" title="Dart基本概念"></a>Dart基本概念</h3><h4 id="样例程序"><a href="#样例程序" class="headerlink" title="样例程序"></a>样例程序</h4><pre><code>// 定义一个函数printInteger(int aNumber){  print(&#39;The number is $aNumber&#39;);}// Dart 程序从 main()函数开始执行void main(){  var number = 42; // 声明并初始化一个变量  printInteger(number); // 调用一个函数}</code></pre><ol><li>// 表示注释</li><li>int 表示数据类型</li><li>main 顶级函数，应用程序的入口</li><li>var 用于定义变量，可以不指定变量类型</li></ol><h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><ol><li>一切皆对象：所有变量引用的都是对象，数字，函数，null都是对象，都继承字Object类</li><li>Dart声明变量类型可选：Dart可以进行类型推断，dynamic可以声明一个不确定的类型</li><li>Dart支持泛型：List<int>或者List<dynaamic>(由任何类型对象组成的列表)</li><li>Dart支持顶级函数，支持属于类或者对象的函数，支持嵌套函数：main</li><li>Dart支持顶级变量，支持属于类或者对象的变量</li><li>标识符下划线开头表示库内私有：_number,_name()</li><li>标识符字母，数字，下划线，由字母或者下划线开头</li><li>Dart表达式有值，语句没有值</li><li>Dart工具可以显示警告和错误两种类型</li></ol><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>分为1，2，3</p><ul><li>1表示上下文关键字，在特定的场合才有用</li><li>2表示内置关键符</li><li>3是1.0之后支持异步的关键字</li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ol><li>变量仅存储对象的引用</li><li>变量声明的时候可以不指定类型</li><li>未初始化的变量内容都为null</li><li>可以使用关键字final或者const修饰变量 final只能赋值一次，const为编译时常量，顶层的final变量或者类的final变量在其第一次使用的时候初始化</li></ol><h3 id="Dart内置类型"><a href="#Dart内置类型" class="headerlink" title="Dart内置类型"></a>Dart内置类型</h3><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><ul><li>长度不超过64位，具体取值范围依赖于不同的平台。在DartVM上其取值位于-2^63至2^63-1.编译吃JavaScript的Dart使用JavaScript数字，范围是-2^53~2^53-1之间</li></ul><h4 id="double"><a href="#double" class="headerlink" title="double"></a>double</h4><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul><li><p>Dart字符串是UTF-16编码的字符序列。可以使用单引号或者双引号创建字符串</p></li><li><p>可以使用+运算拼接字符串</p></li><li><p>使用三个单引号或者三个双引号穿件多行字符串</p></li><li><p>字符串前加上r作为前缀创建“raw”字符串（不会被做任何处理）</p><pre><code>var s1 = &quot;dsadsa&quot;;var s2 = &#39;dadasd&#39;;var s3 = &#39;dasda\&#39;&#39;;var s4 = &quot;ab&quot; + &quot;cd&quot;;var s5 = &quot;dsad&quot;&quot;dasda&quot;;var s6 =&#39;&#39;&#39;dasfsadsadas&#39;&#39;&#39;;var s8 = &quot;dasdas is $a&quot;;const s10 = &quot;a const&quot;;</code></pre></li></ul><h4 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h4><ul><li>bool关键字表示布尔类型，布尔类型只有true和false，是编译时常量</li><li>Dart的类型安全不允许使用1,0做代码判断</li></ul><h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><ul><li><p>Dart中数组由List对象表示的</p></li><li><p>下标从0开始</p></li><li><p>List list = List();//固定长度为数组，无参表示可变长度</p><pre><code>var list = [1,2,3];List list1 = new List();List list2 = List();list2.addAll(list);var temp = list2[0];var list3 = [0, ...list2];var list4 = [0, ...?list3];const list5 = [0,1,2]; // list5[1] = 1; //  不能修改</code></pre></li></ul><h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><ul><li><p>Dart中使用sets表示元素无序，唯一的值</p></li><li><p>支持Set字面量以及Set类型两种形式的set</p></li><li><p>Set字面量是在Dart2.2中加入的</p><pre><code>var set1 = {&#39;1&#39;};var set2 = &lt;int&gt;{}; // 空的set， 不指定类型可用&lt;dynamic&gt;{}Set&lt;int&gt; set3 = Set();const set4 = {&#39;a&#39;};a</code></pre></li></ul><h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><ul><li><p>Dart中的Map通过map字面量和map类型来实现</p></li><li><p>每个键只能出现一次，但是值可能出现重复</p><pre><code>var map = {1:&quot;a&quot;, 2:&quot;b&quot;};Map map1 = Map();Map&lt;int, String&gt; map2 = Map();map2[0]; //0 是可以不是下标final  map3 = const {1:&quot;a&quot;, 2:&quot;b&quot;};</code></pre></li></ul><h4 id="Runes"><a href="#Runes" class="headerlink" title="Runes"></a>Runes</h4><ul><li>dart使用Runes来标识UTF-32编码的字符串</li><li>String类中的codeUniteAt和codeUnite属性返回16位代码单元。Runes属性可以获取字符串的Runes</li></ul><h4 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h4><ul><li>Symbols表示Dart中声明的操作符或者标识符，该类型的对象几乎不会被使用到</li><li>可以使用在标识符前面加#来获取Symbols</li><li>Symbols字面量是编译时的常量</li></ul><h3 id="Dart方法"><a href="#Dart方法" class="headerlink" title="Dart方法"></a>Dart方法</h3><p> Dart是一种真正的面向对象的语言，所以函数也是对象并且类型为Function，这意味着函数可以被赋值给变量或者作为其他函数的参数。可以像调用函数一样调用Dart类的实例</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>函数可以有两张形式的参数；必要参数和可选参数</li><li>必要参数定义在参数列表的前面</li><li>可选参数定义在必要参数的后面</li><li>可选参数<ul><li>可选参数分为命名参数和位置参数</li><li>可选参数列表中任选其一使用，不能混用</li></ul></li></ul><pre><code>int a(int a, int b,{int c, int d = 0, int f}){  return a+b;}void main(){  int c = a(2,3, c:4, d: 6);}// 使用参数名:参数值，的形式来指定命名参数// 使用大括号的来指定命名参数// 可以提供默认值// @required注解来标识一个命名参数是必须的int a(int a, int b,[int c, int d = 0, int f]){  return a+b;}// 使用中括号将一系列参数包裹起来作为位置参数// 可以使用=为函数的位置参数设置默认值，默认值必须是常量默认是null</code></pre><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main()函数"></a>main()函数</h4><ul><li>每个Dart程序都必须有一个main()顶级函数作为程序入口</li></ul><h4 id="函数作为一级对象"><a href="#函数作为一级对象" class="headerlink" title="函数作为一级对象"></a>函数作为一级对象</h4><ul><li>可以将函数作为参数传递给另一个函数</li><li>可以将函数赋值给另一个变量</li></ul><pre><code>var f=  printE;  var a = (e) =&gt; &quot;dsada &quot;; // 胖箭头语法  var b = (e){    return &quot;xxx&quot;;  };</code></pre><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul><li>没有名字的函数<pre><code>([[类型] 参数[,..]]){  函数体;}</code></pre></li></ul><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><ul><li>变量的作用于在写代码的时候就确定了</li><li>大括号内定义的变量只能在大括号内使用</li></ul><h4 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h4><ul><li>闭包即一个函数对象，即使函数对象的调用在它原始作用于范围之外，依然可以访问在它词法作用域内的变量</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul><li>所有函数都有返回值</li><li>没哟显示返回语句的函数，默认返回 return null</li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><ul><li>if else</li><li>三目运算 a == null? “guest”: a;</li><li>a ?? “guest”</li></ul><h4 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h4><pre><code>  var listaa =[&#39;a&#39;, &#39;q&#39;, &#39;f&#39;];  for (var item in listaa) {  }  for (var i = 0; i &lt; listaa.length; i++) {  }  listaa.forEach((f){  });</code></pre><h4 id="while-do-while"><a href="#while-do-while" class="headerlink" title="while /do while"></a>while /do while</h4><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><h4 id="break-continue"><a href="#break-continue" class="headerlink" title="break continue"></a>break continue</h4><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li>Dart能够Throw和catch异常，</li><li>Dart中的所有异常为非检查异常，方法不一定声明他们所抛出的异常，并且你也不需要捕获异常</li><li>Dart提供了Exception和Error类型，以及一些子类，也可以实现自己的异常类型</li></ul><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><pre><code>throw FormatException(&quot;Excepted at least 1 selection&quot;);// 任意类型的异常对象throw &quot;out of IIams&quot;;</code></pre><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><pre><code>try {} on XXXException {} on Exception catch(e) {} catch(e, s) {} finally {}</code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Dart是一个面向对象的编程语言，同时支持基于mixin的继承机制。每个对象都是一个类的实例，所有的累都继承Object。基于Mixin的继承意味着每个类都只有一个超类，一个类的代码可以在其他多个类继承<br>中重复使用</p><h4 id="使用类的成员"><a href="#使用类的成员" class="headerlink" title="使用类的成员"></a>使用类的成员</h4><ul><li>对象的成员由函数和数据（即方法和实例变量）组成，使用(.)来访问对象的实例变量或者方法</li></ul><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><ul><li>可以使用构造函数来创建一个对象。构造函数的命名方式可以为类名或者类名.标识符的形式</li></ul><pre><code>  var p = Point();  var p2 = Point.fromJson({&#39;x&#39;: 1, &#39;y&#39;: 2});  p.x = 3; // 使用x的setter方法</code></pre><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><pre><code>class Point{  int x; //声明变量x并初始化为null  int y;  num z = 0; //声明变量z并初始化为0}void main(){  var p = Point();  // var p2 = Point.fromJson({&#39;x&#39;: 1, &#39;y&#39;: 2});  p.x = 3; // 使用x的setter方法  assert(p.x == 3);// 使用x的getter方法  assert(p.y == null); //默认值为null}</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li><p>声明一个与类名一样的函数，即可声明一个构造函数</p></li><li><p>对于大多数编程语言来说在构造函数中为变量赋值的的过程都类似，而Dart则提供了一种特殊的语法糖简化该步骤</p><pre><code>class Point{int x; //声明变量x并初始化为nullint y;num z = 0; //声明变量z并初始化为0// Point(int x, int y){//   this.x = x;//   this.y = y;// }// this.x,this.y, Dart特殊的语法糖构造函数赋值Point(this.x, this.y);}</code></pre></li><li><p>默认构造函数：如果没有声明构造函数，Dart会自动生成一个无参的构造函数，并且该构造函数会自动调用其父类的无参构造函数</p></li><li><p>构造函数不会被继承：子类不会继承父类的构造函数</p></li><li><p>命名式构造函数：可以为一个类声明多个命名式的构造函数来表达更明确的意图</p><pre><code>class Point{int x; //声明变量x并初始化为nullint y;num z = 0; //声明变量z并初始化为0// 命名式构造函数Point.origin(){  this.x = 0;  this.y = 0;}}</code></pre></li><li><p>重定向构造函数:有时候类中的构造函数会调用类中其他的构造函数，该重定向构造函数没有函数体，只需要在函数签名后面使用（:）指定需要重定向到的其他构造函数既可以</p><pre><code>// 委托实现给主构造函数Point.alongXAxis(int x):this(x, 0);</code></pre></li><li><p>常量构造函数：如果类生成的对象都是不变的，那么可以在生成这些对象时就将其变为编译时常量，你可以在类的构造函数前加上 const 关键字并确保所有实例均为final来实现该功能</p><pre><code>class ImmutablePoint{static final ImmutablePoint point = const ImmutablePoint(0, 0);final int x, y;const ImmutablePoint(this.x, this.y);}</code></pre></li><li><p>工厂构造函数: 使用factory关键字表示类的构造函数将会令该构造函数变为工厂构造函数，这将意味着使用该构造函数构造类的实例时并非总是先返回新的实例对象</p><pre><code>class Logger {final String name;static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};factory Logger(String name){  return _cache.putIfAbsent(name, () =&gt; Logger._internal(name));}static Logger _internal(String name){  return Logger(name);}}</code></pre></li></ul><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><ul><li>在构造函数体执行之前初始化实例变量<pre><code>Point.fromJson(Map&lt;String, int&gt; json){  x = json[&#39;x&#39;];  y = json[&#39;y&#39;];  print(&quot;fromJson(): ($x, $y)&quot; );}</code></pre></li></ul><h4 id="调用父类构造函数"><a href="#调用父类构造函数" class="headerlink" title="调用父类构造函数"></a>调用父类构造函数</h4><ul><li>构造函数调用顺序<ul><li>初始化列表</li><li>父类的无参构造函数</li><li>当前类的构造函数</li></ul></li><li>如果父类无无参构造函数，那么子类必须调用父类的其中一个构造函数，为子类的构造函数指定父类的构造函数只需要在构造函数体前使用(:)指定</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>实例方法：实例方法可以访问实例的变量和this</li><li>getter和setter的方法</li><li>抽象方法：定义一个借口方法而不去做具体的实现让实现他的类去实现该方法，抽象方法只能存在与抽象类中</li></ul><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul><li>使用关键字abstract标识的类让类成为抽象类，抽象类将无法被实例化。抽象类常用于声明接口方法，有时候也会有具体的实现方法</li><li>抽象类尝尝会包含抽象方法</li></ul><h4 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h4><ul><li>继承 extend</li><li>子类可以重写父类的实例方法，getter,setter方法</li></ul><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>是一种特殊的类型，用于存储一些固定数量的常量</p><ul><li>使用关键字 enum</li><li>每一个枚举值都有一个名为index成员变量的getter方法</li><li>使用枚举类的values方法获取一个包含所有枚举值的列表</li><li>switch中使用枚举</li></ul><h4 id="使用mixin为类添加功能"><a href="#使用mixin为类添加功能" class="headerlink" title="使用mixin为类添加功能"></a>使用mixin为类添加功能</h4><p>mixin是一种在多继承中复用某各类中代码的方法模式</p><ul><li>定义一个类继承自Object并且不为该类定义构造函数，这个类就是Mixin类，通过关键字mixin替换class让其成为一个单纯的Mixin类</li><li>使用with关键字并在其后面跟上Mixin类的名字来使用Mixin模式</li></ul><h4 id="静态变量和方法"><a href="#静态变量和方法" class="headerlink" title="静态变量和方法"></a>静态变量和方法</h4><p>static 关键字修饰</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="为什么使用功能泛型"><a href="#为什么使用功能泛型" class="headerlink" title="为什么使用功能泛型"></a>为什么使用功能泛型</h4><ul><li>正确使用泛型可以生成更好的代码</li><li>使用泛型减少重复代码</li><li>构造方法时也可以使用泛型，在类名后用尖括号&lt;..&gt;将一个或多个类型包裹<pre><code>var nameSet = Set&lt;String&gt;.from(names);var views = Map&lt;int, View&gt;();</code></pre></li><li>Dart的泛型类型是固化的，这意味着即便在运行时也会保持类的信息（java中的泛型是类型擦拭的）</li></ul><h4 id="限制参数化类型"><a href="#限制参数化类型" class="headerlink" title="限制参数化类型"></a>限制参数化类型</h4><ul><li>使用extends关键字限制</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Dart的开发环境安装&quot;&gt;&lt;a href=&quot;#Dart的开发环境安装&quot; class=&quot;headerlink&quot; title=&quot;Dart的开发环境安装&quot;&gt;&lt;/a&gt;Dart的开发环境安装&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Flutter" scheme="http://yangxin.online/categories/Flutter/"/>
    
    
      <category term="Dart" scheme="http://yangxin.online/tags/Dart/"/>
    
      <category term="Flutter" scheme="http://yangxin.online/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Java编程入门</title>
    <link href="http://yangxin.online/java-bian-cheng-ru-men.html"/>
    <id>http://yangxin.online/java-bian-cheng-ru-men.html</id>
    <published>2020-01-12T12:53:00.000Z</published>
    <updated>2020-01-12T12:57:57.249Z</updated>
    
    <content type="html"><![CDATA[<h5 id="认识Java"><a href="#认识Java" class="headerlink" title="认识Java"></a>认识Java</h5><ol><li>Java的起源是SUM公司开发的，后来被oracle收购</li><li>Java的开发开发有三种<ul><li>JAVA SE 桌面应用开发</li><li>JAVA ME 嵌入是开发 </li><li>JAVA EE 企业平台开发，即互联网平台开发</li></ul></li></ol><h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ol><li>Java是半开源的项目，可以接触底层代码</li><li>Java是一种编程语言，面向对象的编程思想并且一直在拓展扩充</li><li>提供有方便的内存回收机制</li><li>避免了复杂的指针问题，使用更加简单的引用来代替指针</li><li>Java是支持多线程开发的语言，使得在单位时间内的提升了处理能力</li><li>Java提供了高效的网络处理能力，基于NIO实现了更加高效的网络传输能力</li><li>Java具有良好的可移植性</li><li>足够简单</li></ol><h4 id="Java的可移植性"><a href="#Java的可移植性" class="headerlink" title="Java的可移植性"></a>Java的可移植性</h4><p>在于同一个程序可以在不同的操作系统中执行部署，减少开发难度。依赖于Java虚拟机JVM，不同操作系统拥有不同版本的JVM，实现了移植性。</p><h5 id="Java程序运行机制"><a href="#Java程序运行机制" class="headerlink" title="Java程序运行机制"></a>Java程序运行机制</h5><ul><li>编译型，解释型。Java是两种高级编程语言的结合，先编译成.class文件，再解释成计算机识别的机器指令</li><li>编译命令：Javac.exe</li><li>解释命令：Java.exe</li><li>Java程序的组成：Java源文件，字节码文件，机器码指令</li></ul><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul><li>一台模拟的计算机，可以读取并处理经编译过的与平台无关的字节码class文件</li><li>java编译器针对JVM产生class文件，因此独立于平台</li><li>Java解释器负责将JVM的代码在特定的平台上运行</li></ul><h4 id="JDK的介绍"><a href="#JDK的介绍" class="headerlink" title="JDK的介绍"></a>JDK的介绍</h4><p>是Java的开发工具包,主要版本迭代，其中JRE是运行环境，只提供解释功能不提供程序的开发功能</p><ul><li>1995.05.23，JDK1.0发布， 1996年提供对外</li><li>1998.12.04 JDK1.2，更名为Java2</li><li>2005.05.23 十周年大会，JDK1.5 ，带来了新特性，决定了未来10的核心技术</li><li>2014 JDK1.8，支持了Lambda，可以函数式编程</li><li>2017 JDK1.9,提高了1.8稳定性</li><li>2018 JDK1.10,属于1.9的稳定版</li></ul><h4 id="JDK的安装与配置"><a href="#JDK的安装与配置" class="headerlink" title="JDK的安装与配置"></a>JDK的安装与配置</h4><h4 id="Java编程起步"><a href="#Java编程起步" class="headerlink" title="Java编程起步"></a>Java编程起步</h4><p>创建HelloWorld.java文件，编写源文件，编写输出HelloWord的程序。Java程序是需要经过两次处理之后才能正常执行的</p><ul><li>对源代码进行编译：Javac xxx/HelloWord.java，会出现一个HelloWord.class的字节码文件，利用JVM进行编译，编译出一套与平台无关的字节码文件(*.class)</li><li>在JVM上进行程序的解释执行Java xxx/HelloWord。解释的就是字节码文件，字节码文件的后缀是不需要编写的</li><li>类的定义有两种形式，public class 类名， class 类名。第一种文件名必须与类名一致，第二种可以不一致，生成的*.class文件名与类名一致。一般情况是一个class并且以public修饰，类名是驼峰式</li><li>main方法，程序运行入口主方法</li></ul><h4 id="ClASSPATH环境属性"><a href="#ClASSPATH环境属性" class="headerlink" title="ClASSPATH环境属性"></a>ClASSPATH环境属性</h4><ul><li>PATH: 是操作系统提供的路径配置，定义所有可执行程序的路径</li><li>CLASSPATH: 是JRE提供的，用于定义Java程序解释时类加载路径，默认是源文件的目录</li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>单行注释 //</li><li>多行注释 /* …. */</li><li>文档注释 /** …. */</li></ul><h4 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h4><ul><li>Java语言中有不同的结构：类，方法，变量结构等，对于结构的说明实际上就是标识符，是有命名规则的。</li><li>关键字，是系统对于一些结构的的描述处理，有着特殊含义，public static final 等等</li></ul><h4 id="Java数据类型简介"><a href="#Java数据类型简介" class="headerlink" title="Java数据类型简介"></a>Java数据类型简介</h4><ul><li>数据分类：基本数据类型(数字单元)分三大类，数值型，浮点型，字符型，引用数据类型(内存关系的使用)分数组，类，接口<table><thead><tr><th>类型</th><th>包括</th><th>默认值</th></tr></thead><tbody><tr><td>基本数据类型</td><td></td><td></td></tr><tr><td>整型</td><td>byte,short,int,long</td><td>0</td></tr><tr><td>浮点型</td><td>float，double</td><td>0.0</td></tr><tr><td>布尔型</td><td>boolea</td><td>false</td></tr><tr><td>字符型</td><td>char</td><td>‘\u0000’</td></tr><tr><td>引用类型</td><td>数组，类，接口</td><td>null</td></tr></tbody></table></li><li>使用原则： 如果是描述数字首选int,double；如果要进行数据传输或者文字编码选择byte(二进制处理)；处理中文char;描述内存或者文件大小，表的主键列long</li><li>内存溢出：如果数值的操作超出了数值类型的范围就会陷入循环的现象，通过使用范围更大的数值类型解决</li><li>浮点型数据，都是有小数点的。float 变量相乘会出现多出4位小数的历史bug</li><li>整形数据进行相除，会得到整数部分，10/2 = 2,  除非进行转型</li><li>字符类型char和整形int可以相互转换, 可以获取char字符在系统中的编码。大写字母 A(65)<del>Z(90)，小写字母a(97)</del>z(112),大小写之间相差32位，数字范围‘0’(48)~’9’(57)</li><li>java可以保存中文是因为Java使用的是Unicode 16进制的编码</li><li>布尔类型，只有true和false</li><li>字符串。在Java中范围大的数据类型与范围小的数据类型操作，所有小的数据类型会自动转型为数据范围大的数据类型</li></ul><h4 id="运算符简介"><a href="#运算符简介" class="headerlink" title="运算符简介"></a>运算符简介</h4><ul><li>数学运算符： 加减乘除</li><li>关系运算符：大小的比较，基本数据类型之间支持自动转型，字符类型可以转成int</li><li>逻辑运算符：三目(赋值)运算</li><li>位运算：二进制数的计算处理，(&amp;与) (|或者) (^异或) (~反码)<ul><li>&amp; | 在进行逻辑运算的时候所有的条件都会执行</li><li>&amp;&amp; || 若干个条件判断的时候，前面的返回来false 或者 true，后面的条件判断就不再执行</li></ul></li></ul><h4 id="IF分支结构"><a href="#IF分支结构" class="headerlink" title="IF分支结构"></a>IF分支结构</h4><p>针对关系表达式进行判断处理的的分支操作，关键字为if,else,,在多条件else if判断时需写上else</p><h4 id="switch分支语句"><a href="#switch分支语句" class="headerlink" title="switch分支语句"></a>switch分支语句</h4><p>是一个开关语句，它主要根据内容进行判断,支持String.注意添加break关键字，否则会继续执行。注意添加default关键字</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for(定义循环的初始化数值；循环判断；修改循环数值){<br>    循环执行；<br>}</p><ul><li>在明确循环次数的情况下优先选择for循环</li><li>在不知道循环次数，但知道循坏条件下选择while</li></ul><h4 id="循坏控制"><a href="#循坏控制" class="headerlink" title="循坏控制"></a>循坏控制</h4><p>break：退出整个循坏的结构<br>continue： 在当前的语句之后中的代码不在执行，而直接执行后续的判断处理</p><h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><ul><li>方法的命名规则</li><li>是一段可以被重复调用的代码块</li></ul><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>当方法名相同的时候，参数类型或者个数不同的时候就称为方法的重载。</p><ul><li>同一个方法名称，可以根据我们调用时传递的参数类型及个数实现不同方法体的调用</li><li>方法的重载建议其返回值相同</li></ul><h4 id="方法的递归调用"><a href="#方法的递归调用" class="headerlink" title="方法的递归调用"></a>方法的递归调用</h4><ul><li>方法递归调用的结束条件</li><li>每次调用的过程中一定要修改传递的参数条件</li><li>递归操作虽然可以简化的调用，但是在实际开发中很少出现。容易栈溢出</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;认识Java&quot;&gt;&lt;a href=&quot;#认识Java&quot; class=&quot;headerlink&quot; title=&quot;认识Java&quot;&gt;&lt;/a&gt;认识Java&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;Java的起源是SUM公司开发的，后来被oracle收购&lt;/li&gt;
&lt;li&gt;Java的开发开发有
      
    
    </summary>
    
      <category term="Java" scheme="http://yangxin.online/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yangxin.online/tags/Java/"/>
    
  </entry>
  
</feed>
