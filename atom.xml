<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fighting！</title>
  
  <subtitle>潜行者的沉默</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangxin.online/"/>
  <updated>2019-08-09T13:46:06.068Z</updated>
  <id>http://yangxin.online/</id>
  
  <author>
    <name>三金Sir</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>8月8日</title>
    <link href="http://yangxin.online/8%E6%9C%888%E6%97%A5.html"/>
    <id>http://yangxin.online/8月8日.html</id>
    <published>2019-08-08T02:27:32.000Z</published>
    <updated>2019-08-09T13:46:06.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android开源框架-Aoppermission"><a href="#Android开源框架-Aoppermission" class="headerlink" title="Android开源框架 Aoppermission"></a>Android开源框架 Aoppermission</h3><p>Aoppermission是基于Aspect实现。实现过程及原理分析。Android的常用Aop有两种方式1.通过JNI Hook，2.静态织入</p><h4 id="Acpect基础知识"><a href="#Acpect基础知识" class="headerlink" title="Acpect基础知识"></a>Acpect基础知识</h4><ol><li>注解@Aspect，申明切面标记类</li><li>@Pointcut, 定义切点，标记方法</li><li>@Befeore 前置通知，切点前执行</li><li>@Around 围绕切点执行</li><li>@after 后置通知，切点后执行</li><li>@AfterReturening,返回返回值，切点返回值</li><li>@AfterThrowing ，异常通知，切点抛出异常</li><li>首先需要依赖com.hujiang.aspectjx:gradle-android-plugin-aspectjx，配置好了所需的环境</li><li>通过定义注解，包括NeedPermission,PermissionCanceled,PermissionDenied，三个注解对应这申请权限的三种情况。通过源码看他们的作用域都是Method，保留时间都是一直到运行时期，那就意味着，我们可以通过反射的技术实现想做的，而本项目也恰恰是基于反射和Aspect实现 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android开源框架-Aoppermission&quot;&gt;&lt;a href=&quot;#Android开源框架-Aoppermission&quot; class=&quot;headerlink&quot; title=&quot;Android开源框架 Aoppermission&quot;&gt;&lt;/a&gt;Android开源框架
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>8月7日</title>
    <link href="http://yangxin.online/8%E6%9C%887%E6%97%A5.html"/>
    <id>http://yangxin.online/8月7日.html</id>
    <published>2019-08-07T00:46:51.000Z</published>
    <updated>2019-08-08T13:41:28.653Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android中AOP应用"><a href="#Android中AOP应用" class="headerlink" title="Android中AOP应用"></a>Android中AOP应用</h4><p>在Android开发中，有很多知名的开源框架在使用AOP思想。例如ButterKnife,Retrofit,Hugo等。AOP可以做性能检测和埋点技术也有很多</p><ol><li>性能检测和优化，360的ArgusAPM,滴滴的booster，Hugo</li><li>埋点技术，逻辑思维的DDAuto Tracker, 网易的HubbleData</li><li>通过AOP技术，还可以在我们向服务器请求数据时，会显示一个Loding，结果返回后隐藏它，可以通过AOP技术将Loading动作与业务主体分离</li><li>Android的权限管理Aopermission</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Android中AOP应用&quot;&gt;&lt;a href=&quot;#Android中AOP应用&quot; class=&quot;headerlink&quot; title=&quot;Android中AOP应用&quot;&gt;&lt;/a&gt;Android中AOP应用&lt;/h4&gt;&lt;p&gt;在Android开发中，有很多知名的开源框架在使用A
      
    
    </summary>
    
      <category term="“日记”" scheme="http://yangxin.online/categories/%E2%80%9C%E6%97%A5%E8%AE%B0%E2%80%9D/"/>
    
    
      <category term="AOP" scheme="http://yangxin.online/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>8月6日</title>
    <link href="http://yangxin.online/8%E6%9C%886%E6%97%A5.html"/>
    <id>http://yangxin.online/8月6日.html</id>
    <published>2019-08-06T06:45:59.000Z</published>
    <updated>2019-08-08T00:13:45.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>UML是一种可视化的面向对象的建模语言,可以用来描述系统的静态结构和动态行为。用得最多的是类图，时序图，用例图。</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>类图中类是对象的集合，用来描述类的对象结构类及与类,系统之间的交互关系</p><ol><li>泛化关系(表现为is a)：实线加指向父类或接口的空心箭头,包括类与类的继承，接口与接口的继承，类对接口的实现.</li><li>实现抽象：虚线+指向抽象的类的空心箭头</li><li>聚合关系：不是强依赖关系，用实线+空心菱形箭头指向依赖对象，公司和员工的关系</li><li>组合关系：强依赖关系(共存),用实线+实心菱形箭头指向依赖对象，公司和部门的关系，同时创建，同生命周期</li><li>依赖关系：通过入参依赖，用虚线+实心箭头，体现为局部变量，方法参数或者静态调用方法</li><li>关联关系(has a)：一个类知道另一个类的属性和方法，是另一个类的全局变量<a id="more"></a></li></ol><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p>用来显示对象之间的交互关系的图，涉及到角色,生命线，控制焦点和消息等元素<br>消息可以分为：同步消息，异步消息，返回消息，自关联消息</p><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><p>用来描述角色和系统之间的关系，角色与系统交互及系统反应，包括扩展关系和包含关系</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP面向切面编程。程序设计原则中的单一职责原则，要求我们一个类只负责一个任务，那就意味着一个程序将会有很多类，负责不同能功能。好处是解耦了，但同时如果需要对类的方法进行埋点统一配置等，将会异常繁琐。而AOP就是为了解决这个问题.</p><h4 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h4><p>贯穿多个模块的非主体业务功能，如日志功能</p><h4 id="AOP的几种实现方式"><a href="#AOP的几种实现方式" class="headerlink" title="AOP的几种实现方式"></a>AOP的几种实现方式</h4><ol><li>动态代理</li><li>APT是一种编译期注解处理技术。通过注解和处理来实现编译期生成代码,和源代码一起编译成class文件。将拓展的关注点代码放入注解处理器中</li><li>AspectJ<br>是一种编译器。java编译器基础上加了关键字识别和编译方法，可以编写Aspect程序植入目标程序，拓展程序功能。</li><li>Transform + Javassist/ASM<br>Transform是Android Gradle提供的，可以操作字节码的一种方式。源码-.class-.dex。在.class转变为.dex过程会经历一系列的Transform处理。Javassist/ASM是操作.class字节码</li></ol><p><a href="https://juejin.im/post/5d0a0dfce51d45775d516f94" target="_blank" rel="external">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;UML&quot;&gt;&lt;a href=&quot;#UML&quot; class=&quot;headerlink&quot; title=&quot;UML&quot;&gt;&lt;/a&gt;UML&lt;/h3&gt;&lt;p&gt;UML是一种可视化的面向对象的建模语言,可以用来描述系统的静态结构和动态行为。用得最多的是类图，时序图，用例图。&lt;/p&gt;
&lt;h4 id=&quot;类图&quot;&gt;&lt;a href=&quot;#类图&quot; class=&quot;headerlink&quot; title=&quot;类图&quot;&gt;&lt;/a&gt;类图&lt;/h4&gt;&lt;p&gt;类图中类是对象的集合，用来描述类的对象结构类及与类,系统之间的交互关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;泛化关系(表现为is a)：实线加指向父类或接口的空心箭头,包括类与类的继承，接口与接口的继承，类对接口的实现.&lt;/li&gt;
&lt;li&gt;实现抽象：虚线+指向抽象的类的空心箭头&lt;/li&gt;
&lt;li&gt;聚合关系：不是强依赖关系，用实线+空心菱形箭头指向依赖对象，公司和员工的关系&lt;/li&gt;
&lt;li&gt;组合关系：强依赖关系(共存),用实线+实心菱形箭头指向依赖对象，公司和部门的关系，同时创建，同生命周期&lt;/li&gt;
&lt;li&gt;依赖关系：通过入参依赖，用虚线+实心箭头，体现为局部变量，方法参数或者静态调用方法&lt;/li&gt;
&lt;li&gt;关联关系(has a)：一个类知道另一个类的属性和方法，是另一个类的全局变量
    
    </summary>
    
      <category term="日记" scheme="http://yangxin.online/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="AOP" scheme="http://yangxin.online/tags/AOP/"/>
    
      <category term="UML" scheme="http://yangxin.online/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>8月4日</title>
    <link href="http://yangxin.online/8%E6%9C%884%E6%97%A5.html"/>
    <id>http://yangxin.online/8月4日.html</id>
    <published>2019-08-04T07:27:33.000Z</published>
    <updated>2019-08-06T15:00:17.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="阿里开源项目启动框架Alpha"><a href="#阿里开源项目启动框架Alpha" class="headerlink" title="阿里开源项目启动框架Alpha"></a>阿里开源项目启动框架Alpha</h3><p>前面已经介绍了它的原理是基于PERT技术实现的。将一个项目过程以任务单元合理的安排资源，有些任务存在依赖关系所以执行顺序是定死的，但有些任务可以是脱离顺序，可以从关键任务路径中拎出来并行，从而一个项目的耗时及资源占比最大的任务即关键任务路径，在保证项目质量的前提下，可以对关键任务路径上的任务进行优化，也可以从次要任务优化，使关键任务资源充足，达到优化整体项目的效果。下面介绍关键代码类及点</p><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>任务即项目的执行单元，任务包含的元素</p><ol><li>任务的状态：空闲(idle)，正在执行(runing)，结束(finish)，等待(wait)</li><li>任务优先级：线程是有限的，对于同一时机的任务，其执行顺序也是有先后顺序的</li><li>任务执行所在线程的优先级，对于优先级高的可以分配到更多的cpu时间</li><li>任务执行的线程：1.线程池子线程；2.主线程</li><li>任务名和任务的监听器对象集合</li><li>任务的关联关系：1.前驱任务集合，2.后继任务集合。执行顺序</li><li>当然可以添加监控器，监控任务的执行情况（任务耗时）<a id="more"></a></li></ol><h4 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h4><p>项目即由多个任务组成的集合体，它本身也是一个任务，但有其特殊的属性和方法定义</p><ol><li>定义了项目的生命周期，ProjectStart(),TaskFinish(),ProjectFinish()。项目的开始，项目中某任务的结束，项目的结束</li><li>定义开始和结束任务，两个任务是从图的执行角度来讲是唯一的起始和结束点，可以有效衡量一个图的开始和结束，并且方便将图插入另一个图中.startTask, finishTask</li><li>项目名称及生命周期监听集合 </li><li>添加监控器，及项目执行性能统计</li></ol><h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><ol><li>初始化Project对象，定义startTask，finishTask，定义回调事件</li><li>添加任务，建立任务间的顺序关系</li><li>添加任务会与startTask与finishTask构成环形的有向图，每个任务会记录它的前驱任务集合和后继任务集合。当且仅当前驱任务执行完毕才会执行它自己，然后是后继任务，也就意味着，finnishTask只会在所有任务执行结束调用，最后的最后回调project的finish</li></ol><h4 id="项目意义"><a href="#项目意义" class="headerlink" title="项目意义"></a>项目意义</h4><p>在项目中的实践，</p><ol><li>可以应用于应用启动流程,在应用启动时会初始化很多任务，如数<br>据库，Tinker，图片库，缓存数据等等，这些任务或许可以同步执行<br>，但有些必须顺序执行。通过PERT技术恰恰能解释并优化这个过程</li><li>图片上传任务，数据上传等。数据多可以通过并发上传额方式充分利用cpu</li></ol><p><a href="https://github.com/alibaba/alpha" target="_blank" rel="external">项目地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;阿里开源项目启动框架Alpha&quot;&gt;&lt;a href=&quot;#阿里开源项目启动框架Alpha&quot; class=&quot;headerlink&quot; title=&quot;阿里开源项目启动框架Alpha&quot;&gt;&lt;/a&gt;阿里开源项目启动框架Alpha&lt;/h3&gt;&lt;p&gt;前面已经介绍了它的原理是基于PERT技术实现的。将一个项目过程以任务单元合理的安排资源，有些任务存在依赖关系所以执行顺序是定死的，但有些任务可以是脱离顺序，可以从关键任务路径中拎出来并行，从而一个项目的耗时及资源占比最大的任务即关键任务路径，在保证项目质量的前提下，可以对关键任务路径上的任务进行优化，也可以从次要任务优化，使关键任务资源充足，达到优化整体项目的效果。下面介绍关键代码类及点&lt;/p&gt;
&lt;h4 id=&quot;Task&quot;&gt;&lt;a href=&quot;#Task&quot; class=&quot;headerlink&quot; title=&quot;Task&quot;&gt;&lt;/a&gt;Task&lt;/h4&gt;&lt;p&gt;任务即项目的执行单元，任务包含的元素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任务的状态：空闲(idle)，正在执行(runing)，结束(finish)，等待(wait)&lt;/li&gt;
&lt;li&gt;任务优先级：线程是有限的，对于同一时机的任务，其执行顺序也是有先后顺序的&lt;/li&gt;
&lt;li&gt;任务执行所在线程的优先级，对于优先级高的可以分配到更多的cpu时间&lt;/li&gt;
&lt;li&gt;任务执行的线程：1.线程池子线程；2.主线程&lt;/li&gt;
&lt;li&gt;任务名和任务的监听器对象集合&lt;/li&gt;
&lt;li&gt;任务的关联关系：1.前驱任务集合，2.后继任务集合。执行顺序&lt;/li&gt;
&lt;li&gt;当然可以添加监控器，监控任务的执行情况（任务耗时）
    
    </summary>
    
      <category term="日记" scheme="http://yangxin.online/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Alpha" scheme="http://yangxin.online/tags/Alpha/"/>
    
      <category term="启动优化" scheme="http://yangxin.online/tags/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>8月3日</title>
    <link href="http://yangxin.online/8%E6%9C%883%E6%97%A5.html"/>
    <id>http://yangxin.online/8月3日.html</id>
    <published>2019-08-03T01:20:18.000Z</published>
    <updated>2019-08-06T14:58:33.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Https的用途和工作模式"><a href="#Https的用途和工作模式" class="headerlink" title="Https的用途和工作模式"></a>Https的用途和工作模式</h3><p>用Http协议看新闻没什么问题，但换到严肃的场景中就存在安全风向了，如支付，使用普通的Http协议就会被黑客盯上。通过拦截请求假装自己是服务器，让你输入密码等。解决这种问题的思路是对数据加密，加密方式分两种：</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>在对称加密中，加密解密都使用相同的秘钥，因此秘钥的保密工作需要做好，只能给使用的人知道,存在问题</p><ul><li>秘钥的约定时机，秘钥通过互联网传输一样会被黑客截获</li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>加密和解密使用的秘钥不相同。分公钥和私钥，且公钥加密只能私钥解密，反之亦然。对称加密会存在秘钥约定十几的问题，所以需要非对称加密介入。将非对称加密的公钥公开，私钥自己保留。同样存在问题</p><ul><li>服务器的回复数据，黑客可以通过公钥解密，且黑客也可以模拟发送请求，所以一对公钥私钥不够，客户端同样需要有自己的公钥和私钥，并且客户端的公钥给服务端<a id="more"></a></li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>对称加密的算法比分对称加密的算法效率高性能也好，大多数场景都是用对称加密</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>非对称加密也存在同样的问题，如何将不对称的公钥给对方。一种是放在公网地址上，让对方下载；二是建立链接的时候传给对方。存在问题：</p><ul><li>如何鉴别别人发给你的公钥是对的，而不是冒充的<br>通过权威机构(CA)部门的证书，证书里面包括公钥还要发布者的信息及发布机构，证书有效期等，如身份证一样的存在。证书的签名算法即ＣＡ的私钥,给公司的公钥加密。所有用户在网站上得到的是一个证书，你只要得到ＣＡ的公钥去解密签名就能得到公司的公钥了。关于ＣＡ公钥的可靠性，则需要更加权威的机构证实。</li></ul><h4 id="Https的工作模式"><a href="#Https的工作模式" class="headerlink" title="Https的工作模式"></a>Https的工作模式</h4><p>非对称加密性能不及对称加密，通过非对称加密只对对称加密的秘钥进行加密码，而真正通讯的传输数据则通过对称加密的秘钥进行加解密。过程<br><img width="200" src="/images/lADPDgQ9q4pv-gfNBLbNAuA_736_1206.jpg"></p><ol><li>客户端发送Client Hello 到服务器,会以明文传输TLS版本信息，加密套件候选列表，压缩算法列表等信息，还有一个随机数，在协商对称秘钥的时候使用</li><li>服务器返回Server Hello消息，告诉客户端服务器所选的协议版本，加密套件和压缩算法等，还有一个随机数，用于后续秘钥协商</li><li>服务器发送证书</li><li>客户端从CA仓库里的公钥去解密证书，成功则可信任获得了服务器的公钥。最后客户端产生一个随机数，用服务器公钥加密发送给服务端</li><li>客户端接收到Client Key Exchange,通过私钥解密。最后协商出对称加密的秘钥为客户端的随机数+服务端的随机数+Pre-master产生与客户端相同的对称秘钥</li><li>客户端和服务端通过协商的对称秘钥进行通讯</li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>对称加密的效率比非对称加密高，但无法解决了秘钥传输的问题。非对称加密可以解决这个问题，但是效率不高</li><li>非对称加密需要通过证书合权威机构来验证公钥的合法性</li><li>Https是综合了对称加密合非对称加密算法的Http协议，既保证传输安全，有保证了传输效</li></ul><h3 id="阿里开源项目Alpha启动框架"><a href="#阿里开源项目Alpha启动框架" class="headerlink" title="阿里开源项目Alpha启动框架"></a>阿里开源项目Alpha启动框架</h3><p>是一个基于PERT图构建的异步启动框架，使用简单，高效。<br>在应用启动的时候，我们通常会做很多工作需要，为了提高启动速度，我们尽可能的让这些工作并发进行。但这些工作可能存在前后依赖关系，所以我们需要想办法保证执行顺序的正确性。</p><h4 id="PERT"><a href="#PERT" class="headerlink" title="PERT"></a>PERT</h4><p>即计划评审技术，利用网络分析制定计划以及对计划予以评价的技术。它能调整计划的各道工序，合理安排资源，加速计划进度.</p><h5 id="四个概念"><a href="#四个概念" class="headerlink" title="四个概念"></a>四个概念</h5><ol><li>事件：表示主要活动结束的哪一点</li><li>活动：表示从一个事件到另一个事件之间的过程</li><li>松弛事件：不影响完工前提下可能被推迟完成的最大时间</li><li>关键路线：是PERT中花费时间最长的事件和活动序列</li></ol><h5 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h5><ol><li>构建一个清晰精确的事件活动网络，其中包括时间和资源</li><li>对时间活动进行逻辑排序以确定关键路线</li><li>确定“不确定性”</li><li>计算关键路线和宽裕时间</li></ol><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li>标识出项目的关键路径，以明确项目活动的重点</li><li>对关键步骤进行资源调度及优化</li><li>资源发生矛盾时，通过调度非关键路径资源，保证项目进度</li><li>通过PERT网络分析法可大大缩短项目完成的时间</li></ol><h4 id="在軟件设计的应用"><a href="#在軟件设计的应用" class="headerlink" title="在軟件设计的应用"></a>在軟件设计的应用</h4><ol><li>软件的模块化，不同业务线并行开发</li><li>应用插件化，使宿主与插件分开编译，提高编译速度</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Https的用途和工作模式&quot;&gt;&lt;a href=&quot;#Https的用途和工作模式&quot; class=&quot;headerlink&quot; title=&quot;Https的用途和工作模式&quot;&gt;&lt;/a&gt;Https的用途和工作模式&lt;/h3&gt;&lt;p&gt;用Http协议看新闻没什么问题，但换到严肃的场景中就存在安全风向了，如支付，使用普通的Http协议就会被黑客盯上。通过拦截请求假装自己是服务器，让你输入密码等。解决这种问题的思路是对数据加密，加密方式分两种：&lt;/p&gt;
&lt;h4 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h4&gt;&lt;p&gt;在对称加密中，加密解密都使用相同的秘钥，因此秘钥的保密工作需要做好，只能给使用的人知道,存在问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;秘钥的约定时机，秘钥通过互联网传输一样会被黑客截获&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;非对称加密&quot;&gt;&lt;a href=&quot;#非对称加密&quot; class=&quot;headerlink&quot; title=&quot;非对称加密&quot;&gt;&lt;/a&gt;非对称加密&lt;/h4&gt;&lt;p&gt;加密和解密使用的秘钥不相同。分公钥和私钥，且公钥加密只能私钥解密，反之亦然。对称加密会存在秘钥约定十几的问题，所以需要非对称加密介入。将非对称加密的公钥公开，私钥自己保留。同样存在问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器的回复数据，黑客可以通过公钥解密，且黑客也可以模拟发送请求，所以一对公钥私钥不够，客户端同样需要有自己的公钥和私钥，并且客户端的公钥给服务端
    
    </summary>
    
      <category term="日记" scheme="http://yangxin.online/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Https" scheme="http://yangxin.online/tags/Https/"/>
    
      <category term="日记" scheme="http://yangxin.online/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Gradle学习</title>
    <link href="http://yangxin.online/Gradle%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://yangxin.online/Gradle学习.html</id>
    <published>2019-08-02T01:23:14.000Z</published>
    <updated>2019-08-03T14:31:38.648Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Gradle"><a href="#什么是Gradle" class="headerlink" title="什么是Gradle"></a>什么是Gradle</h4><p>Gradle是一个开源的，非常灵活的自动化构建工具，具有以下几大特点：</p><ol><li>高性能:只执行定义的任务，可以复用任务的输入输出，避免不必要的执行</li><li>基于JVM:可以利用java，Kotlin,Groovy等编译器支持的语言</li><li>定制了基础框架，便于构建</li><li>扩展性：可以自定义任务</li><li>编辑器的支持</li></ol><h4 id="设计Gradle插件"><a href="#设计Gradle插件" class="headerlink" title="设计Gradle插件"></a>设计Gradle插件</h4><h5 id="1-总体架构"><a href="#1-总体架构" class="headerlink" title="1. 总体架构"></a>1. 总体架构</h5><ol><li>提取可用的逻辑编写成二进制插件</li><li>插件对性能的影响</li><li>定制规范，减少配置</li><li>将功能与规范隔离</li></ol><h5 id="2-技术"><a href="#2-技术" class="headerlink" title="2. 技术"></a>2. 技术</h5><ol><li>使用静态语言编写插件</li><li>尽量通过Gradle内部的ApI实现插件<br>2.3 减少外部依赖</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是Gradle&quot;&gt;&lt;a href=&quot;#什么是Gradle&quot; class=&quot;headerlink&quot; title=&quot;什么是Gradle&quot;&gt;&lt;/a&gt;什么是Gradle&lt;/h4&gt;&lt;p&gt;Gradle是一个开源的，非常灵活的自动化构建工具，具有以下几大特点：&lt;/p&gt;
&lt;o
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OkHttp</title>
    <link href="http://yangxin.online/OkHttp.html"/>
    <id>http://yangxin.online/OkHttp.html</id>
    <published>2019-05-20T15:02:01.000Z</published>
    <updated>2019-05-28T15:12:54.624Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-曾经的网络框架"><a href="#一-曾经的网络框架" class="headerlink" title="一. 曾经的网络框架"></a>一. 曾经的网络框架</h4><h5 id="Android的网络框架有四种"><a href="#Android的网络框架有四种" class="headerlink" title="Android的网络框架有四种"></a>Android的网络框架有四种</h5><ol><li>HttpClient ： 2.2版本以下存在bug，所以2.3之后建议使用HttpUrlConnection</li><li>HttpUrlConnection 2.3+， 官方推荐</li><li>Volley，谷歌开发，简单的网络任务框架，底层兼容2.3以前版本使用了HttpClient，2.3+使用的是HttpUrlConnection，功能拓展性弱</li><li>Okhttp，从Android4.4开始HttpURLConnection的底层实现采用的是okHttp.</li></ol><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><img src="/image/compare.png" alt=""><br>通过上面的比较，在Android发展的每个阶段，他们有各自存在的意义，只是时过境迁，被种种原因被替换或者废弃。<br>这个过程是一个框架发展的过程，从重量级繁杂且难以维护，到轻量级易扩展，到过度版本新老版本的兼容，最后取长补短完善自己的网络框架。<br>化繁为简，然后又能包容万象的过程</p><h5 id="网络框架应该有的功能"><a href="#网络框架应该有的功能" class="headerlink" title="网络框架应该有的功能"></a>网络框架应该有的功能</h5><ol><li>自定义请求的Header</li><li>GET，POST</li><li>支持文件上传下载</li><li>图片加载</li><li>支持多任务网络请求操作</li><li>支持缓存</li><li>支持回调</li><li>支持session</li><li>…..</li></ol><h4 id="二-OkHttp简介"><a href="#二-OkHttp简介" class="headerlink" title="二. OkHttp简介"></a>二. OkHttp简介</h4><p>一张图了解OkHttp的整个过程<br><img src="/image/OkHttp.jpg" alt=""><br>在OkHttp中真正核心的东西是Interceptor，他不仅负责拦截请求进行额外的处理(入cookie)，实际上他还会把实际的网络请求，缓存，透明压缩等功能都统一起来，每一个功能都只是一个Interceptor，它们在连接成一个Interceptor.Chain,环环相扣最终完成一次网络请求，从getResponseWithInterceptorChain函数中我们可以看到Interceptor.Chain的分布情况依次是：</p><ol><li>在配置OkHttpClinet时设置的interceptors</li><li>负责失败重试和重定向的RetryAndFollowUpInterceptor</li><li>负责把用户构造的请求转化为发送到服务器的请求，把服务器返回的响应转化为用户友好的响应BridgeInterceptor</li><li>负责读取缓存直接返回，更新缓存的CacheInterceptor</li><li>负责和服务器建立连接的ConnectInterceptor</li><li>配置OkHttpClient时设置的NetworkInterceptor</li><li>负责向服务器发送请求数据，从服务器读取响应数据的CallServerInterceptor</li></ol><p>在这里位置决定了功能，最后一个一定是CallServerInterceptor，其他的在这之前。责任链模式在Interceptor中得到了很好的实践。对于request变成response对象，每个interceptor都能完成这件事，也由各自的inteceptor决定是否要交给下个interceptor。</p><h4 id="三-Interceptor分析"><a href="#三-Interceptor分析" class="headerlink" title="三. Interceptor分析"></a>三. Interceptor分析</h4><p>首先看分析ConnectInterceptor和CallServerInterceptor，这两个interceptor实现了和服务器进行通信的核心</p><h5 id="1-ConnectInterceptor建立连接"><a href="#1-ConnectInterceptor建立连接" class="headerlink" title="1. ConnectInterceptor建立连接"></a>1. ConnectInterceptor建立连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** Opens a connection to the target server and proceeds to the next interceptor. */</span><br><span class="line"></span><br><span class="line">  @Override </span><br><span class="line">  public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">    boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, transmitter, exchange);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过创建一个Exchange对象，他将在后面使用。他的内部是对http，https请求的实现，内部都是利用Okio对Socket的读写操作进行了封装.在内部是对java.io和java.nio进行了封装，内部创建了一个主要的RealConnectionn对象，利用RealConnectionn进行读写</p><h5 id="2-CallServerInterceptor-发送和接受数据"><a href="#2-CallServerInterceptor-发送和接受数据" class="headerlink" title="2. CallServerInterceptor 发送和接受数据"></a>2. CallServerInterceptor 发送和接受数据</h5><p>主要过程：</p><ol><li>向服务器发送request header</li><li>如果有request body,就向服务器发送</li><li>读取response header, 构造response 对象</li><li>如果有response body,则创建一个带body的response对象</li></ol><h5 id="3-CacheIntercepter-缓存"><a href="#3-CacheIntercepter-缓存" class="headerlink" title="3. CacheIntercepter 缓存"></a>3. CacheIntercepter 缓存</h5><p>在建立连接，和服务器通讯之前就是CacheIntercepter，我们需要检查响应是否已经本地缓存了，如果缓存了则直接返回，否则进行后面的流程，并把返回的数据写入缓存</p><ol><li>获取本地缓存cacheCandidate</li><li>如果本地缓存可用则直接返回CacheCandidate，从而打断interceptor链</li><li>走剩下的interceptor获取nnetworkResponse</li><li>networkResponse、cacheResponse构造新的response</li><li>根据新的response里的header定制缓存策略，存入缓存中（method 为get）</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>创建一个单例的OkHttpClient，创建请求对象request，初始化请求方式，请求url，请求header，请求body，然后通过client的newcall（request）构建真正的请求对象realcall。有realcall的execute方法和qnqueue方法区分是同步请求还是异步请求，异步请求依赖线程池dispatcher，最终会调用getResponseWithInterceptorsChain方法返回返回response。内部通过这种拦截器对request请求数据和response响应数据进行处理，每个拦截器直接通过realinterceptchain对象的process连接起来（责任链模式）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-曾经的网络框架&quot;&gt;&lt;a href=&quot;#一-曾经的网络框架&quot; class=&quot;headerlink&quot; title=&quot;一. 曾经的网络框架&quot;&gt;&lt;/a&gt;一. 曾经的网络框架&lt;/h4&gt;&lt;h5 id=&quot;Android的网络框架有四种&quot;&gt;&lt;a href=&quot;#Android的
      
    
    </summary>
    
    
      <category term="网络，Okhttp" scheme="http://yangxin.online/tags/%E7%BD%91%E7%BB%9C%EF%BC%8COkhttp/"/>
    
  </entry>
  
  <entry>
    <title>二维火火种培训</title>
    <link href="http://yangxin.online/%E4%BA%8C%E7%BB%B4%E7%81%AB%E7%81%AB%E7%A7%8D%E5%9F%B9%E8%AE%AD.html"/>
    <id>http://yangxin.online/二维火火种培训.html</id>
    <published>2018-06-21T11:51:43.000Z</published>
    <updated>2018-07-04T05:52:30.547Z</updated>
    
    <content type="html"><![CDATA[<p>毕业在即，我也在二维火实习了近半年时间，随着对产品和公司的了解我决定将继续留在公司学习，想在未来的某一天看着自己参与或者做的项目投入市场，得到大家的认可。</p><h3 id="火种培训"><a href="#火种培训" class="headerlink" title="火种培训"></a>火种培训</h3><p>火种：二维火的种子（实习生），年轻，活力。星星之火可以燎原。</p><h3 id="第一天-2018-6-20"><a href="#第一天-2018-6-20" class="headerlink" title="第一天 2018/6/20"></a>第一天 2018/6/20</h3><ul><li>红烧肉：产品研发负责人《开篇介绍》<br>给我们介绍了公司的使命，愿景，价值观等。聊了聊公司的发展历程以及在公司多年来的经历，给了我们一些切身的建议：每个月看书，写日记 todolist等</li><li>人参果：产品委员会主席《公司产品介绍》<br>细致的讲述了公司的价值观：正直善良，敬畏之心，天道酬情！<br>讲述了公司在10几年间，产品的迭代更替以及公司的主要产品线（排队，扫码点餐，厨房KDS，收银，供应链，掌柜等等）<a id="more"></a></li></ul><h3 id="第二天-2018-6-21"><a href="#第二天-2018-6-21" class="headerlink" title="第二天 2018/6/21"></a>第二天 2018/6/21</h3><ul><li>生抽：交易架构师《高并发下的变成》<br>介绍了Java并发编程的基础，以及交易订单的一些具体场景，如何避免并发导致的数据同步问题。还介绍了锁的应用等等</li><li>小米：项目管理主管《流程规范&amp;项目管理》<br>详细介绍了项目的具体含义：一群人为达到某一目标而做某一件事。<br>告诉我们项目即输入物-〉输出物<br>项目的整个流程等</li></ul><h3 id="第三天-2018-6-22"><a href="#第三天-2018-6-22" class="headerlink" title="第三天 2018/6/22"></a>第三天 2018/6/22</h3><ul><li>四季豆：共享业务总监《二维火服务端技术架构》<br>介绍了千亿级别服务架构的演变过程，从一个点子，几个人快速的做了一个东西推向市场，产品使用量上升，服务器资源有限，添加服务器，负载均衡，缓存设计，业务模块拆封等等</li><li>马宝：供应链客户经理《客户端架构》<br>介绍了Android的一些历史及在二维火中的一些具体应用，同时分享了很多有趣的程序员日常。最后一句，8小时的生存，other 生活！</li></ul><p>上了7天请假两天参加毕业典礼</p><p>pm开放平台项目</p><h3 id="确定项目角色，流程角色及职责"><a href="#确定项目角色，流程角色及职责" class="headerlink" title="确定项目角色，流程角色及职责"></a>确定项目角色，流程角色及职责</h3><ol><li>项目经理：简称PM，项目中职责为主导项目全体成员按照项目计划执行，完成项目目标，管控项目的全过程；善于风险识别及跟踪问题解决。更侧重于项目过程中的沟通协作，会议组织，里程碑进度把控，组织过程资产归档，对外汇报等工作。</li><li>需求经理：简称DM，负责收集各类需求，整理分析后列入禅道的需求池，对接PD推动需求的实现。</li><li>产品经理：简称PD，细化需求制作市场需求文档（简称MRD）；明确项目需求范围边界值，编写产品说明书（简称PRD），协同交互，视觉完善PRD正式版。跟踪产品验收。 立项初始，判定此项目是否为重点业务型项目。</li><li>视觉设计师：简称UI，实现PD的页面需求，将其可视化。视觉稿需通过视觉评审。协同PD确认最终界面符合视觉设计稿。 </li><li>技术经理：简称TM，项目中职责为担任技术总负责，把控项目整体技术方案可行；重点跟进架构设计阶段，开发阶段及发布阶段的具体执行。更侧重于项目过程中的任务计划评估，技术难题解决，代码质量把控，发布管理跟踪等工作。</li><li>开发人员：客户端及服务端的代码实现者。完成编码后的自测，联调，根据冒烟用例进行冒烟测试。</li><li>测试人员：质量的把关者。需要根据测试用例，担当内部测试，接口测试、预发后测试，线上回归测试等。</li><li>配置管理员：简称SCM，进行版本控制，协助完成项目环境配置。</li><li>运维人员：简称SA，提供项目环境（开发、测试环境），评审发布计划，协助发布等。</li><li><p>数据库管理员：简称DBA，主要负责产品研发中心所有数据库的运营和维护，评审SQL等。</p></li><li><p>业务线技术TL：各业务线技术负责人。主要负责立项时候判定项目是否重点技术项目。</p></li><li>架构委员会：由高级架构师，核心应用owner们及业务线技术负责人组成的技术架构组织。如有技术型项目启动时，负责判定项目是否为重点技术型项目。</li><li>产品架构委员会：简称PDM，在项目执行过程中主要负责参与二维火核心产品业务的MRD&amp;PRD评审，以及上线后产品目标的验收。</li></ol><h3 id="立项会"><a href="#立项会" class="headerlink" title="立项会"></a>立项会</h3><p>产品组织，项目经理结果通知</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毕业在即，我也在二维火实习了近半年时间，随着对产品和公司的了解我决定将继续留在公司学习，想在未来的某一天看着自己参与或者做的项目投入市场，得到大家的认可。&lt;/p&gt;
&lt;h3 id=&quot;火种培训&quot;&gt;&lt;a href=&quot;#火种培训&quot; class=&quot;headerlink&quot; title=&quot;火种培训&quot;&gt;&lt;/a&gt;火种培训&lt;/h3&gt;&lt;p&gt;火种：二维火的种子（实习生），年轻，活力。星星之火可以燎原。&lt;/p&gt;
&lt;h3 id=&quot;第一天-2018-6-20&quot;&gt;&lt;a href=&quot;#第一天-2018-6-20&quot; class=&quot;headerlink&quot; title=&quot;第一天 2018/6/20&quot;&gt;&lt;/a&gt;第一天 2018/6/20&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;红烧肉：产品研发负责人《开篇介绍》&lt;br&gt;给我们介绍了公司的使命，愿景，价值观等。聊了聊公司的发展历程以及在公司多年来的经历，给了我们一些切身的建议：每个月看书，写日记 todolist等&lt;/li&gt;
&lt;li&gt;人参果：产品委员会主席《公司产品介绍》&lt;br&gt;细致的讲述了公司的价值观：正直善良，敬畏之心，天道酬情！&lt;br&gt;讲述了公司在10几年间，产品的迭代更替以及公司的主要产品线（排队，扫码点餐，厨房KDS，收银，供应链，掌柜等等）
    
    </summary>
    
      <category term="二维火" scheme="http://yangxin.online/categories/%E4%BA%8C%E7%BB%B4%E7%81%AB/"/>
    
    
      <category term="JOb" scheme="http://yangxin.online/tags/JOb/"/>
    
      <category term="二维火" scheme="http://yangxin.online/tags/%E4%BA%8C%E7%BB%B4%E7%81%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android IPC</title>
    <link href="http://yangxin.online/Android-IPC.html"/>
    <id>http://yangxin.online/Android-IPC.html</id>
    <published>2018-03-31T02:39:30.000Z</published>
    <updated>2018-04-22T06:55:24.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android跨进程通讯的几种方式"><a href="#Android跨进程通讯的几种方式" class="headerlink" title="Android跨进程通讯的几种方式"></a>Android跨进程通讯的几种方式</h3><h4 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h4><p>  Bundle实现了Parcelable，方便在进程中传输数据。主要在activity、service、receiver中Intent中应用，</p><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>Android基于Linux，对文件的读写没有限制。存在的问题就是并发读写的问题<br>sp存在缓存策略，内存中存在备份，导致多进程不可靠</p><h4 id="使用messenger信使"><a href="#使用messenger信使" class="headerlink" title="使用messenger信使"></a>使用messenger信使</h4><ol><li>Messenger可以在不同的进程中传递Message对象，轻松实现数据的跨进程通讯。</li><li>它的底层实现是AIDl，内部一次只做一次处理，因此服务端不用考虑线程同步的问题</li><li>缺点是只能用来简单的信息传递，并发请求不大合适且无法不支持跨进程的方法的调用<br><img src="http://opd2n5pxb.bkt.clouddn.com/Messenger%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Alt text" title="Messenger 工作原理图"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android跨进程通讯的几种方式&quot;&gt;&lt;a href=&quot;#Android跨进程通讯的几种方式&quot; class=&quot;headerlink&quot; title=&quot;Android跨进程通讯的几种方式&quot;&gt;&lt;/a&gt;Android跨进程通讯的几种方式&lt;/h3&gt;&lt;h4 id=&quot;Bundl
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yangxin.online/tags/Android/"/>
    
      <category term="进程通讯" scheme="http://yangxin.online/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>RxJava的使用及源码分析</title>
    <link href="http://yangxin.online/RxJava%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"/>
    <id>http://yangxin.online/RxJava的使用及源码分析.html</id>
    <published>2018-03-18T07:25:44.000Z</published>
    <updated>2018-03-27T12:50:09.970Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于Rxjava-2-1-10版本源码分析"><a href="#基于Rxjava-2-1-10版本源码分析" class="headerlink" title="基于Rxjava-2.1.10版本源码分析"></a>基于Rxjava-2.1.10版本源码分析</h3><p>从开源文档范例开始分析</p><h4 id="范例一-Flowable-just输出HelloWord"><a href="#范例一-Flowable-just输出HelloWord" class="headerlink" title="范例一.Flowable.just输出HelloWord"></a>范例一.Flowable.just输出HelloWord</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(&quot;Hello world&quot;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>1.从just方法开始,首先可以看到三个注解方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@CheckReturnValue  //检查返回值</span><br><span class="line">@BackpressureSupport(BackpressureKind.FULL)  //支持的背压方式</span><br><span class="line">@SchedulerSupport(SchedulerSupport.NONE) //调度方式,即处理事件的方式IO数据流，新开一个线程等。</span><br><span class="line">public static &lt;T&gt; Flowable&lt;T&gt; just(T item) &#123; //方法参数是个泛型，</span><br><span class="line">    ObjectHelper.requireNonNull(item, &quot;item is null&quot;);</span><br><span class="line">    //返回值是个Flowable对象</span><br><span class="line">    return RxJavaPlugins.onAssembly(new FlowableJust&lt;T&gt;(item)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>2.方法第一行是判空操作在很多地方都使用到了，查看方法不为空则返回原对象，否则，抛出异常NullPointerException<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T requireNonNull(T object, String message) &#123;</span><br><span class="line">        if (object == null) &#123;</span><br><span class="line">            throw new NullPointerException(message);</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>3.方法第三行中的看new FlowableJust<t>(item)创建的实例对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class FlowableJust&lt;T&gt; extends Flowable&lt;T&gt; implements ScalarCallable&lt;T&gt; &#123;</span><br><span class="line">    private final T value; //final变量，赋值后不能改变</span><br><span class="line">    public FlowableJust(final T value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    //重写了Flowable的subscribeActual方法，传入了观察者与发射内容构造一个订阅对象</span><br><span class="line">    //由观察者去订阅这个对象</span><br><span class="line">    @Override</span><br><span class="line">    protected void subscribeActual(Subscriber&lt;? super T&gt; s) &#123;</span><br><span class="line">        s.onSubscribe(new ScalarSubscription&lt;T&gt;(s, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>4.然后看RxJavaPlugins.onAssembly()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span><br><span class="line">    @NonNull</span><br><span class="line">    public static &lt;T&gt; Flowable&lt;T&gt; onAssembly(@NonNull Flowable&lt;T&gt; source) &#123;</span><br><span class="line">        //在这里钩子函数为null，即直接返回source</span><br><span class="line">        Function&lt;? super Flowable, ? extends Flowable&gt; f = onFlowableAssembly;</span><br><span class="line">        if (f != null) &#123;</span><br><span class="line">            return apply(f, source);</span><br><span class="line">        &#125;</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>5.所以Flowable.just(“Hello world”)只是生成了一个Flowable对象。接着看subscribe()方法。实现了Consumer接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 回调函数accept去消费这个传入值，</span><br><span class="line">     * Consume the given value.</span><br><span class="line">     * @param t the value</span><br><span class="line">     * @throws Exception on error</span><br><span class="line">     */</span><br><span class="line">    void accept(T t) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.接着看subscribe()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@CheckReturnValue</span><br><span class="line">@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)</span><br><span class="line">@SchedulerSupport(SchedulerSupport.NONE)</span><br><span class="line">public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;</span><br><span class="line">    //onNext即要去消费的接口对象</span><br><span class="line">    //其他传入参数为默认的onError，onComplete接口回调，和最大数量的订阅对象</span><br><span class="line">    return subscribe(onNext, Functions.ON_ERROR_MISSING,</span><br><span class="line">            Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7.然后去看第二个subscribe()内部方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@CheckReturnValue</span><br><span class="line">@BackpressureSupport(BackpressureKind.SPECIAL)</span><br><span class="line">@SchedulerSupport(SchedulerSupport.NONE)</span><br><span class="line">public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,</span><br><span class="line">        Action onComplete, Consumer&lt;? super Subscription&gt; onSubscribe) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);</span><br><span class="line">    ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span><br><span class="line">    ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</span><br><span class="line">    ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span><br><span class="line"></span><br><span class="line">    //上面一系列的判空操作之后，将传入参数组合成一个LambdaSubscriber</span><br><span class="line">    LambdaSubscriber&lt;T&gt; ls = new LambdaSubscriber&lt;T&gt;(onNext, onError, onComplete, onSubscribe);</span><br><span class="line"></span><br><span class="line">    //调用了第三个subscribe方法</span><br><span class="line">    subscribe(ls);</span><br><span class="line"></span><br><span class="line">    return ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>8、先来看一下LambdaSubscriber对象，除了对传入参数赋值之外，内部重写了熟悉的onSubscribe、onNext()、onError()、onComplete()三个方法。从6.可以看出在这四个方法中除了onNext()是我们传入的，其他都是框架默认的。源码过长，不copy了。<br>9.接着继续看第三个subscribe(ls)方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@BackpressureSupport(BackpressureKind.SPECIAL)</span><br><span class="line">@SchedulerSupport(SchedulerSupport.NONE)</span><br><span class="line">@Beta</span><br><span class="line">public final void subscribe(FlowableSubscriber&lt;? super T&gt; s) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(s, &quot;s is null&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 传入当前要观察的对象和处理方法对象构建了一个观察者对象</span><br><span class="line">        Subscriber&lt;? super T&gt; z = RxJavaPlugins.onSubscribe(this, s);</span><br><span class="line"></span><br><span class="line">        ObjectHelper.requireNonNull(z, &quot;Plugin returned null Subscriber&quot;);</span><br><span class="line"></span><br><span class="line">        //在这传入一个观察者对象</span><br><span class="line">        subscribeActual(z);</span><br><span class="line">    &#125; catch (NullPointerException e) &#123; // NOPMD</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        // can&apos;t call onError because no way to know if a Subscription has been set or not</span><br><span class="line">        // can&apos;t call onSubscribe because the call might have set a Subscription already</span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">        NullPointerException npe = new NullPointerException(&quot;Actually not, but can&apos;t throw other exceptions due to RS&quot;);</span><br><span class="line">        npe.initCause(e);</span><br><span class="line">        throw npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>10.接着看subscribeActual(),似曾相识在3.中FlowableJust重写了父类的subscribeActual()方法，所以最后有回来了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void subscribeActual(Subscriber&lt;? super T&gt; s) &#123;</span><br><span class="line">    //1.传入观察者对象和要发射的值创建了一个标量的订阅对象</span><br><span class="line">    //2.观察者对象订阅了这个标量的订阅对象</span><br><span class="line">    s.onSubscribe(new ScalarSubscription&lt;T&gt;(s, value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>11.先看ScalarSubscription方法，可以看到当调用了request(n)的方法时onNext方法就会被调用,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ScalarSubscription(Subscriber&lt;? super T&gt; subscriber, T value) &#123;</span><br><span class="line">    this.subscriber = subscriber;</span><br><span class="line">    this.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request(long n) &#123;</span><br><span class="line">    if (!SubscriptionHelper.validate(n)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (compareAndSet(NO_REQUEST, REQUESTED)) &#123;</span><br><span class="line">        Subscriber&lt;? super T&gt; s = subscriber;</span><br><span class="line">        //这里就是LambdaSubscriber中的onNext，也是我们传入的onNext会去回调的地方</span><br><span class="line">        s.onNext(value);</span><br><span class="line">        if (get() != CANCELLED) &#123;</span><br><span class="line">            s.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>12.所以我们要看request()在哪里调用，接着看继续看s.onSubscribe()方法，它就是LambdaSubscriber中的onSubscribe()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onSubscribe(Subscription s) &#123;</span><br><span class="line">    if (SubscriptionHelper.setOnce(this, s)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //onSubscribe对象是在3.中传入的FlowableInternalHelper.RequestMax.INSTANCE，并调用了accept方法</span><br><span class="line">            onSubscribe.accept(this);</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            s.cancel();</span><br><span class="line">            onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.接着继续看FlowableInternalHelper.RequestMax.INSTANCE。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum RequestMax implements Consumer&lt;Subscription&gt; &#123;</span><br><span class="line">    //枚举法创建的单例</span><br><span class="line">    INSTANCE;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Subscription t) throws Exception &#123;</span><br><span class="line">        //可以看到在这里调用了request方法</span><br><span class="line">        t.request(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>14.接着可以回到11.ScalarSubscription类中，在request方法中就调用了LambdaSubscriber的onNext*()方法并传入了value值<br>15.接着再去看LambdaSubscriber类中的onNext方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onNext(T t) &#123;</span><br><span class="line">        if (!isDisposed()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //在这里回调了我们当初我们传入的实现对象onNext的accept方法，</span><br><span class="line">                onNext.accept(t);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(e);</span><br><span class="line">                get().cancel();</span><br><span class="line">                onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>16.走完onNext方法后，继续看11.它会继续走s.onComplete()方法，这个方法也是默认的Functions.EMPTY_ACTION<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class EmptyAction implements Action &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123; </span><br><span class="line">            //空方法</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;EmptyAction&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>17.至于onError方法会14.在onNext()发生异常时去调用，且在这里也是默认传入的Functions.ON_ERROR_MISSING<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final class OnErrorMissingConsumer implements Consumer&lt;Throwable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Throwable error) &#123;</span><br><span class="line">        RxJavaPlugins.onError(new OnErrorNotImplementedException(error));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext-进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式"><a href="#最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext-进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式" class="headerlink" title="最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext()进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式"></a>最后范例一just的整个流程就是这样，从流程看出just操作符是真的很简单的，只是实现了一个对象的传递，内部也只是对我们要实现的onNext()进行了回调处理，因此其实对其他onError和onComplete我们也可以自定义处理方式</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基于Rxjava-2-1-10版本源码分析&quot;&gt;&lt;a href=&quot;#基于Rxjava-2-1-10版本源码分析&quot; class=&quot;headerlink&quot; title=&quot;基于Rxjava-2.1.10版本源码分析&quot;&gt;&lt;/a&gt;基于Rxjava-2.1.10版本源码分析&lt;/h3&gt;&lt;p&gt;从开源文档范例开始分析&lt;/p&gt;
&lt;h4 id=&quot;范例一-Flowable-just输出HelloWord&quot;&gt;&lt;a href=&quot;#范例一-Flowable-just输出HelloWord&quot; class=&quot;headerlink&quot; title=&quot;范例一.Flowable.just输出HelloWord&quot;&gt;&lt;/a&gt;范例一.Flowable.just输出HelloWord&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Flowable.just(&amp;quot;Hello world&amp;quot;).subscribe(new Consumer&amp;lt;String&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void accept(String s) throws Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;1.从just方法开始,首先可以看到三个注解方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@CheckReturnValue  //检查返回值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@BackpressureSupport(BackpressureKind.FULL)  //支持的背压方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@SchedulerSupport(SchedulerSupport.NONE) //调度方式,即处理事件的方式IO数据流，新开一个线程等。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static &amp;lt;T&amp;gt; Flowable&amp;lt;T&amp;gt; just(T item) &amp;#123; //方法参数是个泛型，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ObjectHelper.requireNonNull(item, &amp;quot;item is null&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //返回值是个Flowable对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return RxJavaPlugins.onAssembly(new FlowableJust&amp;lt;T&amp;gt;(item)); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="RxJava" scheme="http://yangxin.online/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Java反射那些事</title>
    <link href="http://yangxin.online/Java%E5%8F%8D%E5%B0%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html"/>
    <id>http://yangxin.online/Java反射那些事.html</id>
    <published>2018-01-29T03:05:10.000Z</published>
    <updated>2018-04-22T06:55:27.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射机制的定义"><a href="#反射机制的定义" class="headerlink" title="反射机制的定义"></a>反射机制的定义</h2><p>在运行状态期间，能过动态的知道一个类的属性和方法，能够动态的调用一个对象的属性和方法的功能。</p><h2 id="反射机制的功能"><a href="#反射机制的功能" class="headerlink" title="反射机制的功能"></a>反射机制的功能</h2><p>在运行期间</p><ol><li>判断任意一个对象所属的类</li><li>构建任意一个类的对象</li><li>判断任意一个类的属性和方法</li><li>调用任意一个对象的方法</li><li>生成动态代理<a id="more"></a><h2 id="反射机制的应用场景"><a href="#反射机制的应用场景" class="headerlink" title="反射机制的应用场景"></a>反射机制的应用场景</h2></li><li>逆向代码，反编译</li><li>与注解相结合的框架，retrofit</li><li>单纯的反射机制框架，EventBus</li><li>动态生成类框架，Gson</li></ol><h2 id="通过反射获取类信息"><a href="#通过反射获取类信息" class="headerlink" title="通过反射获取类信息"></a>通过反射获取类信息</h2><p>每个类被加载后，系统会为该类生成一个对应的Class对象，通过该Class对象就可以访问JVM中的这个类</p><h4 id="在JAVA程序中获得Class对象通常有三种方法"><a href="#在JAVA程序中获得Class对象通常有三种方法" class="headerlink" title="在JAVA程序中获得Class对象通常有三种方法"></a>在JAVA程序中获得Class对象通常有三种方法</h4><ol><li>使用Class类的forName()静态方法,传入全限定名</li><li>调用某个类的class属性 </li><li>通过对象getClass()获取Class对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Classs  class = Class.forName(com.zyx.Person);</span><br><span class="line">2.Class calss = Person.class;</span><br><span class="line">3.Person person = new Person();</span><br><span class="line">Class class = person.getClass();</span><br></pre></td></tr></table></figure></li></ol><h4 id="获取class对象的属性、方法、构造函数"><a href="#获取class对象的属性、方法、构造函数" class="headerlink" title="获取class对象的属性、方法、构造函数"></a>获取class对象的属性、方法、构造函数</h4><ol><li><p>获取class对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] allFields = class.getDeclaredFileds();// 获取所有声明的属性</span><br><span class="line">Filed[] publicFileds = calss.getFields[]; //获取所有public属性</span><br><span class="line">Field ageField = class.getDeclaredFiled(&quot;age&quot;);// 获取指定声明的属性</span><br><span class="line">Filed desFiled = calss.getField(&quot;age&quot;); //获取指定public属性</span><br></pre></td></tr></table></figure></li><li><p>获取class对象的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = class.getDeclaredMethods();// 获取所有声明的方法</span><br><span class="line">Method[] publicFileds = calss.getMethods[]; //获取所有public方法，</span><br><span class="line">Method[] publicFileds = calss.getMethods[]; //获取所有public方法，带指定形参列表的方法</span><br><span class="line">Method method= class.getDeclaredMethods(&quot;info&quot;,String.class);// 获取指定声明的方法，</span><br><span class="line">Method infoMethod = calss.getMethod(&quot;info&quot;,String.class); //获取指定public方法,带指定形参列表的方法</span><br></pre></td></tr></table></figure></li><li><p>获取class对象的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor</span><br></pre></td></tr></table></figure></li></ol><h4 id="通过Java反射生成并操作对象"><a href="#通过Java反射生成并操作对象" class="headerlink" title="通过Java反射生成并操作对象"></a>通过Java反射生成并操作对象</h4><p><strong>生成实例</strong></p><ol><li>使用Class对象的newInstance()方法来创建Class对象对应的实例，但对应类必须有默认的构造函数</li><li>先使用Class的对象获取指定的Constructor对象，在调用Constructor对象的newInstance()方法<br><strong>调用方法</strong></li><li>通过Class对象的getMethods()或者getMethod()获得指定方法，返回Method对象或者数组。</li><li>通过Method对象中的invoke()方法。第一个参数传调用该方法的对象，第二个参数传对应该方法的参数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = class.newInstance();</span><br><span class="line">Method methdo = calss.getDeclareMethod(&quot;setAge&quot;, int.calss);</span><br><span class="line">method.invoke(obj, 28); //会检查调用权限</span><br></pre></td></tr></table></figure></li></ol><p><strong>访问成员变量赋值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = class.newInstance();</span><br><span class="line">Field field = class.getField(&quot;age&quot;);</span><br><span class="line">field.setInt(obj, 28);</span><br><span class="line">int age = field.getInt(obj);</span><br></pre></td></tr></table></figure></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>给某个类提供一个代理对象，并由代理对象控制对原对象的访问，即客户不直接操控原对象，而是通过代理对象操控原对象</p><h4 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h4><ol><li>静态代理，在编译时就实现好了，会生成对应的Class实际文件</li><li>动态代理，在运行时生成，在运行时生成类字节码被加载到JVM中</li></ol><h4 id="代理模式的思路"><a href="#代理模式的思路" class="headerlink" title="代理模式的思路"></a>代理模式的思路</h4><ol><li>代理对象和目标对象均实现同一个行为接口</li><li>代理对象和目标对象分别实现具体接口逻辑</li><li>在代理对像的构造函数中实例化一个目标对象</li><li>在代理对象中调用目标对象的行为接口</li><li>客户端想要调用目标对象的行为接口只能通过代理对象来操作</li></ol><h4 id="Java反射机制和动态代理"><a href="#Java反射机制和动态代理" class="headerlink" title="Java反射机制和动态代理"></a>Java反射机制和动态代理</h4><p><strong>动态代理介绍</strong></p><ol><li>运行时生成代理类，并将代理类的字节码载入当前代理的ClassLoader</li><li>不需要多些多写一个与目标类相同的代理类</li><li>可以在运行时定制代理类的执行逻辑<br><strong>涉及的类</strong></li><li>java.lang.reflect.Proxy,生成代理类的主类，通过Proxy生成的代理类都继承Proxy。Proxy提供了创建动态代理类和代理对象的方法，是所有动态代理类的父类。</li><li>java.lang.reflect.InvacationHandle 调用处理器，当调用动态代理的方法时会直接转到InvocationHandle的invoke()方法</li></ol><h4 id="泛型与Class"><a href="#泛型与Class" class="headerlink" title="泛型与Class"></a>泛型与Class</h4><p>避免强制转换<br>泛型参数化类型 getGenericType();<br>普通类型 getType()</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;反射机制的定义&quot;&gt;&lt;a href=&quot;#反射机制的定义&quot; class=&quot;headerlink&quot; title=&quot;反射机制的定义&quot;&gt;&lt;/a&gt;反射机制的定义&lt;/h2&gt;&lt;p&gt;在运行状态期间，能过动态的知道一个类的属性和方法，能够动态的调用一个对象的属性和方法的功能。&lt;/p&gt;
&lt;h2 id=&quot;反射机制的功能&quot;&gt;&lt;a href=&quot;#反射机制的功能&quot; class=&quot;headerlink&quot; title=&quot;反射机制的功能&quot;&gt;&lt;/a&gt;反射机制的功能&lt;/h2&gt;&lt;p&gt;在运行期间&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断任意一个对象所属的类&lt;/li&gt;
&lt;li&gt;构建任意一个类的对象&lt;/li&gt;
&lt;li&gt;判断任意一个类的属性和方法&lt;/li&gt;
&lt;li&gt;调用任意一个对象的方法&lt;/li&gt;
&lt;li&gt;生成动态代理
    
    </summary>
    
      <category term="Java" scheme="http://yangxin.online/categories/Java/"/>
    
    
      <category term="【反射机制】" scheme="http://yangxin.online/tags/%E3%80%90%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E3%80%91/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型那些事</title>
    <link href="http://yangxin.online/%E6%B3%9B%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B.html"/>
    <id>http://yangxin.online/泛型那些事.html</id>
    <published>2018-01-29T02:06:54.000Z</published>
    <updated>2018-03-12T07:23:21.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型的目的"><a href="#泛型的目的" class="headerlink" title="泛型的目的"></a>泛型的目的</h2><p>语法糖即糖衣语法，这种语法对语言并没有影响，只是方便了程序员的使用。主要包括：泛型，变长参数，条件编译，自动拆装箱，内部类等。虚拟机并不支持这种语法，在编译期就会被还原为基础语法结构，这个过程被称为解语法糖。<br>泛型的目的：通过泛型使得在编译期间完成类型转换工作，避免运行时强制类型转换而出现ClassCastException，类型转换异常<br><a id="more"></a></p><h2 id="泛型初窥"><a href="#泛型初窥" class="headerlink" title="泛型初窥"></a>泛型初窥</h2><p>JDK1.5之后添加<br>泛型的好处</p><ol><li>类型安全，将类型检测挪到了编译期。</li><li>消除了代码中许多的强制类型转换，增强了代码的可读性</li><li>为较大的优化带来了可能<h2 id="泛型使用"><a href="#泛型使用" class="headerlink" title="泛型使用"></a>泛型使用</h2>泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当做类型使用<br>方法声明定义的形参只能在该方法里使用<br>修饰符<t,s> 返回值类型 方法名（形参列表）{<br> 方法体<br>}<h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2></t,s></li><li>任意通配符：？匹配任意的类型，用作读取不能添加</li><li>上限通配符：使用extends关键字指定这个类型必须是继承某个类，或者是实现某个接口（子类或者本身）</li><li>下限通配符：使用super关键字指定这个类型必须是某个类的父类，或者是某个接口的父类</li></ol><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>作用于编译期间，所以运行期间泛型信息是被擦除的，编译后的Class不包含泛型信息。静态方法，静态初始化或者静态变量声明和初始化不允许使用类型形参。也不能使用instance of运算符</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;泛型的目的&quot;&gt;&lt;a href=&quot;#泛型的目的&quot; class=&quot;headerlink&quot; title=&quot;泛型的目的&quot;&gt;&lt;/a&gt;泛型的目的&lt;/h2&gt;&lt;p&gt;语法糖即糖衣语法，这种语法对语言并没有影响，只是方便了程序员的使用。主要包括：泛型，变长参数，条件编译，自动拆装箱，内部类等。虚拟机并不支持这种语法，在编译期就会被还原为基础语法结构，这个过程被称为解语法糖。&lt;br&gt;泛型的目的：通过泛型使得在编译期间完成类型转换工作，避免运行时强制类型转换而出现ClassCastException，类型转换异常&lt;br&gt;
    
    </summary>
    
      <category term="“JAVA”" scheme="http://yangxin.online/categories/%E2%80%9CJAVA%E2%80%9D/"/>
    
    
      <category term="泛型" scheme="http://yangxin.online/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java集合类分析理解</title>
    <link href="http://yangxin.online/Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%88%86%E6%9E%90%E7%90%86%E8%A7%A3.html"/>
    <id>http://yangxin.online/Java集合类分析理解.html</id>
    <published>2018-01-25T09:32:12.000Z</published>
    <updated>2018-04-22T06:55:26.381Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/csdn_terence/article/details/78379878" title="Optional title" target="_blank" rel="external">Java集合面试总结</a></p><h2 id="Collecton-和-Map"><a href="#Collecton-和-Map" class="headerlink" title="Collecton 和 Map"></a>Collecton 和 Map</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>包括 Set List Queue<br><a id="more"></a></p><h4 id="主要分析"><a href="#主要分析" class="headerlink" title="主要分析"></a>主要分析</h4><ol><li><p>ArrayList</p><ul><li>动态数组</li><li>capacity 扩容机制  1.5倍， 初始 java1.8 : 10 ;android 21 :12</li><li>内部元素变动 System.copyarray();</li><li>线程不安全</li></ul></li><li><p>LinkList<br>双向链表<br>Node()函数，该函数以O(1/2)的性能去获取一个节点<br>链表操作<br>线程不安全</p></li><li><p><a href="http://www.importnew.com/20386.html" title="Optional title" target="_blank" rel="external">HashMap</a></p><ul><li>hash()方法 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) able的长度都是2的幂，因此index仅与hash值的低n位有关 <a href="http://blog.csdn.net/fan2012huan/article/details/51097331&quot;Optional title&quot;" target="_blank" rel="external">计算方式</a></li><li>tableSizeFor() 找到大于等于initialCapacity的最小的2的幂</li><li>Node[] tab哈希桶数组.哈希冲突，开放地址和链地址法</li><li>根据key获取哈希桶数组索引位置</li><li>tab 长度为2的幂次</li><li>threshold 所能容纳的key-value对极限</li><li>Map m = Collections.synchronizeMap(hashMap)实现同步</li><li>初始 capacity 16 loadFactor 0.75</li></ul></li><li><p><a href="http://www.iqiyi.com/v_19rro6v558.html?vfm=m_312_shsp" title="Optional title" target="_blank" rel="external">TreeMap</a></p><ul><li>红黑树的定义，节点非红即黑，根节点为黑色，不能连续的红色，任意节点到末端的路径黑色个数相同</li><li>红黑树的平衡调整，颜色和结构</li><li>继承了SortMap ，put()函数会做比较</li><li>寻找后继节点，中序遍历</li></ul></li><li><p>LinkHashMap</p></li></ol><ul><li>与HashMap类似，不过保证了put顺序</li><li>主要实现了afterNodeAccess(),afterNodeInsert(),afterNoderemoval三个方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/csdn_terence/article/details/78379878&quot; title=&quot;Optional title&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java集合面试总结&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Collecton-和-Map&quot;&gt;&lt;a href=&quot;#Collecton-和-Map&quot; class=&quot;headerlink&quot; title=&quot;Collecton 和 Map&quot;&gt;&lt;/a&gt;Collecton 和 Map&lt;/h2&gt;&lt;h3 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;headerlink&quot; title=&quot;Collection&quot;&gt;&lt;/a&gt;Collection&lt;/h3&gt;&lt;p&gt;包括 Set List Queue&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yangxin.online/categories/Java/"/>
    
    
      <category term="集合" scheme="http://yangxin.online/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>android 线程那些事</title>
    <link href="http://yangxin.online/android-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5.html"/>
    <id>http://yangxin.online/android-线程同步.html</id>
    <published>2018-01-20T14:55:58.000Z</published>
    <updated>2018-01-24T04:22:37.678Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程和线程安全"><a href="#线程和线程安全" class="headerlink" title="线程和线程安全"></a>线程和线程安全</h3><h4 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h4><ol><li>线程为进程的一个实体</li><li>轻量级进程</li><li>是CPU调度和分配的基本单位</li><li>可与同一进程内的线程共享进程内的全部资源</li><li>android 进程通过fork创建，线程通过pthread.creat创建</li></ol><h4 id="并发的优势促使多线程的出现"><a href="#并发的优势促使多线程的出现" class="headerlink" title="并发的优势促使多线程的出现"></a>并发的优势促使多线程的出现</h4><ol><li>资源利用率 ，提高</li><li>公平性，共享资源</li><li>便利性，多任务并发执行比单任务更容易执行</li></ol><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多线程的引入意味着引入了线程安全。当单线程能正确运行的代码，在多线程访问的情况下，不管线程以何种顺序访问，并不添加同步代码都能正确表现行为，则称它为线程安全的</p><h3 id="并发的三大要素"><a href="#并发的三大要素" class="headerlink" title="并发的三大要素"></a>并发的三大要素</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指的是一个或者多个不能再被分割的操作<br>value = 1; //院子操作<br>value++; //复合操作</p><h4 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h4><p>指多进程访问共享资源，不做同步</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>当一个线程对某个变量做出修改时，其他线程可以立刻读取修改后的值</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ol><li>是一种稍弱的同步机制，用来确保变量更新操作同步到其他线程，虚拟机不会指令重排</li><li>锁与volatile不同，锁具有两个特性：互斥性和可见性</li></ol><h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><h4 id="Sychronized关键字"><a href="#Sychronized关键字" class="headerlink" title="Sychronized关键字"></a>Sychronized关键字</h4><p>可作用于class和java对象</p><h4 id="锁的原理"><a href="#锁的原理" class="headerlink" title="锁的原理"></a>锁的原理</h4><ol><li>锁实现了内存可见性和操作原子性</li><li>释放锁时，该线程的本地内存中的共享变量会被刷新到内存中</li><li>锁不会被继承</li><li>同步代码块是使用monitorenter和monitorexit指令实现的，同步方法是通过ACC_SYNCHRONIZED标识符实现</li></ol><h4 id="锁的使用原则"><a href="#锁的使用原则" class="headerlink" title="锁的使用原则"></a>锁的使用原则</h4><ol><li>可能被多个线程同时访问的可变变量，在访问它时都需要持有一个锁，变量由这个锁保护</li><li>每个可变变量都只有一个锁来保护，知道锁的范围</li><li>当锁作用于多个变量时，对每个变量的操作都应该由同一个恶锁保护</li><li>在Android中，工作线程尽量不要和UI线程做同步</li></ol><h4 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h4><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h4 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h4><p>reentrantLock<br>semaphore<br>countDownLatch<br>CyclicBarrier<br>FutureTask</p><h3 id="原子变量和非阻塞算法"><a href="#原子变量和非阻塞算法" class="headerlink" title="原子变量和非阻塞算法"></a>原子变量和非阻塞算法</h3><p>Atomic<br>cas非阻塞算法<br>性能比较</p><p><a href="https://segmentfault.com/l/1500000012849264/play" target="_blank" rel="external">https://segmentfault.com/l/1500000012849264/play</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程和线程安全&quot;&gt;&lt;a href=&quot;#线程和线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程和线程安全&quot;&gt;&lt;/a&gt;线程和线程安全&lt;/h3&gt;&lt;h4 id=&quot;线程是什么&quot;&gt;&lt;a href=&quot;#线程是什么&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bit Manipulation</title>
    <link href="http://yangxin.online/bit-manipulation.html"/>
    <id>http://yangxin.online/bit-manipulation.html</id>
    <published>2017-12-04T07:41:37.000Z</published>
    <updated>2018-01-15T10:01:39.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Bit-Manipulation-位运算-："><a href="#Bit-Manipulation-位运算-：" class="headerlink" title="Bit Manipulation(位运算)："></a>Bit Manipulation(位运算)：</h3><p>一共五种运算：与，或，异或，左移，右移。</p><h4 id="常用技巧："><a href="#常用技巧：" class="headerlink" title="常用技巧："></a>常用技巧：</h4><p>（1） n &amp; （n-1）能够消灭n中最低位中的1。<br>（2） 右移：除以2， 左移：乘以2。<br>（3） 异或性质：交换律，0^a=a, a^a=0;<br>（3） 将常用字符、数字等均转为按位运算，可以节约空间。<br><a id="more"></a></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="Number-of-1-Bits"><a href="#Number-of-1-Bits" class="headerlink" title="Number of 1 Bits"></a><a href="https://leetcode.com/problems/number-of-1-bits/description/" title="Optional title" target="_blank" rel="external">Number of 1 Bits</a></h4><p>使用右移。<br>使用n&amp;(n-1)可以消灭一个1的性质来求解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int hammingWeight(int n) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    while (n &gt; 0) &#123;</span><br><span class="line">        cnt += (n &amp; 1);</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Missing-Number"><a href="#Missing-Number" class="headerlink" title="Missing Number"></a><a href="https://leetcode.com/problems/missing-number/description/" title="Optional title" target="_blank" rel="external">Missing Number</a></h4><p>这道题给我们n个数字，是0到n之间的数但是有一个数字去掉了，让我们寻找这个数字，要求线性的时间复杂度和常数级的空间复杂度。<br><strong>解法一:</strong>最直观的一个方法是用等差数列的求和公式求出0到n之间所有的数字之和，然后再遍历数组算出给定数字的累积和，然后做减法，差值就是丢失的那个数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int missingNumber(int[] nums) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    for(int i =0; i&lt; n; i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)(0.5 * n * (n + 1) - sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>解法二：</strong>，使用位操作Bit Manipulation来解的，用到了异或操作的特性。思路是既然0到n之间少了一个数，我们将这个少了一个数的数组合0到n之间完整的数组异或一下，那么相同的数字都变为0了，剩下的就是少了的那个数字了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int missingNumber1(int[] nums) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        int midres = (i + 1) ^ nums[i];</span><br><span class="line">        res ^= midres;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>解法三：</strong>这道题还可以用二分查找法来做，我们首先要对数组排序，然后我们用二分查找法算出中间元素的下标，然后用元素值和下标值之间做对比，如果元素值大于下标值，则说明缺失的数字在左边，作为读者的你可能会提出，排序的时间复杂度都不止O(n)，何必要多此一举用二分查找，还不如用上面两种方法呢。对，你说的没错，但是在面试的时候，有可能人家给你的数组就是排好序的，那么此时用二分查找法肯定要优于上面两种方法，所以这种方法最好也要掌握以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int missingNumber2(int[] nums) &#123;</span><br><span class="line">    if(nums == null || nums.length ==0)</span><br><span class="line">        return -1;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = nums.length - 1;</span><br><span class="line">    while (low &lt;= high)&#123;</span><br><span class="line">        int mid = low + (high - low)/2;</span><br><span class="line">        if(nums[mid] &gt; mid)&#123;</span><br><span class="line">            high = mid -1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Power-of-Two"><a href="#Power-of-Two" class="headerlink" title="Power of Two"></a><a href="https://leetcode.com/problems/power-of-two/description/" title="Optional title" target="_blank" rel="external">Power of Two</a></h4><p>使用n&amp;(n-1）=0来判断。<br>注意0和负数的情况。<br>这道题让我们判断一个数是否为2的次方数，而且要求时间和空间复杂度都为常数<br><strong>解法一：</strong>那么我们很容易看出来2的次方数都只有一个1，剩下的都是0，所以我们的解题思路就有了，我们只要每次判断最低位是否为1，然后向右移位，最后统计1的个数即可判断是否是2的次方数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isPowerOfTwo(int n) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    while (n &gt; 0) &#123;</span><br><span class="line">        cnt += (n &amp; 1);</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>解法二：</strong>这道题还有一个技巧，如果一个数是2的次方数的话，根据上面分析，那么它的二进数必然是最高位为1，其它都为0，那么如果此时我们减1的话，则最高位会降一位，其余为0的位现在都为变为1，那么我们把两数相与，就会得到0，用这个性质也能来解题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isPowerOfTwo2(int n)&#123;</span><br><span class="line">    int result = n &amp; (n - 1);</span><br><span class="line">    if(n &gt; 0 &amp;&amp; result == 0)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Bit-Manipulation-位运算-：&quot;&gt;&lt;a href=&quot;#Bit-Manipulation-位运算-：&quot; class=&quot;headerlink&quot; title=&quot;Bit Manipulation(位运算)：&quot;&gt;&lt;/a&gt;Bit Manipulation(位运算)：&lt;/h3&gt;&lt;p&gt;一共五种运算：与，或，异或，左移，右移。&lt;/p&gt;
&lt;h4 id=&quot;常用技巧：&quot;&gt;&lt;a href=&quot;#常用技巧：&quot; class=&quot;headerlink&quot; title=&quot;常用技巧：&quot;&gt;&lt;/a&gt;常用技巧：&lt;/h4&gt;&lt;p&gt;（1） n &amp;amp; （n-1）能够消灭n中最低位中的1。&lt;br&gt;（2） 右移：除以2， 左移：乘以2。&lt;br&gt;（3） 异或性质：交换律，0^a=a, a^a=0;&lt;br&gt;（3） 将常用字符、数字等均转为按位运算，可以节约空间。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yangxin.online/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetCode" scheme="http://yangxin.online/tags/leetCode/"/>
    
      <category term="算法" scheme="http://yangxin.online/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>自建梯子，畅行无阻</title>
    <link href="http://yangxin.online/vpn.html"/>
    <id>http://yangxin.online/vpn.html</id>
    <published>2017-12-04T02:12:53.000Z</published>
    <updated>2018-03-12T07:23:35.684Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/codeyu/BTGFW" title="Optional title" target="_blank" rel="external">自建梯子教程</a><br><a href="https://github.com/XX-net/XX-Net/issues/6506#issuecomment-336799889" title="Optional title" target="_blank" rel="external">自己搭建ss/ssr服务器教程（适合初学者）</a></p><p>###【一键部署ssr代码】<br>yum -y install wget<br>wget -N –no-check-certificate <a href="https://softs.fun/Bash/ssr.sh" target="_blank" rel="external">https://softs.fun/Bash/ssr.sh</a> &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</p><p>备用地址<br>yum -y install wget<br>wget -N –no-check-certificate <a href="https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh" target="_blank" rel="external">https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh</a> &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh<br><a id="more"></a><br>参数配置<br>远程端口<br>密码<br>加密方式 aes-256-cfb<br>协议 auth_chain_a<br>混淆方式 plain</p><p>###【谷歌BBR加速教程】</p><p>yum -y install wget</p><p>wget –no-check-certificate <a href="https://github.com/teddysun/across/raw/master/bbr.sh" target="_blank" rel="external">https://github.com/teddysun/across/raw/master/bbr.sh</a></p><p>chmod +x bbr.sh</p><p>./bbr.sh</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/codeyu/BTGFW&quot; title=&quot;Optional title&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自建梯子教程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/XX-net/XX-Net/issues/6506#issuecomment-336799889&quot; title=&quot;Optional title&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自己搭建ss/ssr服务器教程（适合初学者）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###【一键部署ssr代码】&lt;br&gt;yum -y install wget&lt;br&gt;wget -N –no-check-certificate &lt;a href=&quot;https://softs.fun/Bash/ssr.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://softs.fun/Bash/ssr.sh&lt;/a&gt; &amp;amp;&amp;amp; chmod +x ssr.sh &amp;amp;&amp;amp; bash ssr.sh&lt;/p&gt;
&lt;p&gt;备用地址&lt;br&gt;yum -y install wget&lt;br&gt;wget -N –no-check-certificate &lt;a href=&quot;https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh&lt;/a&gt; &amp;amp;&amp;amp; chmod +x ssr.sh &amp;amp;&amp;amp; bash ssr.sh&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://yangxin.online/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://yangxin.online/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Largest Rectangle in Histogram and Maximal Rectangle</title>
    <link href="http://yangxin.online/Largest-Rectangle-in-Histogram.html"/>
    <id>http://yangxin.online/Largest-Rectangle-in-Histogram.html</id>
    <published>2017-11-28T01:52:03.000Z</published>
    <updated>2018-01-15T10:01:39.987Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<br><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" title="Optional title" target="_blank" rel="external">Largest Rectangle in Histogram</a><br><a href="https://leetcode.com/problems/maximal-rectangle/description/" title="Optional title" target="_blank" rel="external">Maximal Rectangle</a><br><a id="more"></a><br>Largest Rectangle in Histogram 这道题算是比较难的一道题，最简单的做法就是对于任意一个bar，向左向右遍历，知道高度小于该bar。这时候计算该区域的面积。对于每一个bar，我们都做如上处理，最后得到最大值。当然这样的做法是O(n2)，过不了大数据集合测试。</p><p>从上面我们直到，对于任意一个bar n，我们得到的包含该bar n的矩形区域里面bar n是最小的。我们使用ln和rn来表示bar n向左及向右第一个小于bar n的bar的索引位置。<br>譬如题目中bar 2的高度是5,它的ln为1，rn为4.包含bar的矩形区域面积为（4-1-1）*5=10</p><p>我们可以从左往右遍历所有的bar，并将其push到一个stack中，如果dangqianbar的高度小于栈顶bar，我们pop出栈顶bar，同时以该bar计算举行面积。纳闷我们如何知道该bar的ln和rn呢？rn铁定就是当前遍历到的bar的索引，而ln则是当前栈顶bar的索引，因为此时栈顶bar的高度一定小于pop出来的bar的高度。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>因为要找三个元素，所以时间复杂度为O(n)，空间复杂度为O(1)</p><h4 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int largestRectangleArea(int[] height )&#123;</span><br><span class="line">    int maxArea  = 0;</span><br><span class="line">    Stack&lt;Integer&gt; s = new Stack&lt;&gt;();</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (i &lt;= height.length)&#123;</span><br><span class="line">        int h = (i == height.length ? 0 : height[i]);</span><br><span class="line">        if(s.isEmpty() ||  h &gt;= height[s.peek()])&#123;</span><br><span class="line">            s.push(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int t = s.pop();</span><br><span class="line">            maxArea = Math.max(maxArea, height[t] * (s.isEmpty() ? i : i - s.peek() - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Maximal Rectangle此题是之前那道的 Largest Rectangle in Histogram直方图中最大的矩形 的扩展，这道题的二维矩阵每一层向上都可以看做一个直方图，输入矩阵有多少行，就可以形成多少个直方图，对每个直方图都调用 Largest Rectangle in Histogram 直方图中最大的矩形 中的方法，就可以得到最大的矩形面积。那么这道题唯一要做的就是将每一层构成直方图，由于题目限定了输入矩阵的字符只有 ‘0’ 和 ‘1’ 两种，所以处理起来也相对简单。方法是，对于每一个点，如果是‘0’，则赋0，如果是 ‘1’，就赋之前的height值加上1。具体参见代码如下：</p><h4 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">    if(matrix == null || matrix.length == 0 || matrix[0].length == 0)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int[] height = new int[matrix[0].length];</span><br><span class="line">    for(int i = 0; i &lt; matrix[0].length; i ++)&#123;</span><br><span class="line">        if(matrix[0][i] == &apos;1&apos;) height[i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int result = largestRectangleArea(height);</span><br><span class="line">    for(int i = 1; i &lt; matrix.length; i ++)&#123;</span><br><span class="line">        resetHeight(matrix, height, i);</span><br><span class="line">        result = Math.max(result, largestRectangleArea(height));</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void resetHeight(char[][] matrix, int[] height, int idx)&#123;</span><br><span class="line">    for(int i = 0; i &lt; matrix[0].length; i ++)&#123;</span><br><span class="line">        if(matrix[idx][i] == &apos;1&apos;) height[i] += 1;</span><br><span class="line">        else height[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int largestRectangleArea(int[] height )&#123;</span><br><span class="line">    int maxArea  = 0;</span><br><span class="line">    Stack&lt;Integer&gt; s = new Stack&lt;&gt;();</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (i &lt;= height.length)&#123;</span><br><span class="line">        int h = (i == height.length ? 0 : height[i]);</span><br><span class="line">        if(s.isEmpty() ||  h &gt;= height[s.peek()])&#123;</span><br><span class="line">            s.push(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int t = s.pop();</span><br><span class="line">            maxArea = Math.max(maxArea, height[t] * (s.isEmpty() ? i : i - s.peek() - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/largest-rectangle-in-histogram/description/&quot; title=&quot;Optional title&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Largest Rectangle in Histogram&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/maximal-rectangle/description/&quot; title=&quot;Optional title&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Maximal Rectangle&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yangxin.online/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetCode" scheme="http://yangxin.online/tags/leetCode/"/>
    
      <category term="算法" scheme="http://yangxin.online/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>需常记心头</title>
    <link href="http://yangxin.online/%E9%9C%80%E5%B8%B8%E8%AE%B0%E5%BF%83%E5%A4%B4.html"/>
    <id>http://yangxin.online/需常记心头.html</id>
    <published>2017-11-25T08:17:29.000Z</published>
    <updated>2018-01-15T10:01:39.988Z</updated>
    
    <content type="html"><![CDATA[<p>在二维火工作收集的经典语句！<br><a id="more"></a><br><strong>不要起个大早，赶个晚集</strong><br>无法快速落地的“点子”都属于“忽悠”。趋势、潮流瞬息万变，竞争对手如狼似虎。再好的点子，如果只是挂在嘴上，不执行、不落实，等于把机会拱手送给别人。</p><p><strong>清空自己</strong><br>用户都很懒，并且时间宝贵，面对陌生的功能需要快速做出决定。所以在设计每一个细节时，尽量清空自己，忘掉身份，忘掉流程，让自己变成一个小白。最终呈现给用户的内容才是浅显易懂的。</p><p><strong>不要被用户牵着鼻子走</strong><br>与用户聊需求时，要挖掘其背后真实的目的。用户不会替我们考虑灵活性、普遍性、规范性。个性化的需求如何落实到通用的产品中区，需要思考，不能被用户带到沟里去。</p><p><strong>切记习以为常</strong><br>习惯一个人，习惯一件事，会让自己变得麻木，忽视其中存在的问题。我们的产品对大部分用户来说是陌生的，用户可能会卡在一些我们倒背如流的节点上，设计和使用自己的产品时需要保持敏感</p><p><strong>定期回顾</strong><br>行业在发展，技术在进步，客户的认知在变化，我们自己也在成长。长时间不用的东西，定期去回顾，会发现很多问题。有些功能用的很少，可能设计过时了，或者流程出问题了。</p><p><strong>产品能解决的事不要靠人去解决</strong><br>“这个功能给店家培训一下就好”，这句话是不负责任的，一个功能点做一次培训，一家店做一次培训，一千个功能点和十万店家需要多少人去培训多少次？人力成本的投入是巨大的，要用好的设计去引导用户，而不是靠人力去解决问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在二维火工作收集的经典语句！&lt;br&gt;
    
    </summary>
    
    
      <category term="经验" scheme="http://yangxin.online/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Find Mininum in Rotated Sorted Array I and II</title>
    <link href="http://yangxin.online/Find-Mininum-in-Rotated-Sorted-Array.html"/>
    <id>http://yangxin.online/Find-Mininum-in-Rotated-Sorted-Array.html</id>
    <published>2017-11-24T02:04:15.000Z</published>
    <updated>2018-01-15T10:01:39.987Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接:<br><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" title="Optional title" target="_blank" rel="external">Find Minimum in Rotated Sorted Array</a><br><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/" title="Optional title" target="_blank" rel="external">Find Minimum in Rotated Sorted Array II</a></p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>Find the minimum element.<br><strong>I和II的区别在于是否有重复元素</strong><br><a id="more"></a></p><h4 id="题目的要求"><a href="#题目的要求" class="headerlink" title="题目的要求"></a>题目的要求</h4><ol><li>一个升序的数组且无重复元素</li><li>在处理数组前进行部分反转</li><li>找出最小元素</li></ol><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><ol><li>寻找最小值，我们可以用二分查找法来做</li><li>在一个区间的A，如果A[start] &lt; A[end]，那么该区间一定是有序的</li></ol><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>假设一个轮转的排序数组arr，我们首先获取中间元素的值，arr[mid], mid = start + (end - start)/2.因为没有重复数组，那么就有两种情况。</p><ol><li>arr[mid] &gt; arr[start], 那么最小值一定在右半区间，eg:{4,5,6,7,0,1,2} 中间数为7.7&gt;4,最小元素一定在{7,0,1,2}</li><li>arr[mid] &lt; arr[start], 那么最小值一定在左半区间,eg:{7,0,1,2,3,4,5,6}中间数为2,2&lt;7，最小元素一定在{7,0,1,2}</li><li>处理重复元素，当arr[mid] == arr[start], 跳过start++.</li></ol><h4 id="边界值"><a href="#边界值" class="headerlink" title="边界值"></a>边界值</h4><ol><li>输入数组arr == null, arr.length == 0 ,return 0</li><li>arr.length == 1, return arr[0]</li><li>输入数组arr为有序数组，return arr[start];</li></ol><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间复杂度为O(logn)，空间复杂度为O(N)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static int findMin(int[] arr)&#123;</span><br><span class="line">    if(arr == null || arr.length == 0)</span><br><span class="line">        return 0;</span><br><span class="line">    if(arr.length == 1)</span><br><span class="line">        return arr[0];</span><br><span class="line"></span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = arr.length -1;</span><br><span class="line"></span><br><span class="line">    while (start &lt; end)&#123;</span><br><span class="line">        if(arr[start] &lt; arr[end])&#123;</span><br><span class="line">            return arr[start];</span><br><span class="line">        &#125;</span><br><span class="line">        int min = start + (end - start)/2; It can avoid overflow.</span><br><span class="line">        if(arr[start] &lt; arr[min])&#123;</span><br><span class="line">            start = min;</span><br><span class="line">        &#125;else if(arr[start] &lt; arr[min])&#123;</span><br><span class="line">            end = min;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            start++; //处理重复元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr[start] &lt; arr[end] ? arr[start] : arr[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接:&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/&quot; title=&quot;Optional title&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Find Minimum in Rotated Sorted Array&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/&quot; title=&quot;Optional title&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Find Minimum in Rotated Sorted Array II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;br&gt;(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).&lt;br&gt;Find the minimum element.&lt;br&gt;&lt;strong&gt;I和II的区别在于是否有重复元素&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yangxin.online/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetCode" scheme="http://yangxin.online/tags/leetCode/"/>
    
      <category term="算法" scheme="http://yangxin.online/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>3Sum</title>
    <link href="http://yangxin.online/3Sum.html"/>
    <id>http://yangxin.online/3Sum.html</id>
    <published>2017-11-20T07:03:24.000Z</published>
    <updated>2018-01-15T10:01:39.987Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/3sum/discuss/" title="Optional title" target="_blank" rel="external">3Sum</a><br>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>Note: The solution set must not contain duplicate triplets.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [-1, 0, 1, 2, -1, -4],</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="题目的两点要求："><a href="#题目的两点要求：" class="headerlink" title="题目的两点要求："></a>题目的两点要求：</h4><ol><li>每个答案组里面的三个数字是要从小到大排列起来的</li><li>每个答案不可以和其他的答案相同</li></ol><h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><ol><li>每个答案数组triplet中的元素是要求升序排列的</li><li>不能包含重复的答案数组</li></ol><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><ol><li>因为要求每个答案数组中的元素都是升序排列的，所以开头我们要对数组进行排序</li><li>因为不能包含重复的答案数组，我们要在代码里做去重操作</li><li>归根结底是Two pointers的想法，定位其中两个指针，根据和的大小移动另外一个</li></ol><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>因为要找三个元素，所以时间复杂度为O(n2)，空间复杂度为O(1)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    if(nums.length &lt; 3)</span><br><span class="line">        return result;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (i &lt; nums.length -2)&#123;</span><br><span class="line">        if(nums[i] &gt; 0)</span><br><span class="line">            return result;</span><br><span class="line">        int j = i + 1;</span><br><span class="line">        int k = nums.length - 1;</span><br><span class="line"></span><br><span class="line">        while (j &lt; k)&#123;</span><br><span class="line">            int sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">            if(sum == 0)</span><br><span class="line">                result.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line">            if(sum &lt;= 0)</span><br><span class="line">                while (nums[j] == nums[++j] &amp;&amp; j &lt; k);</span><br><span class="line">            if(sum &gt;= 0)</span><br><span class="line">                while (nums[k] == nums[--k] &amp;&amp; j &lt; k);</span><br><span class="line">        &#125;</span><br><span class="line">        while (nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/3sum/discuss/&quot; title=&quot;Optional title&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3Sum&lt;/a&gt;&lt;br&gt;Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.&lt;br&gt;Note: The solution set must not contain duplicate triplets.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;For example, given array S = [-1, 0, 1, 2, -1, -4],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A solution set is:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, -1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yangxin.online/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetCode" scheme="http://yangxin.online/tags/leetCode/"/>
    
      <category term="算法" scheme="http://yangxin.online/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
