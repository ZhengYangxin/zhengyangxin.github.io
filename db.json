{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"cc75fbdb977a72e3c33a32b977ec965c1597d5c5","modified":1510148555000},{"_id":"source/CNAME","hash":"e4ce609f8a617040e1cd3bc6c0f51f810b8210a3","modified":1510148009000},{"_id":"themes/next/._config.yml.un~","hash":"e4c3285f2f1f5bb2074228d7d8dfc52a0acbaa93","modified":1510148009000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1510148009000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1510148009000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1510148009000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1510148009000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1510148009000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1510148009000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1510148009000},{"_id":"themes/next/README.en.md","hash":"3b0c7998cf17f9cf9e1a5bfcd65679a43a00c817","modified":1510148009000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1510148009000},{"_id":"themes/next/_config.yml","hash":"b4011202d7d9174ee078366647fd0edcbfbf5705","modified":1510148009000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1510148009000},{"_id":"themes/next/_config.yml~","hash":"2152172b99fac8b75ca877e1163b98a61adad431","modified":1510148009000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1510148009000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1510149069000},{"_id":"source/_posts/Java中方法调用参数传递的方式是传值，有且只有传值.md","hash":"5db3738acdb554ca860cc83e85f89f4083554087","modified":1510148009000},{"_id":"source/_posts/Android-Studio修改包名.md","hash":"26000e4103e7781b8ce0d19884ff7f9841ab72ad","modified":1510148009000},{"_id":"source/_posts/Netty项目实践（一）.md","hash":"91e0c628f115c5f0534d406b4c88cf8e036d1453","modified":1510148009000},{"_id":"source/_posts/Teach-you-to-recognize-MVCMVPMVVM.md","hash":"7662f587fcd26d1d3b11aef83e065ceb4b3e55b9","modified":1510148009000},{"_id":"source/_posts/Subline3下的两款Markdown插件.md","hash":"867409abfa72a797629ec661098d532f884ebf81","modified":1510148009000},{"_id":"source/_posts/android系统架构-一.md","hash":"7b2d6047251a7e073087bd8aec3f8e743c0fbc97","modified":1510148009000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1510148009000},{"_id":"source/_posts/git相关操作.md","hash":"49d737b41c6dee130e0c5167e0e6f824a976eb7e","modified":1510148009000},{"_id":"source/_posts/mactest.md","hash":"ca2bae1d02dedff71b77e0f864ff0e3f52bd4fe7","modified":1510148582000},{"_id":"source/_posts/try-catch-finally的执行顺序及数据处理情况.md","hash":"bf5642bc97ba12a8a7f9c3f443732a04bd7b094a","modified":1510148009000},{"_id":"source/_posts/事件传递机制.md","hash":"6544cb41d749160ab3a90f1df5b36c3709379c3c","modified":1510148009000},{"_id":"source/_posts/什么是算法.md","hash":"cc2ed494af54a0ea55e83d6d4eec14884cb6d223","modified":1510148009000},{"_id":"source/_posts/性能优化之布局.md","hash":"48647b52f7be3e0ddd8384d6df133e970c4a896c","modified":1510148009000},{"_id":"source/_posts/数据结构（一）.md","hash":"80f81e1e999860f799fc78fe52bc33185816a075","modified":1510148009000},{"_id":"source/_posts/数据结构之线性表.md","hash":"b6084d06f86842a415ad68c534c4ba636086b1ff","modified":1510148009000},{"_id":"source/_posts/数据传输加密——非对称加密算法RSA-对称算法AES.md","hash":"8d89d1720d11cbd320c0fae33b2f1cc8d9d53a9d","modified":1510148009000},{"_id":"source/_posts/阿里云Centos7搭建Git服务器仓库.md","hash":"f803e1e1985d14e048d800a92d68b01b9d94a5fb","modified":1510148009000},{"_id":"source/_posts/算法面试准备.md","hash":"ce6e966a5bce6a4bb36bfe072be11e6357fd7886","modified":1510148009000},{"_id":"source/_posts/第三方登录的注意与坑.md","hash":"226023d4b3964282a3e768084e683a8317141b66","modified":1510148009000},{"_id":"source/tags/index.md","hash":"1de462943ed68773aa192292fde34917efd9475d","modified":1510148009000},{"_id":"source/_posts/面试基础（一）.md","hash":"f5027ff07aa5d48362221ccb7c9c814733bf0f7b","modified":1510148009000},{"_id":"source/categories/index.md","hash":"7438fe23ff2dfdc35e17b3f5fa1ed6b7d5d624ff","modified":1510148009000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1510148009000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1510148009000},{"_id":"themes/next/languages/.zh-Hans.yml.un~","hash":"022e9c0401b3fb59c0a935b17b9af0a9a9e6ee5d","modified":1510148009000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1510148009000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1510148009000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1510148009000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1510148009000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1510148009000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1510148009000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1510148009000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1510148009000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1510148009000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1510148009000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"e1e4061d806390f492ceb13b95fb63d4bcca8380","modified":1510148009000},{"_id":"themes/next/languages/zh-Hans.yml~","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1510148009000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1510148009000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1510148009000},{"_id":"themes/next/layout/_layout.swig","hash":"2fa3c74066843a859fac77803324a1de51044da9","modified":1510148009000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1510148009000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1510148009000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1510148009000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1510148009000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1510148009000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1510148009000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1510148009000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1510148009000},{"_id":"themes/next/source/404.html","hash":"b65f21a80fa0f9c62fafb74af518a7304039bc8c","modified":1510148009000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1510148009000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1510148009000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1510148009000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510148009000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1510148009000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1510148009000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1510148009000},{"_id":"themes/next/layout/_macro/post.swig","hash":"e6016def9b512188f4c2725399c9adc7bc41cdae","modified":1510148009000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1510148009000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1510148009000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1510148009000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"78ccfc1dc915247c1fec3c86d742e0f4c2f6d99c","modified":1510148009000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1510148009000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1510148009000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1510148009000},{"_id":"themes/next/layout/_partials/header.swig","hash":"adab5c3f7b173f1b45454787f39dde07aea03483","modified":1510148009000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1510148009000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1510148009000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1510148009000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1510148009000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1510148009000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1510148009000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1510148009000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1510148009000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1510148009000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1510148009000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1510148009000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1510148009000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1510148009000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1510148009000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1510148009000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1510148009000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1510148009000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1510148009000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1510148009000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1510148009000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1510148009000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1510148009000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1510148009000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1510148009000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1510148009000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1510148009000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1510148009000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510148009000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510148009000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510148009000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510148009000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510148009000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510148009000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510148009000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1510148009000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1510148009000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1510148009000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1510148009000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1510148009000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1510148009000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1510148009000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1510148009000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1510148009000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1510148009000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1510148009000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1510148009000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"4abc01bc870e1d7a783cdbd26166edc782a6a4f4","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1510148009000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1510148009000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1510148009000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1510148009000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1510148009000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c459aa6d607d8bcb747544e74f6ad0b8374aa3b1","modified":1510148009000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"fc185c6cec79593775d1c2440dbe2a71cfbe2e99","modified":1510148009000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1510148009000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1510148009000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1510148009000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1510148009000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1510148009000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1510148009000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1510148009000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1510148009000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1510148009000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1510148009000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1510148009000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1510148009000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1510148009000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1510148009000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1510148009000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1510148009000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1510148009000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1510148009000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1510148009000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1510148009000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1510148009000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1510148009000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1510148009000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1510148009000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1510148009000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1510148009000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1510148009000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"ea8078fa9e10be2bb042749d8b6a97adc38f914c","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1510148009000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1510148009000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1510148009000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1510148009000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1510148009000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1510148009000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"1408209dfb9a22a0982a30bdbd14842c2b53f264","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1510148009000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1510148009000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1510148009000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1510148009000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1510148009000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1510148009000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"fdfadbb4483043c7e0afd541ee9712389e633517","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1510148009000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1510148009000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1510148009000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1510148009000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1510148009000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1510148009000},{"_id":"public/tags/index.html","hash":"25be7cfd95d82796ceed2460574fa51c86ce2911","modified":1510149345757},{"_id":"public/categories/index.html","hash":"1146525af5a7f9e1ee2761ad4edb21ed2fbbee47","modified":1510149345757},{"_id":"public/2017/11/08/mactest/index.html","hash":"7b77a24d5435d3fa03d3b3c0be0d651a64eeecdf","modified":1510149345757},{"_id":"public/2017/11/08/hello-world/index.html","hash":"5a4d62cb12bee23ae7ad9dab2b8186f40a722837","modified":1510149345757},{"_id":"public/2017/04/30/第三方登录的注意与坑/index.html","hash":"dcf126439684982cd64feb455d654c78bc13642f","modified":1510149345757},{"_id":"public/categories/Android/index.html","hash":"e8af24e2b3b4591ad00826d97b011bc0146c57c7","modified":1510149345757},{"_id":"public/categories/项目实践/index.html","hash":"98fac201a203097a944e1fe04660e194a9cf6b17","modified":1510149345757},{"_id":"public/categories/总结/index.html","hash":"e4d1acc4af5895ddabdd0dbe3050de46dd81cd84","modified":1510149345757},{"_id":"public/categories/辅助工具/index.html","hash":"7d177f54265a5e6e5a705668840bad7780445025","modified":1510149345757},{"_id":"public/categories/开发工具/index.html","hash":"ac2a409a51228f5e0bac2187e5431bcac64c1bf8","modified":1510149345757},{"_id":"public/categories/算法/index.html","hash":"682c92e1ba91ef07f2850f886e42d088618792fe","modified":1510149345757},{"_id":"public/categories/安全/index.html","hash":"6bc58d00c5548846389366f39cd40472e9f1e8c1","modified":1510149345758},{"_id":"public/archives/index.html","hash":"4649478efeeec84687d52100994efd1f060fad6f","modified":1510149345758},{"_id":"public/archives/page/2/index.html","hash":"81c665b4f39dc675ecc9207553a53c2cd89a3e90","modified":1510149345758},{"_id":"public/archives/2017/index.html","hash":"e575a8d40cf7f73209d9374053711ff57adabd0d","modified":1510149345758},{"_id":"public/archives/2017/page/2/index.html","hash":"2df4efbc83b3a328ab24f9f8d33fdffc1b75898c","modified":1510149345758},{"_id":"public/archives/2017/02/index.html","hash":"4bbf56e9331982fe4ce4b9de9786c010d4d36cde","modified":1510149345758},{"_id":"public/archives/2017/03/index.html","hash":"c027a683f9a5daba8e33bd1e126fab17a06a1e7b","modified":1510149345758},{"_id":"public/archives/2017/04/index.html","hash":"cbd89f7ea6453e085e2df734eb090009c6b0de1f","modified":1510149345758},{"_id":"public/archives/2017/06/index.html","hash":"5206c0954b1390507584198d63a267d921dfb495","modified":1510149345758},{"_id":"public/archives/2017/08/index.html","hash":"047256b0d1d51b0e5a616bc67b2bd7c8a7ca0f50","modified":1510149345758},{"_id":"public/archives/2017/11/index.html","hash":"cc541e330a38dfd8b1ae1817eddacd63f6aab94d","modified":1510149345758},{"_id":"public/tags/Java基础/index.html","hash":"6583d89fc31cf76d5237c84cac683527cd62041e","modified":1510149345758},{"_id":"public/tags/包名修改/index.html","hash":"b7018f4246eab0419df67ed5ac0db2738311dd1f","modified":1510149345758},{"_id":"public/tags/Netty/index.html","hash":"a2d633cd5efb5792335ce3efe1afa790d139d0c0","modified":1510149345758},{"_id":"public/tags/JAVA/index.html","hash":"258024b1fa0d82e76b2aecb7ca2a37aa9608a806","modified":1510149345758},{"_id":"public/tags/模式、Android/index.html","hash":"9cffb2256f8604e989c8f187c4dca2b632aa65ff","modified":1510149345759},{"_id":"public/tags/Subline/index.html","hash":"2c216b0ce031a4773cf59b88e78f361808239c30","modified":1510149345759},{"_id":"public/tags/Markdown/index.html","hash":"14ebd81397016815f726ac0bc91e14c3db4c0a27","modified":1510149345759},{"_id":"public/tags/git/index.html","hash":"0633c6cf3b135c40723a89423dacd89fd6456fd0","modified":1510149345759},{"_id":"public/tags/Android/index.html","hash":"9b4fd9d52192fbdf3e4de707241622530372be2b","modified":1510149345759},{"_id":"public/tags/算法基础/index.html","hash":"6263e4b38b4f82542b782e3c83ced444e737bef6","modified":1510149345759},{"_id":"public/tags/数据结构/index.html","hash":"64107296ff454a20f2b96189ab91b551bf98e094","modified":1510149345759},{"_id":"public/tags/安全、Android/index.html","hash":"0e047fcb026b5cc86933b2496e0bd50bcb83e549","modified":1510149345759},{"_id":"public/2017/08/13/算法面试准备/index.html","hash":"bbbeb781831a56e2095f8b9db5e38d325a0bd0ed","modified":1510149345759},{"_id":"public/2017/08/02/git相关操作/index.html","hash":"877941210b7238f2ccf9658bc0a3ac2f43243130","modified":1510149345759},{"_id":"public/2017/06/26/Java中方法调用参数传递的方式是传值，有且只有传值/index.html","hash":"e664785e95a912bce70553aafd95d5659aed22c6","modified":1510149345759},{"_id":"public/2017/06/25/try-catch-finally的执行顺序及数据处理情况/index.html","hash":"2eaf45b6d351056844f43d0c9203d414034f7827","modified":1510149345759},{"_id":"public/2017/06/22/面试基础（一）/index.html","hash":"7fc6a6e7401c8b0571961cd23603a9a7c10d9e15","modified":1510149345759},{"_id":"public/2017/06/18/数据结构之线性表/index.html","hash":"e26fa001b463ff22887db0fafc326c19b772b3e6","modified":1510149345759},{"_id":"public/2017/06/15/数据结构（一）/index.html","hash":"16d6623795326262bafb858a43941d2cbe2f18d0","modified":1510149345759},{"_id":"public/2017/06/14/什么是算法/index.html","hash":"65fe6016791c9bdb1a1dcb970d024ba37887d8e2","modified":1510149345759},{"_id":"public/2017/04/29/数据传输加密——非对称加密算法RSA-对称算法AES/index.html","hash":"832438590a5117d0bf150993a7777e3bd16a0e6a","modified":1510149345760},{"_id":"public/2017/03/28/Android-Studio修改包名/index.html","hash":"ddc5b9da9fa62e3fa50133dec0f823f528ca2b3f","modified":1510149345760},{"_id":"public/2017/03/27/事件传递机制/index.html","hash":"9259e09529fbe7e6f334fce1b21382d7bf9a4f79","modified":1510149345760},{"_id":"public/2017/03/26/Teach-you-to-recognize-MVCMVPMVVM/index.html","hash":"d8cbdd5cde5ab0713a1e6d582b9737ba1130450a","modified":1510149345760},{"_id":"public/2017/03/21/性能优化之布局/index.html","hash":"f38c14a851a56eac02bc54d605b49b7eb0e3666a","modified":1510149345760},{"_id":"public/2017/03/20/android系统架构-一/index.html","hash":"86d3482745aa7a97d6bfcaebe0ee108b3014de88","modified":1510149345760},{"_id":"public/2017/03/19/Netty项目实践（一）/index.html","hash":"b563882a49b0271c54e0032a33a4fa8b3bd1d288","modified":1510149345760},{"_id":"public/2017/03/18/Subline3下的两款Markdown插件/index.html","hash":"8e7ccd8a401ccbd88c0151cf2396387157cae777","modified":1510149345760},{"_id":"public/2017/02/09/阿里云Centos7搭建Git服务器仓库/index.html","hash":"97d2f1aeadeff0f038c41844c62d11f6bb87b345","modified":1510149345760},{"_id":"public/index.html","hash":"fb98383bd22979f452738a71c6905d0e30f45664","modified":1510149345760},{"_id":"public/page/2/index.html","hash":"ab5870d17e0696245096e9e314e17a60b3a10366","modified":1510149345760},{"_id":"public/CNAME","hash":"e4ce609f8a617040e1cd3bc6c0f51f810b8210a3","modified":1510149345765},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1510149345765},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1510149345765},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1510149345765},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1510149345765},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1510149345765},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1510149345765},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1510149345765},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1510149345765},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1510149345765},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1510149345765},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1510149345765},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1510149345765},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1510149345765},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1510149345766},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1510149345766},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1510149345766},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1510149345766},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1510149345766},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1510149345766},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1510149345766},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1510149345766},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1510149345766},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1510149345766},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1510149345766},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1510149346360},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1510149346363},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1510149346367},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1510149346367},{"_id":"public/404.html","hash":"b65f21a80fa0f9c62fafb74af518a7304039bc8c","modified":1510149346371},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1510149346371},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1510149346371},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1510149346371},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1510149346371},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1510149346371},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1510149346371},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1510149346371},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1510149346371},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1510149346371},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1510149346371},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1510149346371},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1510149346371},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1510149346371},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1510149346371},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1510149346371},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1510149346372},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1510149346372},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1510149346372},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1510149346372},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1510149346372},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1510149346372},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1510149346372},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1510149346372},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1510149346372},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1510149346372},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1510149346372},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1510149346372},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1510149346372},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1510149346372},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1510149346372},{"_id":"public/css/main.css","hash":"be4b1ece4e7ae75237cd7602db235c031a44b84e","modified":1510149346372},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1510149346372},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1510149346373},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1510149346373},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1510149346373},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1510149346373},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1510149346373},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1510149346373},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1510149346373},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1510149346373},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1510149346373},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1510149346373},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1510149346385}],"Category":[{"name":"Android","_id":"cj9r3xeo900069xs6u21d8mrk"},{"name":"项目实践","_id":"cj9r3xeod000c9xs6sugo21kk"},{"name":"总结","_id":"cj9r3xeoh000i9xs6828xma6d"},{"name":"辅助工具","_id":"cj9r3xeoj000n9xs609hdj92y"},{"name":"开发工具","_id":"cj9r3xeom000u9xs6daepi72o"},{"name":"算法","_id":"cj9r3xeos00139xs6fnb79chp"},{"name":"安全","_id":"cj9r3xeox00189xs60eqyeqrj"}],"Data":[],"Page":[{"title":"tags","date":"2015-12-02T04:10:34.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2015-12-02 12:10:34\ntype: \"tags\"\n---\n","updated":"2017-11-08T13:33:29.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj9r3xeo200019xs6ouudxavr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2015-12-02T04:44:45.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2015-12-02 12:44:45\ntype: \"categories\"\n---\n","updated":"2017-11-08T13:33:29.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj9r3xeo500039xs6u0c92qgh","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Java中方法调用参数传递的方式是传值，有且只有传值","date":"2017-06-26T14:56:10.000Z","_content":"#### Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does Java pass by refrence or pass by value）\n\n**基本数据类型与引用数据类型**\n\n- 8种基本数据类型\n\n- 引用数据类型：类、接口类型、数组类型、枚举类型、注解类型。\n\n**区别：**\n\n- 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。\n\n- 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。\n\n例如，有一个类Person,有属性name,age,带有参的构造方法，\n\nPerson p = new Person(\"zhangsan\",20);\n\n**在内存中的具体创建过程是：**\n\n1.首先在栈内存中位其p分配一块空间;\n\n2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值\"\"，0；\n\n3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作；\n\n4.调用构造方法，为两个属性赋值为\"Tom\",20；（注意这个时候p与Person对象之间还没有建立联系）；\n\n5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。\n\n#### 相关知识：\n\n静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在整个程序的生命周期内都存在，由编译器在编译的时候分配。\n\n堆区：  一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错\n\n栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限\n\n文字常量区： 常量字符串就是放在这里的。   程序结束后由系统释放。\n\n程序代码区：存放函数体的二进制代码。\n\n![Alt text](http://images0.cnblogs.com/blog2015/751291/201507/051423530158394.png \"Optional title\")\n\n**在Java中，所有的对象变量都是引用，Java通过引用来管理对象。然而在给方法传参时，Java并没有使用传引用的方式，而是采用了传值的方式。**\n例如下面的badSwap()方法：\n```\npublic void badSwap(int var1, int var2)  \n{  \n  int temp = var1;  \n  var1 = var2;  \n  var2 = temp;  \n}  \n```\n当badSwap方法结束时，原有的var1和var2的值并不会发生变化。即使我们用其它Object类型来替代int，也不会有变化，因为Java在传递引用时也是采用传值的方式。（译者注：这里是关键，全文的核心是：1. Java中对象变量是引用 2. Java中方法是传值的 3. 传方法中参数时，传递的是引用的值）\n代码：\n\n```\npublic void tricky(Point arg1, Point arg2)  \n{  \n  arg1.x = 100;  \n  arg1.y = 100;  \n  Point temp = arg1;  \n  arg1 = arg2;  \n  arg2 = temp;  \n}  \npublic static void main(String [] args)  \n{  \n  Point pnt1 = new Point(0,0);  \n  Point pnt2 = new Point(0,0);  \n  System.out.println(\"X: \" + pnt1.x + \" Y: \" +pnt1.y);   \n  System.out.println(\"X: \" + pnt2.x + \" Y: \" +pnt2.y);  \n  System.out.println(\" \");  \n  tricky(pnt1,pnt2);  \n  System.out.println(\"X: \" + pnt1.x + \" Y:\" + pnt1.y);   \n  System.out.println(\"X: \" + pnt2.x + \" Y: \" +pnt2.y);    \n}  \n```\n执行main()的输出如下：\n\n```\nX: 0 Y: 0  \nX: 0 Y: 0  \nX: 100 Y: 100  \nX: 0 Y: 0  \n```\n这个方法成功地改变了pnt1的值，但pnt1和pnt2的交换却失败了！这是Java参数传递机制里最让人迷惑的地方。在main()中，pnt1和pnt2是Point对象的引用，当将pnt1和pnt2传递给tricky()时，Java使用的正是传值的方式，将这两个引用的传给了﻿﻿arg1和arg2。也就是说arg1和arg2正是pnt1和pnt2的复制，他们所指向的对象是相同的。详情可见下面的图示：\n<div align=center>\n![Alt text](http://images.techhive.com/images/idge/imported/article/jvw/2000/05/03-qa-0512-pass1-100158781-orig.gif \"Optional title\")\n在作为参数传递后，对象至少有两个引用指向自己\n</div>\n在main()中，引用被复制并以传值的方式进行传递，对象本身并不会被传递。因此，tricky()方法中pnt1所指向的对象发生了变化。因为传递的是引用的复制，因此引用的交换既不能引起对象的交换，更不会使原始引用发生变化。如图2所示，tricky()交换了arg1与arg2，但不会影响pnt1和pnt2。因此若想交换原始引用pnt1和pnt2，那么不能通过调用方法的方式来实现。\n<div align=center>\n![Alt text](http://hi.csdn.net/attachment/201201/31/0_13279907114A2K.gif \"Optional title\")\n在作为参数传递后，对象至少有两个引用指向自己\n</div>\n\n#### 总结：####\n1. Java中对象变量是引用 \n2. Java中方法是传值的 \n3. 传方法中参数时，传递的是引用的值 \n\n\n\n","source":"_posts/Java中方法调用参数传递的方式是传值，有且只有传值.md","raw":"---\ntitle: Java中方法调用参数传递的方式是传值，有且只有传值\ndate: 2017-06-26 22:56:10\ntags: [Java基础]\n---\n#### Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does Java pass by refrence or pass by value）\n\n**基本数据类型与引用数据类型**\n\n- 8种基本数据类型\n\n- 引用数据类型：类、接口类型、数组类型、枚举类型、注解类型。\n\n**区别：**\n\n- 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。\n\n- 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。\n\n例如，有一个类Person,有属性name,age,带有参的构造方法，\n\nPerson p = new Person(\"zhangsan\",20);\n\n**在内存中的具体创建过程是：**\n\n1.首先在栈内存中位其p分配一块空间;\n\n2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值\"\"，0；\n\n3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作；\n\n4.调用构造方法，为两个属性赋值为\"Tom\",20；（注意这个时候p与Person对象之间还没有建立联系）；\n\n5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。\n\n#### 相关知识：\n\n静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在整个程序的生命周期内都存在，由编译器在编译的时候分配。\n\n堆区：  一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错\n\n栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限\n\n文字常量区： 常量字符串就是放在这里的。   程序结束后由系统释放。\n\n程序代码区：存放函数体的二进制代码。\n\n![Alt text](http://images0.cnblogs.com/blog2015/751291/201507/051423530158394.png \"Optional title\")\n\n**在Java中，所有的对象变量都是引用，Java通过引用来管理对象。然而在给方法传参时，Java并没有使用传引用的方式，而是采用了传值的方式。**\n例如下面的badSwap()方法：\n```\npublic void badSwap(int var1, int var2)  \n{  \n  int temp = var1;  \n  var1 = var2;  \n  var2 = temp;  \n}  \n```\n当badSwap方法结束时，原有的var1和var2的值并不会发生变化。即使我们用其它Object类型来替代int，也不会有变化，因为Java在传递引用时也是采用传值的方式。（译者注：这里是关键，全文的核心是：1. Java中对象变量是引用 2. Java中方法是传值的 3. 传方法中参数时，传递的是引用的值）\n代码：\n\n```\npublic void tricky(Point arg1, Point arg2)  \n{  \n  arg1.x = 100;  \n  arg1.y = 100;  \n  Point temp = arg1;  \n  arg1 = arg2;  \n  arg2 = temp;  \n}  \npublic static void main(String [] args)  \n{  \n  Point pnt1 = new Point(0,0);  \n  Point pnt2 = new Point(0,0);  \n  System.out.println(\"X: \" + pnt1.x + \" Y: \" +pnt1.y);   \n  System.out.println(\"X: \" + pnt2.x + \" Y: \" +pnt2.y);  \n  System.out.println(\" \");  \n  tricky(pnt1,pnt2);  \n  System.out.println(\"X: \" + pnt1.x + \" Y:\" + pnt1.y);   \n  System.out.println(\"X: \" + pnt2.x + \" Y: \" +pnt2.y);    \n}  \n```\n执行main()的输出如下：\n\n```\nX: 0 Y: 0  \nX: 0 Y: 0  \nX: 100 Y: 100  \nX: 0 Y: 0  \n```\n这个方法成功地改变了pnt1的值，但pnt1和pnt2的交换却失败了！这是Java参数传递机制里最让人迷惑的地方。在main()中，pnt1和pnt2是Point对象的引用，当将pnt1和pnt2传递给tricky()时，Java使用的正是传值的方式，将这两个引用的传给了﻿﻿arg1和arg2。也就是说arg1和arg2正是pnt1和pnt2的复制，他们所指向的对象是相同的。详情可见下面的图示：\n<div align=center>\n![Alt text](http://images.techhive.com/images/idge/imported/article/jvw/2000/05/03-qa-0512-pass1-100158781-orig.gif \"Optional title\")\n在作为参数传递后，对象至少有两个引用指向自己\n</div>\n在main()中，引用被复制并以传值的方式进行传递，对象本身并不会被传递。因此，tricky()方法中pnt1所指向的对象发生了变化。因为传递的是引用的复制，因此引用的交换既不能引起对象的交换，更不会使原始引用发生变化。如图2所示，tricky()交换了arg1与arg2，但不会影响pnt1和pnt2。因此若想交换原始引用pnt1和pnt2，那么不能通过调用方法的方式来实现。\n<div align=center>\n![Alt text](http://hi.csdn.net/attachment/201201/31/0_13279907114A2K.gif \"Optional title\")\n在作为参数传递后，对象至少有两个引用指向自己\n</div>\n\n#### 总结：####\n1. Java中对象变量是引用 \n2. Java中方法是传值的 \n3. 传方法中参数时，传递的是引用的值 \n\n\n\n","slug":"Java中方法调用参数传递的方式是传值，有且只有传值","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeny00009xs62f8gqp5v","content":"<h4 id=\"Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does-Java-pass-by-refrence-or-pass-by-value）\"><a href=\"#Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does-Java-pass-by-refrence-or-pass-by-value）\" class=\"headerlink\" title=\"Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does Java pass by refrence or pass by value）\"></a>Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does Java pass by refrence or pass by value）</h4><p><strong>基本数据类型与引用数据类型</strong></p>\n<ul>\n<li><p>8种基本数据类型</p>\n</li>\n<li><p>引用数据类型：类、接口类型、数组类型、枚举类型、注解类型。</p>\n</li>\n</ul>\n<p><strong>区别：</strong></p>\n<ul>\n<li><p>基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。</p>\n</li>\n<li><p>引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。</p>\n</li>\n</ul>\n<p>例如，有一个类Person,有属性name,age,带有参的构造方法，</p>\n<p>Person p = new Person(“zhangsan”,20);</p>\n<p><strong>在内存中的具体创建过程是：</strong></p>\n<p>1.首先在栈内存中位其p分配一块空间;</p>\n<p>2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值””，0；</p>\n<p>3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作；</p>\n<p>4.调用构造方法，为两个属性赋值为”Tom”,20；（注意这个时候p与Person对象之间还没有建立联系）；</p>\n<p>5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。</p>\n<h4 id=\"相关知识：\"><a href=\"#相关知识：\" class=\"headerlink\" title=\"相关知识：\"></a>相关知识：</h4><p>静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在整个程序的生命周期内都存在，由编译器在编译的时候分配。</p>\n<p>堆区：  一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错</p>\n<p>栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限</p>\n<p>文字常量区： 常量字符串就是放在这里的。   程序结束后由系统释放。</p>\n<p>程序代码区：存放函数体的二进制代码。</p>\n<p><img src=\"http://images0.cnblogs.com/blog2015/751291/201507/051423530158394.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p><strong>在Java中，所有的对象变量都是引用，Java通过引用来管理对象。然而在给方法传参时，Java并没有使用传引用的方式，而是采用了传值的方式。</strong><br>例如下面的badSwap()方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void badSwap(int var1, int var2)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  int temp = var1;  </span><br><span class=\"line\">  var1 = var2;  </span><br><span class=\"line\">  var2 = temp;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当badSwap方法结束时，原有的var1和var2的值并不会发生变化。即使我们用其它Object类型来替代int，也不会有变化，因为Java在传递引用时也是采用传值的方式。（译者注：这里是关键，全文的核心是：1. Java中对象变量是引用 2. Java中方法是传值的 3. 传方法中参数时，传递的是引用的值）<br>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void tricky(Point arg1, Point arg2)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  arg1.x = 100;  </span><br><span class=\"line\">  arg1.y = 100;  </span><br><span class=\"line\">  Point temp = arg1;  </span><br><span class=\"line\">  arg1 = arg2;  </span><br><span class=\"line\">  arg2 = temp;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">public static void main(String [] args)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  Point pnt1 = new Point(0,0);  </span><br><span class=\"line\">  Point pnt2 = new Point(0,0);  </span><br><span class=\"line\">  System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y: &quot; +pnt1.y);   </span><br><span class=\"line\">  System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);  </span><br><span class=\"line\">  System.out.println(&quot; &quot;);  </span><br><span class=\"line\">  tricky(pnt1,pnt2);  </span><br><span class=\"line\">  System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y:&quot; + pnt1.y);   </span><br><span class=\"line\">  System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行main()的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X: 0 Y: 0  </span><br><span class=\"line\">X: 0 Y: 0  </span><br><span class=\"line\">X: 100 Y: 100  </span><br><span class=\"line\">X: 0 Y: 0</span><br></pre></td></tr></table></figure>\n<p>这个方法成功地改变了pnt1的值，但pnt1和pnt2的交换却失败了！这是Java参数传递机制里最让人迷惑的地方。在main()中，pnt1和pnt2是Point对象的引用，当将pnt1和pnt2传递给tricky()时，Java使用的正是传值的方式，将这两个引用的传给了﻿﻿arg1和arg2。也就是说arg1和arg2正是pnt1和pnt2的复制，他们所指向的对象是相同的。详情可见下面的图示：</p>\n<div align=\"center\"><br><img src=\"http://images.techhive.com/images/idge/imported/article/jvw/2000/05/03-qa-0512-pass1-100158781-orig.gif\" alt=\"Alt text\" title=\"Optional title\"><br>在作为参数传递后，对象至少有两个引用指向自己<br></div><br>在main()中，引用被复制并以传值的方式进行传递，对象本身并不会被传递。因此，tricky()方法中pnt1所指向的对象发生了变化。因为传递的是引用的复制，因此引用的交换既不能引起对象的交换，更不会使原始引用发生变化。如图2所示，tricky()交换了arg1与arg2，但不会影响pnt1和pnt2。因此若想交换原始引用pnt1和pnt2，那么不能通过调用方法的方式来实现。<br><div align=\"center\"><br><img src=\"http://hi.csdn.net/attachment/201201/31/0_13279907114A2K.gif\" alt=\"Alt text\" title=\"Optional title\"><br>在作为参数传递后，对象至少有两个引用指向自己<br></div>\n\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><ol>\n<li>Java中对象变量是引用 </li>\n<li>Java中方法是传值的 </li>\n<li>传方法中参数时，传递的是引用的值 </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does-Java-pass-by-refrence-or-pass-by-value）\"><a href=\"#Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does-Java-pass-by-refrence-or-pass-by-value）\" class=\"headerlink\" title=\"Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does Java pass by refrence or pass by value）\"></a>Java中方法调用参数传递的方式是传值，尽管传的是引用的值而不是对象的值。（Does Java pass by refrence or pass by value）</h4><p><strong>基本数据类型与引用数据类型</strong></p>\n<ul>\n<li><p>8种基本数据类型</p>\n</li>\n<li><p>引用数据类型：类、接口类型、数组类型、枚举类型、注解类型。</p>\n</li>\n</ul>\n<p><strong>区别：</strong></p>\n<ul>\n<li><p>基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。</p>\n</li>\n<li><p>引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。</p>\n</li>\n</ul>\n<p>例如，有一个类Person,有属性name,age,带有参的构造方法，</p>\n<p>Person p = new Person(“zhangsan”,20);</p>\n<p><strong>在内存中的具体创建过程是：</strong></p>\n<p>1.首先在栈内存中位其p分配一块空间;</p>\n<p>2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值””，0；</p>\n<p>3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作；</p>\n<p>4.调用构造方法，为两个属性赋值为”Tom”,20；（注意这个时候p与Person对象之间还没有建立联系）；</p>\n<p>5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。</p>\n<h4 id=\"相关知识：\"><a href=\"#相关知识：\" class=\"headerlink\" title=\"相关知识：\"></a>相关知识：</h4><p>静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在整个程序的生命周期内都存在，由编译器在编译的时候分配。</p>\n<p>堆区：  一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错</p>\n<p>栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限</p>\n<p>文字常量区： 常量字符串就是放在这里的。   程序结束后由系统释放。</p>\n<p>程序代码区：存放函数体的二进制代码。</p>\n<p><img src=\"http://images0.cnblogs.com/blog2015/751291/201507/051423530158394.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p><strong>在Java中，所有的对象变量都是引用，Java通过引用来管理对象。然而在给方法传参时，Java并没有使用传引用的方式，而是采用了传值的方式。</strong><br>例如下面的badSwap()方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void badSwap(int var1, int var2)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  int temp = var1;  </span><br><span class=\"line\">  var1 = var2;  </span><br><span class=\"line\">  var2 = temp;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当badSwap方法结束时，原有的var1和var2的值并不会发生变化。即使我们用其它Object类型来替代int，也不会有变化，因为Java在传递引用时也是采用传值的方式。（译者注：这里是关键，全文的核心是：1. Java中对象变量是引用 2. Java中方法是传值的 3. 传方法中参数时，传递的是引用的值）<br>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void tricky(Point arg1, Point arg2)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  arg1.x = 100;  </span><br><span class=\"line\">  arg1.y = 100;  </span><br><span class=\"line\">  Point temp = arg1;  </span><br><span class=\"line\">  arg1 = arg2;  </span><br><span class=\"line\">  arg2 = temp;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">public static void main(String [] args)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  Point pnt1 = new Point(0,0);  </span><br><span class=\"line\">  Point pnt2 = new Point(0,0);  </span><br><span class=\"line\">  System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y: &quot; +pnt1.y);   </span><br><span class=\"line\">  System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);  </span><br><span class=\"line\">  System.out.println(&quot; &quot;);  </span><br><span class=\"line\">  tricky(pnt1,pnt2);  </span><br><span class=\"line\">  System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y:&quot; + pnt1.y);   </span><br><span class=\"line\">  System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行main()的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X: 0 Y: 0  </span><br><span class=\"line\">X: 0 Y: 0  </span><br><span class=\"line\">X: 100 Y: 100  </span><br><span class=\"line\">X: 0 Y: 0</span><br></pre></td></tr></table></figure>\n<p>这个方法成功地改变了pnt1的值，但pnt1和pnt2的交换却失败了！这是Java参数传递机制里最让人迷惑的地方。在main()中，pnt1和pnt2是Point对象的引用，当将pnt1和pnt2传递给tricky()时，Java使用的正是传值的方式，将这两个引用的传给了﻿﻿arg1和arg2。也就是说arg1和arg2正是pnt1和pnt2的复制，他们所指向的对象是相同的。详情可见下面的图示：</p>\n<div align=\"center\"><br><img src=\"http://images.techhive.com/images/idge/imported/article/jvw/2000/05/03-qa-0512-pass1-100158781-orig.gif\" alt=\"Alt text\" title=\"Optional title\"><br>在作为参数传递后，对象至少有两个引用指向自己<br></div><br>在main()中，引用被复制并以传值的方式进行传递，对象本身并不会被传递。因此，tricky()方法中pnt1所指向的对象发生了变化。因为传递的是引用的复制，因此引用的交换既不能引起对象的交换，更不会使原始引用发生变化。如图2所示，tricky()交换了arg1与arg2，但不会影响pnt1和pnt2。因此若想交换原始引用pnt1和pnt2，那么不能通过调用方法的方式来实现。<br><div align=\"center\"><br><img src=\"http://hi.csdn.net/attachment/201201/31/0_13279907114A2K.gif\" alt=\"Alt text\" title=\"Optional title\"><br>在作为参数传递后，对象至少有两个引用指向自己<br></div>\n\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><ol>\n<li>Java中对象变量是引用 </li>\n<li>Java中方法是传值的 </li>\n<li>传方法中参数时，传递的是引用的值 </li>\n</ol>\n"},{"title":"Android Studio修改包名","date":"2017-03-28T11:52:24.000Z","_content":"### Android Studio修改包名\n1. 修改包显示方式\n\n![Alt text](http://img2.tuicool.com/BBBR3qN.png!web \"修改包显示方式\")\n\n通过修改包显示方式，我们可以更方便的修改包名。\n\n2. 修改包名\n\n![Alt text](http://www.itnose.net/img/20150709/10391686.png \"修改包名\")\n\n3. 改build.gradle(module：APP名字)文件中的 applicationId\n\n![Alt text](http://www.itnose.net/img/20150709/10391688.png \"改build.gradle(\")\n\n4. clean和rebuild project\n\n![Alt text](http://www.itnose.net/img/20150709/10391689.png \"clean和rebuild project\")\n\n5. 关闭android studio重启(可选)\n\n亲测有效，完美~\n### 简易操作，全局替换\nctr+shift+r","source":"_posts/Android-Studio修改包名.md","raw":"---\ntitle: Android Studio修改包名\ndate: 2017-03-28 19:52:24\ntags: [包名修改]\ncategory: \"Android\"\n---\n### Android Studio修改包名\n1. 修改包显示方式\n\n![Alt text](http://img2.tuicool.com/BBBR3qN.png!web \"修改包显示方式\")\n\n通过修改包显示方式，我们可以更方便的修改包名。\n\n2. 修改包名\n\n![Alt text](http://www.itnose.net/img/20150709/10391686.png \"修改包名\")\n\n3. 改build.gradle(module：APP名字)文件中的 applicationId\n\n![Alt text](http://www.itnose.net/img/20150709/10391688.png \"改build.gradle(\")\n\n4. clean和rebuild project\n\n![Alt text](http://www.itnose.net/img/20150709/10391689.png \"clean和rebuild project\")\n\n5. 关闭android studio重启(可选)\n\n亲测有效，完美~\n### 简易操作，全局替换\nctr+shift+r","slug":"Android-Studio修改包名","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeo300029xs6aduxckf8","content":"<h3 id=\"Android-Studio修改包名\"><a href=\"#Android-Studio修改包名\" class=\"headerlink\" title=\"Android Studio修改包名\"></a>Android Studio修改包名</h3><ol>\n<li>修改包显示方式</li>\n</ol>\n<p><img src=\"http://img2.tuicool.com/BBBR3qN.png!web\" alt=\"Alt text\" title=\"修改包显示方式\"></p>\n<p>通过修改包显示方式，我们可以更方便的修改包名。</p>\n<ol>\n<li>修改包名</li>\n</ol>\n<p><img src=\"http://www.itnose.net/img/20150709/10391686.png\" alt=\"Alt text\" title=\"修改包名\"></p>\n<ol>\n<li>改build.gradle(module：APP名字)文件中的 applicationId</li>\n</ol>\n<p><img src=\"http://www.itnose.net/img/20150709/10391688.png\" alt=\"Alt text\" title=\"改build.gradle(\"></p>\n<ol>\n<li>clean和rebuild project</li>\n</ol>\n<p><img src=\"http://www.itnose.net/img/20150709/10391689.png\" alt=\"Alt text\" title=\"clean和rebuild project\"></p>\n<ol>\n<li>关闭android studio重启(可选)</li>\n</ol>\n<p>亲测有效，完美~</p>\n<h3 id=\"简易操作，全局替换\"><a href=\"#简易操作，全局替换\" class=\"headerlink\" title=\"简易操作，全局替换\"></a>简易操作，全局替换</h3><p>ctr+shift+r</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Android-Studio修改包名\"><a href=\"#Android-Studio修改包名\" class=\"headerlink\" title=\"Android Studio修改包名\"></a>Android Studio修改包名</h3><ol>\n<li>修改包显示方式</li>\n</ol>\n<p><img src=\"http://img2.tuicool.com/BBBR3qN.png!web\" alt=\"Alt text\" title=\"修改包显示方式\"></p>\n<p>通过修改包显示方式，我们可以更方便的修改包名。</p>\n<ol>\n<li>修改包名</li>\n</ol>\n<p><img src=\"http://www.itnose.net/img/20150709/10391686.png\" alt=\"Alt text\" title=\"修改包名\"></p>\n<ol>\n<li>改build.gradle(module：APP名字)文件中的 applicationId</li>\n</ol>\n<p><img src=\"http://www.itnose.net/img/20150709/10391688.png\" alt=\"Alt text\" title=\"改build.gradle(\"></p>\n<ol>\n<li>clean和rebuild project</li>\n</ol>\n<p><img src=\"http://www.itnose.net/img/20150709/10391689.png\" alt=\"Alt text\" title=\"clean和rebuild project\"></p>\n<ol>\n<li>关闭android studio重启(可选)</li>\n</ol>\n<p>亲测有效，完美~</p>\n<h3 id=\"简易操作，全局替换\"><a href=\"#简易操作，全局替换\" class=\"headerlink\" title=\"简易操作，全局替换\"></a>简易操作，全局替换</h3><p>ctr+shift+r</p>\n"},{"title":"Netty项目实践（一）","date":"2017-03-19T14:14:45.000Z","_content":"### 为什么要学\n需要要做一个中间件，接受由硬件通过wifi和手机反复传递过来的数据（温湿度），然后再通过中间件将数据写入数据库。由于数据是时时接收的，所以用普通的http请求难以完全实现，所以考虑建立长链接实现功能。</br>\n#### Netty的使用场景非常吻合：\n* 构建高性能、低时延的各种Java中间件，例如MQ、分布式服务框架、ESB消息总线等，Netty主要作为基础通信框架提供高性能、低时延的通信服务；\n* 公有或者私有协议栈的基础通信框架，例如可以基于Netty构建异步、高性能的WebSocket协议栈；\n* 各领域应用，例如大数据、游戏等，Netty作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。\n#### 参考:\n[通俗地讲，Netty 能做什么？](https://www.zhihu.com/question/24322387)\n[Netty那些不得不说的事](http://www.kuqin.com/shuoit/20150709/346994.html);\n[Netty系列之Netty高性能之道](http://www.infoq.com/cn/articles/netty-high-performance/)\n### 学习过程\n1. 创建Maven 项目BabyNetty\n```\n <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.zyx.baby</groupId>\n    <artifactId>BabyNetty</artifactId>\n    <packaging>pom</packaging>\n    <version>1.0-SNAPSHOT</version>\n```\nGroupID:是项目组织唯一的标识符，实际对应JAVA的包的结构，是main目录里java的目录结构。\nArtifactID:就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。\n\n2. 创建两个模块JavaClient，NettyCore\nJavaClient:打算用于对服务器的一些数据请求\nNettyCore：数据接收，分发处理\n3. 依赖jar和插件\n```\n<!--“打包“这个词听起来比较土，比较正式的说法应该是”构建项目软件包“，具体说就是将项目中的各种文件，\n比如源代码、编译生成的字节码、配置文件、文档，按照规范的格式生成归档，最常见的当然就是JAR包和WAR包了，-->\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <configuration>\n                    <archive>\n                        <manifest>\n                            <addClasspath>true</addClasspath>\n                            <classpathPrefix>lib/</classpathPrefix>\n                            <mainClass>org.origin.netty.Start</mainClass>\n                        </manifest>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-dependency-plugin</artifactId>\n                <executions>\n                    <execution>\n                        <id>copy</id>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>copy-dependencies</goal>\n                        </goals>\n                        <configuration>\n                            <outputDirectory>${project.build.directory}/lib</outputDirectory>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n\n<dependencies>\n        <!--是一个能够将Java bean/map/collection/Java array/xml转换成JSON并且反过来将JSON转换成java对象的类库-->\n        <dependency>\n            <groupId>net.sf.json-lib</groupId>\n            <artifactId>json-lib</artifactId>\n            <version>2.4</version>\n            <classifier>jdk15</classifier>\n        </dependency>\n        <!--Netty包-->\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-all</artifactId>\n            <version>5.0.0.Alpha2</version>\n        </dependency>\n        <!--Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录-->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n</dependencies>\n```\n4. 配置Log4j日志组件\n日志是应用软件中不可缺少的部分，Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录。在apache网站：jakarta.apache.org/log4j 可以免费下载到Log4j最新版本的软件包。\n参考：[最详细的Log4j使用教程](http://www.codeceo.com/article/log4j-usage.html)\n5. 核心NettyCore编写\n    * 常量数据集定义\n``` JAVA\npackage com.zyx.baby.domain;\n\n/**\n * Created by 三金Sir on 2017/3/19.\n */\npublic class Constant {\n\n    public static final String ENCODING=\"UTF-8\";\n\n\n    public static final String CLIENT_SERVER=\"JAVASERVER\";\n    //not used\n    public static final String CLIENT_IOS_SECRET =\"BABY_IOS\";\n    public static final String CLIENT_ANDROID_SECRET =\"BABY_ANDROID\";\n    public static final String CLIENT_HARDWARE=\"BABY_HARDWARE\";\n\n    public enum Type{\n        SERVER_CONNECT(1000), //Java client connect\n        LOGIN(2000),\n        LOGINOUT(2001),\n        RECONNECT(1020), // app client reconnect\n        SUCCESS_AWARE(4000), // notify client the operation is apply successful.\n        INTERNAL_ERROR(4001), // middleware error\n        DATA_ERROR(4002); // json data parse error\n\n        public int value;\n\n        Type(int value){\n            this.value = value;\n        }\n\n        public int value() {\n            return value;\n        }\n\n        public static Type parse(int value){\n            switch (value){\n                case 1000:\n                    return SERVER_CONNECT;\n                case 2000:\n                    return LOGIN;\n                case 2001:\n                    return LOGINOUT;\n                case 4000:\n                    return SUCCESS_AWARE;\n                case 4001:\n                    return INTERNAL_ERROR;\n                case 1020:\n                    return RECONNECT;\n                default:\n                    return DATA_ERROR;\n            }\n        }\n\n    }\n\n}\n\n```\n知识点 Java 枚举enum\n        - 在实际编程中，往往存在着这样的“数据集”，它们的数值在程序中是稳定的，而且“数据集”中的元素是有限的。\n        - 例如星期一到星期日七个数据元素组成了一周的“数据集”，春夏秋冬四个数据元素组成了四季的“数据集”。\n        - 在Java中如何更好的使用这些“数据集”呢？因此枚举便派上了用场，以下代码详细介绍了枚举的用法。\n        #### 参考 ：\n    [Java 枚举enum 使用详解](http://blog.csdn.net/zcback1/article/details/51014229?locationNum=4&fps=1).</br>[java enum(枚举)使用详解 + 总结](http://blog.csdn.net/zhushuai1221/article/details/51775811?locationNum=7&fps=1).\n* 数据格式定义\n``` JAVA\npackage com.zyx.baby.domain;\n\nimport io.netty.buffer.ByteBuf;\nimport net.sf.json.JSONObject;\n\nimport java.nio.charset.Charset;\n\n/**\n * Created by 三金Sir on 2017/3/19.\n */\npublic class DataPacket {\n    private Constant.Type type;\n    // SERVER、BLUETOOTH、WIFI\n    private String from = \"SERVER\";\n    private String to=\"\";\n    private String data = \"\";\n\n    public DataPacket(Constant.Type type,String data){\n        this.type = type;\n        this.from = \"SERVER\";\n        this.data = data;\n    }\n\n    public DataPacket(String to){\n        this.type = Constant.Type.SUCCESS_AWARE;\n        this.from = \"SERVER\";\n        this.to = to;\n        this.data = \"\";\n    }\n\n    public DataPacket(Constant.Type type,  String to, String data) {\n        this.type = type;\n        this.to = to;\n        this.data = data;\n    }\n\n    public DataPacket(Constant.Type type, String from, String to, String data) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.data = data;\n    }\n\n    // Getter&Setter begin\n\n    public Constant.Type getType() {\n        return type;\n    }\n\n    public void setType(Constant.Type type) {\n        this.type = type;\n    }\n\n    public String getFrom() {\n        return from;\n    }\n\n    public void setFrom(String from) {\n        this.from = from;\n    }\n\n    public String getTo() {\n        return to;\n    }\n\n    public void setTo(String to) {\n        this.to = to;\n    }\n\n    public String getData() {\n        return data;\n    }\n\n    public void setData(String data) {\n        this.data = data;\n    }\n\n    // Getter&Setter end\n\n    public static DataPacket parse(Object object){\n        ByteBuf receive = (ByteBuf)object;\n        JSONObject json=JSONObject.fromObject(receive.toString(Charset.forName(Constant.ENCODING)));\n        receive.release();\n        return new DataPacket(Constant.Type.parse(json.getInt(\"type\")),json.getString(\"from\"),json.getString(\"to\"),json.getString(\"data\"));\n    }\n\n    @Override\n    public String toString() {\n        return \"{\" +\n                \"\\\"type\\\":\" + type.value() +\n                \", \\\"from\\\":\\\"\" + from + '\"' +\n                \", \\\"to\\\":\\\"\" + to + '\"' +\n                \", \\\"data\\\":\\\"\" + data + '\"' +\n                '}';\n    }\n}\n```\n知识点：netty中ByteBuf部分\n[netty中ByteBuf部分的分析](http://www.tuicool.com/articles/FFb6Zr)\n[Netty之ByteBuf](http://blog.csdn.net/alex_bean/article/details/51251015?locationNum=1&fps=1)\n[ Netty中的ByteBuf原理分析]http://blog.csdn.net/u012832964/article/details/50899511\n* 配置拦截器，连接设备身份认证\n    过程：\n        - verify = 设备标识字段+时间戳\n        - MD5加密后与客户端发送code匹配\n        - 成功,返回标识字段;否则null,Access denied\n```JAVA\npackage com.zyx.baby.interceptor;\n\n\nimport com.zyx.baby.domain.Constant;\nimport com.zyx.baby.domain.DataPacket;\nimport com.zyx.baby.utils.Util;\nimport io.netty.channel.ChannelHandlerContext;\n\nimport static org.apache.log4j.Logger.*;\n\n/**\n * 连接设备拦截器\n * Created by 三金Sir on 2017/3/19.\n */\npublic class Interceptor {\n    private static final org.apache.log4j.Logger log = getLogger(Interceptor.class);\n\n    public static String authIntercept(DataPacket pkt, ChannelHandlerContext ctx){\n        String secret = Constant.CLIENT_SERVER;\n        try {\n            String[] data = pkt.getData().split(\"&\");\n            String code = data[0];\n            String timestamp = data[1];\n\n            String verify;\n            if(pkt.getType() == Constant.Type.SERVER_CONNECT)\n                verify = Constant.CLIENT_SERVER + timestamp;\n            else\n                verify = Constant.CLIENT_HARDWARE + timestamp;\n\n            String validateCode = Util.md5(verify);\n\n            boolean isLogin = pkt.getType() == Constant.Type.LOGIN || pkt.getType() == Constant.Type.RECONNECT;\n\n            if(isLogin && !code.equals(validateCode)){\n                verify = Constant.CLIENT_HARDWARE + timestamp;\n                validateCode = Util.md5(verify);\n                secret = Constant.CLIENT_HARDWARE;\n            }\n\n            if(isLogin && !code.equals(validateCode)){\n                verify = Constant.CLIENT_ANDROID_SECRET + timestamp;\n                validateCode = Util.md5(verify);\n                secret = Constant.CLIENT_ANDROID_SECRET;\n            }\n\n            if(isLogin && !code.equals(validateCode)){\n                verify = Constant.CLIENT_IOS_SECRET + timestamp;\n                validateCode = Util.md5(verify);\n                secret = Constant.CLIENT_IOS_SECRET;\n            }\n\n            if (!code.equals(validateCode)) {\n//                SystemService.sendMessage(new DataPacket(Constant.Type.DATA_ERROR, \"Access denied.\"), ctx);\n                ctx.close();\n                log.warn(\"[ socket interceptor ] Access denied.\");\n                return null;\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n\n        return secret;\n    }\n\n}\n```\n未完待续~~~\n\n","source":"_posts/Netty项目实践（一）.md","raw":"---\ntitle: Netty项目实践（一）\ndate: 2017-03-19 22:14:45\ntags: [Netty,JAVA]\ncategory: \"项目实践\"\n---\n### 为什么要学\n需要要做一个中间件，接受由硬件通过wifi和手机反复传递过来的数据（温湿度），然后再通过中间件将数据写入数据库。由于数据是时时接收的，所以用普通的http请求难以完全实现，所以考虑建立长链接实现功能。</br>\n#### Netty的使用场景非常吻合：\n* 构建高性能、低时延的各种Java中间件，例如MQ、分布式服务框架、ESB消息总线等，Netty主要作为基础通信框架提供高性能、低时延的通信服务；\n* 公有或者私有协议栈的基础通信框架，例如可以基于Netty构建异步、高性能的WebSocket协议栈；\n* 各领域应用，例如大数据、游戏等，Netty作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。\n#### 参考:\n[通俗地讲，Netty 能做什么？](https://www.zhihu.com/question/24322387)\n[Netty那些不得不说的事](http://www.kuqin.com/shuoit/20150709/346994.html);\n[Netty系列之Netty高性能之道](http://www.infoq.com/cn/articles/netty-high-performance/)\n### 学习过程\n1. 创建Maven 项目BabyNetty\n```\n <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.zyx.baby</groupId>\n    <artifactId>BabyNetty</artifactId>\n    <packaging>pom</packaging>\n    <version>1.0-SNAPSHOT</version>\n```\nGroupID:是项目组织唯一的标识符，实际对应JAVA的包的结构，是main目录里java的目录结构。\nArtifactID:就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。\n\n2. 创建两个模块JavaClient，NettyCore\nJavaClient:打算用于对服务器的一些数据请求\nNettyCore：数据接收，分发处理\n3. 依赖jar和插件\n```\n<!--“打包“这个词听起来比较土，比较正式的说法应该是”构建项目软件包“，具体说就是将项目中的各种文件，\n比如源代码、编译生成的字节码、配置文件、文档，按照规范的格式生成归档，最常见的当然就是JAR包和WAR包了，-->\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <configuration>\n                    <archive>\n                        <manifest>\n                            <addClasspath>true</addClasspath>\n                            <classpathPrefix>lib/</classpathPrefix>\n                            <mainClass>org.origin.netty.Start</mainClass>\n                        </manifest>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-dependency-plugin</artifactId>\n                <executions>\n                    <execution>\n                        <id>copy</id>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>copy-dependencies</goal>\n                        </goals>\n                        <configuration>\n                            <outputDirectory>${project.build.directory}/lib</outputDirectory>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n\n<dependencies>\n        <!--是一个能够将Java bean/map/collection/Java array/xml转换成JSON并且反过来将JSON转换成java对象的类库-->\n        <dependency>\n            <groupId>net.sf.json-lib</groupId>\n            <artifactId>json-lib</artifactId>\n            <version>2.4</version>\n            <classifier>jdk15</classifier>\n        </dependency>\n        <!--Netty包-->\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-all</artifactId>\n            <version>5.0.0.Alpha2</version>\n        </dependency>\n        <!--Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录-->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n</dependencies>\n```\n4. 配置Log4j日志组件\n日志是应用软件中不可缺少的部分，Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录。在apache网站：jakarta.apache.org/log4j 可以免费下载到Log4j最新版本的软件包。\n参考：[最详细的Log4j使用教程](http://www.codeceo.com/article/log4j-usage.html)\n5. 核心NettyCore编写\n    * 常量数据集定义\n``` JAVA\npackage com.zyx.baby.domain;\n\n/**\n * Created by 三金Sir on 2017/3/19.\n */\npublic class Constant {\n\n    public static final String ENCODING=\"UTF-8\";\n\n\n    public static final String CLIENT_SERVER=\"JAVASERVER\";\n    //not used\n    public static final String CLIENT_IOS_SECRET =\"BABY_IOS\";\n    public static final String CLIENT_ANDROID_SECRET =\"BABY_ANDROID\";\n    public static final String CLIENT_HARDWARE=\"BABY_HARDWARE\";\n\n    public enum Type{\n        SERVER_CONNECT(1000), //Java client connect\n        LOGIN(2000),\n        LOGINOUT(2001),\n        RECONNECT(1020), // app client reconnect\n        SUCCESS_AWARE(4000), // notify client the operation is apply successful.\n        INTERNAL_ERROR(4001), // middleware error\n        DATA_ERROR(4002); // json data parse error\n\n        public int value;\n\n        Type(int value){\n            this.value = value;\n        }\n\n        public int value() {\n            return value;\n        }\n\n        public static Type parse(int value){\n            switch (value){\n                case 1000:\n                    return SERVER_CONNECT;\n                case 2000:\n                    return LOGIN;\n                case 2001:\n                    return LOGINOUT;\n                case 4000:\n                    return SUCCESS_AWARE;\n                case 4001:\n                    return INTERNAL_ERROR;\n                case 1020:\n                    return RECONNECT;\n                default:\n                    return DATA_ERROR;\n            }\n        }\n\n    }\n\n}\n\n```\n知识点 Java 枚举enum\n        - 在实际编程中，往往存在着这样的“数据集”，它们的数值在程序中是稳定的，而且“数据集”中的元素是有限的。\n        - 例如星期一到星期日七个数据元素组成了一周的“数据集”，春夏秋冬四个数据元素组成了四季的“数据集”。\n        - 在Java中如何更好的使用这些“数据集”呢？因此枚举便派上了用场，以下代码详细介绍了枚举的用法。\n        #### 参考 ：\n    [Java 枚举enum 使用详解](http://blog.csdn.net/zcback1/article/details/51014229?locationNum=4&fps=1).</br>[java enum(枚举)使用详解 + 总结](http://blog.csdn.net/zhushuai1221/article/details/51775811?locationNum=7&fps=1).\n* 数据格式定义\n``` JAVA\npackage com.zyx.baby.domain;\n\nimport io.netty.buffer.ByteBuf;\nimport net.sf.json.JSONObject;\n\nimport java.nio.charset.Charset;\n\n/**\n * Created by 三金Sir on 2017/3/19.\n */\npublic class DataPacket {\n    private Constant.Type type;\n    // SERVER、BLUETOOTH、WIFI\n    private String from = \"SERVER\";\n    private String to=\"\";\n    private String data = \"\";\n\n    public DataPacket(Constant.Type type,String data){\n        this.type = type;\n        this.from = \"SERVER\";\n        this.data = data;\n    }\n\n    public DataPacket(String to){\n        this.type = Constant.Type.SUCCESS_AWARE;\n        this.from = \"SERVER\";\n        this.to = to;\n        this.data = \"\";\n    }\n\n    public DataPacket(Constant.Type type,  String to, String data) {\n        this.type = type;\n        this.to = to;\n        this.data = data;\n    }\n\n    public DataPacket(Constant.Type type, String from, String to, String data) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.data = data;\n    }\n\n    // Getter&Setter begin\n\n    public Constant.Type getType() {\n        return type;\n    }\n\n    public void setType(Constant.Type type) {\n        this.type = type;\n    }\n\n    public String getFrom() {\n        return from;\n    }\n\n    public void setFrom(String from) {\n        this.from = from;\n    }\n\n    public String getTo() {\n        return to;\n    }\n\n    public void setTo(String to) {\n        this.to = to;\n    }\n\n    public String getData() {\n        return data;\n    }\n\n    public void setData(String data) {\n        this.data = data;\n    }\n\n    // Getter&Setter end\n\n    public static DataPacket parse(Object object){\n        ByteBuf receive = (ByteBuf)object;\n        JSONObject json=JSONObject.fromObject(receive.toString(Charset.forName(Constant.ENCODING)));\n        receive.release();\n        return new DataPacket(Constant.Type.parse(json.getInt(\"type\")),json.getString(\"from\"),json.getString(\"to\"),json.getString(\"data\"));\n    }\n\n    @Override\n    public String toString() {\n        return \"{\" +\n                \"\\\"type\\\":\" + type.value() +\n                \", \\\"from\\\":\\\"\" + from + '\"' +\n                \", \\\"to\\\":\\\"\" + to + '\"' +\n                \", \\\"data\\\":\\\"\" + data + '\"' +\n                '}';\n    }\n}\n```\n知识点：netty中ByteBuf部分\n[netty中ByteBuf部分的分析](http://www.tuicool.com/articles/FFb6Zr)\n[Netty之ByteBuf](http://blog.csdn.net/alex_bean/article/details/51251015?locationNum=1&fps=1)\n[ Netty中的ByteBuf原理分析]http://blog.csdn.net/u012832964/article/details/50899511\n* 配置拦截器，连接设备身份认证\n    过程：\n        - verify = 设备标识字段+时间戳\n        - MD5加密后与客户端发送code匹配\n        - 成功,返回标识字段;否则null,Access denied\n```JAVA\npackage com.zyx.baby.interceptor;\n\n\nimport com.zyx.baby.domain.Constant;\nimport com.zyx.baby.domain.DataPacket;\nimport com.zyx.baby.utils.Util;\nimport io.netty.channel.ChannelHandlerContext;\n\nimport static org.apache.log4j.Logger.*;\n\n/**\n * 连接设备拦截器\n * Created by 三金Sir on 2017/3/19.\n */\npublic class Interceptor {\n    private static final org.apache.log4j.Logger log = getLogger(Interceptor.class);\n\n    public static String authIntercept(DataPacket pkt, ChannelHandlerContext ctx){\n        String secret = Constant.CLIENT_SERVER;\n        try {\n            String[] data = pkt.getData().split(\"&\");\n            String code = data[0];\n            String timestamp = data[1];\n\n            String verify;\n            if(pkt.getType() == Constant.Type.SERVER_CONNECT)\n                verify = Constant.CLIENT_SERVER + timestamp;\n            else\n                verify = Constant.CLIENT_HARDWARE + timestamp;\n\n            String validateCode = Util.md5(verify);\n\n            boolean isLogin = pkt.getType() == Constant.Type.LOGIN || pkt.getType() == Constant.Type.RECONNECT;\n\n            if(isLogin && !code.equals(validateCode)){\n                verify = Constant.CLIENT_HARDWARE + timestamp;\n                validateCode = Util.md5(verify);\n                secret = Constant.CLIENT_HARDWARE;\n            }\n\n            if(isLogin && !code.equals(validateCode)){\n                verify = Constant.CLIENT_ANDROID_SECRET + timestamp;\n                validateCode = Util.md5(verify);\n                secret = Constant.CLIENT_ANDROID_SECRET;\n            }\n\n            if(isLogin && !code.equals(validateCode)){\n                verify = Constant.CLIENT_IOS_SECRET + timestamp;\n                validateCode = Util.md5(verify);\n                secret = Constant.CLIENT_IOS_SECRET;\n            }\n\n            if (!code.equals(validateCode)) {\n//                SystemService.sendMessage(new DataPacket(Constant.Type.DATA_ERROR, \"Access denied.\"), ctx);\n                ctx.close();\n                log.warn(\"[ socket interceptor ] Access denied.\");\n                return null;\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n\n        return secret;\n    }\n\n}\n```\n未完待续~~~\n\n","slug":"Netty项目实践（一）","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeo800059xs6nbojpzed","content":"<h3 id=\"为什么要学\"><a href=\"#为什么要学\" class=\"headerlink\" title=\"为什么要学\"></a>为什么要学</h3><p>需要要做一个中间件，接受由硬件通过wifi和手机反复传递过来的数据（温湿度），然后再通过中间件将数据写入数据库。由于数据是时时接收的，所以用普通的http请求难以完全实现，所以考虑建立长链接实现功能。<br></p>\n<h4 id=\"Netty的使用场景非常吻合：\"><a href=\"#Netty的使用场景非常吻合：\" class=\"headerlink\" title=\"Netty的使用场景非常吻合：\"></a>Netty的使用场景非常吻合：</h4><ul>\n<li>构建高性能、低时延的各种Java中间件，例如MQ、分布式服务框架、ESB消息总线等，Netty主要作为基础通信框架提供高性能、低时延的通信服务；</li>\n<li>公有或者私有协议栈的基础通信框架，例如可以基于Netty构建异步、高性能的WebSocket协议栈；</li>\n<li>各领域应用，例如大数据、游戏等，Netty作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考:\"></a>参考:</h4><a href=\"https://www.zhihu.com/question/24322387\" target=\"_blank\" rel=\"external\">通俗地讲，Netty 能做什么？</a><br><a href=\"http://www.kuqin.com/shuoit/20150709/346994.html\" target=\"_blank\" rel=\"external\">Netty那些不得不说的事</a>;<br><a href=\"http://www.infoq.com/cn/articles/netty-high-performance/\" target=\"_blank\" rel=\"external\">Netty系列之Netty高性能之道</a><h3 id=\"学习过程\"><a href=\"#学习过程\" class=\"headerlink\" title=\"学习过程\"></a>学习过程</h3></li>\n</ul>\n<ol>\n<li>创建Maven 项目BabyNetty<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;groupId&gt;com.zyx.baby&lt;/groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;BabyNetty&lt;/artifactId&gt;</span><br><span class=\"line\">   &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class=\"line\">   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>GroupID:是项目组织唯一的标识符，实际对应JAVA的包的结构，是main目录里java的目录结构。<br>ArtifactID:就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。</p>\n<ol>\n<li>创建两个模块JavaClient，NettyCore<br>JavaClient:打算用于对服务器的一些数据请求<br>NettyCore：数据接收，分发处理</li>\n<li><p>依赖jar和插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--“打包“这个词听起来比较土，比较正式的说法应该是”构建项目软件包“，具体说就是将项目中的各种文件，</span><br><span class=\"line\">比如源代码、编译生成的字节码、配置文件、文档，按照规范的格式生成归档，最常见的当然就是JAR包和WAR包了，--&gt;</span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">        &lt;plugins&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;archive&gt;</span><br><span class=\"line\">                        &lt;manifest&gt;</span><br><span class=\"line\">                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;</span><br><span class=\"line\">                            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;</span><br><span class=\"line\">                            &lt;mainClass&gt;org.origin.netty.Start&lt;/mainClass&gt;</span><br><span class=\"line\">                        &lt;/manifest&gt;</span><br><span class=\"line\">                    &lt;/archive&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;executions&gt;</span><br><span class=\"line\">                    &lt;execution&gt;</span><br><span class=\"line\">                        &lt;id&gt;copy&lt;/id&gt;</span><br><span class=\"line\">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class=\"line\">                        &lt;goals&gt;</span><br><span class=\"line\">                            &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class=\"line\">                        &lt;/goals&gt;</span><br><span class=\"line\">                        &lt;configuration&gt;</span><br><span class=\"line\">                            &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt;</span><br><span class=\"line\">                        &lt;/configuration&gt;</span><br><span class=\"line\">                    &lt;/execution&gt;</span><br><span class=\"line\">                &lt;/executions&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">        &lt;!--是一个能够将Java bean/map/collection/Java array/xml转换成JSON并且反过来将JSON转换成java对象的类库--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;json-lib&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;2.4&lt;/version&gt;</span><br><span class=\"line\">            &lt;classifier&gt;jdk15&lt;/classifier&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;!--Netty包--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;5.0.0.Alpha2&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;!--Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置Log4j日志组件<br>日志是应用软件中不可缺少的部分，Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录。在apache网站：jakarta.apache.org/log4j 可以免费下载到Log4j最新版本的软件包。<br>参考：<a href=\"http://www.codeceo.com/article/log4j-usage.html\" target=\"_blank\" rel=\"external\">最详细的Log4j使用教程</a></p>\n</li>\n<li>核心NettyCore编写<ul>\n<li>常量数据集定义<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zyx.baby.domain;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by 三金Sir on 2017/3/19.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Constant</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ENCODING=<span class=\"string\">\"UTF-8\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLIENT_SERVER=<span class=\"string\">\"JAVASERVER\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">//not used</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLIENT_IOS_SECRET =<span class=\"string\">\"BABY_IOS\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLIENT_ANDROID_SECRET =<span class=\"string\">\"BABY_ANDROID\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLIENT_HARDWARE=<span class=\"string\">\"BABY_HARDWARE\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Type&#123;</span><br><span class=\"line\">        SERVER_CONNECT(<span class=\"number\">1000</span>), <span class=\"comment\">//Java client connect</span></span><br><span class=\"line\">        LOGIN(<span class=\"number\">2000</span>),</span><br><span class=\"line\">        LOGINOUT(<span class=\"number\">2001</span>),</span><br><span class=\"line\">        RECONNECT(<span class=\"number\">1020</span>), <span class=\"comment\">// app client reconnect</span></span><br><span class=\"line\">        SUCCESS_AWARE(<span class=\"number\">4000</span>), <span class=\"comment\">// notify client the operation is apply successful.</span></span><br><span class=\"line\">        INTERNAL_ERROR(<span class=\"number\">4001</span>), <span class=\"comment\">// middleware error</span></span><br><span class=\"line\">        DATA_ERROR(<span class=\"number\">4002</span>); <span class=\"comment\">// json data parse error</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">        Type(<span class=\"keyword\">int</span> value)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title\">parse</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (value)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1000</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> SERVER_CONNECT;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2000</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> LOGIN;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2001</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> LOGINOUT;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">4000</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> SUCCESS_AWARE;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">4001</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> INTERNAL_ERROR;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1020</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> RECONNECT;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> DATA_ERROR;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p>知识点 Java 枚举enum</p>\n<pre><code>    - 在实际编程中，往往存在着这样的“数据集”，它们的数值在程序中是稳定的，而且“数据集”中的元素是有限的。\n    - 例如星期一到星期日七个数据元素组成了一周的“数据集”，春夏秋冬四个数据元素组成了四季的“数据集”。\n    - 在Java中如何更好的使用这些“数据集”呢？因此枚举便派上了用场，以下代码详细介绍了枚举的用法。\n    #### 参考 ：\n[Java 枚举enum 使用详解](http://blog.csdn.net/zcback1/article/details/51014229?locationNum=4&amp;fps=1).&lt;/br&gt;[java enum(枚举)使用详解 + 总结](http://blog.csdn.net/zhushuai1221/article/details/51775811?locationNum=7&amp;fps=1).\n</code></pre><ul>\n<li>数据格式定义<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zyx.baby.domain;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.json.JSONObject;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.Charset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by 三金Sir on 2017/3/19.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataPacket</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Constant.Type type;</span><br><span class=\"line\">    <span class=\"comment\">// SERVER、BLUETOOTH、WIFI</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String from = <span class=\"string\">\"SERVER\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String to=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String data = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DataPacket</span><span class=\"params\">(Constant.Type type,String data)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.from = <span class=\"string\">\"SERVER\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DataPacket</span><span class=\"params\">(String to)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = Constant.Type.SUCCESS_AWARE;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.from = <span class=\"string\">\"SERVER\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.to = to;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DataPacket</span><span class=\"params\">(Constant.Type type,  String to, String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.to = to;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DataPacket</span><span class=\"params\">(Constant.Type type, String from, String to, String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.from = from;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.to = to;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Getter&amp;Setter begin</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Constant.<span class=\"function\">Type <span class=\"title\">getType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setType</span><span class=\"params\">(Constant.Type type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFrom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFrom</span><span class=\"params\">(String from)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.from = from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> to;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTo</span><span class=\"params\">(String to)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.to = to;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setData</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Getter&amp;Setter end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DataPacket <span class=\"title\">parse</span><span class=\"params\">(Object object)</span></span>&#123;</span><br><span class=\"line\">        ByteBuf receive = (ByteBuf)object;</span><br><span class=\"line\">        JSONObject json=JSONObject.fromObject(receive.toString(Charset.forName(Constant.ENCODING)));</span><br><span class=\"line\">        receive.release();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataPacket(Constant.Type.parse(json.getInt(<span class=\"string\">\"type\"</span>)),json.getString(<span class=\"string\">\"from\"</span>),json.getString(<span class=\"string\">\"to\"</span>),json.getString(<span class=\"string\">\"data\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"\\\"type\\\":\"</span> + type.value() +</span><br><span class=\"line\">                <span class=\"string\">\", \\\"from\\\":\\\"\"</span> + from + <span class=\"string\">'\"'</span> +</span><br><span class=\"line\">                <span class=\"string\">\", \\\"to\\\":\\\"\"</span> + to + <span class=\"string\">'\"'</span> +</span><br><span class=\"line\">                <span class=\"string\">\", \\\"data\\\":\\\"\"</span> + data + <span class=\"string\">'\"'</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>知识点：netty中ByteBuf部分<br><a href=\"http://www.tuicool.com/articles/FFb6Zr\" target=\"_blank\" rel=\"external\">netty中ByteBuf部分的分析</a><br><a href=\"http://blog.csdn.net/alex_bean/article/details/51251015?locationNum=1&amp;fps=1\" target=\"_blank\" rel=\"external\">Netty之ByteBuf</a><br>[ Netty中的ByteBuf原理分析]<a href=\"http://blog.csdn.net/u012832964/article/details/50899511\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u012832964/article/details/50899511</a></p>\n<ul>\n<li>配置拦截器，连接设备身份认证<br>  过程：<pre><code>- verify = 设备标识字段+时间戳\n- MD5加密后与客户端发送code匹配\n- 成功,返回标识字段;否则null,Access denied\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zyx.baby.interceptor;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.zyx.baby.domain.Constant;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.zyx.baby.domain.DataPacket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.zyx.baby.utils.Util;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.log4j.Logger.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 连接设备拦截器</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by 三金Sir on 2017/3/19.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Interceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> org.apache.log4j.Logger log = getLogger(Interceptor.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">authIntercept</span><span class=\"params\">(DataPacket pkt, ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class=\"line\">        String secret = Constant.CLIENT_SERVER;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String[] data = pkt.getData().split(<span class=\"string\">\"&amp;\"</span>);</span><br><span class=\"line\">            String code = data[<span class=\"number\">0</span>];</span><br><span class=\"line\">            String timestamp = data[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">            String verify;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pkt.getType() == Constant.Type.SERVER_CONNECT)</span><br><span class=\"line\">                verify = Constant.CLIENT_SERVER + timestamp;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                verify = Constant.CLIENT_HARDWARE + timestamp;</span><br><span class=\"line\"></span><br><span class=\"line\">            String validateCode = Util.md5(verify);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isLogin = pkt.getType() == Constant.Type.LOGIN || pkt.getType() == Constant.Type.RECONNECT;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isLogin &amp;&amp; !code.equals(validateCode))&#123;</span><br><span class=\"line\">                verify = Constant.CLIENT_HARDWARE + timestamp;</span><br><span class=\"line\">                validateCode = Util.md5(verify);</span><br><span class=\"line\">                secret = Constant.CLIENT_HARDWARE;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isLogin &amp;&amp; !code.equals(validateCode))&#123;</span><br><span class=\"line\">                verify = Constant.CLIENT_ANDROID_SECRET + timestamp;</span><br><span class=\"line\">                validateCode = Util.md5(verify);</span><br><span class=\"line\">                secret = Constant.CLIENT_ANDROID_SECRET;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isLogin &amp;&amp; !code.equals(validateCode))&#123;</span><br><span class=\"line\">                verify = Constant.CLIENT_IOS_SECRET + timestamp;</span><br><span class=\"line\">                validateCode = Util.md5(verify);</span><br><span class=\"line\">                secret = Constant.CLIENT_IOS_SECRET;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!code.equals(validateCode)) &#123;</span><br><span class=\"line\"><span class=\"comment\">//                SystemService.sendMessage(new DataPacket(Constant.Type.DATA_ERROR, \"Access denied.\"), ctx);</span></span><br><span class=\"line\">                ctx.close();</span><br><span class=\"line\">                log.warn(<span class=\"string\">\"[ socket interceptor ] Access denied.\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> secret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>未完待续~~~</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么要学\"><a href=\"#为什么要学\" class=\"headerlink\" title=\"为什么要学\"></a>为什么要学</h3><p>需要要做一个中间件，接受由硬件通过wifi和手机反复传递过来的数据（温湿度），然后再通过中间件将数据写入数据库。由于数据是时时接收的，所以用普通的http请求难以完全实现，所以考虑建立长链接实现功能。<br></p>\n<h4 id=\"Netty的使用场景非常吻合：\"><a href=\"#Netty的使用场景非常吻合：\" class=\"headerlink\" title=\"Netty的使用场景非常吻合：\"></a>Netty的使用场景非常吻合：</h4><ul>\n<li>构建高性能、低时延的各种Java中间件，例如MQ、分布式服务框架、ESB消息总线等，Netty主要作为基础通信框架提供高性能、低时延的通信服务；</li>\n<li>公有或者私有协议栈的基础通信框架，例如可以基于Netty构建异步、高性能的WebSocket协议栈；</li>\n<li>各领域应用，例如大数据、游戏等，Netty作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考:\"></a>参考:</h4><a href=\"https://www.zhihu.com/question/24322387\" target=\"_blank\" rel=\"external\">通俗地讲，Netty 能做什么？</a><br><a href=\"http://www.kuqin.com/shuoit/20150709/346994.html\" target=\"_blank\" rel=\"external\">Netty那些不得不说的事</a>;<br><a href=\"http://www.infoq.com/cn/articles/netty-high-performance/\" target=\"_blank\" rel=\"external\">Netty系列之Netty高性能之道</a><h3 id=\"学习过程\"><a href=\"#学习过程\" class=\"headerlink\" title=\"学习过程\"></a>学习过程</h3></li>\n</ul>\n<ol>\n<li>创建Maven 项目BabyNetty<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;groupId&gt;com.zyx.baby&lt;/groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;BabyNetty&lt;/artifactId&gt;</span><br><span class=\"line\">   &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class=\"line\">   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>GroupID:是项目组织唯一的标识符，实际对应JAVA的包的结构，是main目录里java的目录结构。<br>ArtifactID:就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。</p>\n<ol>\n<li>创建两个模块JavaClient，NettyCore<br>JavaClient:打算用于对服务器的一些数据请求<br>NettyCore：数据接收，分发处理</li>\n<li><p>依赖jar和插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--“打包“这个词听起来比较土，比较正式的说法应该是”构建项目软件包“，具体说就是将项目中的各种文件，</span><br><span class=\"line\">比如源代码、编译生成的字节码、配置文件、文档，按照规范的格式生成归档，最常见的当然就是JAR包和WAR包了，--&gt;</span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">        &lt;plugins&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;archive&gt;</span><br><span class=\"line\">                        &lt;manifest&gt;</span><br><span class=\"line\">                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;</span><br><span class=\"line\">                            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;</span><br><span class=\"line\">                            &lt;mainClass&gt;org.origin.netty.Start&lt;/mainClass&gt;</span><br><span class=\"line\">                        &lt;/manifest&gt;</span><br><span class=\"line\">                    &lt;/archive&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;executions&gt;</span><br><span class=\"line\">                    &lt;execution&gt;</span><br><span class=\"line\">                        &lt;id&gt;copy&lt;/id&gt;</span><br><span class=\"line\">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class=\"line\">                        &lt;goals&gt;</span><br><span class=\"line\">                            &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class=\"line\">                        &lt;/goals&gt;</span><br><span class=\"line\">                        &lt;configuration&gt;</span><br><span class=\"line\">                            &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt;</span><br><span class=\"line\">                        &lt;/configuration&gt;</span><br><span class=\"line\">                    &lt;/execution&gt;</span><br><span class=\"line\">                &lt;/executions&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">        &lt;!--是一个能够将Java bean/map/collection/Java array/xml转换成JSON并且反过来将JSON转换成java对象的类库--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;json-lib&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;2.4&lt;/version&gt;</span><br><span class=\"line\">            &lt;classifier&gt;jdk15&lt;/classifier&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;!--Netty包--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;5.0.0.Alpha2&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;!--Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置Log4j日志组件<br>日志是应用软件中不可缺少的部分，Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录。在apache网站：jakarta.apache.org/log4j 可以免费下载到Log4j最新版本的软件包。<br>参考：<a href=\"http://www.codeceo.com/article/log4j-usage.html\" target=\"_blank\" rel=\"external\">最详细的Log4j使用教程</a></p>\n</li>\n<li>核心NettyCore编写<ul>\n<li>常量数据集定义<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zyx.baby.domain;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by 三金Sir on 2017/3/19.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Constant</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ENCODING=<span class=\"string\">\"UTF-8\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLIENT_SERVER=<span class=\"string\">\"JAVASERVER\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">//not used</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLIENT_IOS_SECRET =<span class=\"string\">\"BABY_IOS\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLIENT_ANDROID_SECRET =<span class=\"string\">\"BABY_ANDROID\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLIENT_HARDWARE=<span class=\"string\">\"BABY_HARDWARE\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Type&#123;</span><br><span class=\"line\">        SERVER_CONNECT(<span class=\"number\">1000</span>), <span class=\"comment\">//Java client connect</span></span><br><span class=\"line\">        LOGIN(<span class=\"number\">2000</span>),</span><br><span class=\"line\">        LOGINOUT(<span class=\"number\">2001</span>),</span><br><span class=\"line\">        RECONNECT(<span class=\"number\">1020</span>), <span class=\"comment\">// app client reconnect</span></span><br><span class=\"line\">        SUCCESS_AWARE(<span class=\"number\">4000</span>), <span class=\"comment\">// notify client the operation is apply successful.</span></span><br><span class=\"line\">        INTERNAL_ERROR(<span class=\"number\">4001</span>), <span class=\"comment\">// middleware error</span></span><br><span class=\"line\">        DATA_ERROR(<span class=\"number\">4002</span>); <span class=\"comment\">// json data parse error</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">        Type(<span class=\"keyword\">int</span> value)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Type <span class=\"title\">parse</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (value)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1000</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> SERVER_CONNECT;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2000</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> LOGIN;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2001</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> LOGINOUT;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">4000</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> SUCCESS_AWARE;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">4001</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> INTERNAL_ERROR;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1020</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> RECONNECT;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> DATA_ERROR;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p>知识点 Java 枚举enum</p>\n<pre><code>    - 在实际编程中，往往存在着这样的“数据集”，它们的数值在程序中是稳定的，而且“数据集”中的元素是有限的。\n    - 例如星期一到星期日七个数据元素组成了一周的“数据集”，春夏秋冬四个数据元素组成了四季的“数据集”。\n    - 在Java中如何更好的使用这些“数据集”呢？因此枚举便派上了用场，以下代码详细介绍了枚举的用法。\n    #### 参考 ：\n[Java 枚举enum 使用详解](http://blog.csdn.net/zcback1/article/details/51014229?locationNum=4&amp;fps=1).&lt;/br&gt;[java enum(枚举)使用详解 + 总结](http://blog.csdn.net/zhushuai1221/article/details/51775811?locationNum=7&amp;fps=1).\n</code></pre><ul>\n<li>数据格式定义<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zyx.baby.domain;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.json.JSONObject;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.Charset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by 三金Sir on 2017/3/19.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataPacket</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Constant.Type type;</span><br><span class=\"line\">    <span class=\"comment\">// SERVER、BLUETOOTH、WIFI</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String from = <span class=\"string\">\"SERVER\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String to=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String data = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DataPacket</span><span class=\"params\">(Constant.Type type,String data)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.from = <span class=\"string\">\"SERVER\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DataPacket</span><span class=\"params\">(String to)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = Constant.Type.SUCCESS_AWARE;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.from = <span class=\"string\">\"SERVER\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.to = to;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DataPacket</span><span class=\"params\">(Constant.Type type,  String to, String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.to = to;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DataPacket</span><span class=\"params\">(Constant.Type type, String from, String to, String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.from = from;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.to = to;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Getter&amp;Setter begin</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Constant.<span class=\"function\">Type <span class=\"title\">getType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setType</span><span class=\"params\">(Constant.Type type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFrom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFrom</span><span class=\"params\">(String from)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.from = from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> to;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTo</span><span class=\"params\">(String to)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.to = to;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setData</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Getter&amp;Setter end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DataPacket <span class=\"title\">parse</span><span class=\"params\">(Object object)</span></span>&#123;</span><br><span class=\"line\">        ByteBuf receive = (ByteBuf)object;</span><br><span class=\"line\">        JSONObject json=JSONObject.fromObject(receive.toString(Charset.forName(Constant.ENCODING)));</span><br><span class=\"line\">        receive.release();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataPacket(Constant.Type.parse(json.getInt(<span class=\"string\">\"type\"</span>)),json.getString(<span class=\"string\">\"from\"</span>),json.getString(<span class=\"string\">\"to\"</span>),json.getString(<span class=\"string\">\"data\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"\\\"type\\\":\"</span> + type.value() +</span><br><span class=\"line\">                <span class=\"string\">\", \\\"from\\\":\\\"\"</span> + from + <span class=\"string\">'\"'</span> +</span><br><span class=\"line\">                <span class=\"string\">\", \\\"to\\\":\\\"\"</span> + to + <span class=\"string\">'\"'</span> +</span><br><span class=\"line\">                <span class=\"string\">\", \\\"data\\\":\\\"\"</span> + data + <span class=\"string\">'\"'</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>知识点：netty中ByteBuf部分<br><a href=\"http://www.tuicool.com/articles/FFb6Zr\" target=\"_blank\" rel=\"external\">netty中ByteBuf部分的分析</a><br><a href=\"http://blog.csdn.net/alex_bean/article/details/51251015?locationNum=1&amp;fps=1\" target=\"_blank\" rel=\"external\">Netty之ByteBuf</a><br>[ Netty中的ByteBuf原理分析]<a href=\"http://blog.csdn.net/u012832964/article/details/50899511\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u012832964/article/details/50899511</a></p>\n<ul>\n<li>配置拦截器，连接设备身份认证<br>  过程：<pre><code>- verify = 设备标识字段+时间戳\n- MD5加密后与客户端发送code匹配\n- 成功,返回标识字段;否则null,Access denied\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zyx.baby.interceptor;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.zyx.baby.domain.Constant;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.zyx.baby.domain.DataPacket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.zyx.baby.utils.Util;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.log4j.Logger.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 连接设备拦截器</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by 三金Sir on 2017/3/19.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Interceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> org.apache.log4j.Logger log = getLogger(Interceptor.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">authIntercept</span><span class=\"params\">(DataPacket pkt, ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class=\"line\">        String secret = Constant.CLIENT_SERVER;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String[] data = pkt.getData().split(<span class=\"string\">\"&amp;\"</span>);</span><br><span class=\"line\">            String code = data[<span class=\"number\">0</span>];</span><br><span class=\"line\">            String timestamp = data[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">            String verify;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pkt.getType() == Constant.Type.SERVER_CONNECT)</span><br><span class=\"line\">                verify = Constant.CLIENT_SERVER + timestamp;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                verify = Constant.CLIENT_HARDWARE + timestamp;</span><br><span class=\"line\"></span><br><span class=\"line\">            String validateCode = Util.md5(verify);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isLogin = pkt.getType() == Constant.Type.LOGIN || pkt.getType() == Constant.Type.RECONNECT;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isLogin &amp;&amp; !code.equals(validateCode))&#123;</span><br><span class=\"line\">                verify = Constant.CLIENT_HARDWARE + timestamp;</span><br><span class=\"line\">                validateCode = Util.md5(verify);</span><br><span class=\"line\">                secret = Constant.CLIENT_HARDWARE;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isLogin &amp;&amp; !code.equals(validateCode))&#123;</span><br><span class=\"line\">                verify = Constant.CLIENT_ANDROID_SECRET + timestamp;</span><br><span class=\"line\">                validateCode = Util.md5(verify);</span><br><span class=\"line\">                secret = Constant.CLIENT_ANDROID_SECRET;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isLogin &amp;&amp; !code.equals(validateCode))&#123;</span><br><span class=\"line\">                verify = Constant.CLIENT_IOS_SECRET + timestamp;</span><br><span class=\"line\">                validateCode = Util.md5(verify);</span><br><span class=\"line\">                secret = Constant.CLIENT_IOS_SECRET;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!code.equals(validateCode)) &#123;</span><br><span class=\"line\"><span class=\"comment\">//                SystemService.sendMessage(new DataPacket(Constant.Type.DATA_ERROR, \"Access denied.\"), ctx);</span></span><br><span class=\"line\">                ctx.close();</span><br><span class=\"line\">                log.warn(<span class=\"string\">\"[ socket interceptor ] Access denied.\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> secret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>未完待续~~~</p>\n"},{"title":"Teach you to recognize MVC, MVP and MVVM","date":"2017-03-26T08:12:29.000Z","_content":"### Teach you to recognize MVC, MVP AND MVVM\nI believe we are no stranger to MVC, MVP and MVVM, as the three most familiar Android framework. Their applications can be very extensive, but for some novice, it can be difficult to distinguish between them three.\n### Article focus:\n1. Learn and distinguish between MVC, MVP and MVVM.\n2. Know how these three models in the use of Android.\n3. Out of the DataBinding errors.\n4. Understand the development model of MVP data binding.\n\n### MVC \nMVC means Model View Controller, is the most common framework in the software architecture, simply through the control of controller to operate the modle layer of data, and return to view layer display.\n\n![Alt text](http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvc.png \"Optional title\")\n\nUse the traditional MVC, which View, corresponding to a variety of layout files, but these layout files are not as powerful as the Web Side, can do very limited. Controller correspods to the Activity, but Activity has the function of operating UI. We in the actual project will hava a lot of UI operations, and also do a lot of View should be dong in the layer\n\nMVC there is an important flaw, we look at the picture above, view layer and the model layer is mutual konw, which means that there is coupling between the two layers. The Coupling is very fatal for large program, beacuse it means that development, testing, maintenance need to spend a lot of energy.\n\n### MVP\nMVP as MVC evolution, to solve a lot of MVC shortcommings. For Android, MVP model layer relative to the MVC is the same, but activity and fragment is no longer the controller layer, but the pure view layer.And all fordwarding of user events is handled by the presenter layer.\n![Alt text](http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvp.png \"Optional title\")\n\nIt can be seen from the figure that the most obvious difference is that the view and model layer are no longer mutual konw and complete descoupling. Instead of the precenter layer acts as bridge, the events used to manipulate the view layer are passed to the presenter layer, the presenter layer to mainpulate the model layer, and the data is returned to the view layer. the view layer and the model layer are completely unconnected throughout the process.\n\n### MVVM\nMVVM最早是由微软提出的\n![Alt text](http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvvm.png \"Optional title\")\n\nFrom the figure to see that it is similiar to MVP, but the presenter layer \nbe replaced by ViewModel layer. And the view layer and the viewmodel are bound to each other, the means that when you update the data of the viewmodel layer, the view layer changes accordingly ui. \n\n### Last: MVP + Databinding\nWe use the data binding framework to save similar findViewById and data binding time, and the use of presenter to separate the business logic and view layer.","source":"_posts/Teach-you-to-recognize-MVCMVPMVVM.md","raw":"---\ntitle: Teach you to recognize MVC, MVP and MVVM\ndate: 2017-03-26 16:12:29\ntags: [模式、Android]\ncategory: \"总结\"\n---\n### Teach you to recognize MVC, MVP AND MVVM\nI believe we are no stranger to MVC, MVP and MVVM, as the three most familiar Android framework. Their applications can be very extensive, but for some novice, it can be difficult to distinguish between them three.\n### Article focus:\n1. Learn and distinguish between MVC, MVP and MVVM.\n2. Know how these three models in the use of Android.\n3. Out of the DataBinding errors.\n4. Understand the development model of MVP data binding.\n\n### MVC \nMVC means Model View Controller, is the most common framework in the software architecture, simply through the control of controller to operate the modle layer of data, and return to view layer display.\n\n![Alt text](http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvc.png \"Optional title\")\n\nUse the traditional MVC, which View, corresponding to a variety of layout files, but these layout files are not as powerful as the Web Side, can do very limited. Controller correspods to the Activity, but Activity has the function of operating UI. We in the actual project will hava a lot of UI operations, and also do a lot of View should be dong in the layer\n\nMVC there is an important flaw, we look at the picture above, view layer and the model layer is mutual konw, which means that there is coupling between the two layers. The Coupling is very fatal for large program, beacuse it means that development, testing, maintenance need to spend a lot of energy.\n\n### MVP\nMVP as MVC evolution, to solve a lot of MVC shortcommings. For Android, MVP model layer relative to the MVC is the same, but activity and fragment is no longer the controller layer, but the pure view layer.And all fordwarding of user events is handled by the presenter layer.\n![Alt text](http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvp.png \"Optional title\")\n\nIt can be seen from the figure that the most obvious difference is that the view and model layer are no longer mutual konw and complete descoupling. Instead of the precenter layer acts as bridge, the events used to manipulate the view layer are passed to the presenter layer, the presenter layer to mainpulate the model layer, and the data is returned to the view layer. the view layer and the model layer are completely unconnected throughout the process.\n\n### MVVM\nMVVM最早是由微软提出的\n![Alt text](http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvvm.png \"Optional title\")\n\nFrom the figure to see that it is similiar to MVP, but the presenter layer \nbe replaced by ViewModel layer. And the view layer and the viewmodel are bound to each other, the means that when you update the data of the viewmodel layer, the view layer changes accordingly ui. \n\n### Last: MVP + Databinding\nWe use the data binding framework to save similar findViewById and data binding time, and the use of presenter to separate the business logic and view layer.","slug":"Teach-you-to-recognize-MVCMVPMVVM","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeo900079xs67kp0a51m","content":"<h3 id=\"Teach-you-to-recognize-MVC-MVP-AND-MVVM\"><a href=\"#Teach-you-to-recognize-MVC-MVP-AND-MVVM\" class=\"headerlink\" title=\"Teach you to recognize MVC, MVP AND MVVM\"></a>Teach you to recognize MVC, MVP AND MVVM</h3><p>I believe we are no stranger to MVC, MVP and MVVM, as the three most familiar Android framework. Their applications can be very extensive, but for some novice, it can be difficult to distinguish between them three.</p>\n<h3 id=\"Article-focus\"><a href=\"#Article-focus\" class=\"headerlink\" title=\"Article focus:\"></a>Article focus:</h3><ol>\n<li>Learn and distinguish between MVC, MVP and MVVM.</li>\n<li>Know how these three models in the use of Android.</li>\n<li>Out of the DataBinding errors.</li>\n<li>Understand the development model of MVP data binding.</li>\n</ol>\n<h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>MVC means Model View Controller, is the most common framework in the software architecture, simply through the control of controller to operate the modle layer of data, and return to view layer display.</p>\n<p><img src=\"http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvc.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>Use the traditional MVC, which View, corresponding to a variety of layout files, but these layout files are not as powerful as the Web Side, can do very limited. Controller correspods to the Activity, but Activity has the function of operating UI. We in the actual project will hava a lot of UI operations, and also do a lot of View should be dong in the layer</p>\n<p>MVC there is an important flaw, we look at the picture above, view layer and the model layer is mutual konw, which means that there is coupling between the two layers. The Coupling is very fatal for large program, beacuse it means that development, testing, maintenance need to spend a lot of energy.</p>\n<h3 id=\"MVP\"><a href=\"#MVP\" class=\"headerlink\" title=\"MVP\"></a>MVP</h3><p>MVP as MVC evolution, to solve a lot of MVC shortcommings. For Android, MVP model layer relative to the MVC is the same, but activity and fragment is no longer the controller layer, but the pure view layer.And all fordwarding of user events is handled by the presenter layer.<br><img src=\"http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvp.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>It can be seen from the figure that the most obvious difference is that the view and model layer are no longer mutual konw and complete descoupling. Instead of the precenter layer acts as bridge, the events used to manipulate the view layer are passed to the presenter layer, the presenter layer to mainpulate the model layer, and the data is returned to the view layer. the view layer and the model layer are completely unconnected throughout the process.</p>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p>MVVM最早是由微软提出的<br><img src=\"http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvvm.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>From the figure to see that it is similiar to MVP, but the presenter layer<br>be replaced by ViewModel layer. And the view layer and the viewmodel are bound to each other, the means that when you update the data of the viewmodel layer, the view layer changes accordingly ui. </p>\n<h3 id=\"Last-MVP-Databinding\"><a href=\"#Last-MVP-Databinding\" class=\"headerlink\" title=\"Last: MVP + Databinding\"></a>Last: MVP + Databinding</h3><p>We use the data binding framework to save similar findViewById and data binding time, and the use of presenter to separate the business logic and view layer.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Teach-you-to-recognize-MVC-MVP-AND-MVVM\"><a href=\"#Teach-you-to-recognize-MVC-MVP-AND-MVVM\" class=\"headerlink\" title=\"Teach you to recognize MVC, MVP AND MVVM\"></a>Teach you to recognize MVC, MVP AND MVVM</h3><p>I believe we are no stranger to MVC, MVP and MVVM, as the three most familiar Android framework. Their applications can be very extensive, but for some novice, it can be difficult to distinguish between them three.</p>\n<h3 id=\"Article-focus\"><a href=\"#Article-focus\" class=\"headerlink\" title=\"Article focus:\"></a>Article focus:</h3><ol>\n<li>Learn and distinguish between MVC, MVP and MVVM.</li>\n<li>Know how these three models in the use of Android.</li>\n<li>Out of the DataBinding errors.</li>\n<li>Understand the development model of MVP data binding.</li>\n</ol>\n<h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>MVC means Model View Controller, is the most common framework in the software architecture, simply through the control of controller to operate the modle layer of data, and return to view layer display.</p>\n<p><img src=\"http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvc.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>Use the traditional MVC, which View, corresponding to a variety of layout files, but these layout files are not as powerful as the Web Side, can do very limited. Controller correspods to the Activity, but Activity has the function of operating UI. We in the actual project will hava a lot of UI operations, and also do a lot of View should be dong in the layer</p>\n<p>MVC there is an important flaw, we look at the picture above, view layer and the model layer is mutual konw, which means that there is coupling between the two layers. The Coupling is very fatal for large program, beacuse it means that development, testing, maintenance need to spend a lot of energy.</p>\n<h3 id=\"MVP\"><a href=\"#MVP\" class=\"headerlink\" title=\"MVP\"></a>MVP</h3><p>MVP as MVC evolution, to solve a lot of MVC shortcommings. For Android, MVP model layer relative to the MVC is the same, but activity and fragment is no longer the controller layer, but the pure view layer.And all fordwarding of user events is handled by the presenter layer.<br><img src=\"http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvp.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>It can be seen from the figure that the most obvious difference is that the view and model layer are no longer mutual konw and complete descoupling. Instead of the precenter layer acts as bridge, the events used to manipulate the view layer are passed to the presenter layer, the presenter layer to mainpulate the model layer, and the data is returned to the view layer. the view layer and the model layer are completely unconnected throughout the process.</p>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p>MVVM最早是由微软提出的<br><img src=\"http://zjutkz.net/images/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC-MVP%E5%92%8CMVVM/mvvm.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>From the figure to see that it is similiar to MVP, but the presenter layer<br>be replaced by ViewModel layer. And the view layer and the viewmodel are bound to each other, the means that when you update the data of the viewmodel layer, the view layer changes accordingly ui. </p>\n<h3 id=\"Last-MVP-Databinding\"><a href=\"#Last-MVP-Databinding\" class=\"headerlink\" title=\"Last: MVP + Databinding\"></a>Last: MVP + Databinding</h3><p>We use the data binding framework to save similar findViewById and data binding time, and the use of presenter to separate the business logic and view layer.</p>\n"},{"title":"Subline3下的两款Markdown插件","date":"2017-03-18T14:38:01.000Z","_content":"### MarkdownEditing\n#### MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。\n1. 安装插件\n安装插件之前，我们需要首先安装一个Sublime 中最不可缺少的插件 Package Control, 以后我们安装和管理插件都需要这个插件的帮助。\n2. 安装\"Package Control\"\n使用快捷键 \" ctrl + `\" 打开Sublime的控制台 ,或者选择 View > Show Console \n在控制台的命令行输入框，把下面一段代码粘贴进去，回车 就可以完成Pacakge Control 的安装了。\n```\nimport urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n3. 安装MarkdownEditing\nPackage Control 安装成功后我们就可以使用它方便的管理插件了，首先使用快捷键 'command + shift + p ' 进入到Sublime 命令面板，输入 \"package install\" 从列表中选择 \"install Package\" 然后回车。这时候Sublime开始请求远程插件仓库的索引，所以第一次使用可能会有一些小的延时。\n![Alt text](http://upload-images.jianshu.io/upload_images/222358-bee1d25963b27ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 \"Optional title\")\n看到列表的更新之后输入 \"markdown ed\" 关键字，选择“MarkdownEditing\" 回车。 插件安装完毕后需要重新启动Sublime插件才能生效。下面是我使用sublime编辑代码片断的显示效\n![Alt text](http://upload-images.jianshu.io/upload_images/222358-d8421f8682fdd2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 \"Optional title\")\n\n输入 \"mdi + tab\" 会自动插入下面的图片标记\n```\n![Alt text](/path/to/img.jpg \"Optional title\")\n```\n输入 \"mdl + tab\" 会自动生成下面的链接标记\n```\n[](link)\n```\n### Markdown Preview 插件\n#### Mardown Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。\n 1. 安装\n通过按组合键Ctrl+Shift+P或是点击Preference->Package Control调出命令面板，然后再输入 install，选择 Package Control: install package。 \n![Alt text](http://img.blog.csdn.net/20160424184816763 \"Optional title\")\n在插件安装面板输入markdown找到Markdown Preview并点击安装即可。\n![Alt text](http://img.blog.csdn.net/20160424211042612 \"Optional title\")\n 2. 使用\n通过按组合键Ctrl+Shift+P或是点击Preference->Package Control调出命令面板，输入mdp，下图中红框圈出的就是在浏览器中预览markdown文件。 \n![Alt text](http://img.blog.csdn.net/20160424211409258 \"Optional title\")\n选中后，你将见到两个选项：GitHub和Mardown。GitHub选项意味着使用GitHub的在线API来解析.md文件。它的解析速度取决于你的联网速度。据称有每天60次访问的限制。[2]但能免费获得GFM格式的语法支持和EMOJI表情的支持。\n另外一个常用功能是图中第五个，Export HTML in Sublime Text，即导出html文件到sublime text。\n 3. 快捷键设置\nSublime Text支持自定义快捷键，markdown preview默认没有快捷键，我们可以自己为preview in browser设置快捷键。方法是在Preferences -> Key Bindings User打开的文件的中括号中添加以下代码(可在Key Bindings Default找到格式)：\n\n```\n{ \"keys\": [\"alt+m\"], \"command\": \"markdown_preview\", \"args\": {\"target\": \"browser\", \"parser\":\"markdown\"}  }\n```\n###### 这里： \n\"alt+m\"可设置为自己喜欢的按键。 \n\"parser\":\"markdown\"也可设置为\"parser\":\"github\"，改为使用Github在线API解析markdown。\n","source":"_posts/Subline3下的两款Markdown插件.md","raw":"---\ntitle: Subline3下的两款Markdown插件\ndate: 2017-03-18 22:38:01\ncategory: \"辅助工具\" \ntags: [Subline,Markdown]\n---\n### MarkdownEditing\n#### MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。\n1. 安装插件\n安装插件之前，我们需要首先安装一个Sublime 中最不可缺少的插件 Package Control, 以后我们安装和管理插件都需要这个插件的帮助。\n2. 安装\"Package Control\"\n使用快捷键 \" ctrl + `\" 打开Sublime的控制台 ,或者选择 View > Show Console \n在控制台的命令行输入框，把下面一段代码粘贴进去，回车 就可以完成Pacakge Control 的安装了。\n```\nimport urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n3. 安装MarkdownEditing\nPackage Control 安装成功后我们就可以使用它方便的管理插件了，首先使用快捷键 'command + shift + p ' 进入到Sublime 命令面板，输入 \"package install\" 从列表中选择 \"install Package\" 然后回车。这时候Sublime开始请求远程插件仓库的索引，所以第一次使用可能会有一些小的延时。\n![Alt text](http://upload-images.jianshu.io/upload_images/222358-bee1d25963b27ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 \"Optional title\")\n看到列表的更新之后输入 \"markdown ed\" 关键字，选择“MarkdownEditing\" 回车。 插件安装完毕后需要重新启动Sublime插件才能生效。下面是我使用sublime编辑代码片断的显示效\n![Alt text](http://upload-images.jianshu.io/upload_images/222358-d8421f8682fdd2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 \"Optional title\")\n\n输入 \"mdi + tab\" 会自动插入下面的图片标记\n```\n![Alt text](/path/to/img.jpg \"Optional title\")\n```\n输入 \"mdl + tab\" 会自动生成下面的链接标记\n```\n[](link)\n```\n### Markdown Preview 插件\n#### Mardown Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。\n 1. 安装\n通过按组合键Ctrl+Shift+P或是点击Preference->Package Control调出命令面板，然后再输入 install，选择 Package Control: install package。 \n![Alt text](http://img.blog.csdn.net/20160424184816763 \"Optional title\")\n在插件安装面板输入markdown找到Markdown Preview并点击安装即可。\n![Alt text](http://img.blog.csdn.net/20160424211042612 \"Optional title\")\n 2. 使用\n通过按组合键Ctrl+Shift+P或是点击Preference->Package Control调出命令面板，输入mdp，下图中红框圈出的就是在浏览器中预览markdown文件。 \n![Alt text](http://img.blog.csdn.net/20160424211409258 \"Optional title\")\n选中后，你将见到两个选项：GitHub和Mardown。GitHub选项意味着使用GitHub的在线API来解析.md文件。它的解析速度取决于你的联网速度。据称有每天60次访问的限制。[2]但能免费获得GFM格式的语法支持和EMOJI表情的支持。\n另外一个常用功能是图中第五个，Export HTML in Sublime Text，即导出html文件到sublime text。\n 3. 快捷键设置\nSublime Text支持自定义快捷键，markdown preview默认没有快捷键，我们可以自己为preview in browser设置快捷键。方法是在Preferences -> Key Bindings User打开的文件的中括号中添加以下代码(可在Key Bindings Default找到格式)：\n\n```\n{ \"keys\": [\"alt+m\"], \"command\": \"markdown_preview\", \"args\": {\"target\": \"browser\", \"parser\":\"markdown\"}  }\n```\n###### 这里： \n\"alt+m\"可设置为自己喜欢的按键。 \n\"parser\":\"markdown\"也可设置为\"parser\":\"github\"，改为使用Github在线API解析markdown。\n","slug":"Subline3下的两款Markdown插件","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeoa00089xs6hz9khy9z","content":"<h3 id=\"MarkdownEditing\"><a href=\"#MarkdownEditing\" class=\"headerlink\" title=\"MarkdownEditing\"></a>MarkdownEditing</h3><h4 id=\"MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。\"><a href=\"#MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。\" class=\"headerlink\" title=\"MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。\"></a>MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。</h4><ol>\n<li>安装插件<br>安装插件之前，我们需要首先安装一个Sublime 中最不可缺少的插件 Package Control, 以后我们安装和管理插件都需要这个插件的帮助。</li>\n<li><p>安装”Package Control”<br>使用快捷键 “ ctrl + `” 打开Sublime的控制台 ,或者选择 View &gt; Show Console<br>在控制台的命令行输入框，把下面一段代码粘贴进去，回车 就可以完成Pacakge Control 的安装了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib.request,os,hashlib; h = &apos;eb2297e1a458f27d836c04bb0cbaf282&apos; + &apos;d0e7a3098092775ccb37ca9d6b2e4b7d&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装MarkdownEditing<br>Package Control 安装成功后我们就可以使用它方便的管理插件了，首先使用快捷键 ‘command + shift + p ‘ 进入到Sublime 命令面板，输入 “package install” 从列表中选择 “install Package” 然后回车。这时候Sublime开始请求远程插件仓库的索引，所以第一次使用可能会有一些小的延时。<br><img src=\"http://upload-images.jianshu.io/upload_images/222358-bee1d25963b27ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Alt text\" title=\"Optional title\"><br>看到列表的更新之后输入 “markdown ed” 关键字，选择“MarkdownEditing” 回车。 插件安装完毕后需要重新启动Sublime插件才能生效。下面是我使用sublime编辑代码片断的显示效<br><img src=\"http://upload-images.jianshu.io/upload_images/222358-d8421f8682fdd2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Alt text\" title=\"Optional title\"></p>\n</li>\n</ol>\n<p>输入 “mdi + tab” 会自动插入下面的图片标记<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>输入 “mdl + tab” 会自动生成下面的链接标记<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](link)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Markdown-Preview-插件\"><a href=\"#Markdown-Preview-插件\" class=\"headerlink\" title=\"Markdown Preview 插件\"></a>Markdown Preview 插件</h3><h4 id=\"Mardown-Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。\"><a href=\"#Mardown-Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。\" class=\"headerlink\" title=\"Mardown Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。\"></a>Mardown Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。</h4><ol>\n<li>安装<br>通过按组合键Ctrl+Shift+P或是点击Preference-&gt;Package Control调出命令面板，然后再输入 install，选择 Package Control: install package。<br><img src=\"http://img.blog.csdn.net/20160424184816763\" alt=\"Alt text\" title=\"Optional title\"><br>在插件安装面板输入markdown找到Markdown Preview并点击安装即可。<br><img src=\"http://img.blog.csdn.net/20160424211042612\" alt=\"Alt text\" title=\"Optional title\"></li>\n<li>使用<br>通过按组合键Ctrl+Shift+P或是点击Preference-&gt;Package Control调出命令面板，输入mdp，下图中红框圈出的就是在浏览器中预览markdown文件。<br><img src=\"http://img.blog.csdn.net/20160424211409258\" alt=\"Alt text\" title=\"Optional title\"><br>选中后，你将见到两个选项：GitHub和Mardown。GitHub选项意味着使用GitHub的在线API来解析.md文件。它的解析速度取决于你的联网速度。据称有每天60次访问的限制。[2]但能免费获得GFM格式的语法支持和EMOJI表情的支持。<br>另外一个常用功能是图中第五个，Export HTML in Sublime Text，即导出html文件到sublime text。</li>\n<li>快捷键设置<br>Sublime Text支持自定义快捷键，markdown preview默认没有快捷键，我们可以自己为preview in browser设置快捷键。方法是在Preferences -&gt; Key Bindings User打开的文件的中括号中添加以下代码(可在Key Bindings Default找到格式)：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;&#125;  &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"这里：\"><a href=\"#这里：\" class=\"headerlink\" title=\"这里：\"></a>这里：</h6><p>“alt+m”可设置为自己喜欢的按键。<br>“parser”:”markdown”也可设置为”parser”:”github”，改为使用Github在线API解析markdown。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"MarkdownEditing\"><a href=\"#MarkdownEditing\" class=\"headerlink\" title=\"MarkdownEditing\"></a>MarkdownEditing</h3><h4 id=\"MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。\"><a href=\"#MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。\" class=\"headerlink\" title=\"MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。\"></a>MarkdownEditing是Markdown写作者必备的插件，它可以不仅可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。</h4><ol>\n<li>安装插件<br>安装插件之前，我们需要首先安装一个Sublime 中最不可缺少的插件 Package Control, 以后我们安装和管理插件都需要这个插件的帮助。</li>\n<li><p>安装”Package Control”<br>使用快捷键 “ ctrl + `” 打开Sublime的控制台 ,或者选择 View &gt; Show Console<br>在控制台的命令行输入框，把下面一段代码粘贴进去，回车 就可以完成Pacakge Control 的安装了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib.request,os,hashlib; h = &apos;eb2297e1a458f27d836c04bb0cbaf282&apos; + &apos;d0e7a3098092775ccb37ca9d6b2e4b7d&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装MarkdownEditing<br>Package Control 安装成功后我们就可以使用它方便的管理插件了，首先使用快捷键 ‘command + shift + p ‘ 进入到Sublime 命令面板，输入 “package install” 从列表中选择 “install Package” 然后回车。这时候Sublime开始请求远程插件仓库的索引，所以第一次使用可能会有一些小的延时。<br><img src=\"http://upload-images.jianshu.io/upload_images/222358-bee1d25963b27ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Alt text\" title=\"Optional title\"><br>看到列表的更新之后输入 “markdown ed” 关键字，选择“MarkdownEditing” 回车。 插件安装完毕后需要重新启动Sublime插件才能生效。下面是我使用sublime编辑代码片断的显示效<br><img src=\"http://upload-images.jianshu.io/upload_images/222358-d8421f8682fdd2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Alt text\" title=\"Optional title\"></p>\n</li>\n</ol>\n<p>输入 “mdi + tab” 会自动插入下面的图片标记<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>输入 “mdl + tab” 会自动生成下面的链接标记<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](link)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Markdown-Preview-插件\"><a href=\"#Markdown-Preview-插件\" class=\"headerlink\" title=\"Markdown Preview 插件\"></a>Markdown Preview 插件</h3><h4 id=\"Mardown-Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。\"><a href=\"#Mardown-Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。\" class=\"headerlink\" title=\"Mardown Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。\"></a>Mardown Preview不仅支持在浏览器中预览markdown文件，还可以导出html代码。</h4><ol>\n<li>安装<br>通过按组合键Ctrl+Shift+P或是点击Preference-&gt;Package Control调出命令面板，然后再输入 install，选择 Package Control: install package。<br><img src=\"http://img.blog.csdn.net/20160424184816763\" alt=\"Alt text\" title=\"Optional title\"><br>在插件安装面板输入markdown找到Markdown Preview并点击安装即可。<br><img src=\"http://img.blog.csdn.net/20160424211042612\" alt=\"Alt text\" title=\"Optional title\"></li>\n<li>使用<br>通过按组合键Ctrl+Shift+P或是点击Preference-&gt;Package Control调出命令面板，输入mdp，下图中红框圈出的就是在浏览器中预览markdown文件。<br><img src=\"http://img.blog.csdn.net/20160424211409258\" alt=\"Alt text\" title=\"Optional title\"><br>选中后，你将见到两个选项：GitHub和Mardown。GitHub选项意味着使用GitHub的在线API来解析.md文件。它的解析速度取决于你的联网速度。据称有每天60次访问的限制。[2]但能免费获得GFM格式的语法支持和EMOJI表情的支持。<br>另外一个常用功能是图中第五个，Export HTML in Sublime Text，即导出html文件到sublime text。</li>\n<li>快捷键设置<br>Sublime Text支持自定义快捷键，markdown preview默认没有快捷键，我们可以自己为preview in browser设置快捷键。方法是在Preferences -&gt; Key Bindings User打开的文件的中括号中添加以下代码(可在Key Bindings Default找到格式)：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;&#125;  &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"这里：\"><a href=\"#这里：\" class=\"headerlink\" title=\"这里：\"></a>这里：</h6><p>“alt+m”可设置为自己喜欢的按键。<br>“parser”:”markdown”也可设置为”parser”:”github”，改为使用Github在线API解析markdown。</p>\n"},{"title":"android系统架构(一)","date":"2017-03-20T10:59:49.000Z","_content":"### 出发点\n&emsp;&emsp;由于在学习Android的时候并没有很系统地进行学习，知识点比较零碎，所以需要将自己的知识点进行系统的整理，那么首要的我需要将android的系统架构搞清楚，这样才能分清楚我所了解的知识点附属于哪个层面，是内核还是应用层，可以进行怎样的扩展，在哪些场景去运用。\n### Android架构解析\n[Google工程师多图详解Android系统架构](http://mobile.51cto.com/android-235496.htm)\n[Android基础之Android系统架构](https://my.oschina.net/fhd/blog/349830)\n[Android维基百科](https://zh.wikipedia.org/wiki/Android#Linux.E6.A0.B8.E5.BF.83)\n[Android对Linux内核的增强](http://tech.it168.com/a2011/0805/1228/000001228471.shtml)\n[Android系统架构详解(2)–Android Runtime](http://www.tuicool.com/articles/EN7nuiN)\n\n以上是我在这个课题下的一些参考博客或者网页链接。里面有对于android架构的一些较好的分析理解，接下来是阅读后自己的一些整理。\n\nAndroid采用层次化系统架构，官方公布的标准架构如下图所示。\n\n![Alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Android-System-Architecture.svg/1000px-Android-System-Architecture.svg.png \"Optional title\")\n\nAndroid由底层往上分为4个主要功能层，分别是Linux内核层（Linux Kernel），系统运行时库层（Libraries和Android Runtime），应用程序架构层（Application Framework）和应用程序层（Applications）。\n\n接下来对这几个层面进行逐个分析：\n\n#### Linux内核层\n\n&emsp;&emsp;Android以Linux操作系统内核为基础，借助Linux内核服务实现硬件设备驱动，进程和内存管理，网络协议栈，电源管理，无线通信等核心功能。Android4.0版本之前基于Linux2.6系列内核，4.0及之后的版本使用更新的Linux3.X内核，并且两个开源项目开始有了互通。Linux3.3内核中正式包括一些Android代码，可以直接引导进入Android。Linux3.4增添了电源管理等更多功能，以增加与Android的硬件兼容性，使Android在更多设备上得到支持。直到现在最新的android6.0仍然继续延用着linux3.4.0，而linux最新的版本已经到了4.3系列，那么为什么android没有继续去更新Linuxkernel的版本也是一个值得探讨的课题。 \n\n&emsp;&emsp;Android内核 对Linux内核进行了增强，增加了一些面向移动计算的特有功能。例如，低内存管理器LMK（Low Memory Keller），匿名共享内存（Ashmem）,以及轻量级的进程间通信Binder机制等。这些内核的增强使Android在继承Linux内核安全机制的同时，进一步提升了内存管理，进程间通信等方面的安全性。\n\n#### 硬件抽象层\n\n&emsp;&emsp;内核驱动和用户软件之间还存在所谓的硬件抽象层（Hardware Abstract Layer,HAL），它是对硬件设备的具体实现加以抽象。HAL没有在Android官方系统架构图中标明，下图标出了硬件抽象层在android系统中的位置：\n\n![Alt text](http://static.oschina.net/uploads/space/2014/1128/125552_hnZu_168814.jpg \"Optional title\")\n\n&emsp;&emsp;鉴于许多硬件设备厂商不希望公开其设备驱动的源代码，如果能将android的应用框架层与linux系统内核的设备驱动隔离，使应用程序框架的开发尽量独立于具体的驱动程序，则android将减少对Linux内核的依赖。HAL由此而生，它是对Linux内核驱动程序进行的封装，将硬件抽象化，屏蔽掉了底层的实现细节。HAL规定了一套应用层对硬件层读写和配置的统一接口，本质上就是将硬件的驱动分为用户空间和内核空间两个层面；Linux内核驱动程序运行于内核空间，硬件抽象层运行于用户空间。\n\n#### 系统运行库层\n&emsp;&emsp;官方的系统架构图中，位于Linux内核层之上的系统运行库层是应用程序框架的支撑，为Android系统中的各个组件提供服务。系统运行库层由系统类库和Android运行时构成。\n\n* 系统类库\n系统类库大部分由C/C++编写，所提供的功能通过Android应用程序框架为开发者所使用。例如SQlite,WebKit,SSL都在会在日常开发中有用到\n\n![Alt text](http://images.51cto.com/files/uploadimg/20101129/1011272.png \"Optional title\")\n\n* 运行时\nAndroid运行时包含核心库和Dalvik虚拟机两部分。\n    - 核心库：核心库提供了Java5 se API的多数功能，并提供Android的核心API，如android.os，android.net，android.media等。\n    - Dalvik虚拟机：Dalvik虚拟机是基于apache的java虚拟机，并被改进以适应低内存，低处理器速度的移动设备环境。Dalvik虚拟机依赖于Linux内核，实现进程隔离与线程调试管理，安全和异常管理，垃圾回收等重要功能。\n    \nDalvik和标准Java虚拟机有以下主要区别：\n\n* Dalvik基于寄存器，而JVM基于栈。一般认为，基于寄存器的实现虽然更多依赖于具体的CPU结构，硬件通用性稍差，但其使用等长指令，在效率速度上较传统JVM更有优势。\n* Dalvik经过优化，允许在有限的内存中同时高效地运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行，都拥有一个独立的Dalvik虚拟机实例。Android这种基于Linux的进程“沙箱”机制，是整个安全设计的基础之一。\n* Dalvik虚拟机从DEX（Dalvik Executable）格式的文件中读取指令与数据，进行解释运行。DEX文件由传统的，编译产生的CLASS文件，经dx工具软件处理后生成。\n* Dalvik的DEX文件还可以进一步优化，提高运行性能。通常，OEM的应用程序可以在系统编译后，直接生成优化文件（.ODEX）； 第三方的应用程序则可在运行时在缓存中优化与保存，优化后的格式为DEY（.dey文件）。\n\n&emsp;&emsp;这部分内容，即从android4.4开始就出现了ART（android runtime），但是这个ART并不是指这一节的主题，而是一种用来代替Dalvik的新型运行环境。当然在4.4的正式环境中用的还是Dalvik，真正开始用ART取代Dalvik是从android5.0开始的。（todo:针对这个改动，楼主会专门另开一个篇幅的文章去探究ART和Dalvik之间的区别）\n\n另外这一节中有提到NDK,相信对于开发者而言SDK和NDK都是必要要接触和了解的东西，那么先从下图来看看sdk和ndk的关系。\n\n![Alt text](http://img.blog.csdn.net/20160107235017221 \"Optional title\")\n\n&emsp;&emsp;很显然地，ndk可以通过native code跨过使用dalvik runtime,直接调用到android内核资源，而sdk则需要在dalvik runtime环境下才能调用到内核资源。然而两者并不是各司其职，各不相关。android提供了JNI(Java native interface)使两者可以进行相互调用和通信。\n\n#### 应用程序框架层\n\n&emsp;&emsp;应用程序框架层提供开发Android应用程序所需的一系列类库，使开发人员可以进行快速的应用程序开发，方便重用组件，也可以通过继承实现个性化的扩展。\n\n![Alt text](http://images.51cto.com/files/uploadimg/20101129/1011271.png \"Optional title\")\n\n#### 应用层\n\n&emsp;&emsp;Android平台的应用层上包括各类与用户直接交互的应用程序，或由java语言编写的运行于后台的服务程序。例如，智能手机上实现的常见基本功能 程序，诸如SMS短信，电话拨号，图片浏览器，日历，游戏，地图，web浏览器等程序，以及开发人员开发的其他应用程序。\n\n&emsp;&emsp;将android的基本架构进行了一个总体的分析和罗列，我们可以发现，平时开发中最常接触和用到的一定是application层，但是我们也不难发现，一些application层应用到的东西都能在系统层找到对应的踪迹，例如sqlite,webkit,甚至alarm。他们是怎么从底层到达application层供我们日常开发所用，这个也是需要去了解和研究的。本篇文章的目的在开篇已经阐述过，是为了能更好地将自己的知识对号入座，并且去补充一些自己在某些层面上缺乏的知识，最终可以将自己的知识形成一个整体的体系结构。\n","source":"_posts/android系统架构-一.md","raw":"---\ntitle: android系统架构(一)\ndate: 2017-03-20 18:59:49\ntags:\n---\n### 出发点\n&emsp;&emsp;由于在学习Android的时候并没有很系统地进行学习，知识点比较零碎，所以需要将自己的知识点进行系统的整理，那么首要的我需要将android的系统架构搞清楚，这样才能分清楚我所了解的知识点附属于哪个层面，是内核还是应用层，可以进行怎样的扩展，在哪些场景去运用。\n### Android架构解析\n[Google工程师多图详解Android系统架构](http://mobile.51cto.com/android-235496.htm)\n[Android基础之Android系统架构](https://my.oschina.net/fhd/blog/349830)\n[Android维基百科](https://zh.wikipedia.org/wiki/Android#Linux.E6.A0.B8.E5.BF.83)\n[Android对Linux内核的增强](http://tech.it168.com/a2011/0805/1228/000001228471.shtml)\n[Android系统架构详解(2)–Android Runtime](http://www.tuicool.com/articles/EN7nuiN)\n\n以上是我在这个课题下的一些参考博客或者网页链接。里面有对于android架构的一些较好的分析理解，接下来是阅读后自己的一些整理。\n\nAndroid采用层次化系统架构，官方公布的标准架构如下图所示。\n\n![Alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Android-System-Architecture.svg/1000px-Android-System-Architecture.svg.png \"Optional title\")\n\nAndroid由底层往上分为4个主要功能层，分别是Linux内核层（Linux Kernel），系统运行时库层（Libraries和Android Runtime），应用程序架构层（Application Framework）和应用程序层（Applications）。\n\n接下来对这几个层面进行逐个分析：\n\n#### Linux内核层\n\n&emsp;&emsp;Android以Linux操作系统内核为基础，借助Linux内核服务实现硬件设备驱动，进程和内存管理，网络协议栈，电源管理，无线通信等核心功能。Android4.0版本之前基于Linux2.6系列内核，4.0及之后的版本使用更新的Linux3.X内核，并且两个开源项目开始有了互通。Linux3.3内核中正式包括一些Android代码，可以直接引导进入Android。Linux3.4增添了电源管理等更多功能，以增加与Android的硬件兼容性，使Android在更多设备上得到支持。直到现在最新的android6.0仍然继续延用着linux3.4.0，而linux最新的版本已经到了4.3系列，那么为什么android没有继续去更新Linuxkernel的版本也是一个值得探讨的课题。 \n\n&emsp;&emsp;Android内核 对Linux内核进行了增强，增加了一些面向移动计算的特有功能。例如，低内存管理器LMK（Low Memory Keller），匿名共享内存（Ashmem）,以及轻量级的进程间通信Binder机制等。这些内核的增强使Android在继承Linux内核安全机制的同时，进一步提升了内存管理，进程间通信等方面的安全性。\n\n#### 硬件抽象层\n\n&emsp;&emsp;内核驱动和用户软件之间还存在所谓的硬件抽象层（Hardware Abstract Layer,HAL），它是对硬件设备的具体实现加以抽象。HAL没有在Android官方系统架构图中标明，下图标出了硬件抽象层在android系统中的位置：\n\n![Alt text](http://static.oschina.net/uploads/space/2014/1128/125552_hnZu_168814.jpg \"Optional title\")\n\n&emsp;&emsp;鉴于许多硬件设备厂商不希望公开其设备驱动的源代码，如果能将android的应用框架层与linux系统内核的设备驱动隔离，使应用程序框架的开发尽量独立于具体的驱动程序，则android将减少对Linux内核的依赖。HAL由此而生，它是对Linux内核驱动程序进行的封装，将硬件抽象化，屏蔽掉了底层的实现细节。HAL规定了一套应用层对硬件层读写和配置的统一接口，本质上就是将硬件的驱动分为用户空间和内核空间两个层面；Linux内核驱动程序运行于内核空间，硬件抽象层运行于用户空间。\n\n#### 系统运行库层\n&emsp;&emsp;官方的系统架构图中，位于Linux内核层之上的系统运行库层是应用程序框架的支撑，为Android系统中的各个组件提供服务。系统运行库层由系统类库和Android运行时构成。\n\n* 系统类库\n系统类库大部分由C/C++编写，所提供的功能通过Android应用程序框架为开发者所使用。例如SQlite,WebKit,SSL都在会在日常开发中有用到\n\n![Alt text](http://images.51cto.com/files/uploadimg/20101129/1011272.png \"Optional title\")\n\n* 运行时\nAndroid运行时包含核心库和Dalvik虚拟机两部分。\n    - 核心库：核心库提供了Java5 se API的多数功能，并提供Android的核心API，如android.os，android.net，android.media等。\n    - Dalvik虚拟机：Dalvik虚拟机是基于apache的java虚拟机，并被改进以适应低内存，低处理器速度的移动设备环境。Dalvik虚拟机依赖于Linux内核，实现进程隔离与线程调试管理，安全和异常管理，垃圾回收等重要功能。\n    \nDalvik和标准Java虚拟机有以下主要区别：\n\n* Dalvik基于寄存器，而JVM基于栈。一般认为，基于寄存器的实现虽然更多依赖于具体的CPU结构，硬件通用性稍差，但其使用等长指令，在效率速度上较传统JVM更有优势。\n* Dalvik经过优化，允许在有限的内存中同时高效地运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行，都拥有一个独立的Dalvik虚拟机实例。Android这种基于Linux的进程“沙箱”机制，是整个安全设计的基础之一。\n* Dalvik虚拟机从DEX（Dalvik Executable）格式的文件中读取指令与数据，进行解释运行。DEX文件由传统的，编译产生的CLASS文件，经dx工具软件处理后生成。\n* Dalvik的DEX文件还可以进一步优化，提高运行性能。通常，OEM的应用程序可以在系统编译后，直接生成优化文件（.ODEX）； 第三方的应用程序则可在运行时在缓存中优化与保存，优化后的格式为DEY（.dey文件）。\n\n&emsp;&emsp;这部分内容，即从android4.4开始就出现了ART（android runtime），但是这个ART并不是指这一节的主题，而是一种用来代替Dalvik的新型运行环境。当然在4.4的正式环境中用的还是Dalvik，真正开始用ART取代Dalvik是从android5.0开始的。（todo:针对这个改动，楼主会专门另开一个篇幅的文章去探究ART和Dalvik之间的区别）\n\n另外这一节中有提到NDK,相信对于开发者而言SDK和NDK都是必要要接触和了解的东西，那么先从下图来看看sdk和ndk的关系。\n\n![Alt text](http://img.blog.csdn.net/20160107235017221 \"Optional title\")\n\n&emsp;&emsp;很显然地，ndk可以通过native code跨过使用dalvik runtime,直接调用到android内核资源，而sdk则需要在dalvik runtime环境下才能调用到内核资源。然而两者并不是各司其职，各不相关。android提供了JNI(Java native interface)使两者可以进行相互调用和通信。\n\n#### 应用程序框架层\n\n&emsp;&emsp;应用程序框架层提供开发Android应用程序所需的一系列类库，使开发人员可以进行快速的应用程序开发，方便重用组件，也可以通过继承实现个性化的扩展。\n\n![Alt text](http://images.51cto.com/files/uploadimg/20101129/1011271.png \"Optional title\")\n\n#### 应用层\n\n&emsp;&emsp;Android平台的应用层上包括各类与用户直接交互的应用程序，或由java语言编写的运行于后台的服务程序。例如，智能手机上实现的常见基本功能 程序，诸如SMS短信，电话拨号，图片浏览器，日历，游戏，地图，web浏览器等程序，以及开发人员开发的其他应用程序。\n\n&emsp;&emsp;将android的基本架构进行了一个总体的分析和罗列，我们可以发现，平时开发中最常接触和用到的一定是application层，但是我们也不难发现，一些application层应用到的东西都能在系统层找到对应的踪迹，例如sqlite,webkit,甚至alarm。他们是怎么从底层到达application层供我们日常开发所用，这个也是需要去了解和研究的。本篇文章的目的在开篇已经阐述过，是为了能更好地将自己的知识对号入座，并且去补充一些自己在某些层面上缺乏的知识，最终可以将自己的知识形成一个整体的体系结构。\n","slug":"android系统架构-一","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeoc000b9xs6khqs9dfz","content":"<h3 id=\"出发点\"><a href=\"#出发点\" class=\"headerlink\" title=\"出发点\"></a>出发点</h3><p>&emsp;&emsp;由于在学习Android的时候并没有很系统地进行学习，知识点比较零碎，所以需要将自己的知识点进行系统的整理，那么首要的我需要将android的系统架构搞清楚，这样才能分清楚我所了解的知识点附属于哪个层面，是内核还是应用层，可以进行怎样的扩展，在哪些场景去运用。</p>\n<h3 id=\"Android架构解析\"><a href=\"#Android架构解析\" class=\"headerlink\" title=\"Android架构解析\"></a>Android架构解析</h3><p><a href=\"http://mobile.51cto.com/android-235496.htm\" target=\"_blank\" rel=\"external\">Google工程师多图详解Android系统架构</a><br><a href=\"https://my.oschina.net/fhd/blog/349830\" target=\"_blank\" rel=\"external\">Android基础之Android系统架构</a><br><a href=\"https://zh.wikipedia.org/wiki/Android#Linux.E6.A0.B8.E5.BF.83\" target=\"_blank\" rel=\"external\">Android维基百科</a><br><a href=\"http://tech.it168.com/a2011/0805/1228/000001228471.shtml\" target=\"_blank\" rel=\"external\">Android对Linux内核的增强</a><br><a href=\"http://www.tuicool.com/articles/EN7nuiN\" target=\"_blank\" rel=\"external\">Android系统架构详解(2)–Android Runtime</a></p>\n<p>以上是我在这个课题下的一些参考博客或者网页链接。里面有对于android架构的一些较好的分析理解，接下来是阅读后自己的一些整理。</p>\n<p>Android采用层次化系统架构，官方公布的标准架构如下图所示。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Android-System-Architecture.svg/1000px-Android-System-Architecture.svg.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>Android由底层往上分为4个主要功能层，分别是Linux内核层（Linux Kernel），系统运行时库层（Libraries和Android Runtime），应用程序架构层（Application Framework）和应用程序层（Applications）。</p>\n<p>接下来对这几个层面进行逐个分析：</p>\n<h4 id=\"Linux内核层\"><a href=\"#Linux内核层\" class=\"headerlink\" title=\"Linux内核层\"></a>Linux内核层</h4><p>&emsp;&emsp;Android以Linux操作系统内核为基础，借助Linux内核服务实现硬件设备驱动，进程和内存管理，网络协议栈，电源管理，无线通信等核心功能。Android4.0版本之前基于Linux2.6系列内核，4.0及之后的版本使用更新的Linux3.X内核，并且两个开源项目开始有了互通。Linux3.3内核中正式包括一些Android代码，可以直接引导进入Android。Linux3.4增添了电源管理等更多功能，以增加与Android的硬件兼容性，使Android在更多设备上得到支持。直到现在最新的android6.0仍然继续延用着linux3.4.0，而linux最新的版本已经到了4.3系列，那么为什么android没有继续去更新Linuxkernel的版本也是一个值得探讨的课题。 </p>\n<p>&emsp;&emsp;Android内核 对Linux内核进行了增强，增加了一些面向移动计算的特有功能。例如，低内存管理器LMK（Low Memory Keller），匿名共享内存（Ashmem）,以及轻量级的进程间通信Binder机制等。这些内核的增强使Android在继承Linux内核安全机制的同时，进一步提升了内存管理，进程间通信等方面的安全性。</p>\n<h4 id=\"硬件抽象层\"><a href=\"#硬件抽象层\" class=\"headerlink\" title=\"硬件抽象层\"></a>硬件抽象层</h4><p>&emsp;&emsp;内核驱动和用户软件之间还存在所谓的硬件抽象层（Hardware Abstract Layer,HAL），它是对硬件设备的具体实现加以抽象。HAL没有在Android官方系统架构图中标明，下图标出了硬件抽象层在android系统中的位置：</p>\n<p><img src=\"http://static.oschina.net/uploads/space/2014/1128/125552_hnZu_168814.jpg\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>&emsp;&emsp;鉴于许多硬件设备厂商不希望公开其设备驱动的源代码，如果能将android的应用框架层与linux系统内核的设备驱动隔离，使应用程序框架的开发尽量独立于具体的驱动程序，则android将减少对Linux内核的依赖。HAL由此而生，它是对Linux内核驱动程序进行的封装，将硬件抽象化，屏蔽掉了底层的实现细节。HAL规定了一套应用层对硬件层读写和配置的统一接口，本质上就是将硬件的驱动分为用户空间和内核空间两个层面；Linux内核驱动程序运行于内核空间，硬件抽象层运行于用户空间。</p>\n<h4 id=\"系统运行库层\"><a href=\"#系统运行库层\" class=\"headerlink\" title=\"系统运行库层\"></a>系统运行库层</h4><p>&emsp;&emsp;官方的系统架构图中，位于Linux内核层之上的系统运行库层是应用程序框架的支撑，为Android系统中的各个组件提供服务。系统运行库层由系统类库和Android运行时构成。</p>\n<ul>\n<li>系统类库<br>系统类库大部分由C/C++编写，所提供的功能通过Android应用程序框架为开发者所使用。例如SQlite,WebKit,SSL都在会在日常开发中有用到</li>\n</ul>\n<p><img src=\"http://images.51cto.com/files/uploadimg/20101129/1011272.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<ul>\n<li>运行时<br>Android运行时包含核心库和Dalvik虚拟机两部分。<ul>\n<li>核心库：核心库提供了Java5 se API的多数功能，并提供Android的核心API，如android.os，android.net，android.media等。</li>\n<li>Dalvik虚拟机：Dalvik虚拟机是基于apache的java虚拟机，并被改进以适应低内存，低处理器速度的移动设备环境。Dalvik虚拟机依赖于Linux内核，实现进程隔离与线程调试管理，安全和异常管理，垃圾回收等重要功能。</li>\n</ul>\n</li>\n</ul>\n<p>Dalvik和标准Java虚拟机有以下主要区别：</p>\n<ul>\n<li>Dalvik基于寄存器，而JVM基于栈。一般认为，基于寄存器的实现虽然更多依赖于具体的CPU结构，硬件通用性稍差，但其使用等长指令，在效率速度上较传统JVM更有优势。</li>\n<li>Dalvik经过优化，允许在有限的内存中同时高效地运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行，都拥有一个独立的Dalvik虚拟机实例。Android这种基于Linux的进程“沙箱”机制，是整个安全设计的基础之一。</li>\n<li>Dalvik虚拟机从DEX（Dalvik Executable）格式的文件中读取指令与数据，进行解释运行。DEX文件由传统的，编译产生的CLASS文件，经dx工具软件处理后生成。</li>\n<li>Dalvik的DEX文件还可以进一步优化，提高运行性能。通常，OEM的应用程序可以在系统编译后，直接生成优化文件（.ODEX）； 第三方的应用程序则可在运行时在缓存中优化与保存，优化后的格式为DEY（.dey文件）。</li>\n</ul>\n<p>&emsp;&emsp;这部分内容，即从android4.4开始就出现了ART（android runtime），但是这个ART并不是指这一节的主题，而是一种用来代替Dalvik的新型运行环境。当然在4.4的正式环境中用的还是Dalvik，真正开始用ART取代Dalvik是从android5.0开始的。（todo:针对这个改动，楼主会专门另开一个篇幅的文章去探究ART和Dalvik之间的区别）</p>\n<p>另外这一节中有提到NDK,相信对于开发者而言SDK和NDK都是必要要接触和了解的东西，那么先从下图来看看sdk和ndk的关系。</p>\n<p><img src=\"http://img.blog.csdn.net/20160107235017221\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>&emsp;&emsp;很显然地，ndk可以通过native code跨过使用dalvik runtime,直接调用到android内核资源，而sdk则需要在dalvik runtime环境下才能调用到内核资源。然而两者并不是各司其职，各不相关。android提供了JNI(Java native interface)使两者可以进行相互调用和通信。</p>\n<h4 id=\"应用程序框架层\"><a href=\"#应用程序框架层\" class=\"headerlink\" title=\"应用程序框架层\"></a>应用程序框架层</h4><p>&emsp;&emsp;应用程序框架层提供开发Android应用程序所需的一系列类库，使开发人员可以进行快速的应用程序开发，方便重用组件，也可以通过继承实现个性化的扩展。</p>\n<p><img src=\"http://images.51cto.com/files/uploadimg/20101129/1011271.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<h4 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h4><p>&emsp;&emsp;Android平台的应用层上包括各类与用户直接交互的应用程序，或由java语言编写的运行于后台的服务程序。例如，智能手机上实现的常见基本功能 程序，诸如SMS短信，电话拨号，图片浏览器，日历，游戏，地图，web浏览器等程序，以及开发人员开发的其他应用程序。</p>\n<p>&emsp;&emsp;将android的基本架构进行了一个总体的分析和罗列，我们可以发现，平时开发中最常接触和用到的一定是application层，但是我们也不难发现，一些application层应用到的东西都能在系统层找到对应的踪迹，例如sqlite,webkit,甚至alarm。他们是怎么从底层到达application层供我们日常开发所用，这个也是需要去了解和研究的。本篇文章的目的在开篇已经阐述过，是为了能更好地将自己的知识对号入座，并且去补充一些自己在某些层面上缺乏的知识，最终可以将自己的知识形成一个整体的体系结构。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"出发点\"><a href=\"#出发点\" class=\"headerlink\" title=\"出发点\"></a>出发点</h3><p>&emsp;&emsp;由于在学习Android的时候并没有很系统地进行学习，知识点比较零碎，所以需要将自己的知识点进行系统的整理，那么首要的我需要将android的系统架构搞清楚，这样才能分清楚我所了解的知识点附属于哪个层面，是内核还是应用层，可以进行怎样的扩展，在哪些场景去运用。</p>\n<h3 id=\"Android架构解析\"><a href=\"#Android架构解析\" class=\"headerlink\" title=\"Android架构解析\"></a>Android架构解析</h3><p><a href=\"http://mobile.51cto.com/android-235496.htm\" target=\"_blank\" rel=\"external\">Google工程师多图详解Android系统架构</a><br><a href=\"https://my.oschina.net/fhd/blog/349830\" target=\"_blank\" rel=\"external\">Android基础之Android系统架构</a><br><a href=\"https://zh.wikipedia.org/wiki/Android#Linux.E6.A0.B8.E5.BF.83\" target=\"_blank\" rel=\"external\">Android维基百科</a><br><a href=\"http://tech.it168.com/a2011/0805/1228/000001228471.shtml\" target=\"_blank\" rel=\"external\">Android对Linux内核的增强</a><br><a href=\"http://www.tuicool.com/articles/EN7nuiN\" target=\"_blank\" rel=\"external\">Android系统架构详解(2)–Android Runtime</a></p>\n<p>以上是我在这个课题下的一些参考博客或者网页链接。里面有对于android架构的一些较好的分析理解，接下来是阅读后自己的一些整理。</p>\n<p>Android采用层次化系统架构，官方公布的标准架构如下图所示。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Android-System-Architecture.svg/1000px-Android-System-Architecture.svg.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>Android由底层往上分为4个主要功能层，分别是Linux内核层（Linux Kernel），系统运行时库层（Libraries和Android Runtime），应用程序架构层（Application Framework）和应用程序层（Applications）。</p>\n<p>接下来对这几个层面进行逐个分析：</p>\n<h4 id=\"Linux内核层\"><a href=\"#Linux内核层\" class=\"headerlink\" title=\"Linux内核层\"></a>Linux内核层</h4><p>&emsp;&emsp;Android以Linux操作系统内核为基础，借助Linux内核服务实现硬件设备驱动，进程和内存管理，网络协议栈，电源管理，无线通信等核心功能。Android4.0版本之前基于Linux2.6系列内核，4.0及之后的版本使用更新的Linux3.X内核，并且两个开源项目开始有了互通。Linux3.3内核中正式包括一些Android代码，可以直接引导进入Android。Linux3.4增添了电源管理等更多功能，以增加与Android的硬件兼容性，使Android在更多设备上得到支持。直到现在最新的android6.0仍然继续延用着linux3.4.0，而linux最新的版本已经到了4.3系列，那么为什么android没有继续去更新Linuxkernel的版本也是一个值得探讨的课题。 </p>\n<p>&emsp;&emsp;Android内核 对Linux内核进行了增强，增加了一些面向移动计算的特有功能。例如，低内存管理器LMK（Low Memory Keller），匿名共享内存（Ashmem）,以及轻量级的进程间通信Binder机制等。这些内核的增强使Android在继承Linux内核安全机制的同时，进一步提升了内存管理，进程间通信等方面的安全性。</p>\n<h4 id=\"硬件抽象层\"><a href=\"#硬件抽象层\" class=\"headerlink\" title=\"硬件抽象层\"></a>硬件抽象层</h4><p>&emsp;&emsp;内核驱动和用户软件之间还存在所谓的硬件抽象层（Hardware Abstract Layer,HAL），它是对硬件设备的具体实现加以抽象。HAL没有在Android官方系统架构图中标明，下图标出了硬件抽象层在android系统中的位置：</p>\n<p><img src=\"http://static.oschina.net/uploads/space/2014/1128/125552_hnZu_168814.jpg\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>&emsp;&emsp;鉴于许多硬件设备厂商不希望公开其设备驱动的源代码，如果能将android的应用框架层与linux系统内核的设备驱动隔离，使应用程序框架的开发尽量独立于具体的驱动程序，则android将减少对Linux内核的依赖。HAL由此而生，它是对Linux内核驱动程序进行的封装，将硬件抽象化，屏蔽掉了底层的实现细节。HAL规定了一套应用层对硬件层读写和配置的统一接口，本质上就是将硬件的驱动分为用户空间和内核空间两个层面；Linux内核驱动程序运行于内核空间，硬件抽象层运行于用户空间。</p>\n<h4 id=\"系统运行库层\"><a href=\"#系统运行库层\" class=\"headerlink\" title=\"系统运行库层\"></a>系统运行库层</h4><p>&emsp;&emsp;官方的系统架构图中，位于Linux内核层之上的系统运行库层是应用程序框架的支撑，为Android系统中的各个组件提供服务。系统运行库层由系统类库和Android运行时构成。</p>\n<ul>\n<li>系统类库<br>系统类库大部分由C/C++编写，所提供的功能通过Android应用程序框架为开发者所使用。例如SQlite,WebKit,SSL都在会在日常开发中有用到</li>\n</ul>\n<p><img src=\"http://images.51cto.com/files/uploadimg/20101129/1011272.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<ul>\n<li>运行时<br>Android运行时包含核心库和Dalvik虚拟机两部分。<ul>\n<li>核心库：核心库提供了Java5 se API的多数功能，并提供Android的核心API，如android.os，android.net，android.media等。</li>\n<li>Dalvik虚拟机：Dalvik虚拟机是基于apache的java虚拟机，并被改进以适应低内存，低处理器速度的移动设备环境。Dalvik虚拟机依赖于Linux内核，实现进程隔离与线程调试管理，安全和异常管理，垃圾回收等重要功能。</li>\n</ul>\n</li>\n</ul>\n<p>Dalvik和标准Java虚拟机有以下主要区别：</p>\n<ul>\n<li>Dalvik基于寄存器，而JVM基于栈。一般认为，基于寄存器的实现虽然更多依赖于具体的CPU结构，硬件通用性稍差，但其使用等长指令，在效率速度上较传统JVM更有优势。</li>\n<li>Dalvik经过优化，允许在有限的内存中同时高效地运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行，都拥有一个独立的Dalvik虚拟机实例。Android这种基于Linux的进程“沙箱”机制，是整个安全设计的基础之一。</li>\n<li>Dalvik虚拟机从DEX（Dalvik Executable）格式的文件中读取指令与数据，进行解释运行。DEX文件由传统的，编译产生的CLASS文件，经dx工具软件处理后生成。</li>\n<li>Dalvik的DEX文件还可以进一步优化，提高运行性能。通常，OEM的应用程序可以在系统编译后，直接生成优化文件（.ODEX）； 第三方的应用程序则可在运行时在缓存中优化与保存，优化后的格式为DEY（.dey文件）。</li>\n</ul>\n<p>&emsp;&emsp;这部分内容，即从android4.4开始就出现了ART（android runtime），但是这个ART并不是指这一节的主题，而是一种用来代替Dalvik的新型运行环境。当然在4.4的正式环境中用的还是Dalvik，真正开始用ART取代Dalvik是从android5.0开始的。（todo:针对这个改动，楼主会专门另开一个篇幅的文章去探究ART和Dalvik之间的区别）</p>\n<p>另外这一节中有提到NDK,相信对于开发者而言SDK和NDK都是必要要接触和了解的东西，那么先从下图来看看sdk和ndk的关系。</p>\n<p><img src=\"http://img.blog.csdn.net/20160107235017221\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>&emsp;&emsp;很显然地，ndk可以通过native code跨过使用dalvik runtime,直接调用到android内核资源，而sdk则需要在dalvik runtime环境下才能调用到内核资源。然而两者并不是各司其职，各不相关。android提供了JNI(Java native interface)使两者可以进行相互调用和通信。</p>\n<h4 id=\"应用程序框架层\"><a href=\"#应用程序框架层\" class=\"headerlink\" title=\"应用程序框架层\"></a>应用程序框架层</h4><p>&emsp;&emsp;应用程序框架层提供开发Android应用程序所需的一系列类库，使开发人员可以进行快速的应用程序开发，方便重用组件，也可以通过继承实现个性化的扩展。</p>\n<p><img src=\"http://images.51cto.com/files/uploadimg/20101129/1011271.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<h4 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h4><p>&emsp;&emsp;Android平台的应用层上包括各类与用户直接交互的应用程序，或由java语言编写的运行于后台的服务程序。例如，智能手机上实现的常见基本功能 程序，诸如SMS短信，电话拨号，图片浏览器，日历，游戏，地图，web浏览器等程序，以及开发人员开发的其他应用程序。</p>\n<p>&emsp;&emsp;将android的基本架构进行了一个总体的分析和罗列，我们可以发现，平时开发中最常接触和用到的一定是application层，但是我们也不难发现，一些application层应用到的东西都能在系统层找到对应的踪迹，例如sqlite,webkit,甚至alarm。他们是怎么从底层到达application层供我们日常开发所用，这个也是需要去了解和研究的。本篇文章的目的在开篇已经阐述过，是为了能更好地将自己的知识对号入座，并且去补充一些自己在某些层面上缺乏的知识，最终可以将自己的知识形成一个整体的体系结构。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-11-08T13:33:29.000Z","updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeoe000d9xs6lcwyd8v9","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n"},{"title":"git相关操作","date":"2017-08-02T14:40:20.000Z","_content":"### 一. git关联本地与远程分支\n\n```\n$ git branch --set-upstream-to=origin/dev2.2 master\nBranch master set up to track remote branch dev2.2 from origin.\n```\n远程分支在前，本地分支在后。\n关联之后就可以正常的pull代码了。\n\n### 二.查看所有分支（本地、远程）\n```\n$ git branch -a\n* master\n  remotes/origin/HEAD -> origin/master\n  remotes/origin/dev\n  remotes/origin/dev2.2\n  remotes/origin/master\n```\n\n### 三.当前关联的远程分支\n```\n$ git branch -vv\n* master beb7725 [origin/dev2.2: behind 1] 首页本地记录上次关闭之前的状态\n```\n\n### 四.git merge 和 git merge --no-ff\n![Alt text](http://img.blog.csdn.net/20150811134840627 \"Optional title\")\n根据这张图片可以看出\nGit merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。\ngit merge 则不会显示 feature，只保留单条分支记录。\n\n### 五.merge 与 rebase 的区别\n1.Git merge 会生成一个新得合并节点，而rebase不会\n比如：\n```\n      D---E test\n     /\nA---B---C---F master\n```\n使用merge合并, 为分支合并自动识别出最佳的同源合并点： git merge master\n```\n      D--------E\n     /          \\\nA---B---C---F----G   test, master\n```\n操作会舍弃 master 分支上提取的 commit，同时不会像 merge 一样生成一个合并修改内容的 commit，相当于把 master 分支（当前所在分支）上的修改在 deve 分支（目标分支）上原样复制了一遍:git rebase test\n```\nA---B---D---E---C'---F'   test, master\n```\n使用git pull时默认是merge， 加 --rebase参数使其使用rebase方式\n```\ngit pull --rebase  \n```\n2.rebase和merge的不同适用场景\n\n**rebase场景：**如果修改了某个公用代码的BUG，这个时候就应该是把所有的OEM版本分支rebase到这个修复BUG的分支上来，在rebase过程中，Git会要你手动解决代码上的冲突，你需要做的就是把修复BUG的代码放到目标分支代码里面去。rebase的结果是：所有的分支依然存在\n\n**merge场景：**因为成员的代码开发工作已经完成了，也不需要再保留这个分支了，所以我们可以把这个成员分支merge到主分支上，当然冲突在所难免，手工解决的工作肯定逃不掉，但是利大于弊不是吗。merge以后，分支就不存在了，但是在git的所有分支历史中还能看到身影。\n\n**一般我们把别的分支合并到master时用merge，而把master合并到别的分支时会用到rebase的原因，这是因为master分支一般commit会比较频繁。**\n\n所以每次下拉代码fetch之后用rebase的原因就是： \n本地commit之后，fetch远端代码，此时，远端代码可能会被若干人修改会有若干个commit，而本地就一个commit，然后git rebase的时候，是默认rebase 远端代码，此时会将本地commit应用到远端代码，也就只需要解决一次冲突，并且rebase之后没有新的commit，很友好。但是，如果使用merge，则会产生新的commit。\n\n### 六.网上推荐的工作流一般是用fetch+rebase (相比pull+merge工作流更干净，不容易出错)\n**比如dev是你的公共开发分支***\n\ngit checkout dev  # 本地切到公共分支 \n\ngit pull              # 将本地的dev更新\n\ngit checkout -b bug_101026  # 新建一个主题分支（一个bug，一个功能什么的）\n... # 改动.. commit.. 测试...\n\ngit fetch origin      # 更新upstream\n\ngit rebase origin/dev  # 将你的commits移到的末尾\n\ngit checkout dev  # 切换到公共分支\n\ngit pull              # 更新公共分支\n\ngit rebase bug_101026  # 将你的主题分支加到公共分支的末尾\n\ngit push               # 推送\n","source":"_posts/git相关操作.md","raw":"---\ntitle: git相关操作\ndate: 2017-08-02 22:40:20\ntags: [git]\ncategory: \"开发工具\"\n---\n### 一. git关联本地与远程分支\n\n```\n$ git branch --set-upstream-to=origin/dev2.2 master\nBranch master set up to track remote branch dev2.2 from origin.\n```\n远程分支在前，本地分支在后。\n关联之后就可以正常的pull代码了。\n\n### 二.查看所有分支（本地、远程）\n```\n$ git branch -a\n* master\n  remotes/origin/HEAD -> origin/master\n  remotes/origin/dev\n  remotes/origin/dev2.2\n  remotes/origin/master\n```\n\n### 三.当前关联的远程分支\n```\n$ git branch -vv\n* master beb7725 [origin/dev2.2: behind 1] 首页本地记录上次关闭之前的状态\n```\n\n### 四.git merge 和 git merge --no-ff\n![Alt text](http://img.blog.csdn.net/20150811134840627 \"Optional title\")\n根据这张图片可以看出\nGit merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。\ngit merge 则不会显示 feature，只保留单条分支记录。\n\n### 五.merge 与 rebase 的区别\n1.Git merge 会生成一个新得合并节点，而rebase不会\n比如：\n```\n      D---E test\n     /\nA---B---C---F master\n```\n使用merge合并, 为分支合并自动识别出最佳的同源合并点： git merge master\n```\n      D--------E\n     /          \\\nA---B---C---F----G   test, master\n```\n操作会舍弃 master 分支上提取的 commit，同时不会像 merge 一样生成一个合并修改内容的 commit，相当于把 master 分支（当前所在分支）上的修改在 deve 分支（目标分支）上原样复制了一遍:git rebase test\n```\nA---B---D---E---C'---F'   test, master\n```\n使用git pull时默认是merge， 加 --rebase参数使其使用rebase方式\n```\ngit pull --rebase  \n```\n2.rebase和merge的不同适用场景\n\n**rebase场景：**如果修改了某个公用代码的BUG，这个时候就应该是把所有的OEM版本分支rebase到这个修复BUG的分支上来，在rebase过程中，Git会要你手动解决代码上的冲突，你需要做的就是把修复BUG的代码放到目标分支代码里面去。rebase的结果是：所有的分支依然存在\n\n**merge场景：**因为成员的代码开发工作已经完成了，也不需要再保留这个分支了，所以我们可以把这个成员分支merge到主分支上，当然冲突在所难免，手工解决的工作肯定逃不掉，但是利大于弊不是吗。merge以后，分支就不存在了，但是在git的所有分支历史中还能看到身影。\n\n**一般我们把别的分支合并到master时用merge，而把master合并到别的分支时会用到rebase的原因，这是因为master分支一般commit会比较频繁。**\n\n所以每次下拉代码fetch之后用rebase的原因就是： \n本地commit之后，fetch远端代码，此时，远端代码可能会被若干人修改会有若干个commit，而本地就一个commit，然后git rebase的时候，是默认rebase 远端代码，此时会将本地commit应用到远端代码，也就只需要解决一次冲突，并且rebase之后没有新的commit，很友好。但是，如果使用merge，则会产生新的commit。\n\n### 六.网上推荐的工作流一般是用fetch+rebase (相比pull+merge工作流更干净，不容易出错)\n**比如dev是你的公共开发分支***\n\ngit checkout dev  # 本地切到公共分支 \n\ngit pull              # 将本地的dev更新\n\ngit checkout -b bug_101026  # 新建一个主题分支（一个bug，一个功能什么的）\n... # 改动.. commit.. 测试...\n\ngit fetch origin      # 更新upstream\n\ngit rebase origin/dev  # 将你的commits移到的末尾\n\ngit checkout dev  # 切换到公共分支\n\ngit pull              # 更新公共分支\n\ngit rebase bug_101026  # 将你的主题分支加到公共分支的末尾\n\ngit push               # 推送\n","slug":"git相关操作","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeog000f9xs6ewy2zkmu","content":"<h3 id=\"一-git关联本地与远程分支\"><a href=\"#一-git关联本地与远程分支\" class=\"headerlink\" title=\"一. git关联本地与远程分支\"></a>一. git关联本地与远程分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --set-upstream-to=origin/dev2.2 master</span><br><span class=\"line\">Branch master set up to track remote branch dev2.2 from origin.</span><br></pre></td></tr></table></figure>\n<p>远程分支在前，本地分支在后。<br>关联之后就可以正常的pull代码了。</p>\n<h3 id=\"二-查看所有分支（本地、远程）\"><a href=\"#二-查看所有分支（本地、远程）\" class=\"headerlink\" title=\"二.查看所有分支（本地、远程）\"></a>二.查看所有分支（本地、远程）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -a</span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/HEAD -&gt; origin/master</span><br><span class=\"line\">  remotes/origin/dev</span><br><span class=\"line\">  remotes/origin/dev2.2</span><br><span class=\"line\">  remotes/origin/master</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-当前关联的远程分支\"><a href=\"#三-当前关联的远程分支\" class=\"headerlink\" title=\"三.当前关联的远程分支\"></a>三.当前关联的远程分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -vv</span><br><span class=\"line\">* master beb7725 [origin/dev2.2: behind 1] 首页本地记录上次关闭之前的状态</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-git-merge-和-git-merge-–no-ff\"><a href=\"#四-git-merge-和-git-merge-–no-ff\" class=\"headerlink\" title=\"四.git merge 和 git merge –no-ff\"></a>四.git merge 和 git merge –no-ff</h3><p><img src=\"http://img.blog.csdn.net/20150811134840627\" alt=\"Alt text\" title=\"Optional title\"><br>根据这张图片可以看出<br>Git merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。<br>git merge 则不会显示 feature，只保留单条分支记录。</p>\n<h3 id=\"五-merge-与-rebase-的区别\"><a href=\"#五-merge-与-rebase-的区别\" class=\"headerlink\" title=\"五.merge 与 rebase 的区别\"></a>五.merge 与 rebase 的区别</h3><p>1.Git merge 会生成一个新得合并节点，而rebase不会<br>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      D---E test</span><br><span class=\"line\">     /</span><br><span class=\"line\">A---B---C---F master</span><br></pre></td></tr></table></figure></p>\n<p>使用merge合并, 为分支合并自动识别出最佳的同源合并点： git merge master<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      D--------E</span><br><span class=\"line\">     /          \\</span><br><span class=\"line\">A---B---C---F----G   test, master</span><br></pre></td></tr></table></figure></p>\n<p>操作会舍弃 master 分支上提取的 commit，同时不会像 merge 一样生成一个合并修改内容的 commit，相当于把 master 分支（当前所在分支）上的修改在 deve 分支（目标分支）上原样复制了一遍:git rebase test<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A---B---D---E---C&apos;---F&apos;   test, master</span><br></pre></td></tr></table></figure></p>\n<p>使用git pull时默认是merge， 加 –rebase参数使其使用rebase方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --rebase</span><br></pre></td></tr></table></figure></p>\n<p>2.rebase和merge的不同适用场景</p>\n<p><strong>rebase场景：</strong>如果修改了某个公用代码的BUG，这个时候就应该是把所有的OEM版本分支rebase到这个修复BUG的分支上来，在rebase过程中，Git会要你手动解决代码上的冲突，你需要做的就是把修复BUG的代码放到目标分支代码里面去。rebase的结果是：所有的分支依然存在</p>\n<p><strong>merge场景：</strong>因为成员的代码开发工作已经完成了，也不需要再保留这个分支了，所以我们可以把这个成员分支merge到主分支上，当然冲突在所难免，手工解决的工作肯定逃不掉，但是利大于弊不是吗。merge以后，分支就不存在了，但是在git的所有分支历史中还能看到身影。</p>\n<p><strong>一般我们把别的分支合并到master时用merge，而把master合并到别的分支时会用到rebase的原因，这是因为master分支一般commit会比较频繁。</strong></p>\n<p>所以每次下拉代码fetch之后用rebase的原因就是：<br>本地commit之后，fetch远端代码，此时，远端代码可能会被若干人修改会有若干个commit，而本地就一个commit，然后git rebase的时候，是默认rebase 远端代码，此时会将本地commit应用到远端代码，也就只需要解决一次冲突，并且rebase之后没有新的commit，很友好。但是，如果使用merge，则会产生新的commit。</p>\n<h3 id=\"六-网上推荐的工作流一般是用fetch-rebase-相比pull-merge工作流更干净，不容易出错\"><a href=\"#六-网上推荐的工作流一般是用fetch-rebase-相比pull-merge工作流更干净，不容易出错\" class=\"headerlink\" title=\"六.网上推荐的工作流一般是用fetch+rebase (相比pull+merge工作流更干净，不容易出错)\"></a>六.网上推荐的工作流一般是用fetch+rebase (相比pull+merge工作流更干净，不容易出错)</h3><p><strong>比如dev是你的公共开发分支*</strong></p>\n<p>git checkout dev  # 本地切到公共分支 </p>\n<p>git pull              # 将本地的dev更新</p>\n<p>git checkout -b bug_101026  # 新建一个主题分支（一个bug，一个功能什么的）<br>… # 改动.. commit.. 测试…</p>\n<p>git fetch origin      # 更新upstream</p>\n<p>git rebase origin/dev  # 将你的commits移到的末尾</p>\n<p>git checkout dev  # 切换到公共分支</p>\n<p>git pull              # 更新公共分支</p>\n<p>git rebase bug_101026  # 将你的主题分支加到公共分支的末尾</p>\n<p>git push               # 推送</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一-git关联本地与远程分支\"><a href=\"#一-git关联本地与远程分支\" class=\"headerlink\" title=\"一. git关联本地与远程分支\"></a>一. git关联本地与远程分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --set-upstream-to=origin/dev2.2 master</span><br><span class=\"line\">Branch master set up to track remote branch dev2.2 from origin.</span><br></pre></td></tr></table></figure>\n<p>远程分支在前，本地分支在后。<br>关联之后就可以正常的pull代码了。</p>\n<h3 id=\"二-查看所有分支（本地、远程）\"><a href=\"#二-查看所有分支（本地、远程）\" class=\"headerlink\" title=\"二.查看所有分支（本地、远程）\"></a>二.查看所有分支（本地、远程）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -a</span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/HEAD -&gt; origin/master</span><br><span class=\"line\">  remotes/origin/dev</span><br><span class=\"line\">  remotes/origin/dev2.2</span><br><span class=\"line\">  remotes/origin/master</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-当前关联的远程分支\"><a href=\"#三-当前关联的远程分支\" class=\"headerlink\" title=\"三.当前关联的远程分支\"></a>三.当前关联的远程分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -vv</span><br><span class=\"line\">* master beb7725 [origin/dev2.2: behind 1] 首页本地记录上次关闭之前的状态</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-git-merge-和-git-merge-–no-ff\"><a href=\"#四-git-merge-和-git-merge-–no-ff\" class=\"headerlink\" title=\"四.git merge 和 git merge –no-ff\"></a>四.git merge 和 git merge –no-ff</h3><p><img src=\"http://img.blog.csdn.net/20150811134840627\" alt=\"Alt text\" title=\"Optional title\"><br>根据这张图片可以看出<br>Git merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。<br>git merge 则不会显示 feature，只保留单条分支记录。</p>\n<h3 id=\"五-merge-与-rebase-的区别\"><a href=\"#五-merge-与-rebase-的区别\" class=\"headerlink\" title=\"五.merge 与 rebase 的区别\"></a>五.merge 与 rebase 的区别</h3><p>1.Git merge 会生成一个新得合并节点，而rebase不会<br>比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      D---E test</span><br><span class=\"line\">     /</span><br><span class=\"line\">A---B---C---F master</span><br></pre></td></tr></table></figure></p>\n<p>使用merge合并, 为分支合并自动识别出最佳的同源合并点： git merge master<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      D--------E</span><br><span class=\"line\">     /          \\</span><br><span class=\"line\">A---B---C---F----G   test, master</span><br></pre></td></tr></table></figure></p>\n<p>操作会舍弃 master 分支上提取的 commit，同时不会像 merge 一样生成一个合并修改内容的 commit，相当于把 master 分支（当前所在分支）上的修改在 deve 分支（目标分支）上原样复制了一遍:git rebase test<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A---B---D---E---C&apos;---F&apos;   test, master</span><br></pre></td></tr></table></figure></p>\n<p>使用git pull时默认是merge， 加 –rebase参数使其使用rebase方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --rebase</span><br></pre></td></tr></table></figure></p>\n<p>2.rebase和merge的不同适用场景</p>\n<p><strong>rebase场景：</strong>如果修改了某个公用代码的BUG，这个时候就应该是把所有的OEM版本分支rebase到这个修复BUG的分支上来，在rebase过程中，Git会要你手动解决代码上的冲突，你需要做的就是把修复BUG的代码放到目标分支代码里面去。rebase的结果是：所有的分支依然存在</p>\n<p><strong>merge场景：</strong>因为成员的代码开发工作已经完成了，也不需要再保留这个分支了，所以我们可以把这个成员分支merge到主分支上，当然冲突在所难免，手工解决的工作肯定逃不掉，但是利大于弊不是吗。merge以后，分支就不存在了，但是在git的所有分支历史中还能看到身影。</p>\n<p><strong>一般我们把别的分支合并到master时用merge，而把master合并到别的分支时会用到rebase的原因，这是因为master分支一般commit会比较频繁。</strong></p>\n<p>所以每次下拉代码fetch之后用rebase的原因就是：<br>本地commit之后，fetch远端代码，此时，远端代码可能会被若干人修改会有若干个commit，而本地就一个commit，然后git rebase的时候，是默认rebase 远端代码，此时会将本地commit应用到远端代码，也就只需要解决一次冲突，并且rebase之后没有新的commit，很友好。但是，如果使用merge，则会产生新的commit。</p>\n<h3 id=\"六-网上推荐的工作流一般是用fetch-rebase-相比pull-merge工作流更干净，不容易出错\"><a href=\"#六-网上推荐的工作流一般是用fetch-rebase-相比pull-merge工作流更干净，不容易出错\" class=\"headerlink\" title=\"六.网上推荐的工作流一般是用fetch+rebase (相比pull+merge工作流更干净，不容易出错)\"></a>六.网上推荐的工作流一般是用fetch+rebase (相比pull+merge工作流更干净，不容易出错)</h3><p><strong>比如dev是你的公共开发分支*</strong></p>\n<p>git checkout dev  # 本地切到公共分支 </p>\n<p>git pull              # 将本地的dev更新</p>\n<p>git checkout -b bug_101026  # 新建一个主题分支（一个bug，一个功能什么的）<br>… # 改动.. commit.. 测试…</p>\n<p>git fetch origin      # 更新upstream</p>\n<p>git rebase origin/dev  # 将你的commits移到的末尾</p>\n<p>git checkout dev  # 切换到公共分支</p>\n<p>git pull              # 更新公共分支</p>\n<p>git rebase bug_101026  # 将你的主题分支加到公共分支的末尾</p>\n<p>git push               # 推送</p>\n"},{"title":"mactest","date":"2017-11-08T13:41:48.000Z","_content":"\ndsdashda sd as\n","source":"_posts/mactest.md","raw":"---\ntitle: mactest\ndate: 2017-11-08 21:41:48\ntags:\n---\n\ndsdashda sd as\n","slug":"mactest","published":1,"updated":"2017-11-08T13:43:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeoh000j9xs6ystmugzb","content":"<p>dsdashda sd as</p>\n","site":{"data":{}},"excerpt":"","more":"<p>dsdashda sd as</p>\n"},{"title":"try catch finally的执行顺序及数据处理情况","date":"2017-06-25T13:19:38.000Z","_content":"#### 结论\n\n1. 不管有木有出现异常，finally块中的代码都会执行\n2. 当try或catch中有return时，finally仍然会执行\n3. 当try或catch中有return时,finally是在return前执行的（此时并没有返回运算后的结果，而是先把运算结果保存起来，而后再去执行finally，此如果finally若有rentrn，则程序结束，若无则操作后跳回try或catch继续执行）\n4. finally中最好不要包含return，否则程序会提前推出，返回值不是catch或catch的值\n \n#### 注意\n- 例1\n```\ntry{} catch(){}finally{} return;\n显然程序按顺序执行。\n```\n- 例2\n```\ntry{ return; }catch(){} finally{} return;\n程序执行try块中return之前（包括return语句中的表达式运算）代码；\n再执行finally块，最后执行try中return;\nfinally块之后的语句return，因为程序在try中已经return所以不再执行。\n```\n- 例3\n```\ntry{ } catch(){return;} finally{} return;\n程序先执行try，如果遇到异常执行catch块，\n有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，\n最后执行catch块中return. finally之后也就是4处的代码不再执行。\n无异常：执行完try再finally再return.\n```\n- 例4\n```\ntry{ return; }catch(){} finally{return;}\n程序执行try块中return之前（包括return语句中的表达式运算）代码；\n再执行finally块，因为finally块中有return所以提前退出。\n```\n- 例5\n```\ntry{} catch(){return;}finally{return;}\n程序执行catch块中return之前（包括return语句中的表达式运算）代码；\n再执行finally块，因为finally块中有return所以提前退出。\n```\n- 例6\n```\ntry{ return;}catch(){return;} finally{return;}\n程序执行try块中return之前（包括return语句中的表达式运算）代码；\n有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；\n则再执行finally块，因为finally块中有return所以提前退出。\n无异常：则再执行finally块，因为finally块中有return所以提前退出。\n```\n#### finally块中改变返回值的特殊情况####\n\n这里涉及到java的引用传递和值传递，首先要明白java全部都是传值的。对于基本数据类型的值是存在栈中的，它是将数据完完整整的拷贝，生成一个新的变量值；对于引用类型的数据既对象它的数据存在于堆中，栈中保存的是指向数据的引用地址，它是将对象的引用地址值拷贝了，所以修改了对象内容，但地址值是不变的。\n测试代码code1\n```\npublic class FinallyTest {\n    public static void main(String[] args) {\n\n        System.out.println(new FinallyTest().test());;\n    }\n\n    static int test()\n    {\n        int x = 1;\n        try\n        {\n            x++;\n            return x;\n        }\n        finally\n        {\n            ++x;\n        }\n    }\n}\n```\n输出2\n测试代码code2\n\n```\n\npublic class FinallyTest2  \n{\n    public static void Main(string[] args)  \n       {  \n         /*测试test1*/   \n           List<string>relist=test1();  \n           foreach (var item in relist)  \n           {  \n               Console.WriteLine(item);  \n           }  \n           Console.ReadLine();  \n       }  \n       private static List<string> test1()  \n       {  \n           List<string> strlist = new List<string>();  \n           strlist.Add(\"zs\");  \n           strlist.Add(\"ls\");  \n           strlist.Add(\"ww\");  \n           strlist.Add(\"mz\");  \n           try  \n           {  \n               strlist.Add(\"wq\");  \n               return strlist;  \n           }  \n           finally  \n           {  \n               strlist.Add(\"yyy\");  \n           }  \n       } \n}\n```\n\n测试输出结果：\nzs\nls\nww\nmz\nwq\nyyy\n\n\n**所以可得**\n如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况：\n\n1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。\n\n2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。\n\n**最终结论：**\n任何执行try或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。\n","source":"_posts/try-catch-finally的执行顺序及数据处理情况.md","raw":"---\ntitle: try catch finally的执行顺序及数据处理情况\ndate: 2017-06-25 21:19:38\ntags: [Java基础]\n---\n#### 结论\n\n1. 不管有木有出现异常，finally块中的代码都会执行\n2. 当try或catch中有return时，finally仍然会执行\n3. 当try或catch中有return时,finally是在return前执行的（此时并没有返回运算后的结果，而是先把运算结果保存起来，而后再去执行finally，此如果finally若有rentrn，则程序结束，若无则操作后跳回try或catch继续执行）\n4. finally中最好不要包含return，否则程序会提前推出，返回值不是catch或catch的值\n \n#### 注意\n- 例1\n```\ntry{} catch(){}finally{} return;\n显然程序按顺序执行。\n```\n- 例2\n```\ntry{ return; }catch(){} finally{} return;\n程序执行try块中return之前（包括return语句中的表达式运算）代码；\n再执行finally块，最后执行try中return;\nfinally块之后的语句return，因为程序在try中已经return所以不再执行。\n```\n- 例3\n```\ntry{ } catch(){return;} finally{} return;\n程序先执行try，如果遇到异常执行catch块，\n有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，\n最后执行catch块中return. finally之后也就是4处的代码不再执行。\n无异常：执行完try再finally再return.\n```\n- 例4\n```\ntry{ return; }catch(){} finally{return;}\n程序执行try块中return之前（包括return语句中的表达式运算）代码；\n再执行finally块，因为finally块中有return所以提前退出。\n```\n- 例5\n```\ntry{} catch(){return;}finally{return;}\n程序执行catch块中return之前（包括return语句中的表达式运算）代码；\n再执行finally块，因为finally块中有return所以提前退出。\n```\n- 例6\n```\ntry{ return;}catch(){return;} finally{return;}\n程序执行try块中return之前（包括return语句中的表达式运算）代码；\n有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；\n则再执行finally块，因为finally块中有return所以提前退出。\n无异常：则再执行finally块，因为finally块中有return所以提前退出。\n```\n#### finally块中改变返回值的特殊情况####\n\n这里涉及到java的引用传递和值传递，首先要明白java全部都是传值的。对于基本数据类型的值是存在栈中的，它是将数据完完整整的拷贝，生成一个新的变量值；对于引用类型的数据既对象它的数据存在于堆中，栈中保存的是指向数据的引用地址，它是将对象的引用地址值拷贝了，所以修改了对象内容，但地址值是不变的。\n测试代码code1\n```\npublic class FinallyTest {\n    public static void main(String[] args) {\n\n        System.out.println(new FinallyTest().test());;\n    }\n\n    static int test()\n    {\n        int x = 1;\n        try\n        {\n            x++;\n            return x;\n        }\n        finally\n        {\n            ++x;\n        }\n    }\n}\n```\n输出2\n测试代码code2\n\n```\n\npublic class FinallyTest2  \n{\n    public static void Main(string[] args)  \n       {  \n         /*测试test1*/   \n           List<string>relist=test1();  \n           foreach (var item in relist)  \n           {  \n               Console.WriteLine(item);  \n           }  \n           Console.ReadLine();  \n       }  \n       private static List<string> test1()  \n       {  \n           List<string> strlist = new List<string>();  \n           strlist.Add(\"zs\");  \n           strlist.Add(\"ls\");  \n           strlist.Add(\"ww\");  \n           strlist.Add(\"mz\");  \n           try  \n           {  \n               strlist.Add(\"wq\");  \n               return strlist;  \n           }  \n           finally  \n           {  \n               strlist.Add(\"yyy\");  \n           }  \n       } \n}\n```\n\n测试输出结果：\nzs\nls\nww\nmz\nwq\nyyy\n\n\n**所以可得**\n如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况：\n\n1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。\n\n2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。\n\n**最终结论：**\n任何执行try或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。\n","slug":"try-catch-finally的执行顺序及数据处理情况","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeoi000l9xs6wo66pwbf","content":"<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><ol>\n<li>不管有木有出现异常，finally块中的代码都会执行</li>\n<li>当try或catch中有return时，finally仍然会执行</li>\n<li>当try或catch中有return时,finally是在return前执行的（此时并没有返回运算后的结果，而是先把运算结果保存起来，而后再去执行finally，此如果finally若有rentrn，则程序结束，若无则操作后跳回try或catch继续执行）</li>\n<li>finally中最好不要包含return，否则程序会提前推出，返回值不是catch或catch的值</li>\n</ol>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li><p>例1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;&#125; catch()&#123;&#125;finally&#123;&#125; return;</span><br><span class=\"line\">显然程序按顺序执行。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123; return; &#125;catch()&#123;&#125; finally&#123;&#125; return;</span><br><span class=\"line\">程序执行try块中return之前（包括return语句中的表达式运算）代码；</span><br><span class=\"line\">再执行finally块，最后执行try中return;</span><br><span class=\"line\">finally块之后的语句return，因为程序在try中已经return所以不再执行。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123; &#125; catch()&#123;return;&#125; finally&#123;&#125; return;</span><br><span class=\"line\">程序先执行try，如果遇到异常执行catch块，</span><br><span class=\"line\">有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，</span><br><span class=\"line\">最后执行catch块中return. finally之后也就是4处的代码不再执行。</span><br><span class=\"line\">无异常：执行完try再finally再return.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123; return; &#125;catch()&#123;&#125; finally&#123;return;&#125;</span><br><span class=\"line\">程序执行try块中return之前（包括return语句中的表达式运算）代码；</span><br><span class=\"line\">再执行finally块，因为finally块中有return所以提前退出。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;&#125; catch()&#123;return;&#125;finally&#123;return;&#125;</span><br><span class=\"line\">程序执行catch块中return之前（包括return语句中的表达式运算）代码；</span><br><span class=\"line\">再执行finally块，因为finally块中有return所以提前退出。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123; return;&#125;catch()&#123;return;&#125; finally&#123;return;&#125;</span><br><span class=\"line\">程序执行try块中return之前（包括return语句中的表达式运算）代码；</span><br><span class=\"line\">有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；</span><br><span class=\"line\">则再执行finally块，因为finally块中有return所以提前退出。</span><br><span class=\"line\">无异常：则再执行finally块，因为finally块中有return所以提前退出。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"finally块中改变返回值的特殊情况\"><a href=\"#finally块中改变返回值的特殊情况\" class=\"headerlink\" title=\"finally块中改变返回值的特殊情况\"></a>finally块中改变返回值的特殊情况</h4><p>这里涉及到java的引用传递和值传递，首先要明白java全部都是传值的。对于基本数据类型的值是存在栈中的，它是将数据完完整整的拷贝，生成一个新的变量值；对于引用类型的数据既对象它的数据存在于堆中，栈中保存的是指向数据的引用地址，它是将对象的引用地址值拷贝了，所以修改了对象内容，但地址值是不变的。<br>测试代码code1<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FinallyTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(new FinallyTest().test());;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static int test()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int x = 1;</span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            x++;</span><br><span class=\"line\">            return x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        finally</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出2<br>测试代码code2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class FinallyTest2  </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public static void Main(string[] args)  </span><br><span class=\"line\">       &#123;  </span><br><span class=\"line\">         /*测试test1*/   </span><br><span class=\"line\">           List&lt;string&gt;relist=test1();  </span><br><span class=\"line\">           foreach (var item in relist)  </span><br><span class=\"line\">           &#123;  </span><br><span class=\"line\">               Console.WriteLine(item);  </span><br><span class=\"line\">           &#125;  </span><br><span class=\"line\">           Console.ReadLine();  </span><br><span class=\"line\">       &#125;  </span><br><span class=\"line\">       private static List&lt;string&gt; test1()  </span><br><span class=\"line\">       &#123;  </span><br><span class=\"line\">           List&lt;string&gt; strlist = new List&lt;string&gt;();  </span><br><span class=\"line\">           strlist.Add(&quot;zs&quot;);  </span><br><span class=\"line\">           strlist.Add(&quot;ls&quot;);  </span><br><span class=\"line\">           strlist.Add(&quot;ww&quot;);  </span><br><span class=\"line\">           strlist.Add(&quot;mz&quot;);  </span><br><span class=\"line\">           try  </span><br><span class=\"line\">           &#123;  </span><br><span class=\"line\">               strlist.Add(&quot;wq&quot;);  </span><br><span class=\"line\">               return strlist;  </span><br><span class=\"line\">           &#125;  </span><br><span class=\"line\">           finally  </span><br><span class=\"line\">           &#123;  </span><br><span class=\"line\">               strlist.Add(&quot;yyy&quot;);  </span><br><span class=\"line\">           &#125;  </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试输出结果：<br>zs<br>ls<br>ww<br>mz<br>wq<br>yyy</p>\n<p><strong>所以可得</strong><br>如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况：</p>\n<p>1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。</p>\n<p>2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</p>\n<p><strong>最终结论：</strong><br>任何执行try或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><ol>\n<li>不管有木有出现异常，finally块中的代码都会执行</li>\n<li>当try或catch中有return时，finally仍然会执行</li>\n<li>当try或catch中有return时,finally是在return前执行的（此时并没有返回运算后的结果，而是先把运算结果保存起来，而后再去执行finally，此如果finally若有rentrn，则程序结束，若无则操作后跳回try或catch继续执行）</li>\n<li>finally中最好不要包含return，否则程序会提前推出，返回值不是catch或catch的值</li>\n</ol>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li><p>例1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;&#125; catch()&#123;&#125;finally&#123;&#125; return;</span><br><span class=\"line\">显然程序按顺序执行。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123; return; &#125;catch()&#123;&#125; finally&#123;&#125; return;</span><br><span class=\"line\">程序执行try块中return之前（包括return语句中的表达式运算）代码；</span><br><span class=\"line\">再执行finally块，最后执行try中return;</span><br><span class=\"line\">finally块之后的语句return，因为程序在try中已经return所以不再执行。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123; &#125; catch()&#123;return;&#125; finally&#123;&#125; return;</span><br><span class=\"line\">程序先执行try，如果遇到异常执行catch块，</span><br><span class=\"line\">有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，</span><br><span class=\"line\">最后执行catch块中return. finally之后也就是4处的代码不再执行。</span><br><span class=\"line\">无异常：执行完try再finally再return.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123; return; &#125;catch()&#123;&#125; finally&#123;return;&#125;</span><br><span class=\"line\">程序执行try块中return之前（包括return语句中的表达式运算）代码；</span><br><span class=\"line\">再执行finally块，因为finally块中有return所以提前退出。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;&#125; catch()&#123;return;&#125;finally&#123;return;&#125;</span><br><span class=\"line\">程序执行catch块中return之前（包括return语句中的表达式运算）代码；</span><br><span class=\"line\">再执行finally块，因为finally块中有return所以提前退出。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123; return;&#125;catch()&#123;return;&#125; finally&#123;return;&#125;</span><br><span class=\"line\">程序执行try块中return之前（包括return语句中的表达式运算）代码；</span><br><span class=\"line\">有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；</span><br><span class=\"line\">则再执行finally块，因为finally块中有return所以提前退出。</span><br><span class=\"line\">无异常：则再执行finally块，因为finally块中有return所以提前退出。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"finally块中改变返回值的特殊情况\"><a href=\"#finally块中改变返回值的特殊情况\" class=\"headerlink\" title=\"finally块中改变返回值的特殊情况\"></a>finally块中改变返回值的特殊情况</h4><p>这里涉及到java的引用传递和值传递，首先要明白java全部都是传值的。对于基本数据类型的值是存在栈中的，它是将数据完完整整的拷贝，生成一个新的变量值；对于引用类型的数据既对象它的数据存在于堆中，栈中保存的是指向数据的引用地址，它是将对象的引用地址值拷贝了，所以修改了对象内容，但地址值是不变的。<br>测试代码code1<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FinallyTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(new FinallyTest().test());;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static int test()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int x = 1;</span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            x++;</span><br><span class=\"line\">            return x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        finally</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出2<br>测试代码code2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class FinallyTest2  </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public static void Main(string[] args)  </span><br><span class=\"line\">       &#123;  </span><br><span class=\"line\">         /*测试test1*/   </span><br><span class=\"line\">           List&lt;string&gt;relist=test1();  </span><br><span class=\"line\">           foreach (var item in relist)  </span><br><span class=\"line\">           &#123;  </span><br><span class=\"line\">               Console.WriteLine(item);  </span><br><span class=\"line\">           &#125;  </span><br><span class=\"line\">           Console.ReadLine();  </span><br><span class=\"line\">       &#125;  </span><br><span class=\"line\">       private static List&lt;string&gt; test1()  </span><br><span class=\"line\">       &#123;  </span><br><span class=\"line\">           List&lt;string&gt; strlist = new List&lt;string&gt;();  </span><br><span class=\"line\">           strlist.Add(&quot;zs&quot;);  </span><br><span class=\"line\">           strlist.Add(&quot;ls&quot;);  </span><br><span class=\"line\">           strlist.Add(&quot;ww&quot;);  </span><br><span class=\"line\">           strlist.Add(&quot;mz&quot;);  </span><br><span class=\"line\">           try  </span><br><span class=\"line\">           &#123;  </span><br><span class=\"line\">               strlist.Add(&quot;wq&quot;);  </span><br><span class=\"line\">               return strlist;  </span><br><span class=\"line\">           &#125;  </span><br><span class=\"line\">           finally  </span><br><span class=\"line\">           &#123;  </span><br><span class=\"line\">               strlist.Add(&quot;yyy&quot;);  </span><br><span class=\"line\">           &#125;  </span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试输出结果：<br>zs<br>ls<br>ww<br>mz<br>wq<br>yyy</p>\n<p><strong>所以可得</strong><br>如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况：</p>\n<p>1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。</p>\n<p>2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</p>\n<p><strong>最终结论：</strong><br>任何执行try或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。</p>\n"},{"title":"事件传递机制","date":"2017-03-27T07:07:55.000Z","_content":"### Touch事件传递机制\n其中Activity和View控件（TextView）拥有分派和处理事件方法，View容器（LinearLayout）具有分派，拦截，处理事件方法。这里也有个比喻：领导都会把任务向下分派，一旦下面的人把事情做不好，就不会再把后续的任务交给下面的人来做了，只能自己亲自做，如果自己也做不了，就只能告诉上级不能完成任务，上级又会重复他的过程。另外，领导都有权利拦截任务，对下级隐瞒该任务，而直接自己去做，如果做不成，也只能向上级报告不能完成任务。\n``` java\n//分派事件\npublic boolean dispatchTouchEvent(MotionEvent ev)\n//拦截事件 \npublic boolean onInterceptTouchEvent(MotionEvent ev)\n//处理事件\npublic boolean onTouchEvent(MotionEvent event)\n```\n\n![Alt text](http://static.open-open.com/lib/uploadImg/20150128/20150128145842_296.png \"Optional title\")\n\n![Alt text](http://www.codeceo.com/wp-content/uploads/2015/01/touch-event-5.png \"Optional title\")\n\n从上面两张事件传递图我们的出来一些结论：\n\n1. 事件是先有dispatchTouchEvent分派给下一级\n\n2. 要经过onInterceptTouchEvent是否需要拦截，不拦截传递给下一级，最终传递给view控件，\n\n3. onTouchEvent方法中，在处理事件中，如果返回True，则表示能处理，传递将会终止。反着，不能，如果不能的话，这会返回上一级的onTouchEvent方法中，如果还是false，会一直到到上一层的onTouchEvent方法中。\n\n好奇的我们会发现一个问题：图二中的黄色线，没有像红色线那样，先传递到最底层，然后再回滚回去，这是为什么呢？\n\n答：就如我们故事中，他都知道了，底下人都不会去做了，那么他干嘛还分派给他呢，他就会自己做了，直接给onTouchEvent ，这就是事件传递中的“记忆”功能。我们是手指点击蓝色区域，Touch事件有两个，第一个ACTION_DOWN，第二个ACTION_UP，第一个 ACTION_DOWN事件向下传递到某View，它把事件继续传递交给它的子View，它会记录该事件是否被它下面的View给处理成功了，（怎么能知 道呢？如果该事件会再次被向上传递到我这里来由我的onTouchEvent来处理，那就说明下面的View都没能成功处理该事件）；当第二个 ACTION_UP事件向下传递到该View，该View的dispatchTouchEvent方法机会判断，若上次的事件由下面的view成功处理 了，那么这次的事件就继续交给下面的来处理，若上次的事件没有被下面的处理成功，那么这次的事件就不会向下传递了，该View直接调用自己的 onTouchEvent方法来处理该事件。\n\nPS：关于这“记忆”功能的信息只在一系列事件完成之前有效，也就是从ACTION_DOWN事件开始，直到后续事件 ACTION_MOVE，ACTION_UP结束后，“记忆”的信息就会清除。也就是说如果某View处理ACTION_DOWN事件失败了 （onTouchEvent()返回false），那么后续的ACTION_MOVE,ACTION_UP等事件就不会再传递到该View了，由其父 View自己来处理。在下一次发生ACTION_DOWN事件的时候，还是会传递到该View的。\n\n补充说明：\n\n-》若在向下传递的过程中被拦截了，即onInterceptTouchEvent方法返回true，则事件将停止向下传递，直接由当前的onTouchEvent方法来处理，若处理成功则OK，若处理不成功，则事件会向上传递。\n","source":"_posts/事件传递机制.md","raw":"---\ntitle: 事件传递机制\ndate: 2017-03-27 15:07:55\ntags: [Android]\ncategory: \"Android\"\n---\n### Touch事件传递机制\n其中Activity和View控件（TextView）拥有分派和处理事件方法，View容器（LinearLayout）具有分派，拦截，处理事件方法。这里也有个比喻：领导都会把任务向下分派，一旦下面的人把事情做不好，就不会再把后续的任务交给下面的人来做了，只能自己亲自做，如果自己也做不了，就只能告诉上级不能完成任务，上级又会重复他的过程。另外，领导都有权利拦截任务，对下级隐瞒该任务，而直接自己去做，如果做不成，也只能向上级报告不能完成任务。\n``` java\n//分派事件\npublic boolean dispatchTouchEvent(MotionEvent ev)\n//拦截事件 \npublic boolean onInterceptTouchEvent(MotionEvent ev)\n//处理事件\npublic boolean onTouchEvent(MotionEvent event)\n```\n\n![Alt text](http://static.open-open.com/lib/uploadImg/20150128/20150128145842_296.png \"Optional title\")\n\n![Alt text](http://www.codeceo.com/wp-content/uploads/2015/01/touch-event-5.png \"Optional title\")\n\n从上面两张事件传递图我们的出来一些结论：\n\n1. 事件是先有dispatchTouchEvent分派给下一级\n\n2. 要经过onInterceptTouchEvent是否需要拦截，不拦截传递给下一级，最终传递给view控件，\n\n3. onTouchEvent方法中，在处理事件中，如果返回True，则表示能处理，传递将会终止。反着，不能，如果不能的话，这会返回上一级的onTouchEvent方法中，如果还是false，会一直到到上一层的onTouchEvent方法中。\n\n好奇的我们会发现一个问题：图二中的黄色线，没有像红色线那样，先传递到最底层，然后再回滚回去，这是为什么呢？\n\n答：就如我们故事中，他都知道了，底下人都不会去做了，那么他干嘛还分派给他呢，他就会自己做了，直接给onTouchEvent ，这就是事件传递中的“记忆”功能。我们是手指点击蓝色区域，Touch事件有两个，第一个ACTION_DOWN，第二个ACTION_UP，第一个 ACTION_DOWN事件向下传递到某View，它把事件继续传递交给它的子View，它会记录该事件是否被它下面的View给处理成功了，（怎么能知 道呢？如果该事件会再次被向上传递到我这里来由我的onTouchEvent来处理，那就说明下面的View都没能成功处理该事件）；当第二个 ACTION_UP事件向下传递到该View，该View的dispatchTouchEvent方法机会判断，若上次的事件由下面的view成功处理 了，那么这次的事件就继续交给下面的来处理，若上次的事件没有被下面的处理成功，那么这次的事件就不会向下传递了，该View直接调用自己的 onTouchEvent方法来处理该事件。\n\nPS：关于这“记忆”功能的信息只在一系列事件完成之前有效，也就是从ACTION_DOWN事件开始，直到后续事件 ACTION_MOVE，ACTION_UP结束后，“记忆”的信息就会清除。也就是说如果某View处理ACTION_DOWN事件失败了 （onTouchEvent()返回false），那么后续的ACTION_MOVE,ACTION_UP等事件就不会再传递到该View了，由其父 View自己来处理。在下一次发生ACTION_DOWN事件的时候，还是会传递到该View的。\n\n补充说明：\n\n-》若在向下传递的过程中被拦截了，即onInterceptTouchEvent方法返回true，则事件将停止向下传递，直接由当前的onTouchEvent方法来处理，若处理成功则OK，若处理不成功，则事件会向上传递。\n","slug":"事件传递机制","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeoj000o9xs6lwz2j771","content":"<h3 id=\"Touch事件传递机制\"><a href=\"#Touch事件传递机制\" class=\"headerlink\" title=\"Touch事件传递机制\"></a>Touch事件传递机制</h3><p>其中Activity和View控件（TextView）拥有分派和处理事件方法，View容器（LinearLayout）具有分派，拦截，处理事件方法。这里也有个比喻：领导都会把任务向下分派，一旦下面的人把事情做不好，就不会再把后续的任务交给下面的人来做了，只能自己亲自做，如果自己也做不了，就只能告诉上级不能完成任务，上级又会重复他的过程。另外，领导都有权利拦截任务，对下级隐瞒该任务，而直接自己去做，如果做不成，也只能向上级报告不能完成任务。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分派事件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//拦截事件 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//处理事件</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://static.open-open.com/lib/uploadImg/20150128/20150128145842_296.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p><img src=\"http://www.codeceo.com/wp-content/uploads/2015/01/touch-event-5.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>从上面两张事件传递图我们的出来一些结论：</p>\n<ol>\n<li><p>事件是先有dispatchTouchEvent分派给下一级</p>\n</li>\n<li><p>要经过onInterceptTouchEvent是否需要拦截，不拦截传递给下一级，最终传递给view控件，</p>\n</li>\n<li><p>onTouchEvent方法中，在处理事件中，如果返回True，则表示能处理，传递将会终止。反着，不能，如果不能的话，这会返回上一级的onTouchEvent方法中，如果还是false，会一直到到上一层的onTouchEvent方法中。</p>\n</li>\n</ol>\n<p>好奇的我们会发现一个问题：图二中的黄色线，没有像红色线那样，先传递到最底层，然后再回滚回去，这是为什么呢？</p>\n<p>答：就如我们故事中，他都知道了，底下人都不会去做了，那么他干嘛还分派给他呢，他就会自己做了，直接给onTouchEvent ，这就是事件传递中的“记忆”功能。我们是手指点击蓝色区域，Touch事件有两个，第一个ACTION_DOWN，第二个ACTION_UP，第一个 ACTION_DOWN事件向下传递到某View，它把事件继续传递交给它的子View，它会记录该事件是否被它下面的View给处理成功了，（怎么能知 道呢？如果该事件会再次被向上传递到我这里来由我的onTouchEvent来处理，那就说明下面的View都没能成功处理该事件）；当第二个 ACTION_UP事件向下传递到该View，该View的dispatchTouchEvent方法机会判断，若上次的事件由下面的view成功处理 了，那么这次的事件就继续交给下面的来处理，若上次的事件没有被下面的处理成功，那么这次的事件就不会向下传递了，该View直接调用自己的 onTouchEvent方法来处理该事件。</p>\n<p>PS：关于这“记忆”功能的信息只在一系列事件完成之前有效，也就是从ACTION_DOWN事件开始，直到后续事件 ACTION_MOVE，ACTION_UP结束后，“记忆”的信息就会清除。也就是说如果某View处理ACTION_DOWN事件失败了 （onTouchEvent()返回false），那么后续的ACTION_MOVE,ACTION_UP等事件就不会再传递到该View了，由其父 View自己来处理。在下一次发生ACTION_DOWN事件的时候，还是会传递到该View的。</p>\n<p>补充说明：</p>\n<p>-》若在向下传递的过程中被拦截了，即onInterceptTouchEvent方法返回true，则事件将停止向下传递，直接由当前的onTouchEvent方法来处理，若处理成功则OK，若处理不成功，则事件会向上传递。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Touch事件传递机制\"><a href=\"#Touch事件传递机制\" class=\"headerlink\" title=\"Touch事件传递机制\"></a>Touch事件传递机制</h3><p>其中Activity和View控件（TextView）拥有分派和处理事件方法，View容器（LinearLayout）具有分派，拦截，处理事件方法。这里也有个比喻：领导都会把任务向下分派，一旦下面的人把事情做不好，就不会再把后续的任务交给下面的人来做了，只能自己亲自做，如果自己也做不了，就只能告诉上级不能完成任务，上级又会重复他的过程。另外，领导都有权利拦截任务，对下级隐瞒该任务，而直接自己去做，如果做不成，也只能向上级报告不能完成任务。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分派事件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//拦截事件 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//处理事件</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://static.open-open.com/lib/uploadImg/20150128/20150128145842_296.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p><img src=\"http://www.codeceo.com/wp-content/uploads/2015/01/touch-event-5.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>从上面两张事件传递图我们的出来一些结论：</p>\n<ol>\n<li><p>事件是先有dispatchTouchEvent分派给下一级</p>\n</li>\n<li><p>要经过onInterceptTouchEvent是否需要拦截，不拦截传递给下一级，最终传递给view控件，</p>\n</li>\n<li><p>onTouchEvent方法中，在处理事件中，如果返回True，则表示能处理，传递将会终止。反着，不能，如果不能的话，这会返回上一级的onTouchEvent方法中，如果还是false，会一直到到上一层的onTouchEvent方法中。</p>\n</li>\n</ol>\n<p>好奇的我们会发现一个问题：图二中的黄色线，没有像红色线那样，先传递到最底层，然后再回滚回去，这是为什么呢？</p>\n<p>答：就如我们故事中，他都知道了，底下人都不会去做了，那么他干嘛还分派给他呢，他就会自己做了，直接给onTouchEvent ，这就是事件传递中的“记忆”功能。我们是手指点击蓝色区域，Touch事件有两个，第一个ACTION_DOWN，第二个ACTION_UP，第一个 ACTION_DOWN事件向下传递到某View，它把事件继续传递交给它的子View，它会记录该事件是否被它下面的View给处理成功了，（怎么能知 道呢？如果该事件会再次被向上传递到我这里来由我的onTouchEvent来处理，那就说明下面的View都没能成功处理该事件）；当第二个 ACTION_UP事件向下传递到该View，该View的dispatchTouchEvent方法机会判断，若上次的事件由下面的view成功处理 了，那么这次的事件就继续交给下面的来处理，若上次的事件没有被下面的处理成功，那么这次的事件就不会向下传递了，该View直接调用自己的 onTouchEvent方法来处理该事件。</p>\n<p>PS：关于这“记忆”功能的信息只在一系列事件完成之前有效，也就是从ACTION_DOWN事件开始，直到后续事件 ACTION_MOVE，ACTION_UP结束后，“记忆”的信息就会清除。也就是说如果某View处理ACTION_DOWN事件失败了 （onTouchEvent()返回false），那么后续的ACTION_MOVE,ACTION_UP等事件就不会再传递到该View了，由其父 View自己来处理。在下一次发生ACTION_DOWN事件的时候，还是会传递到该View的。</p>\n<p>补充说明：</p>\n<p>-》若在向下传递的过程中被拦截了，即onInterceptTouchEvent方法返回true，则事件将停止向下传递，直接由当前的onTouchEvent方法来处理，若处理成功则OK，若处理不成功，则事件会向上传递。</p>\n"},{"title":"什么是算法","date":"2017-06-14T14:31:05.000Z","_content":"#### 算法：\n- 算法是模型分析的一组可行的、确定的和有穷的规则（广泛）\n- 算法是解决实际问题的一种精确的描述方法\n- 算法是对特定问题的求解步骤的一种精确描述方法\n\n#### 算法的特性\n- 有穷性：算法的指令或者执行步骤是有限的\n- 确切的：算法的每一个指令和步骤都必须有明确的定义和描述\n- 输入：一个算法应该有的输入条件，用于初始化\n- 输出：一个算法应该有个名明确的结果输出\n- 可行性：执行步骤的可行，且有可以在有限时间内完成\n\n#### 算法分类\n- 按照应用来分类\n    - 基础算法、数据结构、几何、加密、查询、排序等等 \n- 按照确定性来分类\n    - 确定性算法：有限时间内完成，结果唯一\n    - 非确定性算法：有限时间内完成，结果往往不唯一\n- 按照算法思路\n    - 递推、递归、穷举、贪婪、分治、动态规划、迭代等算法 \n\n#### 算法概念\n- 数据结构+算法+程序设计语言 = 程序\n- 数据结构表示处理对象，算法是计算和处理的核心方法，程序设计语言是算法的实现方法。这几者综合便构成了一个程序\n\n#### 算法的表示\n- 自然语言表示\n- 流程图\n- N-S图\n- 伪代码表示\n\n#### 算法性能评价\n- 时间复杂度：算法执行所消耗的时间，时间越短，性能越好,算法越好。\n    - 与每条语句执行的数量有关\n    - 与问题的规模有关\n- 空间复杂度：算法执行所消耗的存储空间，消耗越小，算法越好。\n    - 程序保存所需要的存储空间，程序的大小\n    - 程序执行过程中所需消耗的存储空间（变量等）\n\n#### 算法实例\n一个班级学生档案集中查找某一个学生的档案\n伪代码\n```\n变量 x = 输入需要查找的数据\n变量 arr = 随机生产数组数据\nfor 1到20{\n    if(arr[i] ==){\n    找到数据\n    break;\n    }\n}\n输出该数据的位置\n程序结束\n```\nCode\n```\npublic Class Test1{\n    static int N = 20;\n    public static void main(String args[]){\n    int arr[] = new int[N];\n    int x;\n    int pos = -1;\n    Random r= new Random();\n    for(int i=0; i<N; i++){\n        arr[i] = r.nextInt(100);\n    }\n    System.out.println(\"生成随机数序列\")\n    for(int i=0; i<N; i++){\n        System.out.print(arr[i]+\" \");\n    }\n\n    System.out.print(\"输入要查找的整数\");\n    Scanner input = new Scanner(System.in);\n    x = input.getInt();\n    for(int i=0; i<N; i++){\n        if(arr[i] == x){\n            pos = i;\n            break;\n        }\n    }\n\n    if(f<0){\n        System.out.print(\"未找到数据\");\n    }else{\n        System.out.print(x+\"数据位于\"+pos+\"位置，是数组的第\"+(pos+1)+\"个元素\");\n    }\n    } \n}\n```","source":"_posts/什么是算法.md","raw":"---\ntitle: 什么是算法\ndate: 2017-06-14 22:31:05\ntags: [算法基础]\ncategory: \"算法\"\n---\n#### 算法：\n- 算法是模型分析的一组可行的、确定的和有穷的规则（广泛）\n- 算法是解决实际问题的一种精确的描述方法\n- 算法是对特定问题的求解步骤的一种精确描述方法\n\n#### 算法的特性\n- 有穷性：算法的指令或者执行步骤是有限的\n- 确切的：算法的每一个指令和步骤都必须有明确的定义和描述\n- 输入：一个算法应该有的输入条件，用于初始化\n- 输出：一个算法应该有个名明确的结果输出\n- 可行性：执行步骤的可行，且有可以在有限时间内完成\n\n#### 算法分类\n- 按照应用来分类\n    - 基础算法、数据结构、几何、加密、查询、排序等等 \n- 按照确定性来分类\n    - 确定性算法：有限时间内完成，结果唯一\n    - 非确定性算法：有限时间内完成，结果往往不唯一\n- 按照算法思路\n    - 递推、递归、穷举、贪婪、分治、动态规划、迭代等算法 \n\n#### 算法概念\n- 数据结构+算法+程序设计语言 = 程序\n- 数据结构表示处理对象，算法是计算和处理的核心方法，程序设计语言是算法的实现方法。这几者综合便构成了一个程序\n\n#### 算法的表示\n- 自然语言表示\n- 流程图\n- N-S图\n- 伪代码表示\n\n#### 算法性能评价\n- 时间复杂度：算法执行所消耗的时间，时间越短，性能越好,算法越好。\n    - 与每条语句执行的数量有关\n    - 与问题的规模有关\n- 空间复杂度：算法执行所消耗的存储空间，消耗越小，算法越好。\n    - 程序保存所需要的存储空间，程序的大小\n    - 程序执行过程中所需消耗的存储空间（变量等）\n\n#### 算法实例\n一个班级学生档案集中查找某一个学生的档案\n伪代码\n```\n变量 x = 输入需要查找的数据\n变量 arr = 随机生产数组数据\nfor 1到20{\n    if(arr[i] ==){\n    找到数据\n    break;\n    }\n}\n输出该数据的位置\n程序结束\n```\nCode\n```\npublic Class Test1{\n    static int N = 20;\n    public static void main(String args[]){\n    int arr[] = new int[N];\n    int x;\n    int pos = -1;\n    Random r= new Random();\n    for(int i=0; i<N; i++){\n        arr[i] = r.nextInt(100);\n    }\n    System.out.println(\"生成随机数序列\")\n    for(int i=0; i<N; i++){\n        System.out.print(arr[i]+\" \");\n    }\n\n    System.out.print(\"输入要查找的整数\");\n    Scanner input = new Scanner(System.in);\n    x = input.getInt();\n    for(int i=0; i<N; i++){\n        if(arr[i] == x){\n            pos = i;\n            break;\n        }\n    }\n\n    if(f<0){\n        System.out.print(\"未找到数据\");\n    }else{\n        System.out.print(x+\"数据位于\"+pos+\"位置，是数组的第\"+(pos+1)+\"个元素\");\n    }\n    } \n}\n```","slug":"什么是算法","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeok000r9xs6fjpvjyul","content":"<h4 id=\"算法：\"><a href=\"#算法：\" class=\"headerlink\" title=\"算法：\"></a>算法：</h4><ul>\n<li>算法是模型分析的一组可行的、确定的和有穷的规则（广泛）</li>\n<li>算法是解决实际问题的一种精确的描述方法</li>\n<li>算法是对特定问题的求解步骤的一种精确描述方法</li>\n</ul>\n<h4 id=\"算法的特性\"><a href=\"#算法的特性\" class=\"headerlink\" title=\"算法的特性\"></a>算法的特性</h4><ul>\n<li>有穷性：算法的指令或者执行步骤是有限的</li>\n<li>确切的：算法的每一个指令和步骤都必须有明确的定义和描述</li>\n<li>输入：一个算法应该有的输入条件，用于初始化</li>\n<li>输出：一个算法应该有个名明确的结果输出</li>\n<li>可行性：执行步骤的可行，且有可以在有限时间内完成</li>\n</ul>\n<h4 id=\"算法分类\"><a href=\"#算法分类\" class=\"headerlink\" title=\"算法分类\"></a>算法分类</h4><ul>\n<li>按照应用来分类<ul>\n<li>基础算法、数据结构、几何、加密、查询、排序等等 </li>\n</ul>\n</li>\n<li>按照确定性来分类<ul>\n<li>确定性算法：有限时间内完成，结果唯一</li>\n<li>非确定性算法：有限时间内完成，结果往往不唯一</li>\n</ul>\n</li>\n<li>按照算法思路<ul>\n<li>递推、递归、穷举、贪婪、分治、动态规划、迭代等算法 </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"算法概念\"><a href=\"#算法概念\" class=\"headerlink\" title=\"算法概念\"></a>算法概念</h4><ul>\n<li>数据结构+算法+程序设计语言 = 程序</li>\n<li>数据结构表示处理对象，算法是计算和处理的核心方法，程序设计语言是算法的实现方法。这几者综合便构成了一个程序</li>\n</ul>\n<h4 id=\"算法的表示\"><a href=\"#算法的表示\" class=\"headerlink\" title=\"算法的表示\"></a>算法的表示</h4><ul>\n<li>自然语言表示</li>\n<li>流程图</li>\n<li>N-S图</li>\n<li>伪代码表示</li>\n</ul>\n<h4 id=\"算法性能评价\"><a href=\"#算法性能评价\" class=\"headerlink\" title=\"算法性能评价\"></a>算法性能评价</h4><ul>\n<li>时间复杂度：算法执行所消耗的时间，时间越短，性能越好,算法越好。<ul>\n<li>与每条语句执行的数量有关</li>\n<li>与问题的规模有关</li>\n</ul>\n</li>\n<li>空间复杂度：算法执行所消耗的存储空间，消耗越小，算法越好。<ul>\n<li>程序保存所需要的存储空间，程序的大小</li>\n<li>程序执行过程中所需消耗的存储空间（变量等）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"算法实例\"><a href=\"#算法实例\" class=\"headerlink\" title=\"算法实例\"></a>算法实例</h4><p>一个班级学生档案集中查找某一个学生的档案<br>伪代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量 x = 输入需要查找的数据</span><br><span class=\"line\">变量 arr = 随机生产数组数据</span><br><span class=\"line\">for 1到20&#123;</span><br><span class=\"line\">    if(arr[i] ==)&#123;</span><br><span class=\"line\">    找到数据</span><br><span class=\"line\">    break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出该数据的位置</span><br><span class=\"line\">程序结束</span><br></pre></td></tr></table></figure></p>\n<p>Code<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Class Test1&#123;</span><br><span class=\"line\">    static int N = 20;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">    int arr[] = new int[N];</span><br><span class=\"line\">    int x;</span><br><span class=\"line\">    int pos = -1;</span><br><span class=\"line\">    Random r= new Random();</span><br><span class=\"line\">    for(int i=0; i&lt;N; i++)&#123;</span><br><span class=\"line\">        arr[i] = r.nextInt(100);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(&quot;生成随机数序列&quot;)</span><br><span class=\"line\">    for(int i=0; i&lt;N; i++)&#123;</span><br><span class=\"line\">        System.out.print(arr[i]+&quot; &quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.print(&quot;输入要查找的整数&quot;);</span><br><span class=\"line\">    Scanner input = new Scanner(System.in);</span><br><span class=\"line\">    x = input.getInt();</span><br><span class=\"line\">    for(int i=0; i&lt;N; i++)&#123;</span><br><span class=\"line\">        if(arr[i] == x)&#123;</span><br><span class=\"line\">            pos = i;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if(f&lt;0)&#123;</span><br><span class=\"line\">        System.out.print(&quot;未找到数据&quot;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        System.out.print(x+&quot;数据位于&quot;+pos+&quot;位置，是数组的第&quot;+(pos+1)+&quot;个元素&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"算法：\"><a href=\"#算法：\" class=\"headerlink\" title=\"算法：\"></a>算法：</h4><ul>\n<li>算法是模型分析的一组可行的、确定的和有穷的规则（广泛）</li>\n<li>算法是解决实际问题的一种精确的描述方法</li>\n<li>算法是对特定问题的求解步骤的一种精确描述方法</li>\n</ul>\n<h4 id=\"算法的特性\"><a href=\"#算法的特性\" class=\"headerlink\" title=\"算法的特性\"></a>算法的特性</h4><ul>\n<li>有穷性：算法的指令或者执行步骤是有限的</li>\n<li>确切的：算法的每一个指令和步骤都必须有明确的定义和描述</li>\n<li>输入：一个算法应该有的输入条件，用于初始化</li>\n<li>输出：一个算法应该有个名明确的结果输出</li>\n<li>可行性：执行步骤的可行，且有可以在有限时间内完成</li>\n</ul>\n<h4 id=\"算法分类\"><a href=\"#算法分类\" class=\"headerlink\" title=\"算法分类\"></a>算法分类</h4><ul>\n<li>按照应用来分类<ul>\n<li>基础算法、数据结构、几何、加密、查询、排序等等 </li>\n</ul>\n</li>\n<li>按照确定性来分类<ul>\n<li>确定性算法：有限时间内完成，结果唯一</li>\n<li>非确定性算法：有限时间内完成，结果往往不唯一</li>\n</ul>\n</li>\n<li>按照算法思路<ul>\n<li>递推、递归、穷举、贪婪、分治、动态规划、迭代等算法 </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"算法概念\"><a href=\"#算法概念\" class=\"headerlink\" title=\"算法概念\"></a>算法概念</h4><ul>\n<li>数据结构+算法+程序设计语言 = 程序</li>\n<li>数据结构表示处理对象，算法是计算和处理的核心方法，程序设计语言是算法的实现方法。这几者综合便构成了一个程序</li>\n</ul>\n<h4 id=\"算法的表示\"><a href=\"#算法的表示\" class=\"headerlink\" title=\"算法的表示\"></a>算法的表示</h4><ul>\n<li>自然语言表示</li>\n<li>流程图</li>\n<li>N-S图</li>\n<li>伪代码表示</li>\n</ul>\n<h4 id=\"算法性能评价\"><a href=\"#算法性能评价\" class=\"headerlink\" title=\"算法性能评价\"></a>算法性能评价</h4><ul>\n<li>时间复杂度：算法执行所消耗的时间，时间越短，性能越好,算法越好。<ul>\n<li>与每条语句执行的数量有关</li>\n<li>与问题的规模有关</li>\n</ul>\n</li>\n<li>空间复杂度：算法执行所消耗的存储空间，消耗越小，算法越好。<ul>\n<li>程序保存所需要的存储空间，程序的大小</li>\n<li>程序执行过程中所需消耗的存储空间（变量等）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"算法实例\"><a href=\"#算法实例\" class=\"headerlink\" title=\"算法实例\"></a>算法实例</h4><p>一个班级学生档案集中查找某一个学生的档案<br>伪代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量 x = 输入需要查找的数据</span><br><span class=\"line\">变量 arr = 随机生产数组数据</span><br><span class=\"line\">for 1到20&#123;</span><br><span class=\"line\">    if(arr[i] ==)&#123;</span><br><span class=\"line\">    找到数据</span><br><span class=\"line\">    break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出该数据的位置</span><br><span class=\"line\">程序结束</span><br></pre></td></tr></table></figure></p>\n<p>Code<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Class Test1&#123;</span><br><span class=\"line\">    static int N = 20;</span><br><span class=\"line\">    public static void main(String args[])&#123;</span><br><span class=\"line\">    int arr[] = new int[N];</span><br><span class=\"line\">    int x;</span><br><span class=\"line\">    int pos = -1;</span><br><span class=\"line\">    Random r= new Random();</span><br><span class=\"line\">    for(int i=0; i&lt;N; i++)&#123;</span><br><span class=\"line\">        arr[i] = r.nextInt(100);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(&quot;生成随机数序列&quot;)</span><br><span class=\"line\">    for(int i=0; i&lt;N; i++)&#123;</span><br><span class=\"line\">        System.out.print(arr[i]+&quot; &quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.print(&quot;输入要查找的整数&quot;);</span><br><span class=\"line\">    Scanner input = new Scanner(System.in);</span><br><span class=\"line\">    x = input.getInt();</span><br><span class=\"line\">    for(int i=0; i&lt;N; i++)&#123;</span><br><span class=\"line\">        if(arr[i] == x)&#123;</span><br><span class=\"line\">            pos = i;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if(f&lt;0)&#123;</span><br><span class=\"line\">        System.out.print(&quot;未找到数据&quot;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        System.out.print(x+&quot;数据位于&quot;+pos+&quot;位置，是数组的第&quot;+(pos+1)+&quot;个元素&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"性能优化之布局","date":"2017-03-21T15:34:46.000Z","_content":"1. 性能优化之布局\n</include>重用\n</merger>减少视图层级\n</ViewStub>需要时加载，懒加载布局\n使用工具：Hierarchy View\n2. Android 性能优化方法\n使用Dalvik提供的 dalvik.system.VMRuntime类来设置最小堆内存为例:\n3. bitmap 设置图片尺寸\n避免 内存溢出 OutOfMemoryError的优化方法\n options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一\n4. Android 还有一些性能优化的方法：\n首先内存方面，可以参考 Android堆内存也可自己定义大小 和 优化Dalvik虚拟机的堆内存分配\n基础类型上，因为Java没有实际的指针，在敏感运算方面还是要借助NDK来完成。这点比较有意思的是Google 推出NDK可能是帮助游戏开发人员，比如OpenGL ES的支持有明显的改观，本地代码操作图形界面是很必要的。\n 图形对象优化，这里要说的是Android上的Bitmap对象销毁，可以借助recycle()方法显示让GC回收一个Bitmap对象，通常对一个不用的Bitmap可以使用下面的方式。\n5. [从代码角度进行优化](http://mobile.51cto.com/abased-410791.htm)\n静态变量引起内存泄露\n使用Application的Context\n及时关闭资源\n使用Bitmap及时调用recycle()\n对Adapter进行优化\n代码“微优化”\n5. [使用软引用和弱引用](http://mobile.51cto.com/abased-410795.htm)\n6. [Android 中的Activity、Window、View之间的关系](http://www.cnblogs.com/kest/p/5141817.html)\nActivity在onCreate时调用attach方法，在attach方法中会创建window对象。window对象创建时并没有创建 DocerView 对象。用户在Activity中调用setContentView,然后调用window的setContentView，这时会检查DecorView是否存在，如果不存在则创建DecorView对象，然后把用户自己的 View  添加到 DecorView 中。\n7. [Activity的几种LaunchMode及使用场景](http://www.tuicool.com/articles/iIf6BbV)\n[Android关于Task的一些实践](http://blog.csdn.net/linmiansheng/article/details/24297375)\n8. [Android 设计模式之MVC模式](http://www.cnblogs.com/liqw/p/4175325.html)\nMVC模式下，系统框架的类库被划分为3种：模型（Model）、视图（View）、控制器（Controller）。模型对象负责建立数据结构和相应的行为操作处理。视图对象负责在屏幕上渲染出相应的图形信息展示给用户看。控制器对象负责截获用户的按键和屏幕触摸等事件，协调Model对象和View对象。\n　　用户与视图交互，视图接收并反馈用户的动作；视图把用户的请求传给相应的控制器，由控制器决定调用哪个模型，然后由模型调用相应的业务逻辑对用户请求进行加工处理，如果需要返回数据，模型会把相应的数据返回给控制器，由控制器调用相应的视图，最终由视图格式化和渲染返回的数据，对于返回的数据完全可以增加用户体验效果展现给用户。\n9. [教你认清MVC，MVP和MVVM](http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/)\n[如何设计MVP中的Presentation层](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0301/4018.html)\n[google 官方mvp实例的实践之mvp-databinding-Rxjava（一）](http://www.jianshu.com/p/ce1b447efc4f)\n10. [Netty 4.0在Android 上的使用，长连接断线自动重连](https://jiangchunyu.github.io/2016/08/28/Netty-4-0%E5%9C%A8Android-%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/)\n","source":"_posts/性能优化之布局.md","raw":"---\ntitle: 性能优化之布局\ndate: 2017-03-21 23:34:46\ntags:\n---\n1. 性能优化之布局\n</include>重用\n</merger>减少视图层级\n</ViewStub>需要时加载，懒加载布局\n使用工具：Hierarchy View\n2. Android 性能优化方法\n使用Dalvik提供的 dalvik.system.VMRuntime类来设置最小堆内存为例:\n3. bitmap 设置图片尺寸\n避免 内存溢出 OutOfMemoryError的优化方法\n options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一\n4. Android 还有一些性能优化的方法：\n首先内存方面，可以参考 Android堆内存也可自己定义大小 和 优化Dalvik虚拟机的堆内存分配\n基础类型上，因为Java没有实际的指针，在敏感运算方面还是要借助NDK来完成。这点比较有意思的是Google 推出NDK可能是帮助游戏开发人员，比如OpenGL ES的支持有明显的改观，本地代码操作图形界面是很必要的。\n 图形对象优化，这里要说的是Android上的Bitmap对象销毁，可以借助recycle()方法显示让GC回收一个Bitmap对象，通常对一个不用的Bitmap可以使用下面的方式。\n5. [从代码角度进行优化](http://mobile.51cto.com/abased-410791.htm)\n静态变量引起内存泄露\n使用Application的Context\n及时关闭资源\n使用Bitmap及时调用recycle()\n对Adapter进行优化\n代码“微优化”\n5. [使用软引用和弱引用](http://mobile.51cto.com/abased-410795.htm)\n6. [Android 中的Activity、Window、View之间的关系](http://www.cnblogs.com/kest/p/5141817.html)\nActivity在onCreate时调用attach方法，在attach方法中会创建window对象。window对象创建时并没有创建 DocerView 对象。用户在Activity中调用setContentView,然后调用window的setContentView，这时会检查DecorView是否存在，如果不存在则创建DecorView对象，然后把用户自己的 View  添加到 DecorView 中。\n7. [Activity的几种LaunchMode及使用场景](http://www.tuicool.com/articles/iIf6BbV)\n[Android关于Task的一些实践](http://blog.csdn.net/linmiansheng/article/details/24297375)\n8. [Android 设计模式之MVC模式](http://www.cnblogs.com/liqw/p/4175325.html)\nMVC模式下，系统框架的类库被划分为3种：模型（Model）、视图（View）、控制器（Controller）。模型对象负责建立数据结构和相应的行为操作处理。视图对象负责在屏幕上渲染出相应的图形信息展示给用户看。控制器对象负责截获用户的按键和屏幕触摸等事件，协调Model对象和View对象。\n　　用户与视图交互，视图接收并反馈用户的动作；视图把用户的请求传给相应的控制器，由控制器决定调用哪个模型，然后由模型调用相应的业务逻辑对用户请求进行加工处理，如果需要返回数据，模型会把相应的数据返回给控制器，由控制器调用相应的视图，最终由视图格式化和渲染返回的数据，对于返回的数据完全可以增加用户体验效果展现给用户。\n9. [教你认清MVC，MVP和MVVM](http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/)\n[如何设计MVP中的Presentation层](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0301/4018.html)\n[google 官方mvp实例的实践之mvp-databinding-Rxjava（一）](http://www.jianshu.com/p/ce1b447efc4f)\n10. [Netty 4.0在Android 上的使用，长连接断线自动重连](https://jiangchunyu.github.io/2016/08/28/Netty-4-0%E5%9C%A8Android-%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/)\n","slug":"性能优化之布局","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeom000v9xs60jnul6s1","content":"<ol>\n<li>性能优化之布局<br>重用<br>减少视图层级<br>需要时加载，懒加载布局<br>使用工具：Hierarchy View</li>\n<li>Android 性能优化方法<br>使用Dalvik提供的 dalvik.system.VMRuntime类来设置最小堆内存为例:</li>\n<li>bitmap 设置图片尺寸<br>避免 内存溢出 OutOfMemoryError的优化方法<br>options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一</li>\n<li>Android 还有一些性能优化的方法：<br>首先内存方面，可以参考 Android堆内存也可自己定义大小 和 优化Dalvik虚拟机的堆内存分配<br>基础类型上，因为Java没有实际的指针，在敏感运算方面还是要借助NDK来完成。这点比较有意思的是Google 推出NDK可能是帮助游戏开发人员，比如OpenGL ES的支持有明显的改观，本地代码操作图形界面是很必要的。<br>图形对象优化，这里要说的是Android上的Bitmap对象销毁，可以借助recycle()方法显示让GC回收一个Bitmap对象，通常对一个不用的Bitmap可以使用下面的方式。</li>\n<li><a href=\"http://mobile.51cto.com/abased-410791.htm\" target=\"_blank\" rel=\"external\">从代码角度进行优化</a><br>静态变量引起内存泄露<br>使用Application的Context<br>及时关闭资源<br>使用Bitmap及时调用recycle()<br>对Adapter进行优化<br>代码“微优化”</li>\n<li><a href=\"http://mobile.51cto.com/abased-410795.htm\" target=\"_blank\" rel=\"external\">使用软引用和弱引用</a></li>\n<li><a href=\"http://www.cnblogs.com/kest/p/5141817.html\" target=\"_blank\" rel=\"external\">Android 中的Activity、Window、View之间的关系</a><br>Activity在onCreate时调用attach方法，在attach方法中会创建window对象。window对象创建时并没有创建 DocerView 对象。用户在Activity中调用setContentView,然后调用window的setContentView，这时会检查DecorView是否存在，如果不存在则创建DecorView对象，然后把用户自己的 View  添加到 DecorView 中。</li>\n<li><a href=\"http://www.tuicool.com/articles/iIf6BbV\" target=\"_blank\" rel=\"external\">Activity的几种LaunchMode及使用场景</a><br><a href=\"http://blog.csdn.net/linmiansheng/article/details/24297375\" target=\"_blank\" rel=\"external\">Android关于Task的一些实践</a></li>\n<li><a href=\"http://www.cnblogs.com/liqw/p/4175325.html\" target=\"_blank\" rel=\"external\">Android 设计模式之MVC模式</a><br>MVC模式下，系统框架的类库被划分为3种：模型（Model）、视图（View）、控制器（Controller）。模型对象负责建立数据结构和相应的行为操作处理。视图对象负责在屏幕上渲染出相应的图形信息展示给用户看。控制器对象负责截获用户的按键和屏幕触摸等事件，协调Model对象和View对象。<br>　　用户与视图交互，视图接收并反馈用户的动作；视图把用户的请求传给相应的控制器，由控制器决定调用哪个模型，然后由模型调用相应的业务逻辑对用户请求进行加工处理，如果需要返回数据，模型会把相应的数据返回给控制器，由控制器调用相应的视图，最终由视图格式化和渲染返回的数据，对于返回的数据完全可以增加用户体验效果展现给用户。</li>\n<li><a href=\"http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/\" target=\"_blank\" rel=\"external\">教你认清MVC，MVP和MVVM</a><br><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0301/4018.html\" target=\"_blank\" rel=\"external\">如何设计MVP中的Presentation层</a><br><a href=\"http://www.jianshu.com/p/ce1b447efc4f\" target=\"_blank\" rel=\"external\">google 官方mvp实例的实践之mvp-databinding-Rxjava（一）</a></li>\n<li><a href=\"https://jiangchunyu.github.io/2016/08/28/Netty-4-0%E5%9C%A8Android-%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/\" target=\"_blank\" rel=\"external\">Netty 4.0在Android 上的使用，长连接断线自动重连</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>性能优化之布局<br>重用<br>减少视图层级<br>需要时加载，懒加载布局<br>使用工具：Hierarchy View</li>\n<li>Android 性能优化方法<br>使用Dalvik提供的 dalvik.system.VMRuntime类来设置最小堆内存为例:</li>\n<li>bitmap 设置图片尺寸<br>避免 内存溢出 OutOfMemoryError的优化方法<br>options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一</li>\n<li>Android 还有一些性能优化的方法：<br>首先内存方面，可以参考 Android堆内存也可自己定义大小 和 优化Dalvik虚拟机的堆内存分配<br>基础类型上，因为Java没有实际的指针，在敏感运算方面还是要借助NDK来完成。这点比较有意思的是Google 推出NDK可能是帮助游戏开发人员，比如OpenGL ES的支持有明显的改观，本地代码操作图形界面是很必要的。<br>图形对象优化，这里要说的是Android上的Bitmap对象销毁，可以借助recycle()方法显示让GC回收一个Bitmap对象，通常对一个不用的Bitmap可以使用下面的方式。</li>\n<li><a href=\"http://mobile.51cto.com/abased-410791.htm\" target=\"_blank\" rel=\"external\">从代码角度进行优化</a><br>静态变量引起内存泄露<br>使用Application的Context<br>及时关闭资源<br>使用Bitmap及时调用recycle()<br>对Adapter进行优化<br>代码“微优化”</li>\n<li><a href=\"http://mobile.51cto.com/abased-410795.htm\" target=\"_blank\" rel=\"external\">使用软引用和弱引用</a></li>\n<li><a href=\"http://www.cnblogs.com/kest/p/5141817.html\" target=\"_blank\" rel=\"external\">Android 中的Activity、Window、View之间的关系</a><br>Activity在onCreate时调用attach方法，在attach方法中会创建window对象。window对象创建时并没有创建 DocerView 对象。用户在Activity中调用setContentView,然后调用window的setContentView，这时会检查DecorView是否存在，如果不存在则创建DecorView对象，然后把用户自己的 View  添加到 DecorView 中。</li>\n<li><a href=\"http://www.tuicool.com/articles/iIf6BbV\" target=\"_blank\" rel=\"external\">Activity的几种LaunchMode及使用场景</a><br><a href=\"http://blog.csdn.net/linmiansheng/article/details/24297375\" target=\"_blank\" rel=\"external\">Android关于Task的一些实践</a></li>\n<li><a href=\"http://www.cnblogs.com/liqw/p/4175325.html\" target=\"_blank\" rel=\"external\">Android 设计模式之MVC模式</a><br>MVC模式下，系统框架的类库被划分为3种：模型（Model）、视图（View）、控制器（Controller）。模型对象负责建立数据结构和相应的行为操作处理。视图对象负责在屏幕上渲染出相应的图形信息展示给用户看。控制器对象负责截获用户的按键和屏幕触摸等事件，协调Model对象和View对象。<br>　　用户与视图交互，视图接收并反馈用户的动作；视图把用户的请求传给相应的控制器，由控制器决定调用哪个模型，然后由模型调用相应的业务逻辑对用户请求进行加工处理，如果需要返回数据，模型会把相应的数据返回给控制器，由控制器调用相应的视图，最终由视图格式化和渲染返回的数据，对于返回的数据完全可以增加用户体验效果展现给用户。</li>\n<li><a href=\"http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/\" target=\"_blank\" rel=\"external\">教你认清MVC，MVP和MVVM</a><br><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0301/4018.html\" target=\"_blank\" rel=\"external\">如何设计MVP中的Presentation层</a><br><a href=\"http://www.jianshu.com/p/ce1b447efc4f\" target=\"_blank\" rel=\"external\">google 官方mvp实例的实践之mvp-databinding-Rxjava（一）</a></li>\n<li><a href=\"https://jiangchunyu.github.io/2016/08/28/Netty-4-0%E5%9C%A8Android-%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%96%AD%E7%BA%BF%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E/\" target=\"_blank\" rel=\"external\">Netty 4.0在Android 上的使用，长连接断线自动重连</a></li>\n</ol>\n"},{"title":"数据结构（一）","date":"2017-06-15T15:17:40.000Z","_content":"#### 什么是数据结构\n- 数据结构是数据对象、存在于该对象的实例以及组成实例的数据元素之间的关系，并且这种关系可以通过定义相关的函数来给出\n- 数据结构是抽象数据类型ADT的物理实现\n- 一个数据结构是由数据元素依据某种逻辑联系起来的，对数据元素之间逻辑关系的描述称为数据的逻辑结构。由于数据必须在计算机内存储，数据的存储结构是其在计算机内的表示，既数据的实现形式\n\n#### 基本概念\n- 数据（Data）：数据是信息的载体，其能够被计算机识别、存储和加工处理，是计算机程序加工的“原材料”。\n- 数据元素：数据元素是数据的基本单位，其也称之为元素，结点、顶点、记录等。\n- 数据项：一个元素可以由若干个数据项组成，数据项是具有独立含义的最小标识单位。数据项也可称之为字段、域、属性\n- 数据结构：是指数据间的相互关系，也就是数据的组织形式。\n\n####数据结构的内容\n- 数据的逻辑结构\n- 数据的存储结构\n- 数据的运算（检索、插入、删除、更新、排序等） \n\n#### 数据结构分类\n- 按逻辑结构分类\n    1. 线性结构\n        - 线性结构是非空集\n        - 线性结构有且仅有一个开始结点和一个终端结点\n        - 线性结构所有结点最多只有一个直接前驱结点和一个直接后继结点 \n        - 线性表、栈、队列和串等\n    2. 非线性结构\n        - 非线性结构是非空集\n        - 非线性结构的一个结点可能有多个直接前驱结点和多个直接后继结点\n        - 数组、广义表、树结构和图结构等\n- 按存储结构分类\n    1. 顺序存储结构\n        - 在一块连续的存储区域一个接着一个的存放数据\n        - 线性存储方式主要用于线性逻辑结构的数据存放\n    2. 链式存储结构\n        - 不要求逻辑上相邻的结点物理位置上相邻，结点间的逻辑关系由附加的引用字段表示。一个结点的引用字段往往指向下一个结点的存放位置。\n        - 也称链式存储结构\n    3. 索引存储结构\n        - 采用附加的索引表的方式来存储结点信息\n    4. 散列存储方式\n        - 根据结点的关键字 直接计算出该结点的存储地址的一种存储方式\n\n#### 常用数据结构\n1. 数组\n数组是一种聚合数据类型，是将具有相同类型的若干变量有序的组织在一起的计集合。\n2. 栈\n栈是一种特殊的线性表，其只能在一个表的固定端进行数据节点的插入和删除操作。\n3. 队列\n队列和栈类似也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，在表的另一端进行删除操作。\n4. 链表\n链表是一种数据元素按照链式存储结构进行存储的数据结构。\n5. 树\n树是典型的非线性结构，其中包括了n个结点的有穷集合。\n6. 图\n图是另一种非线性结构\n7. 堆\n堆是一种特殊的树形结构，我们一般讨论的是堆都是二叉树。\n8. 散列表\n散列表源自于散列函数，结构中存在关键字和T相等的记录。\n    \n","source":"_posts/数据结构（一）.md","raw":"---\ntitle: 数据结构（一）\ndate: 2017-06-15 23:17:40\ntags: [数据结构]\n---\n#### 什么是数据结构\n- 数据结构是数据对象、存在于该对象的实例以及组成实例的数据元素之间的关系，并且这种关系可以通过定义相关的函数来给出\n- 数据结构是抽象数据类型ADT的物理实现\n- 一个数据结构是由数据元素依据某种逻辑联系起来的，对数据元素之间逻辑关系的描述称为数据的逻辑结构。由于数据必须在计算机内存储，数据的存储结构是其在计算机内的表示，既数据的实现形式\n\n#### 基本概念\n- 数据（Data）：数据是信息的载体，其能够被计算机识别、存储和加工处理，是计算机程序加工的“原材料”。\n- 数据元素：数据元素是数据的基本单位，其也称之为元素，结点、顶点、记录等。\n- 数据项：一个元素可以由若干个数据项组成，数据项是具有独立含义的最小标识单位。数据项也可称之为字段、域、属性\n- 数据结构：是指数据间的相互关系，也就是数据的组织形式。\n\n####数据结构的内容\n- 数据的逻辑结构\n- 数据的存储结构\n- 数据的运算（检索、插入、删除、更新、排序等） \n\n#### 数据结构分类\n- 按逻辑结构分类\n    1. 线性结构\n        - 线性结构是非空集\n        - 线性结构有且仅有一个开始结点和一个终端结点\n        - 线性结构所有结点最多只有一个直接前驱结点和一个直接后继结点 \n        - 线性表、栈、队列和串等\n    2. 非线性结构\n        - 非线性结构是非空集\n        - 非线性结构的一个结点可能有多个直接前驱结点和多个直接后继结点\n        - 数组、广义表、树结构和图结构等\n- 按存储结构分类\n    1. 顺序存储结构\n        - 在一块连续的存储区域一个接着一个的存放数据\n        - 线性存储方式主要用于线性逻辑结构的数据存放\n    2. 链式存储结构\n        - 不要求逻辑上相邻的结点物理位置上相邻，结点间的逻辑关系由附加的引用字段表示。一个结点的引用字段往往指向下一个结点的存放位置。\n        - 也称链式存储结构\n    3. 索引存储结构\n        - 采用附加的索引表的方式来存储结点信息\n    4. 散列存储方式\n        - 根据结点的关键字 直接计算出该结点的存储地址的一种存储方式\n\n#### 常用数据结构\n1. 数组\n数组是一种聚合数据类型，是将具有相同类型的若干变量有序的组织在一起的计集合。\n2. 栈\n栈是一种特殊的线性表，其只能在一个表的固定端进行数据节点的插入和删除操作。\n3. 队列\n队列和栈类似也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，在表的另一端进行删除操作。\n4. 链表\n链表是一种数据元素按照链式存储结构进行存储的数据结构。\n5. 树\n树是典型的非线性结构，其中包括了n个结点的有穷集合。\n6. 图\n图是另一种非线性结构\n7. 堆\n堆是一种特殊的树形结构，我们一般讨论的是堆都是二叉树。\n8. 散列表\n散列表源自于散列函数，结构中存在关键字和T相等的记录。\n    \n","slug":"数据结构（一）","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeop000x9xs686nnd0dn","content":"<h4 id=\"什么是数据结构\"><a href=\"#什么是数据结构\" class=\"headerlink\" title=\"什么是数据结构\"></a>什么是数据结构</h4><ul>\n<li>数据结构是数据对象、存在于该对象的实例以及组成实例的数据元素之间的关系，并且这种关系可以通过定义相关的函数来给出</li>\n<li>数据结构是抽象数据类型ADT的物理实现</li>\n<li>一个数据结构是由数据元素依据某种逻辑联系起来的，对数据元素之间逻辑关系的描述称为数据的逻辑结构。由于数据必须在计算机内存储，数据的存储结构是其在计算机内的表示，既数据的实现形式</li>\n</ul>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ul>\n<li>数据（Data）：数据是信息的载体，其能够被计算机识别、存储和加工处理，是计算机程序加工的“原材料”。</li>\n<li>数据元素：数据元素是数据的基本单位，其也称之为元素，结点、顶点、记录等。</li>\n<li>数据项：一个元素可以由若干个数据项组成，数据项是具有独立含义的最小标识单位。数据项也可称之为字段、域、属性</li>\n<li>数据结构：是指数据间的相互关系，也就是数据的组织形式。</li>\n</ul>\n<p>####数据结构的内容</p>\n<ul>\n<li>数据的逻辑结构</li>\n<li>数据的存储结构</li>\n<li>数据的运算（检索、插入、删除、更新、排序等） </li>\n</ul>\n<h4 id=\"数据结构分类\"><a href=\"#数据结构分类\" class=\"headerlink\" title=\"数据结构分类\"></a>数据结构分类</h4><ul>\n<li>按逻辑结构分类<ol>\n<li>线性结构<ul>\n<li>线性结构是非空集</li>\n<li>线性结构有且仅有一个开始结点和一个终端结点</li>\n<li>线性结构所有结点最多只有一个直接前驱结点和一个直接后继结点 </li>\n<li>线性表、栈、队列和串等</li>\n</ul>\n</li>\n<li>非线性结构<ul>\n<li>非线性结构是非空集</li>\n<li>非线性结构的一个结点可能有多个直接前驱结点和多个直接后继结点</li>\n<li>数组、广义表、树结构和图结构等</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>按存储结构分类<ol>\n<li>顺序存储结构<ul>\n<li>在一块连续的存储区域一个接着一个的存放数据</li>\n<li>线性存储方式主要用于线性逻辑结构的数据存放</li>\n</ul>\n</li>\n<li>链式存储结构<ul>\n<li>不要求逻辑上相邻的结点物理位置上相邻，结点间的逻辑关系由附加的引用字段表示。一个结点的引用字段往往指向下一个结点的存放位置。</li>\n<li>也称链式存储结构</li>\n</ul>\n</li>\n<li>索引存储结构<ul>\n<li>采用附加的索引表的方式来存储结点信息</li>\n</ul>\n</li>\n<li>散列存储方式<ul>\n<li>根据结点的关键字 直接计算出该结点的存储地址的一种存储方式</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"常用数据结构\"><a href=\"#常用数据结构\" class=\"headerlink\" title=\"常用数据结构\"></a>常用数据结构</h4><ol>\n<li>数组<br>数组是一种聚合数据类型，是将具有相同类型的若干变量有序的组织在一起的计集合。</li>\n<li>栈<br>栈是一种特殊的线性表，其只能在一个表的固定端进行数据节点的插入和删除操作。</li>\n<li>队列<br>队列和栈类似也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，在表的另一端进行删除操作。</li>\n<li>链表<br>链表是一种数据元素按照链式存储结构进行存储的数据结构。</li>\n<li>树<br>树是典型的非线性结构，其中包括了n个结点的有穷集合。</li>\n<li>图<br>图是另一种非线性结构</li>\n<li>堆<br>堆是一种特殊的树形结构，我们一般讨论的是堆都是二叉树。</li>\n<li>散列表<br>散列表源自于散列函数，结构中存在关键字和T相等的记录。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是数据结构\"><a href=\"#什么是数据结构\" class=\"headerlink\" title=\"什么是数据结构\"></a>什么是数据结构</h4><ul>\n<li>数据结构是数据对象、存在于该对象的实例以及组成实例的数据元素之间的关系，并且这种关系可以通过定义相关的函数来给出</li>\n<li>数据结构是抽象数据类型ADT的物理实现</li>\n<li>一个数据结构是由数据元素依据某种逻辑联系起来的，对数据元素之间逻辑关系的描述称为数据的逻辑结构。由于数据必须在计算机内存储，数据的存储结构是其在计算机内的表示，既数据的实现形式</li>\n</ul>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ul>\n<li>数据（Data）：数据是信息的载体，其能够被计算机识别、存储和加工处理，是计算机程序加工的“原材料”。</li>\n<li>数据元素：数据元素是数据的基本单位，其也称之为元素，结点、顶点、记录等。</li>\n<li>数据项：一个元素可以由若干个数据项组成，数据项是具有独立含义的最小标识单位。数据项也可称之为字段、域、属性</li>\n<li>数据结构：是指数据间的相互关系，也就是数据的组织形式。</li>\n</ul>\n<p>####数据结构的内容</p>\n<ul>\n<li>数据的逻辑结构</li>\n<li>数据的存储结构</li>\n<li>数据的运算（检索、插入、删除、更新、排序等） </li>\n</ul>\n<h4 id=\"数据结构分类\"><a href=\"#数据结构分类\" class=\"headerlink\" title=\"数据结构分类\"></a>数据结构分类</h4><ul>\n<li>按逻辑结构分类<ol>\n<li>线性结构<ul>\n<li>线性结构是非空集</li>\n<li>线性结构有且仅有一个开始结点和一个终端结点</li>\n<li>线性结构所有结点最多只有一个直接前驱结点和一个直接后继结点 </li>\n<li>线性表、栈、队列和串等</li>\n</ul>\n</li>\n<li>非线性结构<ul>\n<li>非线性结构是非空集</li>\n<li>非线性结构的一个结点可能有多个直接前驱结点和多个直接后继结点</li>\n<li>数组、广义表、树结构和图结构等</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>按存储结构分类<ol>\n<li>顺序存储结构<ul>\n<li>在一块连续的存储区域一个接着一个的存放数据</li>\n<li>线性存储方式主要用于线性逻辑结构的数据存放</li>\n</ul>\n</li>\n<li>链式存储结构<ul>\n<li>不要求逻辑上相邻的结点物理位置上相邻，结点间的逻辑关系由附加的引用字段表示。一个结点的引用字段往往指向下一个结点的存放位置。</li>\n<li>也称链式存储结构</li>\n</ul>\n</li>\n<li>索引存储结构<ul>\n<li>采用附加的索引表的方式来存储结点信息</li>\n</ul>\n</li>\n<li>散列存储方式<ul>\n<li>根据结点的关键字 直接计算出该结点的存储地址的一种存储方式</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"常用数据结构\"><a href=\"#常用数据结构\" class=\"headerlink\" title=\"常用数据结构\"></a>常用数据结构</h4><ol>\n<li>数组<br>数组是一种聚合数据类型，是将具有相同类型的若干变量有序的组织在一起的计集合。</li>\n<li>栈<br>栈是一种特殊的线性表，其只能在一个表的固定端进行数据节点的插入和删除操作。</li>\n<li>队列<br>队列和栈类似也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，在表的另一端进行删除操作。</li>\n<li>链表<br>链表是一种数据元素按照链式存储结构进行存储的数据结构。</li>\n<li>树<br>树是典型的非线性结构，其中包括了n个结点的有穷集合。</li>\n<li>图<br>图是另一种非线性结构</li>\n<li>堆<br>堆是一种特殊的树形结构，我们一般讨论的是堆都是二叉树。</li>\n<li>散列表<br>散列表源自于散列函数，结构中存在关键字和T相等的记录。</li>\n</ol>\n"},{"title":"数据结构之线性表","date":"2017-06-18T15:19:52.000Z","_content":"#### 什么是线性表\n线性表就是由n（n>0）个数据元素a1,a2....组成的有限序列\n- 数据元素的个数为n，表长度，当n=0时为空表\n- 一个线性表为非空表，既n>0，则可以简单记为（a1,a2....,an)\n- 数据元素ai表示了各个元素，在不同场合含义不同\n逻辑结构特点\n- 有且仅有一个开始结点a1,没有直接前驱结点,有且仅有一个后继结点a2\n- 有且仅有一个终结点an,没有直接后继结点，有且仅有一个前驱结点an-1\n- 其余内部结点ai（2<=i<=n-1）都有且仅有一个前驱结点和一个后继结点\n- 同一个线性表，各个数据元素ai必须具有相同的数据类型\n\n#### 线性表的基本运算\n1. 初始化\n2. 计算表表长\n3. 获取结点\n4. 查找结点\n5. 插入结点\n6. 删除结点\n\n#### 顺序表\n1. 顺序表就是按照顺序存储方式存储的线性表，该线性表的结点按照逻辑次依次存放在计算机的一组连续的存储单元中\n2. 结点ai存储地址的LOC(ai)计算式：LOC(ai)=a1+(i-1)*c  (0<=i<=n)\n3. 重点\n    - 插入结点：先判断结点数量是否已满，以及插入结点序号是否正确，满足，将顺序表的数据后移，同时插入节点，更新结点数量表长度\n    - 删除结点：先判断待删除结点序号是否正确，然后开始移动数据，并更新结点数量\n4. 顺序表缺点\n    - 在插入和删除节点的时候，往往需要移动大量的数据\n    - 如果表比较大，有时比较难分配足够的连续存储空间，往往导致内存分配失败，而无法存储\n\n#### 链表结构\n1. 链表结构是一种动态存储分配的结构形式，可以根据需要动态申请内存单元\n2. 链表中每个结点都包含如下两部分\n    - 数据部分，保存的是该节点的实际数据\n    - 地址部分，保存的是下一个节点的地址\n3. 采用引用来指示下一个数据的地址，因此在链表结构中，逻辑上相邻的结点在内存中并不一定相邻，逻辑上相邻关系通过地址部分的引用变量来实现。\n4. 链表结构分类\n    - 单链表\n    - 双链表:每个结点包含两个引用，一个指向下一个结点，一个指向上一个结点\n    - 单循环链表:在单链表中，将终端结点的引用域null改为指向表头结点或者开始结点\n    - 多重链的循环表：将表中结点链在多个环上\n5. 重点\n    - 追加结点\n    - 头引用head\n","source":"_posts/数据结构之线性表.md","raw":"---\ntitle: 数据结构之线性表\ndate: 2017-06-18 23:19:52\ntags:\n---\n#### 什么是线性表\n线性表就是由n（n>0）个数据元素a1,a2....组成的有限序列\n- 数据元素的个数为n，表长度，当n=0时为空表\n- 一个线性表为非空表，既n>0，则可以简单记为（a1,a2....,an)\n- 数据元素ai表示了各个元素，在不同场合含义不同\n逻辑结构特点\n- 有且仅有一个开始结点a1,没有直接前驱结点,有且仅有一个后继结点a2\n- 有且仅有一个终结点an,没有直接后继结点，有且仅有一个前驱结点an-1\n- 其余内部结点ai（2<=i<=n-1）都有且仅有一个前驱结点和一个后继结点\n- 同一个线性表，各个数据元素ai必须具有相同的数据类型\n\n#### 线性表的基本运算\n1. 初始化\n2. 计算表表长\n3. 获取结点\n4. 查找结点\n5. 插入结点\n6. 删除结点\n\n#### 顺序表\n1. 顺序表就是按照顺序存储方式存储的线性表，该线性表的结点按照逻辑次依次存放在计算机的一组连续的存储单元中\n2. 结点ai存储地址的LOC(ai)计算式：LOC(ai)=a1+(i-1)*c  (0<=i<=n)\n3. 重点\n    - 插入结点：先判断结点数量是否已满，以及插入结点序号是否正确，满足，将顺序表的数据后移，同时插入节点，更新结点数量表长度\n    - 删除结点：先判断待删除结点序号是否正确，然后开始移动数据，并更新结点数量\n4. 顺序表缺点\n    - 在插入和删除节点的时候，往往需要移动大量的数据\n    - 如果表比较大，有时比较难分配足够的连续存储空间，往往导致内存分配失败，而无法存储\n\n#### 链表结构\n1. 链表结构是一种动态存储分配的结构形式，可以根据需要动态申请内存单元\n2. 链表中每个结点都包含如下两部分\n    - 数据部分，保存的是该节点的实际数据\n    - 地址部分，保存的是下一个节点的地址\n3. 采用引用来指示下一个数据的地址，因此在链表结构中，逻辑上相邻的结点在内存中并不一定相邻，逻辑上相邻关系通过地址部分的引用变量来实现。\n4. 链表结构分类\n    - 单链表\n    - 双链表:每个结点包含两个引用，一个指向下一个结点，一个指向上一个结点\n    - 单循环链表:在单链表中，将终端结点的引用域null改为指向表头结点或者开始结点\n    - 多重链的循环表：将表中结点链在多个环上\n5. 重点\n    - 追加结点\n    - 头引用head\n","slug":"数据结构之线性表","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeos00119xs627r8zdw4","content":"<h4 id=\"什么是线性表\"><a href=\"#什么是线性表\" class=\"headerlink\" title=\"什么是线性表\"></a>什么是线性表</h4><p>线性表就是由n（n&gt;0）个数据元素a1,a2….组成的有限序列</p>\n<ul>\n<li>数据元素的个数为n，表长度，当n=0时为空表</li>\n<li>一个线性表为非空表，既n&gt;0，则可以简单记为（a1,a2….,an)</li>\n<li>数据元素ai表示了各个元素，在不同场合含义不同<br>逻辑结构特点</li>\n<li>有且仅有一个开始结点a1,没有直接前驱结点,有且仅有一个后继结点a2</li>\n<li>有且仅有一个终结点an,没有直接后继结点，有且仅有一个前驱结点an-1</li>\n<li>其余内部结点ai（2&lt;=i&lt;=n-1）都有且仅有一个前驱结点和一个后继结点</li>\n<li>同一个线性表，各个数据元素ai必须具有相同的数据类型</li>\n</ul>\n<h4 id=\"线性表的基本运算\"><a href=\"#线性表的基本运算\" class=\"headerlink\" title=\"线性表的基本运算\"></a>线性表的基本运算</h4><ol>\n<li>初始化</li>\n<li>计算表表长</li>\n<li>获取结点</li>\n<li>查找结点</li>\n<li>插入结点</li>\n<li>删除结点</li>\n</ol>\n<h4 id=\"顺序表\"><a href=\"#顺序表\" class=\"headerlink\" title=\"顺序表\"></a>顺序表</h4><ol>\n<li>顺序表就是按照顺序存储方式存储的线性表，该线性表的结点按照逻辑次依次存放在计算机的一组连续的存储单元中</li>\n<li>结点ai存储地址的LOC(ai)计算式：LOC(ai)=a1+(i-1)*c  (0&lt;=i&lt;=n)</li>\n<li>重点<ul>\n<li>插入结点：先判断结点数量是否已满，以及插入结点序号是否正确，满足，将顺序表的数据后移，同时插入节点，更新结点数量表长度</li>\n<li>删除结点：先判断待删除结点序号是否正确，然后开始移动数据，并更新结点数量</li>\n</ul>\n</li>\n<li>顺序表缺点<ul>\n<li>在插入和删除节点的时候，往往需要移动大量的数据</li>\n<li>如果表比较大，有时比较难分配足够的连续存储空间，往往导致内存分配失败，而无法存储</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"链表结构\"><a href=\"#链表结构\" class=\"headerlink\" title=\"链表结构\"></a>链表结构</h4><ol>\n<li>链表结构是一种动态存储分配的结构形式，可以根据需要动态申请内存单元</li>\n<li>链表中每个结点都包含如下两部分<ul>\n<li>数据部分，保存的是该节点的实际数据</li>\n<li>地址部分，保存的是下一个节点的地址</li>\n</ul>\n</li>\n<li>采用引用来指示下一个数据的地址，因此在链表结构中，逻辑上相邻的结点在内存中并不一定相邻，逻辑上相邻关系通过地址部分的引用变量来实现。</li>\n<li>链表结构分类<ul>\n<li>单链表</li>\n<li>双链表:每个结点包含两个引用，一个指向下一个结点，一个指向上一个结点</li>\n<li>单循环链表:在单链表中，将终端结点的引用域null改为指向表头结点或者开始结点</li>\n<li>多重链的循环表：将表中结点链在多个环上</li>\n</ul>\n</li>\n<li>重点<ul>\n<li>追加结点</li>\n<li>头引用head</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是线性表\"><a href=\"#什么是线性表\" class=\"headerlink\" title=\"什么是线性表\"></a>什么是线性表</h4><p>线性表就是由n（n&gt;0）个数据元素a1,a2….组成的有限序列</p>\n<ul>\n<li>数据元素的个数为n，表长度，当n=0时为空表</li>\n<li>一个线性表为非空表，既n&gt;0，则可以简单记为（a1,a2….,an)</li>\n<li>数据元素ai表示了各个元素，在不同场合含义不同<br>逻辑结构特点</li>\n<li>有且仅有一个开始结点a1,没有直接前驱结点,有且仅有一个后继结点a2</li>\n<li>有且仅有一个终结点an,没有直接后继结点，有且仅有一个前驱结点an-1</li>\n<li>其余内部结点ai（2&lt;=i&lt;=n-1）都有且仅有一个前驱结点和一个后继结点</li>\n<li>同一个线性表，各个数据元素ai必须具有相同的数据类型</li>\n</ul>\n<h4 id=\"线性表的基本运算\"><a href=\"#线性表的基本运算\" class=\"headerlink\" title=\"线性表的基本运算\"></a>线性表的基本运算</h4><ol>\n<li>初始化</li>\n<li>计算表表长</li>\n<li>获取结点</li>\n<li>查找结点</li>\n<li>插入结点</li>\n<li>删除结点</li>\n</ol>\n<h4 id=\"顺序表\"><a href=\"#顺序表\" class=\"headerlink\" title=\"顺序表\"></a>顺序表</h4><ol>\n<li>顺序表就是按照顺序存储方式存储的线性表，该线性表的结点按照逻辑次依次存放在计算机的一组连续的存储单元中</li>\n<li>结点ai存储地址的LOC(ai)计算式：LOC(ai)=a1+(i-1)*c  (0&lt;=i&lt;=n)</li>\n<li>重点<ul>\n<li>插入结点：先判断结点数量是否已满，以及插入结点序号是否正确，满足，将顺序表的数据后移，同时插入节点，更新结点数量表长度</li>\n<li>删除结点：先判断待删除结点序号是否正确，然后开始移动数据，并更新结点数量</li>\n</ul>\n</li>\n<li>顺序表缺点<ul>\n<li>在插入和删除节点的时候，往往需要移动大量的数据</li>\n<li>如果表比较大，有时比较难分配足够的连续存储空间，往往导致内存分配失败，而无法存储</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"链表结构\"><a href=\"#链表结构\" class=\"headerlink\" title=\"链表结构\"></a>链表结构</h4><ol>\n<li>链表结构是一种动态存储分配的结构形式，可以根据需要动态申请内存单元</li>\n<li>链表中每个结点都包含如下两部分<ul>\n<li>数据部分，保存的是该节点的实际数据</li>\n<li>地址部分，保存的是下一个节点的地址</li>\n</ul>\n</li>\n<li>采用引用来指示下一个数据的地址，因此在链表结构中，逻辑上相邻的结点在内存中并不一定相邻，逻辑上相邻关系通过地址部分的引用变量来实现。</li>\n<li>链表结构分类<ul>\n<li>单链表</li>\n<li>双链表:每个结点包含两个引用，一个指向下一个结点，一个指向上一个结点</li>\n<li>单循环链表:在单链表中，将终端结点的引用域null改为指向表头结点或者开始结点</li>\n<li>多重链的循环表：将表中结点链在多个环上</li>\n</ul>\n</li>\n<li>重点<ul>\n<li>追加结点</li>\n<li>头引用head</li>\n</ul>\n</li>\n</ol>\n"},{"title":"数据传输加密——非对称加密算法RSA+对称算法AES","date":"2017-04-29T15:52:12.000Z","_content":"### 数据传输加密\n&emsp;&emsp;在开发应用过程中，客户端与服务端经常需要进行数据传输，涉及到重要隐私信息时，开发者自然会想到对其进行加密，即使传输过程中被“有心人”截取，也不会将信息泄露。对于加密算法，相信不少开发者也有所耳闻，比如MD5加密，Base64加密，DES加密，AES加密，RSA加密等等。在这里我主要向大家介绍一下我在开发过程中使用到的加密算法，RSA加密算法+AES加密算法。简单地介绍一下这两种算法吧。\n\n### RSA\n\n&emsp;&emsp;之所以叫RSA算法，是因为算法的三位发明者RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准，主要的算法原理就不多加介绍，如果对此感兴趣的话，建议去百度一下RSA算法。需要了解的是RSA算法属于非对称加密算法，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。简单的说是“公钥加密，私钥解密；私钥加密，公钥解密”。\n\n### AES\n\n &emsp;&emsp;高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。\n\n### 为什么要结合使用这两种算法\n&emsp;&emsp;如果不清楚非对称算法和对称算法，也许你会问，为什么要结合使用这两种算法，单纯使用一种算法不行吗？这就要结合不同的场景和需求了。\n\n&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密的情况\n&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密，例如绑定银行卡的时候，需要传递用户的银行卡号，手机号等重要信息，客户端这边就需要对这些重要信息进行加密，使用RSA公钥加密，服务端使用RSA解密，然后返回一些普通信息，比如状态码code,提示信息msg,提示操作是成功还是失败。这种场景下，仅仅使用RSA加密是可以的。\n\n&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密的情况\n&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密,例如客户端登录的时候，传递用户名和密码等资料，需要进行加密，服务端验证登录信息后，返回令牌token需要进行加密，客户端解密后保存。此时就需要结合这两种算法了。至于整个流程是怎样的，在下面会慢慢通过例子向你介绍，因为如果一开始就这么多文字类的操作，可能会让读者感到一头雾水。\n\n### 使用RSA加密和解密\n产生公钥和私钥：产生RSA公钥和密钥的方法有很多，在这里我直接使用我封装好的方法产生，都最后我会将两个算法的工具类赠送给大家。\n\n````\n/**\n * 生成公钥和私钥\n * \n * @throws Exception\n * \n */\npublic static void getKeys() throws Exception {\n    KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(\"RSA\");\n    keyPairGen.initialize(1024);\n    KeyPair keyPair = keyPairGen.generateKeyPair();\n    RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n    RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n\n    String publicKeyStr = getPublicKeyStr(publicKey);\n    String privateKeyStr = getPrivateKeyStr(privateKey);\n\n    System.out.println(\"公钥\\r\\n\" + publicKeyStr);\n    System.out.println(\"私钥\\r\\n\" + privateKeyStr);\n}\n\npublic static String getPrivateKeyStr(PrivateKey privateKey)\n        throws Exception {\n    return new String(Base64Utils.encode(privateKey.getEncoded()));\n}\n\npublic static String getPublicKeyStr(PublicKey publicKey) throws Exception {\n    return new String(Base64Utils.encode(publicKey.getEncoded()));\n}\n````\n公匙\n````\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCRQZ5O/AOAjeYAaSFf6Rjhqovws78I716I9oGF7WxCIPmcaUa1YuyLOncCCuPsaw69+RMWjdbOBp8hd4PPM/d4mKTOVEYUE0SfxhhDTZaM5CzQEUXUyXy7icQTGR5wBjrbjU1yHCKOf5PJJZZQWB06husSFZ40TdL7FdlBpZ1u1QIDAQAB\n````\n私钥\n````\nMIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJFBnk78A4CN5gBpIV/pGOGqi/CzvwjvXoj2gYXtbEIg+ZxpRrVi7Is6dwIK4+xrDr35ExaN1s4GnyF3g88z93iYpM5URhQTRJ/GGENNlozkLNARRdTJfLuJxBMZHnAGOtuNTXIcIo5/k8klllBYHTqG6xIVnjRN0vsV2UGlnW7VAgMBAAECgYBMoT9xD8aRNUrXgJ7YyFIWCzEUZN8tSYqn2tPt4ZkxMdA9UdS5sFx1/vv1meUwPjJiylnlliJyQlAFCdYBo7qzmib8+3Q8EU3MDP9bNlpxxC1go57/q/TbaymWyOk3pK2VXaX+8vQmllgRZMQRi2JFBHVoep1f1x7lSsf2TpipgQJBANJlO+UDmync9X/1YdrVaDOi4o7g3w9u1eVq9B01+WklAP3bvxIoBRI97HlDPKHx+CZXeODx1xj0xPOK3HUz5FECQQCwvdagPPtWHhHx0boPF/s4ZrTUIH04afuePUuwKTQQRijnl0eb2idBe0z2VAH1utPps/p4SpuT3HI3PJJ8MlVFAkAFypuXdj3zLQ3k89A5wd4Ybcdmv3HkbtyccBFALJgs+MPKOR5NVaSuF95GiD9HBe4awBWnu4B8Q2CYg54F6+PBAkBKNgvukGyARnQGc6eKOumTTxzSjSnHDElIsjgbqdFgm/UE+TJqMHmXNyyjqbaA9YeRc67R35HfzgpvQxHG8GN5AkEAxSKOlfACUCQ/CZJovETMmaUDas463hbrUznp71uRMk8RP7DY/lBnGGMeUeeZLIVK5X2Ngcp9nJQSKWCGtpnfLQ==\n````\n\n&emsp;&emsp;很明显，公钥字符串长度比较短，私钥的比较长。生成完密钥后，公钥可以存放在客户端，即使被别人知道公钥，也是没有问题的；私钥则一定要保存在服务端。如果到时公司面临人事变动，避免私钥被离职人员泄露，可以重新生成公钥和密钥。\n\n使用公钥加密，私钥解密\n![Alt text](http://i.imgur.com/EzSYTst.png \"Optional title\")\n这里在客户端模拟加密的情况，对字符串”Beyond黄家驹”使用RSA加密，调用RSAUtils的encryptByPublicKey()方法，输出结果为：\n````\n密文: BRFjf3tUqRqlwuP5JtzxZinf7lp+AHuHM9JSabM5BNFDxuUe9+uuO6RpCHVH5PibifqQHzGNsyZn1G9QcIENT9Tbm+PZwAbNUlMPZRDBU1FSnOtY8dBdeW/lJdnY9sJVwNvIBnOLQk66hxRh6R2149dwlgdsGUpWMOMBzcP3vsU=\n````\n在服务端，可以使用RSAUtils的decryptByPrivateKey()方法进行解密，现在模拟服务端解密\n![Alt text](http://i.imgur.com/oNox5Ma.png \"Optional title\")\n&emsp;&emsp;在这里虽然没有完全模拟数据传输过程，比如说客户端发起一个网络请求，传递参数给服务端，服务端接收参数并进行处理，也是为了让大家可以更加容易明白，所以这里只是进行简单的模拟。可以看到Android客户端端和Java服务端的RSA加密解密算法是可以互通的，原因是他们所使用到的base64加密类是一致的，所以才可以实现加密和解密的算法互通。\n![Alt text](http://i.imgur.com/lLgQbab.png \"Optional title\")\n![Alt text](http://i.imgur.com/lLgQbab.png \"Optional title\")\n&emsp;&emsp;使用到的jar包都是javabase64-1.3.1.jar,相信不少人都知道，java中有自带的Base64算法类，但是安卓中却没有，之前出现的情况是，使用的Base64类不统一，比如在安卓客户端开发使用的Base64算法是使用第三方提供的jar包，而java服务端中使用的是JDK自带的Base64,导致从客户端传过来的密文，服务端解析出错。\n\n&emsp;&emsp;上面的例子展示了客户端使用公钥加密，服务端使用私钥解密的过程。也许你会这么想，既然可以如此，那服务端那边信息也可以通过RSA加密后，传递加密信息过来，客户端进行解密。但是，这样做，显示是不安全的。原因是，由于客户端并没有保存私钥，只有公钥，只可以服务端进行私钥加密，客户端进行公钥解密，但由于公钥是公开，别人也可以获取到公钥，如果信息被他们截取，他们同样可以通过公钥进行解密，那么这样子加密，就毫无意义了，所以这个时候，就要结合对称算法，实现客户端与服务端之前的安全通信了。\n\n使用AES加密解密\n加密\n![Alt text](http://i.imgur.com/WgX5ss7.png \"Optional title\")\n模拟客户端进行AES加密，我们通过调用AESUtils中的generateKey()方法，随机产生一个密钥，用于对数据进行加密。输出的结果为：\n````\n密钥: 6446c69c0f914a57\n密文: GECDQOsc22yV48hdJENTMg==\n````\n\n解密\n&emsp;&emsp;模拟服务端进行AES解密，由于AES属于对称算法，加密和解密需要使用同一把密钥，所以，服务端要解密传递过来的内容，就需要密钥 + 密文。这里模拟一下服务端解密。\n![Alt text](http://i.imgur.com/NXLPGwG.png \"Optional title\")\n&emsp;&emsp;到这里也许你会问，客户端使用AES进行加密，服务端要进行解密的话，需要用到产生的密钥，那密钥必须从客户端传输到服务端，如果不对密钥进行加密，那加密就没有意义了。所以这里终于谈到了重点，RSA算法+AES算法结合使用。\n\nRSA算法+AES算法的使用\n&emsp;&emsp;举一个简单的例子来说明一下吧，例如实名认证功能，需要传递用户真实姓名和身份证号，对于这种重要信息，需要进行加密处理。\n\n客户端使用RSA + AES对重要信息进行加密\n客户端加密过程主要分为以下三个步骤：\n\n1. 客户端随机产生AES的密钥；\n\n2. 对身份证信息（重要信息）进行AES加密；\n\n3. 通过使用RSA对AES密钥进行公钥加密。\n![Alt text](http://i.imgur.com/8c2YKWN.png \"Optional title\")\n\n&emsp;&emsp;这样在传输的过程中，即时加密后的AES密钥被别人截取，对其也无济于事，因为他并不知道RSA的私钥，无法解密得到原本的AES密钥，就无法解密用AES加密后的重要信息。\n\n服务端使用RSA + AES对重要信息进行解密\n\n服务端解密过程主要分为以下两个步骤：\n\n1. 对加密后的AES密钥进行RSA私钥解密，拿到密钥原文；\n\n2. 对加密后的重要信息进行AES解密，拿到原始内容。\n![Alt text](http://i.imgur.com/kVrEvsu.png \"Optional title\")\n\n&emsp;&emsp;现实开发中，服务端有时也需要向客户端传递重要信息，比如登录的时候，返回token给客户端，作为令牌，这个令牌就需要进行加密，原理也是差不多的，比上面多一个步骤而已，就是将解密后的AES密钥，对将要传递给客户端的数据token进行AES加密，返回给客户端，由于客户端和服务端都已经拿到同一把AES钥匙，所以客户端可以解密服务端返回的加密后的数据。如果客户端想要将令牌进行保存，则需要使用自己定义的默认的AES密钥进行加密后保存，需要使用的时候传入默认密钥和密文，解密后得到原token。\n\n&emsp;&emsp;上面提及到客户端加密，服务端返回数据不加密的情况，上面说到仅仅使用RSA是可以，但是还是建议同时使用这两种算法，即产生一个AES密钥，使用RSA对该密钥进行公钥加密，对重要信息进行AES加密，服务端通过RSA私钥解密拿到AES密钥，再对加密后的重要信息进行解密。如果仅仅使用RSA，服务端只通过RSA解密，这样会对于性能会有所影响，原因是RSA的解密耗时约等于AES解密耗时的100倍，所以如果每个重要信息都只通过RSA加密和解密，则会影响服务端系统的性能，所以建议两种算法一起使用。\n\n同时还有相应的JS版RSA和AES算法，使用方式也差不多，在这里简单演示一下：\n\n````\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>RSA+AES.html</title>\n\n    <meta name=\"keywords\" content=\"keyword1,keyword2,keyword3\">\n    <meta name=\"description\" content=\"this is my page\">\n    <meta name=\"content-type\" content=\"text/html; charset=UTF-8\">\n    <script type=\"text/javascript\" src=\"./js/rsa.js\"></script>\n    <script type=\"text/javascript\" src=\"./js/aes.js\"></script>\n    <script type=\"text/javascript\">\n        var key = getKey();//随机产生AES密钥\n        var encryptKey = RSA(key);//对AES密钥进行RSA加密\n        console.log(\"encryptKey: \" + encryptKey);\n\n        //测试AES加密和解密\n        var cipherText = AESEnc(key,\"123456\");\n        var plainText = AESDec(key,cipherText);\n        console.log(\"密文: \" + cipherText);\n        console.log(\"明文: \" + plainText);\n    </script>\n  </head>\n\n  <body>\n    This is my HTML page. <br>\n  </body>\n</html>\n````\n打开页面后，查看控制台输出：\n![Alt text](http://i.imgur.com/PyU0b3r.png \"Optional title\")\n同时，模拟服务端解密，运行结果如下：\n![Alt text](http://i.imgur.com/3VrRv3d.png \"Optional title\")\n\n需要注意的是:\n\n1.RSAUtils中配置公钥和密钥，可以使用getKeys()方法产生。如果是客户端，则无须配置私钥，把没有私钥的RSAUtils放到客户端，因为仅需要用到公钥加密的方法。\n\n2.AESUtils中配置偏移量IV_STRING；\n\n3.rsa.js中最底部配置公钥，须和上面RSAUtils配置的公钥一致；\n\n4.aes.js中的底部var iv = CryptoJS.enc.Utf8.parse(“16-Bytes–String”); //加密向量中，替换里面的字符串，加密向量须和 \n是上面的AESUtils中的偏移量一致。\n\n各种语言的加密的处理方式有所差异，所以我们需要因地制宜。了解此加密的思想方法即可\n1. [php 和 java RSA 对称加密互通的问题](http://blog.csdn.net/treesky/article/details/49422645)\n2. [php与java通用AES加密解密算法](http://www.cnblogs.com/yipu/articles/3871576.html)\n3. [Android错误解决：java.lang.NoSuchMethodError: No static method encodeBase64String](http://blog.csdn.net/pbm863521/article/details/54023009)\n","source":"_posts/数据传输加密——非对称加密算法RSA-对称算法AES.md","raw":"---\ntitle: 数据传输加密——非对称加密算法RSA+对称算法AES\ndate: 2017-04-29 23:52:12\ntags: [安全、Android]\ncategory: \"安全\"\n---\n### 数据传输加密\n&emsp;&emsp;在开发应用过程中，客户端与服务端经常需要进行数据传输，涉及到重要隐私信息时，开发者自然会想到对其进行加密，即使传输过程中被“有心人”截取，也不会将信息泄露。对于加密算法，相信不少开发者也有所耳闻，比如MD5加密，Base64加密，DES加密，AES加密，RSA加密等等。在这里我主要向大家介绍一下我在开发过程中使用到的加密算法，RSA加密算法+AES加密算法。简单地介绍一下这两种算法吧。\n\n### RSA\n\n&emsp;&emsp;之所以叫RSA算法，是因为算法的三位发明者RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准，主要的算法原理就不多加介绍，如果对此感兴趣的话，建议去百度一下RSA算法。需要了解的是RSA算法属于非对称加密算法，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。简单的说是“公钥加密，私钥解密；私钥加密，公钥解密”。\n\n### AES\n\n &emsp;&emsp;高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。\n\n### 为什么要结合使用这两种算法\n&emsp;&emsp;如果不清楚非对称算法和对称算法，也许你会问，为什么要结合使用这两种算法，单纯使用一种算法不行吗？这就要结合不同的场景和需求了。\n\n&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密的情况\n&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密，例如绑定银行卡的时候，需要传递用户的银行卡号，手机号等重要信息，客户端这边就需要对这些重要信息进行加密，使用RSA公钥加密，服务端使用RSA解密，然后返回一些普通信息，比如状态码code,提示信息msg,提示操作是成功还是失败。这种场景下，仅仅使用RSA加密是可以的。\n\n&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密的情况\n&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密,例如客户端登录的时候，传递用户名和密码等资料，需要进行加密，服务端验证登录信息后，返回令牌token需要进行加密，客户端解密后保存。此时就需要结合这两种算法了。至于整个流程是怎样的，在下面会慢慢通过例子向你介绍，因为如果一开始就这么多文字类的操作，可能会让读者感到一头雾水。\n\n### 使用RSA加密和解密\n产生公钥和私钥：产生RSA公钥和密钥的方法有很多，在这里我直接使用我封装好的方法产生，都最后我会将两个算法的工具类赠送给大家。\n\n````\n/**\n * 生成公钥和私钥\n * \n * @throws Exception\n * \n */\npublic static void getKeys() throws Exception {\n    KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(\"RSA\");\n    keyPairGen.initialize(1024);\n    KeyPair keyPair = keyPairGen.generateKeyPair();\n    RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n    RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n\n    String publicKeyStr = getPublicKeyStr(publicKey);\n    String privateKeyStr = getPrivateKeyStr(privateKey);\n\n    System.out.println(\"公钥\\r\\n\" + publicKeyStr);\n    System.out.println(\"私钥\\r\\n\" + privateKeyStr);\n}\n\npublic static String getPrivateKeyStr(PrivateKey privateKey)\n        throws Exception {\n    return new String(Base64Utils.encode(privateKey.getEncoded()));\n}\n\npublic static String getPublicKeyStr(PublicKey publicKey) throws Exception {\n    return new String(Base64Utils.encode(publicKey.getEncoded()));\n}\n````\n公匙\n````\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCRQZ5O/AOAjeYAaSFf6Rjhqovws78I716I9oGF7WxCIPmcaUa1YuyLOncCCuPsaw69+RMWjdbOBp8hd4PPM/d4mKTOVEYUE0SfxhhDTZaM5CzQEUXUyXy7icQTGR5wBjrbjU1yHCKOf5PJJZZQWB06husSFZ40TdL7FdlBpZ1u1QIDAQAB\n````\n私钥\n````\nMIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJFBnk78A4CN5gBpIV/pGOGqi/CzvwjvXoj2gYXtbEIg+ZxpRrVi7Is6dwIK4+xrDr35ExaN1s4GnyF3g88z93iYpM5URhQTRJ/GGENNlozkLNARRdTJfLuJxBMZHnAGOtuNTXIcIo5/k8klllBYHTqG6xIVnjRN0vsV2UGlnW7VAgMBAAECgYBMoT9xD8aRNUrXgJ7YyFIWCzEUZN8tSYqn2tPt4ZkxMdA9UdS5sFx1/vv1meUwPjJiylnlliJyQlAFCdYBo7qzmib8+3Q8EU3MDP9bNlpxxC1go57/q/TbaymWyOk3pK2VXaX+8vQmllgRZMQRi2JFBHVoep1f1x7lSsf2TpipgQJBANJlO+UDmync9X/1YdrVaDOi4o7g3w9u1eVq9B01+WklAP3bvxIoBRI97HlDPKHx+CZXeODx1xj0xPOK3HUz5FECQQCwvdagPPtWHhHx0boPF/s4ZrTUIH04afuePUuwKTQQRijnl0eb2idBe0z2VAH1utPps/p4SpuT3HI3PJJ8MlVFAkAFypuXdj3zLQ3k89A5wd4Ybcdmv3HkbtyccBFALJgs+MPKOR5NVaSuF95GiD9HBe4awBWnu4B8Q2CYg54F6+PBAkBKNgvukGyARnQGc6eKOumTTxzSjSnHDElIsjgbqdFgm/UE+TJqMHmXNyyjqbaA9YeRc67R35HfzgpvQxHG8GN5AkEAxSKOlfACUCQ/CZJovETMmaUDas463hbrUznp71uRMk8RP7DY/lBnGGMeUeeZLIVK5X2Ngcp9nJQSKWCGtpnfLQ==\n````\n\n&emsp;&emsp;很明显，公钥字符串长度比较短，私钥的比较长。生成完密钥后，公钥可以存放在客户端，即使被别人知道公钥，也是没有问题的；私钥则一定要保存在服务端。如果到时公司面临人事变动，避免私钥被离职人员泄露，可以重新生成公钥和密钥。\n\n使用公钥加密，私钥解密\n![Alt text](http://i.imgur.com/EzSYTst.png \"Optional title\")\n这里在客户端模拟加密的情况，对字符串”Beyond黄家驹”使用RSA加密，调用RSAUtils的encryptByPublicKey()方法，输出结果为：\n````\n密文: BRFjf3tUqRqlwuP5JtzxZinf7lp+AHuHM9JSabM5BNFDxuUe9+uuO6RpCHVH5PibifqQHzGNsyZn1G9QcIENT9Tbm+PZwAbNUlMPZRDBU1FSnOtY8dBdeW/lJdnY9sJVwNvIBnOLQk66hxRh6R2149dwlgdsGUpWMOMBzcP3vsU=\n````\n在服务端，可以使用RSAUtils的decryptByPrivateKey()方法进行解密，现在模拟服务端解密\n![Alt text](http://i.imgur.com/oNox5Ma.png \"Optional title\")\n&emsp;&emsp;在这里虽然没有完全模拟数据传输过程，比如说客户端发起一个网络请求，传递参数给服务端，服务端接收参数并进行处理，也是为了让大家可以更加容易明白，所以这里只是进行简单的模拟。可以看到Android客户端端和Java服务端的RSA加密解密算法是可以互通的，原因是他们所使用到的base64加密类是一致的，所以才可以实现加密和解密的算法互通。\n![Alt text](http://i.imgur.com/lLgQbab.png \"Optional title\")\n![Alt text](http://i.imgur.com/lLgQbab.png \"Optional title\")\n&emsp;&emsp;使用到的jar包都是javabase64-1.3.1.jar,相信不少人都知道，java中有自带的Base64算法类，但是安卓中却没有，之前出现的情况是，使用的Base64类不统一，比如在安卓客户端开发使用的Base64算法是使用第三方提供的jar包，而java服务端中使用的是JDK自带的Base64,导致从客户端传过来的密文，服务端解析出错。\n\n&emsp;&emsp;上面的例子展示了客户端使用公钥加密，服务端使用私钥解密的过程。也许你会这么想，既然可以如此，那服务端那边信息也可以通过RSA加密后，传递加密信息过来，客户端进行解密。但是，这样做，显示是不安全的。原因是，由于客户端并没有保存私钥，只有公钥，只可以服务端进行私钥加密，客户端进行公钥解密，但由于公钥是公开，别人也可以获取到公钥，如果信息被他们截取，他们同样可以通过公钥进行解密，那么这样子加密，就毫无意义了，所以这个时候，就要结合对称算法，实现客户端与服务端之前的安全通信了。\n\n使用AES加密解密\n加密\n![Alt text](http://i.imgur.com/WgX5ss7.png \"Optional title\")\n模拟客户端进行AES加密，我们通过调用AESUtils中的generateKey()方法，随机产生一个密钥，用于对数据进行加密。输出的结果为：\n````\n密钥: 6446c69c0f914a57\n密文: GECDQOsc22yV48hdJENTMg==\n````\n\n解密\n&emsp;&emsp;模拟服务端进行AES解密，由于AES属于对称算法，加密和解密需要使用同一把密钥，所以，服务端要解密传递过来的内容，就需要密钥 + 密文。这里模拟一下服务端解密。\n![Alt text](http://i.imgur.com/NXLPGwG.png \"Optional title\")\n&emsp;&emsp;到这里也许你会问，客户端使用AES进行加密，服务端要进行解密的话，需要用到产生的密钥，那密钥必须从客户端传输到服务端，如果不对密钥进行加密，那加密就没有意义了。所以这里终于谈到了重点，RSA算法+AES算法结合使用。\n\nRSA算法+AES算法的使用\n&emsp;&emsp;举一个简单的例子来说明一下吧，例如实名认证功能，需要传递用户真实姓名和身份证号，对于这种重要信息，需要进行加密处理。\n\n客户端使用RSA + AES对重要信息进行加密\n客户端加密过程主要分为以下三个步骤：\n\n1. 客户端随机产生AES的密钥；\n\n2. 对身份证信息（重要信息）进行AES加密；\n\n3. 通过使用RSA对AES密钥进行公钥加密。\n![Alt text](http://i.imgur.com/8c2YKWN.png \"Optional title\")\n\n&emsp;&emsp;这样在传输的过程中，即时加密后的AES密钥被别人截取，对其也无济于事，因为他并不知道RSA的私钥，无法解密得到原本的AES密钥，就无法解密用AES加密后的重要信息。\n\n服务端使用RSA + AES对重要信息进行解密\n\n服务端解密过程主要分为以下两个步骤：\n\n1. 对加密后的AES密钥进行RSA私钥解密，拿到密钥原文；\n\n2. 对加密后的重要信息进行AES解密，拿到原始内容。\n![Alt text](http://i.imgur.com/kVrEvsu.png \"Optional title\")\n\n&emsp;&emsp;现实开发中，服务端有时也需要向客户端传递重要信息，比如登录的时候，返回token给客户端，作为令牌，这个令牌就需要进行加密，原理也是差不多的，比上面多一个步骤而已，就是将解密后的AES密钥，对将要传递给客户端的数据token进行AES加密，返回给客户端，由于客户端和服务端都已经拿到同一把AES钥匙，所以客户端可以解密服务端返回的加密后的数据。如果客户端想要将令牌进行保存，则需要使用自己定义的默认的AES密钥进行加密后保存，需要使用的时候传入默认密钥和密文，解密后得到原token。\n\n&emsp;&emsp;上面提及到客户端加密，服务端返回数据不加密的情况，上面说到仅仅使用RSA是可以，但是还是建议同时使用这两种算法，即产生一个AES密钥，使用RSA对该密钥进行公钥加密，对重要信息进行AES加密，服务端通过RSA私钥解密拿到AES密钥，再对加密后的重要信息进行解密。如果仅仅使用RSA，服务端只通过RSA解密，这样会对于性能会有所影响，原因是RSA的解密耗时约等于AES解密耗时的100倍，所以如果每个重要信息都只通过RSA加密和解密，则会影响服务端系统的性能，所以建议两种算法一起使用。\n\n同时还有相应的JS版RSA和AES算法，使用方式也差不多，在这里简单演示一下：\n\n````\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>RSA+AES.html</title>\n\n    <meta name=\"keywords\" content=\"keyword1,keyword2,keyword3\">\n    <meta name=\"description\" content=\"this is my page\">\n    <meta name=\"content-type\" content=\"text/html; charset=UTF-8\">\n    <script type=\"text/javascript\" src=\"./js/rsa.js\"></script>\n    <script type=\"text/javascript\" src=\"./js/aes.js\"></script>\n    <script type=\"text/javascript\">\n        var key = getKey();//随机产生AES密钥\n        var encryptKey = RSA(key);//对AES密钥进行RSA加密\n        console.log(\"encryptKey: \" + encryptKey);\n\n        //测试AES加密和解密\n        var cipherText = AESEnc(key,\"123456\");\n        var plainText = AESDec(key,cipherText);\n        console.log(\"密文: \" + cipherText);\n        console.log(\"明文: \" + plainText);\n    </script>\n  </head>\n\n  <body>\n    This is my HTML page. <br>\n  </body>\n</html>\n````\n打开页面后，查看控制台输出：\n![Alt text](http://i.imgur.com/PyU0b3r.png \"Optional title\")\n同时，模拟服务端解密，运行结果如下：\n![Alt text](http://i.imgur.com/3VrRv3d.png \"Optional title\")\n\n需要注意的是:\n\n1.RSAUtils中配置公钥和密钥，可以使用getKeys()方法产生。如果是客户端，则无须配置私钥，把没有私钥的RSAUtils放到客户端，因为仅需要用到公钥加密的方法。\n\n2.AESUtils中配置偏移量IV_STRING；\n\n3.rsa.js中最底部配置公钥，须和上面RSAUtils配置的公钥一致；\n\n4.aes.js中的底部var iv = CryptoJS.enc.Utf8.parse(“16-Bytes–String”); //加密向量中，替换里面的字符串，加密向量须和 \n是上面的AESUtils中的偏移量一致。\n\n各种语言的加密的处理方式有所差异，所以我们需要因地制宜。了解此加密的思想方法即可\n1. [php 和 java RSA 对称加密互通的问题](http://blog.csdn.net/treesky/article/details/49422645)\n2. [php与java通用AES加密解密算法](http://www.cnblogs.com/yipu/articles/3871576.html)\n3. [Android错误解决：java.lang.NoSuchMethodError: No static method encodeBase64String](http://blog.csdn.net/pbm863521/article/details/54023009)\n","slug":"数据传输加密——非对称加密算法RSA-对称算法AES","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeot00149xs6fh1czcxm","content":"<h3 id=\"数据传输加密\"><a href=\"#数据传输加密\" class=\"headerlink\" title=\"数据传输加密\"></a>数据传输加密</h3><p>&emsp;&emsp;在开发应用过程中，客户端与服务端经常需要进行数据传输，涉及到重要隐私信息时，开发者自然会想到对其进行加密，即使传输过程中被“有心人”截取，也不会将信息泄露。对于加密算法，相信不少开发者也有所耳闻，比如MD5加密，Base64加密，DES加密，AES加密，RSA加密等等。在这里我主要向大家介绍一下我在开发过程中使用到的加密算法，RSA加密算法+AES加密算法。简单地介绍一下这两种算法吧。</p>\n<h3 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h3><p>&emsp;&emsp;之所以叫RSA算法，是因为算法的三位发明者RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准，主要的算法原理就不多加介绍，如果对此感兴趣的话，建议去百度一下RSA算法。需要了解的是RSA算法属于非对称加密算法，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。简单的说是“公钥加密，私钥解密；私钥加密，公钥解密”。</p>\n<h3 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h3><p> &emsp;&emsp;高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p>\n<h3 id=\"为什么要结合使用这两种算法\"><a href=\"#为什么要结合使用这两种算法\" class=\"headerlink\" title=\"为什么要结合使用这两种算法\"></a>为什么要结合使用这两种算法</h3><p>&emsp;&emsp;如果不清楚非对称算法和对称算法，也许你会问，为什么要结合使用这两种算法，单纯使用一种算法不行吗？这就要结合不同的场景和需求了。</p>\n<p>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密的情况<br>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密，例如绑定银行卡的时候，需要传递用户的银行卡号，手机号等重要信息，客户端这边就需要对这些重要信息进行加密，使用RSA公钥加密，服务端使用RSA解密，然后返回一些普通信息，比如状态码code,提示信息msg,提示操作是成功还是失败。这种场景下，仅仅使用RSA加密是可以的。</p>\n<p>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密的情况<br>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密,例如客户端登录的时候，传递用户名和密码等资料，需要进行加密，服务端验证登录信息后，返回令牌token需要进行加密，客户端解密后保存。此时就需要结合这两种算法了。至于整个流程是怎样的，在下面会慢慢通过例子向你介绍，因为如果一开始就这么多文字类的操作，可能会让读者感到一头雾水。</p>\n<h3 id=\"使用RSA加密和解密\"><a href=\"#使用RSA加密和解密\" class=\"headerlink\" title=\"使用RSA加密和解密\"></a>使用RSA加密和解密</h3><p>产生公钥和私钥：产生RSA公钥和密钥的方法有很多，在这里我直接使用我封装好的方法产生，都最后我会将两个算法的工具类赠送给大家。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 生成公钥和私钥</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @throws Exception</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void getKeys() throws Exception &#123;</span><br><span class=\"line\">    KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class=\"line\">    keyPairGen.initialize(1024);</span><br><span class=\"line\">    KeyPair keyPair = keyPairGen.generateKeyPair();</span><br><span class=\"line\">    RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class=\"line\">    RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class=\"line\"></span><br><span class=\"line\">    String publicKeyStr = getPublicKeyStr(publicKey);</span><br><span class=\"line\">    String privateKeyStr = getPrivateKeyStr(privateKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;公钥\\r\\n&quot; + publicKeyStr);</span><br><span class=\"line\">    System.out.println(&quot;私钥\\r\\n&quot; + privateKeyStr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static String getPrivateKeyStr(PrivateKey privateKey)</span><br><span class=\"line\">        throws Exception &#123;</span><br><span class=\"line\">    return new String(Base64Utils.encode(privateKey.getEncoded()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static String getPublicKeyStr(PublicKey publicKey) throws Exception &#123;</span><br><span class=\"line\">    return new String(Base64Utils.encode(publicKey.getEncoded()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>公匙<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCRQZ5O/AOAjeYAaSFf6Rjhqovws78I716I9oGF7WxCIPmcaUa1YuyLOncCCuPsaw69+RMWjdbOBp8hd4PPM/d4mKTOVEYUE0SfxhhDTZaM5CzQEUXUyXy7icQTGR5wBjrbjU1yHCKOf5PJJZZQWB06husSFZ40TdL7FdlBpZ1u1QIDAQAB</span><br></pre></td></tr></table></figure></p>\n<p>私钥<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJFBnk78A4CN5gBpIV/pGOGqi/CzvwjvXoj2gYXtbEIg+ZxpRrVi7Is6dwIK4+xrDr35ExaN1s4GnyF3g88z93iYpM5URhQTRJ/GGENNlozkLNARRdTJfLuJxBMZHnAGOtuNTXIcIo5/k8klllBYHTqG6xIVnjRN0vsV2UGlnW7VAgMBAAECgYBMoT9xD8aRNUrXgJ7YyFIWCzEUZN8tSYqn2tPt4ZkxMdA9UdS5sFx1/vv1meUwPjJiylnlliJyQlAFCdYBo7qzmib8+3Q8EU3MDP9bNlpxxC1go57/q/TbaymWyOk3pK2VXaX+8vQmllgRZMQRi2JFBHVoep1f1x7lSsf2TpipgQJBANJlO+UDmync9X/1YdrVaDOi4o7g3w9u1eVq9B01+WklAP3bvxIoBRI97HlDPKHx+CZXeODx1xj0xPOK3HUz5FECQQCwvdagPPtWHhHx0boPF/s4ZrTUIH04afuePUuwKTQQRijnl0eb2idBe0z2VAH1utPps/p4SpuT3HI3PJJ8MlVFAkAFypuXdj3zLQ3k89A5wd4Ybcdmv3HkbtyccBFALJgs+MPKOR5NVaSuF95GiD9HBe4awBWnu4B8Q2CYg54F6+PBAkBKNgvukGyARnQGc6eKOumTTxzSjSnHDElIsjgbqdFgm/UE+TJqMHmXNyyjqbaA9YeRc67R35HfzgpvQxHG8GN5AkEAxSKOlfACUCQ/CZJovETMmaUDas463hbrUznp71uRMk8RP7DY/lBnGGMeUeeZLIVK5X2Ngcp9nJQSKWCGtpnfLQ==</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;很明显，公钥字符串长度比较短，私钥的比较长。生成完密钥后，公钥可以存放在客户端，即使被别人知道公钥，也是没有问题的；私钥则一定要保存在服务端。如果到时公司面临人事变动，避免私钥被离职人员泄露，可以重新生成公钥和密钥。</p>\n<p>使用公钥加密，私钥解密<br><img src=\"http://i.imgur.com/EzSYTst.png\" alt=\"Alt text\" title=\"Optional title\"><br>这里在客户端模拟加密的情况，对字符串”Beyond黄家驹”使用RSA加密，调用RSAUtils的encryptByPublicKey()方法，输出结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">密文: BRFjf3tUqRqlwuP5JtzxZinf7lp+AHuHM9JSabM5BNFDxuUe9+uuO6RpCHVH5PibifqQHzGNsyZn1G9QcIENT9Tbm+PZwAbNUlMPZRDBU1FSnOtY8dBdeW/lJdnY9sJVwNvIBnOLQk66hxRh6R2149dwlgdsGUpWMOMBzcP3vsU=</span><br></pre></td></tr></table></figure></p>\n<p>在服务端，可以使用RSAUtils的decryptByPrivateKey()方法进行解密，现在模拟服务端解密<br><img src=\"http://i.imgur.com/oNox5Ma.png\" alt=\"Alt text\" title=\"Optional title\"><br>&emsp;&emsp;在这里虽然没有完全模拟数据传输过程，比如说客户端发起一个网络请求，传递参数给服务端，服务端接收参数并进行处理，也是为了让大家可以更加容易明白，所以这里只是进行简单的模拟。可以看到Android客户端端和Java服务端的RSA加密解密算法是可以互通的，原因是他们所使用到的base64加密类是一致的，所以才可以实现加密和解密的算法互通。<br><img src=\"http://i.imgur.com/lLgQbab.png\" alt=\"Alt text\" title=\"Optional title\"><br><img src=\"http://i.imgur.com/lLgQbab.png\" alt=\"Alt text\" title=\"Optional title\"><br>&emsp;&emsp;使用到的jar包都是javabase64-1.3.1.jar,相信不少人都知道，java中有自带的Base64算法类，但是安卓中却没有，之前出现的情况是，使用的Base64类不统一，比如在安卓客户端开发使用的Base64算法是使用第三方提供的jar包，而java服务端中使用的是JDK自带的Base64,导致从客户端传过来的密文，服务端解析出错。</p>\n<p>&emsp;&emsp;上面的例子展示了客户端使用公钥加密，服务端使用私钥解密的过程。也许你会这么想，既然可以如此，那服务端那边信息也可以通过RSA加密后，传递加密信息过来，客户端进行解密。但是，这样做，显示是不安全的。原因是，由于客户端并没有保存私钥，只有公钥，只可以服务端进行私钥加密，客户端进行公钥解密，但由于公钥是公开，别人也可以获取到公钥，如果信息被他们截取，他们同样可以通过公钥进行解密，那么这样子加密，就毫无意义了，所以这个时候，就要结合对称算法，实现客户端与服务端之前的安全通信了。</p>\n<p>使用AES加密解密<br>加密<br><img src=\"http://i.imgur.com/WgX5ss7.png\" alt=\"Alt text\" title=\"Optional title\"><br>模拟客户端进行AES加密，我们通过调用AESUtils中的generateKey()方法，随机产生一个密钥，用于对数据进行加密。输出的结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">密钥: 6446c69c0f914a57</span><br><span class=\"line\">密文: GECDQOsc22yV48hdJENTMg==</span><br></pre></td></tr></table></figure></p>\n<p>解密<br>&emsp;&emsp;模拟服务端进行AES解密，由于AES属于对称算法，加密和解密需要使用同一把密钥，所以，服务端要解密传递过来的内容，就需要密钥 + 密文。这里模拟一下服务端解密。<br><img src=\"http://i.imgur.com/NXLPGwG.png\" alt=\"Alt text\" title=\"Optional title\"><br>&emsp;&emsp;到这里也许你会问，客户端使用AES进行加密，服务端要进行解密的话，需要用到产生的密钥，那密钥必须从客户端传输到服务端，如果不对密钥进行加密，那加密就没有意义了。所以这里终于谈到了重点，RSA算法+AES算法结合使用。</p>\n<p>RSA算法+AES算法的使用<br>&emsp;&emsp;举一个简单的例子来说明一下吧，例如实名认证功能，需要传递用户真实姓名和身份证号，对于这种重要信息，需要进行加密处理。</p>\n<p>客户端使用RSA + AES对重要信息进行加密<br>客户端加密过程主要分为以下三个步骤：</p>\n<ol>\n<li><p>客户端随机产生AES的密钥；</p>\n</li>\n<li><p>对身份证信息（重要信息）进行AES加密；</p>\n</li>\n<li><p>通过使用RSA对AES密钥进行公钥加密。<br><img src=\"http://i.imgur.com/8c2YKWN.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n</li>\n</ol>\n<p>&emsp;&emsp;这样在传输的过程中，即时加密后的AES密钥被别人截取，对其也无济于事，因为他并不知道RSA的私钥，无法解密得到原本的AES密钥，就无法解密用AES加密后的重要信息。</p>\n<p>服务端使用RSA + AES对重要信息进行解密</p>\n<p>服务端解密过程主要分为以下两个步骤：</p>\n<ol>\n<li><p>对加密后的AES密钥进行RSA私钥解密，拿到密钥原文；</p>\n</li>\n<li><p>对加密后的重要信息进行AES解密，拿到原始内容。<br><img src=\"http://i.imgur.com/kVrEvsu.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n</li>\n</ol>\n<p>&emsp;&emsp;现实开发中，服务端有时也需要向客户端传递重要信息，比如登录的时候，返回token给客户端，作为令牌，这个令牌就需要进行加密，原理也是差不多的，比上面多一个步骤而已，就是将解密后的AES密钥，对将要传递给客户端的数据token进行AES加密，返回给客户端，由于客户端和服务端都已经拿到同一把AES钥匙，所以客户端可以解密服务端返回的加密后的数据。如果客户端想要将令牌进行保存，则需要使用自己定义的默认的AES密钥进行加密后保存，需要使用的时候传入默认密钥和密文，解密后得到原token。</p>\n<p>&emsp;&emsp;上面提及到客户端加密，服务端返回数据不加密的情况，上面说到仅仅使用RSA是可以，但是还是建议同时使用这两种算法，即产生一个AES密钥，使用RSA对该密钥进行公钥加密，对重要信息进行AES加密，服务端通过RSA私钥解密拿到AES密钥，再对加密后的重要信息进行解密。如果仅仅使用RSA，服务端只通过RSA解密，这样会对于性能会有所影响，原因是RSA的解密耗时约等于AES解密耗时的100倍，所以如果每个重要信息都只通过RSA加密和解密，则会影响服务端系统的性能，所以建议两种算法一起使用。</p>\n<p>同时还有相应的JS版RSA和AES算法，使用方式也差不多，在这里简单演示一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;RSA+AES.html&lt;/title&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;meta name=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;description&quot; content=&quot;this is my page&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/rsa.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/aes.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">        var key = getKey();//随机产生AES密钥</span><br><span class=\"line\">        var encryptKey = RSA(key);//对AES密钥进行RSA加密</span><br><span class=\"line\">        console.log(&quot;encryptKey: &quot; + encryptKey);</span><br><span class=\"line\"></span><br><span class=\"line\">        //测试AES加密和解密</span><br><span class=\"line\">        var cipherText = AESEnc(key,&quot;123456&quot;);</span><br><span class=\"line\">        var plainText = AESDec(key,cipherText);</span><br><span class=\"line\">        console.log(&quot;密文: &quot; + cipherText);</span><br><span class=\"line\">        console.log(&quot;明文: &quot; + plainText);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    This is my HTML page. &lt;br&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>打开页面后，查看控制台输出：<br><img src=\"http://i.imgur.com/PyU0b3r.png\" alt=\"Alt text\" title=\"Optional title\"><br>同时，模拟服务端解密，运行结果如下：<br><img src=\"http://i.imgur.com/3VrRv3d.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>需要注意的是:</p>\n<p>1.RSAUtils中配置公钥和密钥，可以使用getKeys()方法产生。如果是客户端，则无须配置私钥，把没有私钥的RSAUtils放到客户端，因为仅需要用到公钥加密的方法。</p>\n<p>2.AESUtils中配置偏移量IV_STRING；</p>\n<p>3.rsa.js中最底部配置公钥，须和上面RSAUtils配置的公钥一致；</p>\n<p>4.aes.js中的底部var iv = CryptoJS.enc.Utf8.parse(“16-Bytes–String”); //加密向量中，替换里面的字符串，加密向量须和<br>是上面的AESUtils中的偏移量一致。</p>\n<p>各种语言的加密的处理方式有所差异，所以我们需要因地制宜。了解此加密的思想方法即可</p>\n<ol>\n<li><a href=\"http://blog.csdn.net/treesky/article/details/49422645\" target=\"_blank\" rel=\"external\">php 和 java RSA 对称加密互通的问题</a></li>\n<li><a href=\"http://www.cnblogs.com/yipu/articles/3871576.html\" target=\"_blank\" rel=\"external\">php与java通用AES加密解密算法</a></li>\n<li><a href=\"http://blog.csdn.net/pbm863521/article/details/54023009\" target=\"_blank\" rel=\"external\">Android错误解决：java.lang.NoSuchMethodError: No static method encodeBase64String</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数据传输加密\"><a href=\"#数据传输加密\" class=\"headerlink\" title=\"数据传输加密\"></a>数据传输加密</h3><p>&emsp;&emsp;在开发应用过程中，客户端与服务端经常需要进行数据传输，涉及到重要隐私信息时，开发者自然会想到对其进行加密，即使传输过程中被“有心人”截取，也不会将信息泄露。对于加密算法，相信不少开发者也有所耳闻，比如MD5加密，Base64加密，DES加密，AES加密，RSA加密等等。在这里我主要向大家介绍一下我在开发过程中使用到的加密算法，RSA加密算法+AES加密算法。简单地介绍一下这两种算法吧。</p>\n<h3 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h3><p>&emsp;&emsp;之所以叫RSA算法，是因为算法的三位发明者RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准，主要的算法原理就不多加介绍，如果对此感兴趣的话，建议去百度一下RSA算法。需要了解的是RSA算法属于非对称加密算法，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。简单的说是“公钥加密，私钥解密；私钥加密，公钥解密”。</p>\n<h3 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h3><p> &emsp;&emsp;高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p>\n<h3 id=\"为什么要结合使用这两种算法\"><a href=\"#为什么要结合使用这两种算法\" class=\"headerlink\" title=\"为什么要结合使用这两种算法\"></a>为什么要结合使用这两种算法</h3><p>&emsp;&emsp;如果不清楚非对称算法和对称算法，也许你会问，为什么要结合使用这两种算法，单纯使用一种算法不行吗？这就要结合不同的场景和需求了。</p>\n<p>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密的情况<br>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息不需加密，例如绑定银行卡的时候，需要传递用户的银行卡号，手机号等重要信息，客户端这边就需要对这些重要信息进行加密，使用RSA公钥加密，服务端使用RSA解密，然后返回一些普通信息，比如状态码code,提示信息msg,提示操作是成功还是失败。这种场景下，仅仅使用RSA加密是可以的。</p>\n<p>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密的情况<br>&emsp;&emsp;客户端传输重要信息给服务端，服务端返回的信息需加密,例如客户端登录的时候，传递用户名和密码等资料，需要进行加密，服务端验证登录信息后，返回令牌token需要进行加密，客户端解密后保存。此时就需要结合这两种算法了。至于整个流程是怎样的，在下面会慢慢通过例子向你介绍，因为如果一开始就这么多文字类的操作，可能会让读者感到一头雾水。</p>\n<h3 id=\"使用RSA加密和解密\"><a href=\"#使用RSA加密和解密\" class=\"headerlink\" title=\"使用RSA加密和解密\"></a>使用RSA加密和解密</h3><p>产生公钥和私钥：产生RSA公钥和密钥的方法有很多，在这里我直接使用我封装好的方法产生，都最后我会将两个算法的工具类赠送给大家。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 生成公钥和私钥</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @throws Exception</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void getKeys() throws Exception &#123;</span><br><span class=\"line\">    KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class=\"line\">    keyPairGen.initialize(1024);</span><br><span class=\"line\">    KeyPair keyPair = keyPairGen.generateKeyPair();</span><br><span class=\"line\">    RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class=\"line\">    RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class=\"line\"></span><br><span class=\"line\">    String publicKeyStr = getPublicKeyStr(publicKey);</span><br><span class=\"line\">    String privateKeyStr = getPrivateKeyStr(privateKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;公钥\\r\\n&quot; + publicKeyStr);</span><br><span class=\"line\">    System.out.println(&quot;私钥\\r\\n&quot; + privateKeyStr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static String getPrivateKeyStr(PrivateKey privateKey)</span><br><span class=\"line\">        throws Exception &#123;</span><br><span class=\"line\">    return new String(Base64Utils.encode(privateKey.getEncoded()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static String getPublicKeyStr(PublicKey publicKey) throws Exception &#123;</span><br><span class=\"line\">    return new String(Base64Utils.encode(publicKey.getEncoded()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>公匙<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCRQZ5O/AOAjeYAaSFf6Rjhqovws78I716I9oGF7WxCIPmcaUa1YuyLOncCCuPsaw69+RMWjdbOBp8hd4PPM/d4mKTOVEYUE0SfxhhDTZaM5CzQEUXUyXy7icQTGR5wBjrbjU1yHCKOf5PJJZZQWB06husSFZ40TdL7FdlBpZ1u1QIDAQAB</span><br></pre></td></tr></table></figure></p>\n<p>私钥<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJFBnk78A4CN5gBpIV/pGOGqi/CzvwjvXoj2gYXtbEIg+ZxpRrVi7Is6dwIK4+xrDr35ExaN1s4GnyF3g88z93iYpM5URhQTRJ/GGENNlozkLNARRdTJfLuJxBMZHnAGOtuNTXIcIo5/k8klllBYHTqG6xIVnjRN0vsV2UGlnW7VAgMBAAECgYBMoT9xD8aRNUrXgJ7YyFIWCzEUZN8tSYqn2tPt4ZkxMdA9UdS5sFx1/vv1meUwPjJiylnlliJyQlAFCdYBo7qzmib8+3Q8EU3MDP9bNlpxxC1go57/q/TbaymWyOk3pK2VXaX+8vQmllgRZMQRi2JFBHVoep1f1x7lSsf2TpipgQJBANJlO+UDmync9X/1YdrVaDOi4o7g3w9u1eVq9B01+WklAP3bvxIoBRI97HlDPKHx+CZXeODx1xj0xPOK3HUz5FECQQCwvdagPPtWHhHx0boPF/s4ZrTUIH04afuePUuwKTQQRijnl0eb2idBe0z2VAH1utPps/p4SpuT3HI3PJJ8MlVFAkAFypuXdj3zLQ3k89A5wd4Ybcdmv3HkbtyccBFALJgs+MPKOR5NVaSuF95GiD9HBe4awBWnu4B8Q2CYg54F6+PBAkBKNgvukGyARnQGc6eKOumTTxzSjSnHDElIsjgbqdFgm/UE+TJqMHmXNyyjqbaA9YeRc67R35HfzgpvQxHG8GN5AkEAxSKOlfACUCQ/CZJovETMmaUDas463hbrUznp71uRMk8RP7DY/lBnGGMeUeeZLIVK5X2Ngcp9nJQSKWCGtpnfLQ==</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;很明显，公钥字符串长度比较短，私钥的比较长。生成完密钥后，公钥可以存放在客户端，即使被别人知道公钥，也是没有问题的；私钥则一定要保存在服务端。如果到时公司面临人事变动，避免私钥被离职人员泄露，可以重新生成公钥和密钥。</p>\n<p>使用公钥加密，私钥解密<br><img src=\"http://i.imgur.com/EzSYTst.png\" alt=\"Alt text\" title=\"Optional title\"><br>这里在客户端模拟加密的情况，对字符串”Beyond黄家驹”使用RSA加密，调用RSAUtils的encryptByPublicKey()方法，输出结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">密文: BRFjf3tUqRqlwuP5JtzxZinf7lp+AHuHM9JSabM5BNFDxuUe9+uuO6RpCHVH5PibifqQHzGNsyZn1G9QcIENT9Tbm+PZwAbNUlMPZRDBU1FSnOtY8dBdeW/lJdnY9sJVwNvIBnOLQk66hxRh6R2149dwlgdsGUpWMOMBzcP3vsU=</span><br></pre></td></tr></table></figure></p>\n<p>在服务端，可以使用RSAUtils的decryptByPrivateKey()方法进行解密，现在模拟服务端解密<br><img src=\"http://i.imgur.com/oNox5Ma.png\" alt=\"Alt text\" title=\"Optional title\"><br>&emsp;&emsp;在这里虽然没有完全模拟数据传输过程，比如说客户端发起一个网络请求，传递参数给服务端，服务端接收参数并进行处理，也是为了让大家可以更加容易明白，所以这里只是进行简单的模拟。可以看到Android客户端端和Java服务端的RSA加密解密算法是可以互通的，原因是他们所使用到的base64加密类是一致的，所以才可以实现加密和解密的算法互通。<br><img src=\"http://i.imgur.com/lLgQbab.png\" alt=\"Alt text\" title=\"Optional title\"><br><img src=\"http://i.imgur.com/lLgQbab.png\" alt=\"Alt text\" title=\"Optional title\"><br>&emsp;&emsp;使用到的jar包都是javabase64-1.3.1.jar,相信不少人都知道，java中有自带的Base64算法类，但是安卓中却没有，之前出现的情况是，使用的Base64类不统一，比如在安卓客户端开发使用的Base64算法是使用第三方提供的jar包，而java服务端中使用的是JDK自带的Base64,导致从客户端传过来的密文，服务端解析出错。</p>\n<p>&emsp;&emsp;上面的例子展示了客户端使用公钥加密，服务端使用私钥解密的过程。也许你会这么想，既然可以如此，那服务端那边信息也可以通过RSA加密后，传递加密信息过来，客户端进行解密。但是，这样做，显示是不安全的。原因是，由于客户端并没有保存私钥，只有公钥，只可以服务端进行私钥加密，客户端进行公钥解密，但由于公钥是公开，别人也可以获取到公钥，如果信息被他们截取，他们同样可以通过公钥进行解密，那么这样子加密，就毫无意义了，所以这个时候，就要结合对称算法，实现客户端与服务端之前的安全通信了。</p>\n<p>使用AES加密解密<br>加密<br><img src=\"http://i.imgur.com/WgX5ss7.png\" alt=\"Alt text\" title=\"Optional title\"><br>模拟客户端进行AES加密，我们通过调用AESUtils中的generateKey()方法，随机产生一个密钥，用于对数据进行加密。输出的结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">密钥: 6446c69c0f914a57</span><br><span class=\"line\">密文: GECDQOsc22yV48hdJENTMg==</span><br></pre></td></tr></table></figure></p>\n<p>解密<br>&emsp;&emsp;模拟服务端进行AES解密，由于AES属于对称算法，加密和解密需要使用同一把密钥，所以，服务端要解密传递过来的内容，就需要密钥 + 密文。这里模拟一下服务端解密。<br><img src=\"http://i.imgur.com/NXLPGwG.png\" alt=\"Alt text\" title=\"Optional title\"><br>&emsp;&emsp;到这里也许你会问，客户端使用AES进行加密，服务端要进行解密的话，需要用到产生的密钥，那密钥必须从客户端传输到服务端，如果不对密钥进行加密，那加密就没有意义了。所以这里终于谈到了重点，RSA算法+AES算法结合使用。</p>\n<p>RSA算法+AES算法的使用<br>&emsp;&emsp;举一个简单的例子来说明一下吧，例如实名认证功能，需要传递用户真实姓名和身份证号，对于这种重要信息，需要进行加密处理。</p>\n<p>客户端使用RSA + AES对重要信息进行加密<br>客户端加密过程主要分为以下三个步骤：</p>\n<ol>\n<li><p>客户端随机产生AES的密钥；</p>\n</li>\n<li><p>对身份证信息（重要信息）进行AES加密；</p>\n</li>\n<li><p>通过使用RSA对AES密钥进行公钥加密。<br><img src=\"http://i.imgur.com/8c2YKWN.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n</li>\n</ol>\n<p>&emsp;&emsp;这样在传输的过程中，即时加密后的AES密钥被别人截取，对其也无济于事，因为他并不知道RSA的私钥，无法解密得到原本的AES密钥，就无法解密用AES加密后的重要信息。</p>\n<p>服务端使用RSA + AES对重要信息进行解密</p>\n<p>服务端解密过程主要分为以下两个步骤：</p>\n<ol>\n<li><p>对加密后的AES密钥进行RSA私钥解密，拿到密钥原文；</p>\n</li>\n<li><p>对加密后的重要信息进行AES解密，拿到原始内容。<br><img src=\"http://i.imgur.com/kVrEvsu.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n</li>\n</ol>\n<p>&emsp;&emsp;现实开发中，服务端有时也需要向客户端传递重要信息，比如登录的时候，返回token给客户端，作为令牌，这个令牌就需要进行加密，原理也是差不多的，比上面多一个步骤而已，就是将解密后的AES密钥，对将要传递给客户端的数据token进行AES加密，返回给客户端，由于客户端和服务端都已经拿到同一把AES钥匙，所以客户端可以解密服务端返回的加密后的数据。如果客户端想要将令牌进行保存，则需要使用自己定义的默认的AES密钥进行加密后保存，需要使用的时候传入默认密钥和密文，解密后得到原token。</p>\n<p>&emsp;&emsp;上面提及到客户端加密，服务端返回数据不加密的情况，上面说到仅仅使用RSA是可以，但是还是建议同时使用这两种算法，即产生一个AES密钥，使用RSA对该密钥进行公钥加密，对重要信息进行AES加密，服务端通过RSA私钥解密拿到AES密钥，再对加密后的重要信息进行解密。如果仅仅使用RSA，服务端只通过RSA解密，这样会对于性能会有所影响，原因是RSA的解密耗时约等于AES解密耗时的100倍，所以如果每个重要信息都只通过RSA加密和解密，则会影响服务端系统的性能，所以建议两种算法一起使用。</p>\n<p>同时还有相应的JS版RSA和AES算法，使用方式也差不多，在这里简单演示一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;RSA+AES.html&lt;/title&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;meta name=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;description&quot; content=&quot;this is my page&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/rsa.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/aes.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">        var key = getKey();//随机产生AES密钥</span><br><span class=\"line\">        var encryptKey = RSA(key);//对AES密钥进行RSA加密</span><br><span class=\"line\">        console.log(&quot;encryptKey: &quot; + encryptKey);</span><br><span class=\"line\"></span><br><span class=\"line\">        //测试AES加密和解密</span><br><span class=\"line\">        var cipherText = AESEnc(key,&quot;123456&quot;);</span><br><span class=\"line\">        var plainText = AESDec(key,cipherText);</span><br><span class=\"line\">        console.log(&quot;密文: &quot; + cipherText);</span><br><span class=\"line\">        console.log(&quot;明文: &quot; + plainText);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    This is my HTML page. &lt;br&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>打开页面后，查看控制台输出：<br><img src=\"http://i.imgur.com/PyU0b3r.png\" alt=\"Alt text\" title=\"Optional title\"><br>同时，模拟服务端解密，运行结果如下：<br><img src=\"http://i.imgur.com/3VrRv3d.png\" alt=\"Alt text\" title=\"Optional title\"></p>\n<p>需要注意的是:</p>\n<p>1.RSAUtils中配置公钥和密钥，可以使用getKeys()方法产生。如果是客户端，则无须配置私钥，把没有私钥的RSAUtils放到客户端，因为仅需要用到公钥加密的方法。</p>\n<p>2.AESUtils中配置偏移量IV_STRING；</p>\n<p>3.rsa.js中最底部配置公钥，须和上面RSAUtils配置的公钥一致；</p>\n<p>4.aes.js中的底部var iv = CryptoJS.enc.Utf8.parse(“16-Bytes–String”); //加密向量中，替换里面的字符串，加密向量须和<br>是上面的AESUtils中的偏移量一致。</p>\n<p>各种语言的加密的处理方式有所差异，所以我们需要因地制宜。了解此加密的思想方法即可</p>\n<ol>\n<li><a href=\"http://blog.csdn.net/treesky/article/details/49422645\" target=\"_blank\" rel=\"external\">php 和 java RSA 对称加密互通的问题</a></li>\n<li><a href=\"http://www.cnblogs.com/yipu/articles/3871576.html\" target=\"_blank\" rel=\"external\">php与java通用AES加密解密算法</a></li>\n<li><a href=\"http://blog.csdn.net/pbm863521/article/details/54023009\" target=\"_blank\" rel=\"external\">Android错误解决：java.lang.NoSuchMethodError: No static method encodeBase64String</a></li>\n</ol>\n"},{"title":"阿里云Centos7搭建Git服务器仓库","date":"2017-02-09T12:30:45.000Z","_content":"阿里云Centos7 搭建Git服务器仓库，记录过程\n\n## 1.首先需要安装Git，可以使用yum源在线安装：\n```\n[root@localhost Desktop]# yum install -y git\n```\n![这里写图片描述](http://img.blog.csdn.net/20170209181003136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n \n## 2.创建一个git用户，用来运行git服务\n```\n# adduser git  \n```\n![这里写图片描述](http://img.blog.csdn.net/20170209181024793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n \n## 3.初始化git仓库：这里我们选择/usr/local/tomcat7/webapps/baby_android/来作为我们的git仓库\n```\n# git init\n```\n仓库路径  /usr/local/tomcat7/webapps/baby_android/\n\n![这里写图片描述](http://img.blog.csdn.net/20170209181915113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n执行以上命令，会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，设置权限：\n```\n[root@localhost webapps]# chown - Rh git:users baby \n```\n\n## 5.创建SSH Key\n 首先在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n```\n$ ssh-keygen -t rsa -C \"youremail@example.com\"\n```\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n## 6.Git服务器打开RSA认证\n然后就可以去Git服务器上添加你的公钥用来验证你的信息了。在Git服务器上首先需要将/etc/ssh/sshd_config中将RSA认证打开，即：\n```\n1.RSAAuthentication yes    \n2.PubkeyAuthentication yes    \n3.AuthorizedKeysFile  .ssh/authorized_keys\n```\n\n这里我们可以看到公钥存放在.ssh/authorized_keys文件中。所以我们在/home/git下创建.ssh目录，然后创建authorized_keys文件，并将刚生成的公钥导入进去。\n创建文件夹 mkdir 路径/文件夹名\n创建文件 vi 路径/文件名\n然后再次clone的时候，或者是之后push的时候，就不需要再输入密码了：\n\n##  7.禁用git用户的shell登陆\n出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：\n```\ngit:x:1001:1001:,,,:/home/git:/bin/bash \n```\n最后一个冒号后改为：\n![这里写图片描述](http://img.blog.csdn.net/20170209185636959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n```\ngit:x:1001:1001:,,,:/home/git:/usr/bin/git-shell  \n```\n \n git clone git@42.96.150.57: /usr/local/tomcat7/webapps/baby/\n\n## 8. 客户端基本操作\ngit add .  \ngit commit\ngit push\n\n## 9.服务器自动更新部署\n1. 进入到  /usr/local/tomcat7/webapps/baby/.git 文件夹中，会发现 .git/hook 文件夹在里面，进入到 hook 中，里面有很多的 sample 脚本，这里我们只需要用到 post-update。\npost-update脚本\n2. 设置文件权限\n``` \nchown -Rh git:users baby\n```\n\n \n## 10.创建git服务器远程仓库\n\n```\n$ mv post-update.sample post-update\n    $ vim post-update\n```\n\n\n## 注意：\n1. Git: push 出错的解决 master -> master (branch is currently checked out)\n这是由于git默认拒绝了push操作，需要进行设置，修改.git/config添加如下代码：\n```\n    [receive]\n    denyCurrentBranch = ignore\n```\n线上添加文件设置权限\n``` \nchown -Rh git:users baby\n```\n","source":"_posts/阿里云Centos7搭建Git服务器仓库.md","raw":"---\ntitle: 阿里云Centos7搭建Git服务器仓库\ndate: 2017-02-09 20:30:45\ntags:\n---\n阿里云Centos7 搭建Git服务器仓库，记录过程\n\n## 1.首先需要安装Git，可以使用yum源在线安装：\n```\n[root@localhost Desktop]# yum install -y git\n```\n![这里写图片描述](http://img.blog.csdn.net/20170209181003136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n \n## 2.创建一个git用户，用来运行git服务\n```\n# adduser git  \n```\n![这里写图片描述](http://img.blog.csdn.net/20170209181024793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n \n## 3.初始化git仓库：这里我们选择/usr/local/tomcat7/webapps/baby_android/来作为我们的git仓库\n```\n# git init\n```\n仓库路径  /usr/local/tomcat7/webapps/baby_android/\n\n![这里写图片描述](http://img.blog.csdn.net/20170209181915113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n执行以上命令，会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，设置权限：\n```\n[root@localhost webapps]# chown - Rh git:users baby \n```\n\n## 5.创建SSH Key\n 首先在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n```\n$ ssh-keygen -t rsa -C \"youremail@example.com\"\n```\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n## 6.Git服务器打开RSA认证\n然后就可以去Git服务器上添加你的公钥用来验证你的信息了。在Git服务器上首先需要将/etc/ssh/sshd_config中将RSA认证打开，即：\n```\n1.RSAAuthentication yes    \n2.PubkeyAuthentication yes    \n3.AuthorizedKeysFile  .ssh/authorized_keys\n```\n\n这里我们可以看到公钥存放在.ssh/authorized_keys文件中。所以我们在/home/git下创建.ssh目录，然后创建authorized_keys文件，并将刚生成的公钥导入进去。\n创建文件夹 mkdir 路径/文件夹名\n创建文件 vi 路径/文件名\n然后再次clone的时候，或者是之后push的时候，就不需要再输入密码了：\n\n##  7.禁用git用户的shell登陆\n出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：\n```\ngit:x:1001:1001:,,,:/home/git:/bin/bash \n```\n最后一个冒号后改为：\n![这里写图片描述](http://img.blog.csdn.net/20170209185636959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n```\ngit:x:1001:1001:,,,:/home/git:/usr/bin/git-shell  \n```\n \n git clone git@42.96.150.57: /usr/local/tomcat7/webapps/baby/\n\n## 8. 客户端基本操作\ngit add .  \ngit commit\ngit push\n\n## 9.服务器自动更新部署\n1. 进入到  /usr/local/tomcat7/webapps/baby/.git 文件夹中，会发现 .git/hook 文件夹在里面，进入到 hook 中，里面有很多的 sample 脚本，这里我们只需要用到 post-update。\npost-update脚本\n2. 设置文件权限\n``` \nchown -Rh git:users baby\n```\n\n \n## 10.创建git服务器远程仓库\n\n```\n$ mv post-update.sample post-update\n    $ vim post-update\n```\n\n\n## 注意：\n1. Git: push 出错的解决 master -> master (branch is currently checked out)\n这是由于git默认拒绝了push操作，需要进行设置，修改.git/config添加如下代码：\n```\n    [receive]\n    denyCurrentBranch = ignore\n```\n线上添加文件设置权限\n``` \nchown -Rh git:users baby\n```\n","slug":"阿里云Centos7搭建Git服务器仓库","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeow00169xs629mfk118","content":"<p>阿里云Centos7 搭建Git服务器仓库，记录过程</p>\n<h2 id=\"1-首先需要安装Git，可以使用yum源在线安装：\"><a href=\"#1-首先需要安装Git，可以使用yum源在线安装：\" class=\"headerlink\" title=\"1.首先需要安装Git，可以使用yum源在线安装：\"></a>1.首先需要安装Git，可以使用yum源在线安装：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost Desktop]# yum install -y git</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.blog.csdn.net/20170209181003136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"2-创建一个git用户，用来运行git服务\"><a href=\"#2-创建一个git用户，用来运行git服务\" class=\"headerlink\" title=\"2.创建一个git用户，用来运行git服务\"></a>2.创建一个git用户，用来运行git服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># adduser git</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.blog.csdn.net/20170209181024793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"3-初始化git仓库：这里我们选择-usr-local-tomcat7-webapps-baby-android-来作为我们的git仓库\"><a href=\"#3-初始化git仓库：这里我们选择-usr-local-tomcat7-webapps-baby-android-来作为我们的git仓库\" class=\"headerlink\" title=\"3.初始化git仓库：这里我们选择/usr/local/tomcat7/webapps/baby_android/来作为我们的git仓库\"></a>3.初始化git仓库：这里我们选择/usr/local/tomcat7/webapps/baby_android/来作为我们的git仓库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git init</span><br></pre></td></tr></table></figure>\n<p>仓库路径  /usr/local/tomcat7/webapps/baby_android/</p>\n<p><img src=\"http://img.blog.csdn.net/20170209181915113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>执行以上命令，会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，设置权限：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost webapps]# chown - Rh git:users baby</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-创建SSH-Key\"><a href=\"#5-创建SSH-Key\" class=\"headerlink\" title=\"5.创建SSH Key\"></a>5.创建SSH Key</h2><p> 首先在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></p>\n<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>\n<h2 id=\"6-Git服务器打开RSA认证\"><a href=\"#6-Git服务器打开RSA认证\" class=\"headerlink\" title=\"6.Git服务器打开RSA认证\"></a>6.Git服务器打开RSA认证</h2><p>然后就可以去Git服务器上添加你的公钥用来验证你的信息了。在Git服务器上首先需要将/etc/ssh/sshd_config中将RSA认证打开，即：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.RSAAuthentication yes    </span><br><span class=\"line\">2.PubkeyAuthentication yes    </span><br><span class=\"line\">3.AuthorizedKeysFile  .ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>\n<p>这里我们可以看到公钥存放在.ssh/authorized_keys文件中。所以我们在/home/git下创建.ssh目录，然后创建authorized_keys文件，并将刚生成的公钥导入进去。<br>创建文件夹 mkdir 路径/文件夹名<br>创建文件 vi 路径/文件名<br>然后再次clone的时候，或者是之后push的时候，就不需要再输入密码了：</p>\n<h2 id=\"7-禁用git用户的shell登陆\"><a href=\"#7-禁用git用户的shell登陆\" class=\"headerlink\" title=\"7.禁用git用户的shell登陆\"></a>7.禁用git用户的shell登陆</h2><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure></p>\n<p>最后一个冒号后改为：<br><img src=\"http://img.blog.csdn.net/20170209185636959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p>\n<p> git clone git@42.96.150.57: /usr/local/tomcat7/webapps/baby/</p>\n<h2 id=\"8-客户端基本操作\"><a href=\"#8-客户端基本操作\" class=\"headerlink\" title=\"8. 客户端基本操作\"></a>8. 客户端基本操作</h2><p>git add .<br>git commit<br>git push</p>\n<h2 id=\"9-服务器自动更新部署\"><a href=\"#9-服务器自动更新部署\" class=\"headerlink\" title=\"9.服务器自动更新部署\"></a>9.服务器自动更新部署</h2><ol>\n<li>进入到  /usr/local/tomcat7/webapps/baby/.git 文件夹中，会发现 .git/hook 文件夹在里面，进入到 hook 中，里面有很多的 sample 脚本，这里我们只需要用到 post-update。<br>post-update脚本</li>\n<li>设置文件权限<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -Rh git:users baby</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"10-创建git服务器远程仓库\"><a href=\"#10-创建git服务器远程仓库\" class=\"headerlink\" title=\"10.创建git服务器远程仓库\"></a>10.创建git服务器远程仓库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mv post-update.sample post-update</span><br><span class=\"line\">    $ vim post-update</span><br></pre></td></tr></table></figure>\n<h2 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><ol>\n<li>Git: push 出错的解决 master -&gt; master (branch is currently checked out)<br>这是由于git默认拒绝了push操作，需要进行设置，修改.git/config添加如下代码：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[receive]</span><br><span class=\"line\">denyCurrentBranch = ignore</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>线上添加文件设置权限<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -Rh git:users baby</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>阿里云Centos7 搭建Git服务器仓库，记录过程</p>\n<h2 id=\"1-首先需要安装Git，可以使用yum源在线安装：\"><a href=\"#1-首先需要安装Git，可以使用yum源在线安装：\" class=\"headerlink\" title=\"1.首先需要安装Git，可以使用yum源在线安装：\"></a>1.首先需要安装Git，可以使用yum源在线安装：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost Desktop]# yum install -y git</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.blog.csdn.net/20170209181003136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"2-创建一个git用户，用来运行git服务\"><a href=\"#2-创建一个git用户，用来运行git服务\" class=\"headerlink\" title=\"2.创建一个git用户，用来运行git服务\"></a>2.创建一个git用户，用来运行git服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># adduser git</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.blog.csdn.net/20170209181024793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"3-初始化git仓库：这里我们选择-usr-local-tomcat7-webapps-baby-android-来作为我们的git仓库\"><a href=\"#3-初始化git仓库：这里我们选择-usr-local-tomcat7-webapps-baby-android-来作为我们的git仓库\" class=\"headerlink\" title=\"3.初始化git仓库：这里我们选择/usr/local/tomcat7/webapps/baby_android/来作为我们的git仓库\"></a>3.初始化git仓库：这里我们选择/usr/local/tomcat7/webapps/baby_android/来作为我们的git仓库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git init</span><br></pre></td></tr></table></figure>\n<p>仓库路径  /usr/local/tomcat7/webapps/baby_android/</p>\n<p><img src=\"http://img.blog.csdn.net/20170209181915113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>执行以上命令，会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，设置权限：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost webapps]# chown - Rh git:users baby</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-创建SSH-Key\"><a href=\"#5-创建SSH-Key\" class=\"headerlink\" title=\"5.创建SSH Key\"></a>5.创建SSH Key</h2><p> 首先在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></p>\n<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>\n<h2 id=\"6-Git服务器打开RSA认证\"><a href=\"#6-Git服务器打开RSA认证\" class=\"headerlink\" title=\"6.Git服务器打开RSA认证\"></a>6.Git服务器打开RSA认证</h2><p>然后就可以去Git服务器上添加你的公钥用来验证你的信息了。在Git服务器上首先需要将/etc/ssh/sshd_config中将RSA认证打开，即：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.RSAAuthentication yes    </span><br><span class=\"line\">2.PubkeyAuthentication yes    </span><br><span class=\"line\">3.AuthorizedKeysFile  .ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>\n<p>这里我们可以看到公钥存放在.ssh/authorized_keys文件中。所以我们在/home/git下创建.ssh目录，然后创建authorized_keys文件，并将刚生成的公钥导入进去。<br>创建文件夹 mkdir 路径/文件夹名<br>创建文件 vi 路径/文件名<br>然后再次clone的时候，或者是之后push的时候，就不需要再输入密码了：</p>\n<h2 id=\"7-禁用git用户的shell登陆\"><a href=\"#7-禁用git用户的shell登陆\" class=\"headerlink\" title=\"7.禁用git用户的shell登陆\"></a>7.禁用git用户的shell登陆</h2><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure></p>\n<p>最后一个冒号后改为：<br><img src=\"http://img.blog.csdn.net/20170209185636959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ3hpbjExMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p>\n<p> git clone git@42.96.150.57: /usr/local/tomcat7/webapps/baby/</p>\n<h2 id=\"8-客户端基本操作\"><a href=\"#8-客户端基本操作\" class=\"headerlink\" title=\"8. 客户端基本操作\"></a>8. 客户端基本操作</h2><p>git add .<br>git commit<br>git push</p>\n<h2 id=\"9-服务器自动更新部署\"><a href=\"#9-服务器自动更新部署\" class=\"headerlink\" title=\"9.服务器自动更新部署\"></a>9.服务器自动更新部署</h2><ol>\n<li>进入到  /usr/local/tomcat7/webapps/baby/.git 文件夹中，会发现 .git/hook 文件夹在里面，进入到 hook 中，里面有很多的 sample 脚本，这里我们只需要用到 post-update。<br>post-update脚本</li>\n<li>设置文件权限<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -Rh git:users baby</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"10-创建git服务器远程仓库\"><a href=\"#10-创建git服务器远程仓库\" class=\"headerlink\" title=\"10.创建git服务器远程仓库\"></a>10.创建git服务器远程仓库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mv post-update.sample post-update</span><br><span class=\"line\">    $ vim post-update</span><br></pre></td></tr></table></figure>\n<h2 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><ol>\n<li>Git: push 出错的解决 master -&gt; master (branch is currently checked out)<br>这是由于git默认拒绝了push操作，需要进行设置，修改.git/config添加如下代码：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[receive]</span><br><span class=\"line\">denyCurrentBranch = ignore</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>线上添加文件设置权限<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -Rh git:users baby</span><br></pre></td></tr></table></figure></p>\n"},{"title":"算法面试准备","date":"2017-08-13T08:15:21.000Z","_content":"### 一道排序体题需要考与面试官沟通的点\n- 有没有可能包含大量的重复元素\n- 是否近乎有序\n- 数据取值范围是否有限\n- 是否需要稳定排序\n- 是否用链式存储\n- 数据大小足够装载内存里\n\n### 算法面试优秀不意味技术面试优秀\n- 考虑项目经历和项目中遇到的实际问题\n- 印象最深的bug\n- 面向对象\n- 设计模式\n- 网络相关：安全相关、内存相关、并发相关\n- 系统设计：scalability\n\n### 技术面试优秀不意味着能够拿到Offer\n**创建自己的项目**\n\n- 自己做小应用\n- 自己解决小问题\n- “不是项目”的项目：书籍的整理\n- 技术分享，blog、github \n\n**了解过去自身的思考行为方式**\n\n- 遇到最大的挑战\n- 犯过的错误\n- 遭遇的失败\n- 最享受的工作内容\n- 遇到冲突处理方式\n- 做的最与众不同的事儿\n\n**准备好问面试官的问题**\n\n- 整个小组的大概运行模式是怎么样的\n- 整个项目组的后续规划是如何\n- 这个产品中某个问题的解决方案\n- 为什么选择某些技术？标准？\n- 对某技术很感性局，是否有机会深入\n\n### 算法面试没这么难\n\n- 没必要啃完《算法导论》\n- 高级数据结构和算法面试提及概率很低（红黑树、计算几何、B-Tree、数论、斐波那契堆、FFT）\n\n### 准备范围\n**关注基础算法和数据结构，非“有意思”的题目\n**\n\n- 各种排序算法\n- 基础数据结构和算法实现：堆、二叉树、图...\n- 基础数据结构使用：链表、栈、队列、哈希表、图、Trie...\n- 基础算法：深度优先、广度优先、二分查找、递归...\n- 基本算法思想：递归、分支、回溯搜索、贪心、动态规划...\n\n### 解决算法问题的整体思路\n\n- 注意题目中的条件\n- 当没有思路时（测试用例，暴力解法——>优化）\n- 优化算法（算法思路、数据结构、空间换时间、预处理数据、瓶颈除找解决方案）\n- 实际编写问题，极端条件的判断（数组为空、字符串为空、数据为NULL），代码规范（变量名、模块化、复用性）","source":"_posts/算法面试准备.md","raw":"---\ntitle: 算法面试准备\ndate: 2017-08-13 16:15:21\ntags: [算法基础]\ncategory: \"算法\"\n---\n### 一道排序体题需要考与面试官沟通的点\n- 有没有可能包含大量的重复元素\n- 是否近乎有序\n- 数据取值范围是否有限\n- 是否需要稳定排序\n- 是否用链式存储\n- 数据大小足够装载内存里\n\n### 算法面试优秀不意味技术面试优秀\n- 考虑项目经历和项目中遇到的实际问题\n- 印象最深的bug\n- 面向对象\n- 设计模式\n- 网络相关：安全相关、内存相关、并发相关\n- 系统设计：scalability\n\n### 技术面试优秀不意味着能够拿到Offer\n**创建自己的项目**\n\n- 自己做小应用\n- 自己解决小问题\n- “不是项目”的项目：书籍的整理\n- 技术分享，blog、github \n\n**了解过去自身的思考行为方式**\n\n- 遇到最大的挑战\n- 犯过的错误\n- 遭遇的失败\n- 最享受的工作内容\n- 遇到冲突处理方式\n- 做的最与众不同的事儿\n\n**准备好问面试官的问题**\n\n- 整个小组的大概运行模式是怎么样的\n- 整个项目组的后续规划是如何\n- 这个产品中某个问题的解决方案\n- 为什么选择某些技术？标准？\n- 对某技术很感性局，是否有机会深入\n\n### 算法面试没这么难\n\n- 没必要啃完《算法导论》\n- 高级数据结构和算法面试提及概率很低（红黑树、计算几何、B-Tree、数论、斐波那契堆、FFT）\n\n### 准备范围\n**关注基础算法和数据结构，非“有意思”的题目\n**\n\n- 各种排序算法\n- 基础数据结构和算法实现：堆、二叉树、图...\n- 基础数据结构使用：链表、栈、队列、哈希表、图、Trie...\n- 基础算法：深度优先、广度优先、二分查找、递归...\n- 基本算法思想：递归、分支、回溯搜索、贪心、动态规划...\n\n### 解决算法问题的整体思路\n\n- 注意题目中的条件\n- 当没有思路时（测试用例，暴力解法——>优化）\n- 优化算法（算法思路、数据结构、空间换时间、预处理数据、瓶颈除找解决方案）\n- 实际编写问题，极端条件的判断（数组为空、字符串为空、数据为NULL），代码规范（变量名、模块化、复用性）","slug":"算法面试准备","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeox00199xs6e7q0943m","content":"<h3 id=\"一道排序体题需要考与面试官沟通的点\"><a href=\"#一道排序体题需要考与面试官沟通的点\" class=\"headerlink\" title=\"一道排序体题需要考与面试官沟通的点\"></a>一道排序体题需要考与面试官沟通的点</h3><ul>\n<li>有没有可能包含大量的重复元素</li>\n<li>是否近乎有序</li>\n<li>数据取值范围是否有限</li>\n<li>是否需要稳定排序</li>\n<li>是否用链式存储</li>\n<li>数据大小足够装载内存里</li>\n</ul>\n<h3 id=\"算法面试优秀不意味技术面试优秀\"><a href=\"#算法面试优秀不意味技术面试优秀\" class=\"headerlink\" title=\"算法面试优秀不意味技术面试优秀\"></a>算法面试优秀不意味技术面试优秀</h3><ul>\n<li>考虑项目经历和项目中遇到的实际问题</li>\n<li>印象最深的bug</li>\n<li>面向对象</li>\n<li>设计模式</li>\n<li>网络相关：安全相关、内存相关、并发相关</li>\n<li>系统设计：scalability</li>\n</ul>\n<h3 id=\"技术面试优秀不意味着能够拿到Offer\"><a href=\"#技术面试优秀不意味着能够拿到Offer\" class=\"headerlink\" title=\"技术面试优秀不意味着能够拿到Offer\"></a>技术面试优秀不意味着能够拿到Offer</h3><p><strong>创建自己的项目</strong></p>\n<ul>\n<li>自己做小应用</li>\n<li>自己解决小问题</li>\n<li>“不是项目”的项目：书籍的整理</li>\n<li>技术分享，blog、github </li>\n</ul>\n<p><strong>了解过去自身的思考行为方式</strong></p>\n<ul>\n<li>遇到最大的挑战</li>\n<li>犯过的错误</li>\n<li>遭遇的失败</li>\n<li>最享受的工作内容</li>\n<li>遇到冲突处理方式</li>\n<li>做的最与众不同的事儿</li>\n</ul>\n<p><strong>准备好问面试官的问题</strong></p>\n<ul>\n<li>整个小组的大概运行模式是怎么样的</li>\n<li>整个项目组的后续规划是如何</li>\n<li>这个产品中某个问题的解决方案</li>\n<li>为什么选择某些技术？标准？</li>\n<li>对某技术很感性局，是否有机会深入</li>\n</ul>\n<h3 id=\"算法面试没这么难\"><a href=\"#算法面试没这么难\" class=\"headerlink\" title=\"算法面试没这么难\"></a>算法面试没这么难</h3><ul>\n<li>没必要啃完《算法导论》</li>\n<li>高级数据结构和算法面试提及概率很低（红黑树、计算几何、B-Tree、数论、斐波那契堆、FFT）</li>\n</ul>\n<h3 id=\"准备范围\"><a href=\"#准备范围\" class=\"headerlink\" title=\"准备范围\"></a>准备范围</h3><p><strong>关注基础算法和数据结构，非“有意思”的题目\n</strong></p>\n<ul>\n<li>各种排序算法</li>\n<li>基础数据结构和算法实现：堆、二叉树、图…</li>\n<li>基础数据结构使用：链表、栈、队列、哈希表、图、Trie…</li>\n<li>基础算法：深度优先、广度优先、二分查找、递归…</li>\n<li>基本算法思想：递归、分支、回溯搜索、贪心、动态规划…</li>\n</ul>\n<h3 id=\"解决算法问题的整体思路\"><a href=\"#解决算法问题的整体思路\" class=\"headerlink\" title=\"解决算法问题的整体思路\"></a>解决算法问题的整体思路</h3><ul>\n<li>注意题目中的条件</li>\n<li>当没有思路时（测试用例，暴力解法——&gt;优化）</li>\n<li>优化算法（算法思路、数据结构、空间换时间、预处理数据、瓶颈除找解决方案）</li>\n<li>实际编写问题，极端条件的判断（数组为空、字符串为空、数据为NULL），代码规范（变量名、模块化、复用性）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一道排序体题需要考与面试官沟通的点\"><a href=\"#一道排序体题需要考与面试官沟通的点\" class=\"headerlink\" title=\"一道排序体题需要考与面试官沟通的点\"></a>一道排序体题需要考与面试官沟通的点</h3><ul>\n<li>有没有可能包含大量的重复元素</li>\n<li>是否近乎有序</li>\n<li>数据取值范围是否有限</li>\n<li>是否需要稳定排序</li>\n<li>是否用链式存储</li>\n<li>数据大小足够装载内存里</li>\n</ul>\n<h3 id=\"算法面试优秀不意味技术面试优秀\"><a href=\"#算法面试优秀不意味技术面试优秀\" class=\"headerlink\" title=\"算法面试优秀不意味技术面试优秀\"></a>算法面试优秀不意味技术面试优秀</h3><ul>\n<li>考虑项目经历和项目中遇到的实际问题</li>\n<li>印象最深的bug</li>\n<li>面向对象</li>\n<li>设计模式</li>\n<li>网络相关：安全相关、内存相关、并发相关</li>\n<li>系统设计：scalability</li>\n</ul>\n<h3 id=\"技术面试优秀不意味着能够拿到Offer\"><a href=\"#技术面试优秀不意味着能够拿到Offer\" class=\"headerlink\" title=\"技术面试优秀不意味着能够拿到Offer\"></a>技术面试优秀不意味着能够拿到Offer</h3><p><strong>创建自己的项目</strong></p>\n<ul>\n<li>自己做小应用</li>\n<li>自己解决小问题</li>\n<li>“不是项目”的项目：书籍的整理</li>\n<li>技术分享，blog、github </li>\n</ul>\n<p><strong>了解过去自身的思考行为方式</strong></p>\n<ul>\n<li>遇到最大的挑战</li>\n<li>犯过的错误</li>\n<li>遭遇的失败</li>\n<li>最享受的工作内容</li>\n<li>遇到冲突处理方式</li>\n<li>做的最与众不同的事儿</li>\n</ul>\n<p><strong>准备好问面试官的问题</strong></p>\n<ul>\n<li>整个小组的大概运行模式是怎么样的</li>\n<li>整个项目组的后续规划是如何</li>\n<li>这个产品中某个问题的解决方案</li>\n<li>为什么选择某些技术？标准？</li>\n<li>对某技术很感性局，是否有机会深入</li>\n</ul>\n<h3 id=\"算法面试没这么难\"><a href=\"#算法面试没这么难\" class=\"headerlink\" title=\"算法面试没这么难\"></a>算法面试没这么难</h3><ul>\n<li>没必要啃完《算法导论》</li>\n<li>高级数据结构和算法面试提及概率很低（红黑树、计算几何、B-Tree、数论、斐波那契堆、FFT）</li>\n</ul>\n<h3 id=\"准备范围\"><a href=\"#准备范围\" class=\"headerlink\" title=\"准备范围\"></a>准备范围</h3><p><strong>关注基础算法和数据结构，非“有意思”的题目\n</strong></p>\n<ul>\n<li>各种排序算法</li>\n<li>基础数据结构和算法实现：堆、二叉树、图…</li>\n<li>基础数据结构使用：链表、栈、队列、哈希表、图、Trie…</li>\n<li>基础算法：深度优先、广度优先、二分查找、递归…</li>\n<li>基本算法思想：递归、分支、回溯搜索、贪心、动态规划…</li>\n</ul>\n<h3 id=\"解决算法问题的整体思路\"><a href=\"#解决算法问题的整体思路\" class=\"headerlink\" title=\"解决算法问题的整体思路\"></a>解决算法问题的整体思路</h3><ul>\n<li>注意题目中的条件</li>\n<li>当没有思路时（测试用例，暴力解法——&gt;优化）</li>\n<li>优化算法（算法思路、数据结构、空间换时间、预处理数据、瓶颈除找解决方案）</li>\n<li>实际编写问题，极端条件的判断（数组为空、字符串为空、数据为NULL），代码规范（变量名、模块化、复用性）</li>\n</ul>\n"},{"title":"第三方登录的注意与坑","date":"2017-04-29T16:00:23.000Z","_content":"### 三方登录实多平台快捷方现方式\nMob平台 集成开发 三方登录和分享\nShareSdk.xml 配置\nAndroidManifest.xml 配置\n\n### 注意点\n- 微信平台 \n    包名千万不要写错\n    数字签名 是MD5 非 SHA1(大部分平台都是SHA1)\n    测试签名和发行签名区分或统一。\n- QQ 平台\n    添加测试账号\n","source":"_posts/第三方登录的注意与坑.md","raw":"---\ntitle: 第三方登录的注意与坑\ndate: 2017-04-30 00:00:23\ntags: [Android]\ncategory: \"Android\"\n---\n### 三方登录实多平台快捷方现方式\nMob平台 集成开发 三方登录和分享\nShareSdk.xml 配置\nAndroidManifest.xml 配置\n\n### 注意点\n- 微信平台 \n    包名千万不要写错\n    数字签名 是MD5 非 SHA1(大部分平台都是SHA1)\n    测试签名和发行签名区分或统一。\n- QQ 平台\n    添加测试账号\n","slug":"第三方登录的注意与坑","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xeoy001b9xs6ygyiozzd","content":"<h3 id=\"三方登录实多平台快捷方现方式\"><a href=\"#三方登录实多平台快捷方现方式\" class=\"headerlink\" title=\"三方登录实多平台快捷方现方式\"></a>三方登录实多平台快捷方现方式</h3><p>Mob平台 集成开发 三方登录和分享<br>ShareSdk.xml 配置<br>AndroidManifest.xml 配置</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><ul>\n<li>微信平台<br>  包名千万不要写错<br>  数字签名 是MD5 非 SHA1(大部分平台都是SHA1)<br>  测试签名和发行签名区分或统一。</li>\n<li>QQ 平台<br>  添加测试账号</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"三方登录实多平台快捷方现方式\"><a href=\"#三方登录实多平台快捷方现方式\" class=\"headerlink\" title=\"三方登录实多平台快捷方现方式\"></a>三方登录实多平台快捷方现方式</h3><p>Mob平台 集成开发 三方登录和分享<br>ShareSdk.xml 配置<br>AndroidManifest.xml 配置</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><ul>\n<li>微信平台<br>  包名千万不要写错<br>  数字签名 是MD5 非 SHA1(大部分平台都是SHA1)<br>  测试签名和发行签名区分或统一。</li>\n<li>QQ 平台<br>  添加测试账号</li>\n</ul>\n"},{"title":"面试基础（一）","date":"2017-06-22T14:25:37.000Z","_content":"\n#### 基础数据类型\n基本数据类型分为原始类型和包装类型，Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型(wrapper class)，int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。\n\n8种原始类型 | 容量 | 对应包装类型\n------------ | ------------- | ------------\nbyte(字节)    |         8 位   |           Byte\nshot(短整型)   |        16位     |         Short\nint(整型)      |           32 位 |            Integer\nlong(长整型)   |       64 位      |         Long\nfloat(浮点型)  |        32 位     |          Float\ndouble(双精度) |    64 位        |       Double\nchar(字符型)   |       16 位     |          Character\nboolean(布尔型) |   1 位         |       Boolean\n\n注意几点：\n\n**1、各数据类型按容量大小（表数范围大小）由小到大排列为：**\n\nbyte <—— short, char  <——int <——long <——float <——double\n\n**2、基本类型之间的转换原则：**\n\n1）运算时，容量小的类型自动转换为容量大的类型；\n\n2）容量大的类型转换为容量小的类型时，要加强制转换符，且精度可能丢失；\n\n```\n如：float f = 1.2f;\nint ff = (int) f;\nSystem.out.println(ff);  1\n```            \n\n3）short，char之间不会互相转换（需要强制转换），byte、short、char并且三者在计算时首先转换为int类型；\n\n4）实数常量默认为double类型， 整数常量默认为int类型；\n\n**3、包装类及String类都是定定义为public final class的，因此这几个都不能被继承；　　**\n\n**4、原始类型是可以通过==直接判断是否相等的，而包装类型是类，通过==判断值是否相等是不对的，必须通过equals()函数**\n\n\n\n**下面的程序中，temp的最终值是什么？  **\n\n```\nlong temp=(int)3.9;   3\n\ntemp%=2;   1\n```\n\nA .0\n\nB .1\n\nC .2\n\nD .3\n\nE .4\n\n\n**short s1 = 1; s1 = s1 + 1;有什么错（错误）? short s1 = 1; s1 += 1;有什么错（正确）?**\n\n\n**下面哪个不是JAVA关键字 **\n\nA  integer\n\nB  double\n\nC  float\n\nD  default\n\n\n###2.1.2 历年考题\n\n**下面哪些不是java的简单数据类型?** AC\n\nA. short  B. Boolean  C. Double  D. float\n\n\n**0.6332的数据类型是（）**  A\n\nA float     B double     C Float      D Double\n\n\n**float f=3.4;是否正确?**  错\n\n\n\n**下面哪些类可以被继承**\n\n下面哪些类可以被继承？  ABDE\nJava.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader\nA、Thread    B、Number    C、Double    D、Math    E、ClassLoader\n\n\n**String 是最基本的数据类型吗?**不是\n\n\n**int和Integer有什么区别?** 原始类型和封装类型，java5后自动拆箱和封箱机制\n\n\n**5、请写出下面程序的运行结果：**\n　\n```\nclass AutoUnboxingTest {\n    public static void main(String[] args) {\n        Integer a = new Integer(3);\n        Integer b = 3; // 将3自动装箱成Integer类型\n        int c = 3;\n        System.out.println(a == b); // false 两个引用没有引用同一对象\n        System.out.println(a == c); // true a自动拆箱成int类型再和c比较\n        System.out.println(b == c); // true b自动装箱然后自动拆箱成int类型再和c比较\n\n    }\n}\n```\n\n\n## 2.2 String、StringBuilder、StringBuffer\n\n### 2.2.1 String\n\n字符串常量，不可更改，因为其内部定义的是一个final类型的数组来保存值的，如下：\n\n```\nprivate final char value[];\n```    \n\n所以，当我们每次去“更改”String变量的值的时候（包括重新赋值或者使用String内部的一些方法），其实是重新新建了一个String对象（new String）来保存新的值，然后让我们的变量指向新的对象。因此，当我们需要频繁改变字符串的时候，使用String会带来较大的开销。\n\n定义String的方法有两种：\n\n（1）String str = \"abc\";\n（2）String str2 = new String(\"def\");\n\n第一种方式创建的String对象“abc”是存放在字符串常量池中，创建过程是，首先在字符串常量池中查找有没有\"abc\"对象，如果有则将str直接指向它，如果没有就在字符串常量池中创建出来“abc”，然后在将str指向它。当有另一个String变量被赋值为abc时，直接将字符串常量池中的地址给它。如下：\n\n```\nString a = \"abc\";  \nString b = \"abc\";  \nSystem.out.println(a == b);    //打印 true \n```\n\n也就是说通过第一种方式创建的字符串在字符串常量池中，是可共享的。同时，也是不可更改的，体现在：     \n\n```\nString a = \"abc\";  \nString b = \"abc\";  \nb = b + \"def\";  \n```\n此时，字符串常量池中存在了两个对象“abc”和“abcdef”。\n\n第二种创建方式其实分为两步： \n\n```\nString s = \"def\";      \nString str2 = new String(s);  \n```\n\n第一步就是上面的第一种情况；第二步在堆内存中new出一个String对象，将str2指向该堆内存地址，新new出的String对象内容，是在字符串常量池中找到的或创建出“def”对象，相当于此时存在两份“def”对象拷贝，一份存在字符串常量池中，一份被堆内存的String对象私有化管理着。所以使用String str2 = new String(\"def\");这种方式创建对象，实际上创建了两个对象。\n\n###2.2.2 StringBuffer(JDK 1.0) 和StringBuilder(JDK1.5)\n\nStringBuffer和StringBuilder在功能上基本完全相同，它们都继承自AbstractStringBuilder，使用方法也都一样;可以对StringBuffer和StringBuilder对象进行改变，每次改变还是再原来的对象上发生的，不会重新new出新的StringBuffer或StringBuilder对象来。所以，当我们需要频繁修改字符串内容的时候，使用StringBuffer和StringBuilder是很好地选择。\n\nStringBuffer和StringBuilder的最主要区别就是线程安全方面，由于在StringBuffer内大部分方法都添加了synchronized同步，所以StringBuffer是线程安全的，而StringBuilder不是线程安全的。因此，当我们处于多线程的环境下时，我们需要使用StringBuffer，如果我们的程序是线程安全的使用StringBuilder在性能上就会更优一点。\n\n\n历年面试题：\n\n**String与StringBuffer的区别：**\n\n\n\n## 2.3 关键字\n\n### 2.3.1 switch\n\n**1、switch中的参数类型**\n\n在jdk1.7 之前switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。\n在jdk1.7 及1.7以后，switch也支持了String类型，如下：\n        \n```\nString str = \"abc\";  \nswitch (str) {  \ncase \"abc\":  \n    System.out.println(\"-----abc-----\");  \n    break;  \ncase \"aaa\":  \n    System.out.println(\"-----aaa-----\");  \n    break;  \n} \n```\n\n枚举类型\n\n```\nenum ColorEnum {\n    RED,\n    GREEN,\n    BLUE\n}\n\npublic static void main(String[] args) {\n    ColorEnum color = ColorEnum.BLUE;\n    switch (color) {\n        case RED:\n            System.out.println(\"红色\");\n            break;\n        case GREEN:\n            System.out.println(\"绿色\");\n            break;\n        case BLUE:\n            System.out.println(\"蓝色\");\n            break;\n    }\n}\n```\n\n**历年试题：**\n\n**swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?**\n\n\n### 2.3.2 break,continue,goto\n\nbreak的作用是跳出当前循环块（for、while、do while）或程序块（switch）。在循环块中的作用是跳出当前正在循环的循环体。在程序块中的作用是中断和下一个case条件的比较。\n \ncontinue用于结束循环体中其后语句的执行，并跳回循环程序块的开头执行下一次循环，而不是离开循环体。\n\ngoto:goto是java中的保留字，现在没有在java中使用。 \n\n\n**break,continue与标签**\n\n“标签”是后面跟一个冒号的标识符，就象下面这样：```label1:```\n\n对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方——在\n标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另\n一个循环或者一个开关。这是由于 break 和 continue 关键字通常只中断当前循环，但若随同标签使用，它们\n就会中断到存在标签的地方。如下所示：\n\n```\nlabel1:\n外部循环{\n  内部循环 {\n    //...\n    break; //1\n    //...\n    continue; //2\n    //...\n    continue label1; //3\n    //...\n    break label1; //4\n   }\n}\n```\n在条件 1 中，break 中断内部循环，并在外部循环结束。\n\n在条件 2 中，continue 移回内部循环的起始处。\n\n在条件 3 中，continue label1 却同时中断内部循环以及外部循环，并移至 label1 处。随后，它实际是继续\n循环，但却从外部循环开始。\n\n在条件 4 中，break label1 也会中断所有循环，并回到 label1 处，但并不重\n新进入循环。也就是说，它实际是完全中止了两个循环。\n\n**示例：**\n\n```\npublic static void main(String[] args) {\n    outerCycle:\n    for(int i = 0; i < 10; i++){\n        for(int j = 0; j < 10; j++){\n            if(j == 5){\n                continue outerCycle;\n            }\n            System.out.print(\"(\"+i+\",\"+j+\") \");\n        }\n        System.out.println();\n    }\n}\n```\n\n给外层循起始处加了标签（也就是说给外层循环起了个名字）“outerCycle”，在内层循环使用“continue outerCycle”时，就相当于在outerCycle这个循环中直接使用continue语句。\n\n(0,0) (0,1) (0,2) (0,3) (0,4) (1,0) (1,1) (1,2) (1,3) (1,4) (2,0) (2,1) (2,2) (2,3) (2,4) (3,0) (3,1) (3,2) (3,3) (3,4) (4,0) (4,1) (4,2) (4,3) (4,4) (5,0) (5,1) (5,2) (5,3) (5,4) (6,0) (6,1) (6,2) (6,3) (6,4) (7,0) (7,1) (7,2) (7,3) (7,4) (8,0) (8,1) (8,2) (8,3) (8,4) (9,0) (9,1) (9,2) (9,3) (9,4)\n\n```\npublic static void main(String[] args) {\n    outerCycle:\n    for(int i = 0; i < 10; i++){\n        for(int j = 0; j < 10; j++){\n            if(j == 5){\n                break outerCycle;\n            }\n            System.out.print(\"(\"+i+\",\"+j+\") \");\n        }\n        System.out.println();\n    }\n}\n```\n\n运行结果\n\n(0,0) (0,1) (0,2) (0,3) (0,4)\n\n\n**历年试题：**\n\n请写出下面程序的运行结果 ：\n\n```\npublic static void main(String[] args) {\n    int i = 0;\n    outer:\n    // 第一个标签\n    for (; true; ) {\n        inner:\n        //第二个标签\n        for (; i < 10; i++) {\n            prt(\"i = \" + i);\n            if (i == 2) {\n                prt(\"continue\");\n                continue;\n            }\n            if (i == 3) {\n                prt(\"break\");\n                i++; // 注意\n                break;\n            }\n            if (i == 7) {\n                prt(\"continue outer\");\n                i++; //注意\n                continue outer;\n            }\n            if (i == 8) {\n                prt(\"break outer\");\n                break outer;\n            }\n            for (int k = 0; k < 5; k++) {\n                if (k == 3) {\n                    prt(\"continue inner\");\n                    continue inner;\n                }\n            }\n        }\n    }\n\n\n}\n\n\nstatic void prt(String s) {\n    System.out.println(s);\n}\n```\n\n\n下面是输出结果：\ni = 0\ncontinue inner\ni = 1\ncontinue inner\ni = 2\ncontinue\ni = 3\nbreak\ni = 4\ncontinue inner\ni = 5\ncontinue inner\ni = 6\ncontinue inner\ni = 7\ncontinue outer\ni = 8\nbreak outer\n\n\n\n**需要匹配后通过break关键字跳出程序块，不然继续向下执行**\n\n下面的方法，当输入为2的时候返回值是多少?（）\n\n```\n    public static int getValue(int i) {\n        int result = 0;\n        switch (i) {\n        case 1:\n            result = result + i;\n        case 2:\n            result = result + i * 2;\n        case 3:\n            result = result + i * 3;\n        }\n        return result;\n    }\n```\n\nA0                    B2                    C4                     D10\n\n\n**break语句的描述中，正确的是( )**\n\nA、只中断最内层的循环 \n\nB、只中断最外层的循环 \n\nC、借助于标号，可以实现任何外层循环中断\n\nD、只中断某一层的循环\n\n\n##2.4 值传递和引用传递\n\n首先要说明的是java中是没有指针的，java中只存在值传递，只存在值传递！！！  然而我们经常看到对于对象（数组，类，接口）的传递似乎有点像引用传递，可以改变对象中某个属性的值。但是不要被这个假象所蒙蔽，实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以还是按值传递。\n\n需要注意的是当传递的是数组名或对象实例的话，其实传递的都是地址拷贝\n\n```\npublic class Test3 {\n    public static void change(int a){\n        a=50;\n    }\n    public static void main(String[] args) {\n        int a=10;\n        System.out.println(a);  //10\n        change(a);\n        System.out.println(a);  //10\n    }\n}\n```\n\n\n```\npublic class Test3 {\n    public static void change(int []a){\n        a[0]=50;\n    }\n    public static void main(String[] args) {\n        int []a={10,20};\n        System.out.println(a[0]);  //10\n        change(a);\n        System.out.println(a[0]);  //50\n    }\n}\n```\n\n\n```\nclass Emp {\n    public int age;\n}\npublic class Test {\n    public static void change(Emp emp)\n    {\n        emp.age = 50;\n        emp = new Emp();//再创建一个对象\n        emp.age=1000;\n    }\n    \n    public static void main(String[] args) {\n        Emp emp = new Emp();\n        emp.age = 100;\n        System.out.println(emp.age);  //100\n        change(emp);\n        System.out.println(emp.age);  //50\n        System.out.println(emp.age);  //50\n    }\n}\n```\n\n\n**历史考题**\n\n指出下列程序运行的结果 （）\n\n```\npublic class Example {\n\n    String str = new String(\"good\");\n\n    char[] ch = { 'a', 'b', 'c' };\n\n    public static void main(String args[]) {\n\n        Example ex = new Example();\n\n        ex.change(ex.str, ex.ch);\n\n        System.out.print(ex.str + \" and \");  //good and gbc\n\n        System.out.print(ex.ch);\n\n    }\n\n    public void change(String str, char ch[]) {\n\n        str = \"test ok\";\n\n        ch[0] = 'g';\n\n    }\n}\n```\nA、 good and abc\n\nB、 good and gbc\n\nC、 test ok and abc\n\nD、 test ok and gbc \n\n\n\n##2.5 数组\n\n**声明数组的两种方式：**\n\nint a[];\nint []a;\n\n通过上边的定义，我们只是得到了一个数组的引用。这时已经为引用分配了存储空间，但是还没有给数组对象本身分配任何空间。想要给数组对象分配存储空间，必须使用初始化表达式。\n\n**初始化数组的方式：**\n\nint a[] = new int[8]; //分配空间，赋值默认值\nint a[] = {0,1,2,3};\nint a[] = new int[]{0,1,2,3};\n\n\n\n**默认初始化**\n\n如果我们利用int a[] = new int[6]，为数组元素分配了空间，但没有初始化，Java会为他们分配默认值。如下表所示：\n\n基本类型    默认值\nboolean false\nchar       '/u0000'(null)\nbyte       (byte)0\nshort      (short)0\nint         0\nlong       0L\nfloat      0.0f\ndouble     0.0d\n\n\n**7.下面哪些语句能够正确地生成5个空字符串？**\n\nA.String   a[]=new   String[5]；for(int   i=0;i<5;a[i++]=\"\");     \n\nB.String   a[]={\"\"，\"\"，\"\"，\"\"，\"\"}；     \n\nC.String   a[5]；     \n\nD.String[5] a；     \n\nE.String   []a=new   String[5];for(int   i=0;i<5;a[i++]=null);\n\n\n\n**5.下面哪个语句正确地声明一个整型的二维数组？ **\n\n\nA. int   a[][] =   new   int[][]；     \n\nB. int   a[10][10]   =   new   int[][]；     \n\nC. int   a[][]   =   new   int[10][10]；     \n\nD. int   [][]a   =   new   int[10][10]；     \n\nE. int   []a[]   =   new   int[10][10]；\n\n\n**27.哪个语句创建了一个数组实例？ **\n\nA. int[] ia = new int [15]; \n\nB. float fa = new float [20]; \n\nC. char[] ca = \"Some String\"; \n\nD. int ia [][] = {4, 5, 6} {1, 2, 3};\n\n\n\n**数组有没有length()这个方法? String有没有length()这个方法？**\n没有，有\n\n**请问下面程序在初始化后，a[0]和b[0]的值是多少？**\n\nString []a = new String[10];  //null\nint []b = new int[10];  //0\n\n\n\n**下面程序的运行结果是：**\n\n```\nint index=1; \nint foo[]=new int[3]; \nint bar=foo[index]; \nint baz=bar+index; \n```\n\nA. baz has a value of 0 \nB. baz has value of 1 \nC. baz has value of 2 \nD. an exception is thrown \nE. the code will not compile \n\n**下面代码的运行结果为：（）**\n\n```\nimport java.io.*;\n\nimport java.util.*;\npublic class foo{\n\n    public static void main (String[] args){\n\n        String s;\n\n        System.out.println(\"s=\" + s);\n\n    }\n\n}\n```\n\nA 代码得到编译，并输出“s=”\n\nB 代码得到编译，并输出“s=null”\n\nC 由于String s没有初始化，代码不能编译通过\n\nD 代码得到编译，但捕获到 NullPointException异常\n\n\n##2.6  构造函数相关\n\n**1、如果一个类中没有写任何的构造方法，JVM会生成一个默认的无参构造方法。**\n\n**2、如果一个基类中写了有参构造函数，没有定义无参构造函数，基类是不会默认生成无参构造函数的。而且子类的构造函数中，如果没有显示通过super.调用基类构造函数，那么默认是调用父类的无参构造方法（即默认为super()，一般这句话省略了）。**\n\n下面哪三个描述是正确的？  B、C、E\n\nA. 默认构造器初始化方法变量\n\nB. 默认构造器有和它所在类相同的访问修饰词.\n\nC. 默认构造器调用其父类的无参构造器.\n\nD. 如果一个类没有无参构造器,编译器会它创建一个默认构造器.\n\nE. 只有当一个类没有任何构造器时，编译器会为它创建一个默认构造器\n\n\n以下子类B的情形哪一个是可以通过编译的：\n\n```\npublic class A {  \n    public A(String s){  }  \n}  \n\n\npublic class B extends A {   \n    String name = \"llyB\";  \n}  \n\n  \npublic class B extends A {    \n    String name = \"llyB\";  \n    public B(String s){}  \n}  \n\n  \npublic class B extends A {    \n    String name = \"llyB\";  \n    public B(String s){  \n        super(s);  \n    }  \n}   能\n```\n\n所以，只要记住，在子类的构造方法中，只要里面没有显示的通过super去调用父类相应的构造方法，默认都是调用super()，即无参构造方法，因此要确保父类有相应的构造方法。\n\n\n**3、Java创建对象的几种方式：**\n\n(1) 用new语句创建对象，这是最常见的创建对象的方法。\n(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。\n(3) 调用对象的clone()方法。\n(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。\n\n(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。\n\n\n\n历年考题：不通过构造函数也能创建对象吗（A）\n\nA 是     B 否\n\n\n\n下列说法正确的有（c）\n\nA． class中的constructor不可省略\n\nB． constructor必须与class同名，但方法不能与class同名\n\nC． constructor在一个对象被new时执行\n\nD．一个class只能定义一个constructor\n\n\n**4、构造函数调用顺序**\n\n在Java中，子类的构造过程中必须调用其父类的构造函数，是因为有继承关系存在时，子类要把父类的内容继承下来。但如果父类有多个构造函数时，该如何选择调用呢？\n\n第一个规则：子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，那么编译器会帮我们加上一个默认的构造方法（就是没有参数的构造方法），但是如果你自己写了构造方法，那么编译器就不会给你添加了，所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是如果在子类构造方法中我们并没有显示的调用基类的构造方法，如：super();  这样就会调用父类没有参数的构造方法。    \n\n第二个规则：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数，此时无参的构造函数就不会被调用。\n\n总之，一句话：子类没有显示调用父类构造函数，不管子类构造函数是否带参数都默认调用父类无参的构造函数，若父类没有则编译出错。\n\n历年考题：下面是People和Child类的定义和构造方法，每个构造方法都输出编号。在执行new Child(\"mike\")的时候都有哪些构造方法被顺序调用？请选择输出结果 ( )\n\n```\nclass People {\n    String name;\n\n    public People() {\n        System.out.print(1);\n    }\n\n    public People(String name) {\n        System.out.print(2);\n        this.name = name;\n    }\n}\n\nclass Child extends People {\n    People father;\n\n    public Child(String name) {\n        System.out.print(3);\n        this.name = name;\n        father = new People(name + \":F\");\n    }\n\n    public Child() {\n        System.out.print(4);\n    }\n    \n}\n```\nA312              B 32               C 432              D 132\n\n\n**5、override与Overloading**\n\nOverride（重写）:    \n    在子类中定义与父类具有完全相同的名称和参数的方法，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，是子类与父类之间多态性的一种体现。特点如下：\n  （1）子类方法的访问权限只能比父类的更大，不能更小（可以相同）；\n  （2）如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法；\n\nOverload（重载）:\n  同一个类中可以有多个名称相同的方法，但方法的参数个数和参数类型或者参数顺序不同；\n    关于重载函数返回类型能否不一样，需分情况：\n（1）如果几个Overloaded的方法的参数列表不一样（个数或类型），它们的返回者类型当然也可以不一样；\n（2）两个方法的参数列表完全一样，则不能通过让其返回类型的不同来实现重载。\n（3）不同的参数顺序也是可以实现重载的；  \n（4）构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载。  \n\n### 2.7 静态代码块执行顺序\n\n执行顺序：1.静态代码块 --> 2.普通代码块 --> 3.构造方法\n\n需要明白的是，1是类级别的，2和3是实例级别的，所以在父子类关系中，上述的执行顺序为：\n\n父类静态代码块-->子类静态代码块-->父类普通代码块-->父类构造方法-->子类代码块-->子类构造方法；\n\n也就是上到下（父类到子类）先走完 类级别的（静态的）--> 再依次走完父类的所有实例级别代码 --> 再走子类所有实例级别代码\n\n历史题目：\n\n如下代码的输出结果：\n\n```\npublic class HelloB extends HelloA {\n     public HelloB() {\n         System.out.println(\"-----------HelloB 构造方法------------\");\n     }\n\n     {\n         System.out.println(\"I’m B class\");\n     }\n\n     static{\n         System.out.println(\"static B\");\n     }\n     public static void main(String[] args){\n         new HelloB();\n     }\n}\n\nclass HelloA{\n     public HelloA(){\n         System.out.println(\"-----------HelloA 构造方法------------\");\n     }\n\n     {\n         System.out.println(\"I’m A class\");\n     }\n\n     static{\n         System.out.println(\"static A\");\n     }\n}\n```\n\n输出结果：\nstatic A\nstatic B\nI’m A class\n-----------HelloA 构造方法------------\nI’m B class\n-----------HelloB 构造方法------------\n\n\n**下面程序的运行结果是什么（）**\n\n```\nclass HelloA {\n\n    public HelloA() {\n        System.out.println(\"HelloA\");\n    }\n    \n    { System.out.println(\"I'm A class\"); }\n    \n    static { System.out.println(\"static A\"); }\n\n}\n\npublic class HelloB extends HelloA {\n    public HelloB() {\n        System.out.println(\"HelloB\");\n    }\n    \n    { System.out.println(\"I'm B class\"); }\n    \n    static { System.out.println(\"static B\"); }\n    \n    public static void main(String[] args) { \n　　　　 new HelloB(); \n　　 }\n\n}\n```\n\n答案：\n\n```\nstatic A\nstatic B\nI'm A class\nHelloA\nI'm B class\nHelloB\n```\n\n\n### 2.8 面向对象\n\n1、Java面向对象的基本思想之一是封装细节并且公开接口。Java语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为四种级别：\n\n（1）public： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；\n\n（2）protected： 用protected修饰的类、类属变量及方法，包内的任何类及包外那些继承了该类的子类才能访问（此处稍后解释），protected重点突出继承；\n\n（3）default： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。default重点突出包；\n\n（4）private： 用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。　\n\n|修饰符    |当前类    |同 包    |子 类    |其他包|\n| ----- |------ |-------|-------|------|\n|public |  √    | √     | √     | √    |\n|protected | √  |    √  |     √ |     ×|\n|default|   √   | √     | ×     | ×    |\n|private|   √   | ×     | ×     | ×    |\n\n2、final修饰的类不能被继承，没有子类。\n\n3、abstract修饰的类不能被实例化，必须被子类继承。类只要有一个抽象方法就必定是抽象类，但抽象类不一定要有抽象方法。声明方式必须是：```abstract void C();``` 不能带我实现体大括号。\n\n历史题目：\n\n**1、如下代码：**\n\n```\nclass A {\n\nA() { }\n\n}\n\nclass B extends A {\n\n}\n```\n\n哪两个说明是正确的？   \n\nA. B类的构造器应该是 public.\n\nB. B类的构造器应该是没有参数\n\nC. B类的构造器应该调用this().\n\nD. B类的构造器应该调用super().\n\n**是否可以继承String类?**\n\nString类是final类故不可以继承。\n\n**以public修饰的类如：public class Car{…} 则Car( )  **\n\nA、可被其它程序包中的类使用 B、仅能被本程序包中的类使用\n\nC、不能被任意其它类使用 D、不能被其它类继承\n\n### 2.9 equals与==的区别\n\n**（1）==是一个运算符，它比较的是值**\n    \n对于基本数据类型，直接比较其数据值是否相等。如果是不同的基本数据类型之间进行比较，则遵循基本数据类型间运算的转换原则。如下：\n  \n```        \nif(12 == 12.0){  \n    System.out.println(\"-----12 == 12.0-------\");  \n} \n``` \n\n此时打印了-----12 == 12.0-------，因为低一级的int类型的12自动转换为高一级的float类型\n\n对于引用类型，==比较的还是值，只不过此时比较的是两个对象变量的内存地址。所以，用==来比较对象，实际上是判断这两个对象是否是同一个new出来的对象，或者是否是一个对象赋值给另一个对象的情况。如：\n\n```\nString s1 = new String(\"abc\");\nString s2 = s1;//将s1对的内存地址赋给了s2，此时s1==s2返回true；\n```\n\n**（2）equals**\n\nequals方法是属于Object类的一个方法，其实现源码如下：\n   \n```\npublic boolean equals(Object obj) {  \n    return (this == obj);  \n}  \n```\n\n可以看到，其实equals方法里面用的还是==运算符，所以对于那些没有重写过Object类的equals方法来说，==和equals方法是等价的！\n\n然而，很多类都自己去重写了equals方法，比如String类、所有基本数据类型的包装类等\nString类的equals源码如下：\n    \n```\npublic boolean equals(Object anObject) {  \n    if (this == anObject) {  \n        return true;  \n    }  \n    if (anObject instanceof String) {  \n        String anotherString = (String) anObject;  \n        int n = value.length;  \n        if (n == anotherString.value.length) {  \n            char v1[] = value;  \n            char v2[] = anotherString.value;  \n            int i = 0;  \n            while (n-- != 0) {  \n                if (v1[i] != v2[i])  \n                        return false;  \n                i++;  \n            }  \n            return true;  \n        }  \n    }  \n    return false;  \n}  \n```\n\n首先判断是否是同一个new出来的对象，即判断内存地址是否相同；如果不同则判断对象中的内容是否相同。\n\nInteger类的equals方法如下：\n\n```   \npublic boolean equals(Object obj) {  \n    if (obj instanceof Integer) {  \n        return value == ((Integer)obj).intValue();  \n    }  \n    return false;  \n}  \n```\n\n直接转成判断值是否相等了。\n\n因此，对于String类和所有基本数据类型的包装类来说，equals方法就是判断其内容是否相等。对于其他类来说，要具体看其是否重写了equals方法及具体业务实现。\n\n另：对于基本数据类型来说，使用equals方法，需要用该基本类型对应的包装类，因为equals是针对对象来使用的！\n\n\n**下面程序的运行结果是（）**\n\n```\nString str1 = \"hello\";\nString str2 = \"he\" + new String(\"llo\");\nSystem.err.println(str1 == str2);\n```\n\n\n##其它基础\n\n**&和&&的区别**\n\n&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）。\n\n**下面的语句会产生什么样的输出? **\n\nSystem.out.println(4&7);\n\nA.4\n\nB.5\n\nC.6\n\nD.7\n\nE.0\n\n**5、try、catch、finally执行顺序问题**\n\n**14. 如下代码：**\n\n```\npublic class Foo {\n\npublic static void main(String[] args) {\n\ntry {\n\nreturn;\n\n} finally {\n\nSystem.out.println( \"Finally\" );\n\n}\n}\n}\n```\n\n输出结果是什么?   A\n\nA. Finally\n\nB.编译失败\n\nC. 代码正常运行但没有任何输出.\n\nD. 运行时抛出异常\n\n\n下面函数将返回？\n\n```\npublicstaticintfunc (){\n    try{\n        return 1;\n    }catch(Exception e){\n        return 2;\n    }finally{\n        return 3;\n    }\n}\n```\nA、1    B、2    C、3     D、编译错误\n\n","source":"_posts/面试基础（一）.md","raw":"---\ntitle: 面试基础（一）\ndate: 2017-06-22 22:25:37\ntags:\n---\n\n#### 基础数据类型\n基本数据类型分为原始类型和包装类型，Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型(wrapper class)，int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。\n\n8种原始类型 | 容量 | 对应包装类型\n------------ | ------------- | ------------\nbyte(字节)    |         8 位   |           Byte\nshot(短整型)   |        16位     |         Short\nint(整型)      |           32 位 |            Integer\nlong(长整型)   |       64 位      |         Long\nfloat(浮点型)  |        32 位     |          Float\ndouble(双精度) |    64 位        |       Double\nchar(字符型)   |       16 位     |          Character\nboolean(布尔型) |   1 位         |       Boolean\n\n注意几点：\n\n**1、各数据类型按容量大小（表数范围大小）由小到大排列为：**\n\nbyte <—— short, char  <——int <——long <——float <——double\n\n**2、基本类型之间的转换原则：**\n\n1）运算时，容量小的类型自动转换为容量大的类型；\n\n2）容量大的类型转换为容量小的类型时，要加强制转换符，且精度可能丢失；\n\n```\n如：float f = 1.2f;\nint ff = (int) f;\nSystem.out.println(ff);  1\n```            \n\n3）short，char之间不会互相转换（需要强制转换），byte、short、char并且三者在计算时首先转换为int类型；\n\n4）实数常量默认为double类型， 整数常量默认为int类型；\n\n**3、包装类及String类都是定定义为public final class的，因此这几个都不能被继承；　　**\n\n**4、原始类型是可以通过==直接判断是否相等的，而包装类型是类，通过==判断值是否相等是不对的，必须通过equals()函数**\n\n\n\n**下面的程序中，temp的最终值是什么？  **\n\n```\nlong temp=(int)3.9;   3\n\ntemp%=2;   1\n```\n\nA .0\n\nB .1\n\nC .2\n\nD .3\n\nE .4\n\n\n**short s1 = 1; s1 = s1 + 1;有什么错（错误）? short s1 = 1; s1 += 1;有什么错（正确）?**\n\n\n**下面哪个不是JAVA关键字 **\n\nA  integer\n\nB  double\n\nC  float\n\nD  default\n\n\n###2.1.2 历年考题\n\n**下面哪些不是java的简单数据类型?** AC\n\nA. short  B. Boolean  C. Double  D. float\n\n\n**0.6332的数据类型是（）**  A\n\nA float     B double     C Float      D Double\n\n\n**float f=3.4;是否正确?**  错\n\n\n\n**下面哪些类可以被继承**\n\n下面哪些类可以被继承？  ABDE\nJava.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader\nA、Thread    B、Number    C、Double    D、Math    E、ClassLoader\n\n\n**String 是最基本的数据类型吗?**不是\n\n\n**int和Integer有什么区别?** 原始类型和封装类型，java5后自动拆箱和封箱机制\n\n\n**5、请写出下面程序的运行结果：**\n　\n```\nclass AutoUnboxingTest {\n    public static void main(String[] args) {\n        Integer a = new Integer(3);\n        Integer b = 3; // 将3自动装箱成Integer类型\n        int c = 3;\n        System.out.println(a == b); // false 两个引用没有引用同一对象\n        System.out.println(a == c); // true a自动拆箱成int类型再和c比较\n        System.out.println(b == c); // true b自动装箱然后自动拆箱成int类型再和c比较\n\n    }\n}\n```\n\n\n## 2.2 String、StringBuilder、StringBuffer\n\n### 2.2.1 String\n\n字符串常量，不可更改，因为其内部定义的是一个final类型的数组来保存值的，如下：\n\n```\nprivate final char value[];\n```    \n\n所以，当我们每次去“更改”String变量的值的时候（包括重新赋值或者使用String内部的一些方法），其实是重新新建了一个String对象（new String）来保存新的值，然后让我们的变量指向新的对象。因此，当我们需要频繁改变字符串的时候，使用String会带来较大的开销。\n\n定义String的方法有两种：\n\n（1）String str = \"abc\";\n（2）String str2 = new String(\"def\");\n\n第一种方式创建的String对象“abc”是存放在字符串常量池中，创建过程是，首先在字符串常量池中查找有没有\"abc\"对象，如果有则将str直接指向它，如果没有就在字符串常量池中创建出来“abc”，然后在将str指向它。当有另一个String变量被赋值为abc时，直接将字符串常量池中的地址给它。如下：\n\n```\nString a = \"abc\";  \nString b = \"abc\";  \nSystem.out.println(a == b);    //打印 true \n```\n\n也就是说通过第一种方式创建的字符串在字符串常量池中，是可共享的。同时，也是不可更改的，体现在：     \n\n```\nString a = \"abc\";  \nString b = \"abc\";  \nb = b + \"def\";  \n```\n此时，字符串常量池中存在了两个对象“abc”和“abcdef”。\n\n第二种创建方式其实分为两步： \n\n```\nString s = \"def\";      \nString str2 = new String(s);  \n```\n\n第一步就是上面的第一种情况；第二步在堆内存中new出一个String对象，将str2指向该堆内存地址，新new出的String对象内容，是在字符串常量池中找到的或创建出“def”对象，相当于此时存在两份“def”对象拷贝，一份存在字符串常量池中，一份被堆内存的String对象私有化管理着。所以使用String str2 = new String(\"def\");这种方式创建对象，实际上创建了两个对象。\n\n###2.2.2 StringBuffer(JDK 1.0) 和StringBuilder(JDK1.5)\n\nStringBuffer和StringBuilder在功能上基本完全相同，它们都继承自AbstractStringBuilder，使用方法也都一样;可以对StringBuffer和StringBuilder对象进行改变，每次改变还是再原来的对象上发生的，不会重新new出新的StringBuffer或StringBuilder对象来。所以，当我们需要频繁修改字符串内容的时候，使用StringBuffer和StringBuilder是很好地选择。\n\nStringBuffer和StringBuilder的最主要区别就是线程安全方面，由于在StringBuffer内大部分方法都添加了synchronized同步，所以StringBuffer是线程安全的，而StringBuilder不是线程安全的。因此，当我们处于多线程的环境下时，我们需要使用StringBuffer，如果我们的程序是线程安全的使用StringBuilder在性能上就会更优一点。\n\n\n历年面试题：\n\n**String与StringBuffer的区别：**\n\n\n\n## 2.3 关键字\n\n### 2.3.1 switch\n\n**1、switch中的参数类型**\n\n在jdk1.7 之前switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。\n在jdk1.7 及1.7以后，switch也支持了String类型，如下：\n        \n```\nString str = \"abc\";  \nswitch (str) {  \ncase \"abc\":  \n    System.out.println(\"-----abc-----\");  \n    break;  \ncase \"aaa\":  \n    System.out.println(\"-----aaa-----\");  \n    break;  \n} \n```\n\n枚举类型\n\n```\nenum ColorEnum {\n    RED,\n    GREEN,\n    BLUE\n}\n\npublic static void main(String[] args) {\n    ColorEnum color = ColorEnum.BLUE;\n    switch (color) {\n        case RED:\n            System.out.println(\"红色\");\n            break;\n        case GREEN:\n            System.out.println(\"绿色\");\n            break;\n        case BLUE:\n            System.out.println(\"蓝色\");\n            break;\n    }\n}\n```\n\n**历年试题：**\n\n**swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?**\n\n\n### 2.3.2 break,continue,goto\n\nbreak的作用是跳出当前循环块（for、while、do while）或程序块（switch）。在循环块中的作用是跳出当前正在循环的循环体。在程序块中的作用是中断和下一个case条件的比较。\n \ncontinue用于结束循环体中其后语句的执行，并跳回循环程序块的开头执行下一次循环，而不是离开循环体。\n\ngoto:goto是java中的保留字，现在没有在java中使用。 \n\n\n**break,continue与标签**\n\n“标签”是后面跟一个冒号的标识符，就象下面这样：```label1:```\n\n对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方——在\n标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另\n一个循环或者一个开关。这是由于 break 和 continue 关键字通常只中断当前循环，但若随同标签使用，它们\n就会中断到存在标签的地方。如下所示：\n\n```\nlabel1:\n外部循环{\n  内部循环 {\n    //...\n    break; //1\n    //...\n    continue; //2\n    //...\n    continue label1; //3\n    //...\n    break label1; //4\n   }\n}\n```\n在条件 1 中，break 中断内部循环，并在外部循环结束。\n\n在条件 2 中，continue 移回内部循环的起始处。\n\n在条件 3 中，continue label1 却同时中断内部循环以及外部循环，并移至 label1 处。随后，它实际是继续\n循环，但却从外部循环开始。\n\n在条件 4 中，break label1 也会中断所有循环，并回到 label1 处，但并不重\n新进入循环。也就是说，它实际是完全中止了两个循环。\n\n**示例：**\n\n```\npublic static void main(String[] args) {\n    outerCycle:\n    for(int i = 0; i < 10; i++){\n        for(int j = 0; j < 10; j++){\n            if(j == 5){\n                continue outerCycle;\n            }\n            System.out.print(\"(\"+i+\",\"+j+\") \");\n        }\n        System.out.println();\n    }\n}\n```\n\n给外层循起始处加了标签（也就是说给外层循环起了个名字）“outerCycle”，在内层循环使用“continue outerCycle”时，就相当于在outerCycle这个循环中直接使用continue语句。\n\n(0,0) (0,1) (0,2) (0,3) (0,4) (1,0) (1,1) (1,2) (1,3) (1,4) (2,0) (2,1) (2,2) (2,3) (2,4) (3,0) (3,1) (3,2) (3,3) (3,4) (4,0) (4,1) (4,2) (4,3) (4,4) (5,0) (5,1) (5,2) (5,3) (5,4) (6,0) (6,1) (6,2) (6,3) (6,4) (7,0) (7,1) (7,2) (7,3) (7,4) (8,0) (8,1) (8,2) (8,3) (8,4) (9,0) (9,1) (9,2) (9,3) (9,4)\n\n```\npublic static void main(String[] args) {\n    outerCycle:\n    for(int i = 0; i < 10; i++){\n        for(int j = 0; j < 10; j++){\n            if(j == 5){\n                break outerCycle;\n            }\n            System.out.print(\"(\"+i+\",\"+j+\") \");\n        }\n        System.out.println();\n    }\n}\n```\n\n运行结果\n\n(0,0) (0,1) (0,2) (0,3) (0,4)\n\n\n**历年试题：**\n\n请写出下面程序的运行结果 ：\n\n```\npublic static void main(String[] args) {\n    int i = 0;\n    outer:\n    // 第一个标签\n    for (; true; ) {\n        inner:\n        //第二个标签\n        for (; i < 10; i++) {\n            prt(\"i = \" + i);\n            if (i == 2) {\n                prt(\"continue\");\n                continue;\n            }\n            if (i == 3) {\n                prt(\"break\");\n                i++; // 注意\n                break;\n            }\n            if (i == 7) {\n                prt(\"continue outer\");\n                i++; //注意\n                continue outer;\n            }\n            if (i == 8) {\n                prt(\"break outer\");\n                break outer;\n            }\n            for (int k = 0; k < 5; k++) {\n                if (k == 3) {\n                    prt(\"continue inner\");\n                    continue inner;\n                }\n            }\n        }\n    }\n\n\n}\n\n\nstatic void prt(String s) {\n    System.out.println(s);\n}\n```\n\n\n下面是输出结果：\ni = 0\ncontinue inner\ni = 1\ncontinue inner\ni = 2\ncontinue\ni = 3\nbreak\ni = 4\ncontinue inner\ni = 5\ncontinue inner\ni = 6\ncontinue inner\ni = 7\ncontinue outer\ni = 8\nbreak outer\n\n\n\n**需要匹配后通过break关键字跳出程序块，不然继续向下执行**\n\n下面的方法，当输入为2的时候返回值是多少?（）\n\n```\n    public static int getValue(int i) {\n        int result = 0;\n        switch (i) {\n        case 1:\n            result = result + i;\n        case 2:\n            result = result + i * 2;\n        case 3:\n            result = result + i * 3;\n        }\n        return result;\n    }\n```\n\nA0                    B2                    C4                     D10\n\n\n**break语句的描述中，正确的是( )**\n\nA、只中断最内层的循环 \n\nB、只中断最外层的循环 \n\nC、借助于标号，可以实现任何外层循环中断\n\nD、只中断某一层的循环\n\n\n##2.4 值传递和引用传递\n\n首先要说明的是java中是没有指针的，java中只存在值传递，只存在值传递！！！  然而我们经常看到对于对象（数组，类，接口）的传递似乎有点像引用传递，可以改变对象中某个属性的值。但是不要被这个假象所蒙蔽，实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以还是按值传递。\n\n需要注意的是当传递的是数组名或对象实例的话，其实传递的都是地址拷贝\n\n```\npublic class Test3 {\n    public static void change(int a){\n        a=50;\n    }\n    public static void main(String[] args) {\n        int a=10;\n        System.out.println(a);  //10\n        change(a);\n        System.out.println(a);  //10\n    }\n}\n```\n\n\n```\npublic class Test3 {\n    public static void change(int []a){\n        a[0]=50;\n    }\n    public static void main(String[] args) {\n        int []a={10,20};\n        System.out.println(a[0]);  //10\n        change(a);\n        System.out.println(a[0]);  //50\n    }\n}\n```\n\n\n```\nclass Emp {\n    public int age;\n}\npublic class Test {\n    public static void change(Emp emp)\n    {\n        emp.age = 50;\n        emp = new Emp();//再创建一个对象\n        emp.age=1000;\n    }\n    \n    public static void main(String[] args) {\n        Emp emp = new Emp();\n        emp.age = 100;\n        System.out.println(emp.age);  //100\n        change(emp);\n        System.out.println(emp.age);  //50\n        System.out.println(emp.age);  //50\n    }\n}\n```\n\n\n**历史考题**\n\n指出下列程序运行的结果 （）\n\n```\npublic class Example {\n\n    String str = new String(\"good\");\n\n    char[] ch = { 'a', 'b', 'c' };\n\n    public static void main(String args[]) {\n\n        Example ex = new Example();\n\n        ex.change(ex.str, ex.ch);\n\n        System.out.print(ex.str + \" and \");  //good and gbc\n\n        System.out.print(ex.ch);\n\n    }\n\n    public void change(String str, char ch[]) {\n\n        str = \"test ok\";\n\n        ch[0] = 'g';\n\n    }\n}\n```\nA、 good and abc\n\nB、 good and gbc\n\nC、 test ok and abc\n\nD、 test ok and gbc \n\n\n\n##2.5 数组\n\n**声明数组的两种方式：**\n\nint a[];\nint []a;\n\n通过上边的定义，我们只是得到了一个数组的引用。这时已经为引用分配了存储空间，但是还没有给数组对象本身分配任何空间。想要给数组对象分配存储空间，必须使用初始化表达式。\n\n**初始化数组的方式：**\n\nint a[] = new int[8]; //分配空间，赋值默认值\nint a[] = {0,1,2,3};\nint a[] = new int[]{0,1,2,3};\n\n\n\n**默认初始化**\n\n如果我们利用int a[] = new int[6]，为数组元素分配了空间，但没有初始化，Java会为他们分配默认值。如下表所示：\n\n基本类型    默认值\nboolean false\nchar       '/u0000'(null)\nbyte       (byte)0\nshort      (short)0\nint         0\nlong       0L\nfloat      0.0f\ndouble     0.0d\n\n\n**7.下面哪些语句能够正确地生成5个空字符串？**\n\nA.String   a[]=new   String[5]；for(int   i=0;i<5;a[i++]=\"\");     \n\nB.String   a[]={\"\"，\"\"，\"\"，\"\"，\"\"}；     \n\nC.String   a[5]；     \n\nD.String[5] a；     \n\nE.String   []a=new   String[5];for(int   i=0;i<5;a[i++]=null);\n\n\n\n**5.下面哪个语句正确地声明一个整型的二维数组？ **\n\n\nA. int   a[][] =   new   int[][]；     \n\nB. int   a[10][10]   =   new   int[][]；     \n\nC. int   a[][]   =   new   int[10][10]；     \n\nD. int   [][]a   =   new   int[10][10]；     \n\nE. int   []a[]   =   new   int[10][10]；\n\n\n**27.哪个语句创建了一个数组实例？ **\n\nA. int[] ia = new int [15]; \n\nB. float fa = new float [20]; \n\nC. char[] ca = \"Some String\"; \n\nD. int ia [][] = {4, 5, 6} {1, 2, 3};\n\n\n\n**数组有没有length()这个方法? String有没有length()这个方法？**\n没有，有\n\n**请问下面程序在初始化后，a[0]和b[0]的值是多少？**\n\nString []a = new String[10];  //null\nint []b = new int[10];  //0\n\n\n\n**下面程序的运行结果是：**\n\n```\nint index=1; \nint foo[]=new int[3]; \nint bar=foo[index]; \nint baz=bar+index; \n```\n\nA. baz has a value of 0 \nB. baz has value of 1 \nC. baz has value of 2 \nD. an exception is thrown \nE. the code will not compile \n\n**下面代码的运行结果为：（）**\n\n```\nimport java.io.*;\n\nimport java.util.*;\npublic class foo{\n\n    public static void main (String[] args){\n\n        String s;\n\n        System.out.println(\"s=\" + s);\n\n    }\n\n}\n```\n\nA 代码得到编译，并输出“s=”\n\nB 代码得到编译，并输出“s=null”\n\nC 由于String s没有初始化，代码不能编译通过\n\nD 代码得到编译，但捕获到 NullPointException异常\n\n\n##2.6  构造函数相关\n\n**1、如果一个类中没有写任何的构造方法，JVM会生成一个默认的无参构造方法。**\n\n**2、如果一个基类中写了有参构造函数，没有定义无参构造函数，基类是不会默认生成无参构造函数的。而且子类的构造函数中，如果没有显示通过super.调用基类构造函数，那么默认是调用父类的无参构造方法（即默认为super()，一般这句话省略了）。**\n\n下面哪三个描述是正确的？  B、C、E\n\nA. 默认构造器初始化方法变量\n\nB. 默认构造器有和它所在类相同的访问修饰词.\n\nC. 默认构造器调用其父类的无参构造器.\n\nD. 如果一个类没有无参构造器,编译器会它创建一个默认构造器.\n\nE. 只有当一个类没有任何构造器时，编译器会为它创建一个默认构造器\n\n\n以下子类B的情形哪一个是可以通过编译的：\n\n```\npublic class A {  \n    public A(String s){  }  \n}  \n\n\npublic class B extends A {   \n    String name = \"llyB\";  \n}  \n\n  \npublic class B extends A {    \n    String name = \"llyB\";  \n    public B(String s){}  \n}  \n\n  \npublic class B extends A {    \n    String name = \"llyB\";  \n    public B(String s){  \n        super(s);  \n    }  \n}   能\n```\n\n所以，只要记住，在子类的构造方法中，只要里面没有显示的通过super去调用父类相应的构造方法，默认都是调用super()，即无参构造方法，因此要确保父类有相应的构造方法。\n\n\n**3、Java创建对象的几种方式：**\n\n(1) 用new语句创建对象，这是最常见的创建对象的方法。\n(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。\n(3) 调用对象的clone()方法。\n(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。\n\n(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。\n\n\n\n历年考题：不通过构造函数也能创建对象吗（A）\n\nA 是     B 否\n\n\n\n下列说法正确的有（c）\n\nA． class中的constructor不可省略\n\nB． constructor必须与class同名，但方法不能与class同名\n\nC． constructor在一个对象被new时执行\n\nD．一个class只能定义一个constructor\n\n\n**4、构造函数调用顺序**\n\n在Java中，子类的构造过程中必须调用其父类的构造函数，是因为有继承关系存在时，子类要把父类的内容继承下来。但如果父类有多个构造函数时，该如何选择调用呢？\n\n第一个规则：子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，那么编译器会帮我们加上一个默认的构造方法（就是没有参数的构造方法），但是如果你自己写了构造方法，那么编译器就不会给你添加了，所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是如果在子类构造方法中我们并没有显示的调用基类的构造方法，如：super();  这样就会调用父类没有参数的构造方法。    \n\n第二个规则：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数，此时无参的构造函数就不会被调用。\n\n总之，一句话：子类没有显示调用父类构造函数，不管子类构造函数是否带参数都默认调用父类无参的构造函数，若父类没有则编译出错。\n\n历年考题：下面是People和Child类的定义和构造方法，每个构造方法都输出编号。在执行new Child(\"mike\")的时候都有哪些构造方法被顺序调用？请选择输出结果 ( )\n\n```\nclass People {\n    String name;\n\n    public People() {\n        System.out.print(1);\n    }\n\n    public People(String name) {\n        System.out.print(2);\n        this.name = name;\n    }\n}\n\nclass Child extends People {\n    People father;\n\n    public Child(String name) {\n        System.out.print(3);\n        this.name = name;\n        father = new People(name + \":F\");\n    }\n\n    public Child() {\n        System.out.print(4);\n    }\n    \n}\n```\nA312              B 32               C 432              D 132\n\n\n**5、override与Overloading**\n\nOverride（重写）:    \n    在子类中定义与父类具有完全相同的名称和参数的方法，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，是子类与父类之间多态性的一种体现。特点如下：\n  （1）子类方法的访问权限只能比父类的更大，不能更小（可以相同）；\n  （2）如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法；\n\nOverload（重载）:\n  同一个类中可以有多个名称相同的方法，但方法的参数个数和参数类型或者参数顺序不同；\n    关于重载函数返回类型能否不一样，需分情况：\n（1）如果几个Overloaded的方法的参数列表不一样（个数或类型），它们的返回者类型当然也可以不一样；\n（2）两个方法的参数列表完全一样，则不能通过让其返回类型的不同来实现重载。\n（3）不同的参数顺序也是可以实现重载的；  \n（4）构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载。  \n\n### 2.7 静态代码块执行顺序\n\n执行顺序：1.静态代码块 --> 2.普通代码块 --> 3.构造方法\n\n需要明白的是，1是类级别的，2和3是实例级别的，所以在父子类关系中，上述的执行顺序为：\n\n父类静态代码块-->子类静态代码块-->父类普通代码块-->父类构造方法-->子类代码块-->子类构造方法；\n\n也就是上到下（父类到子类）先走完 类级别的（静态的）--> 再依次走完父类的所有实例级别代码 --> 再走子类所有实例级别代码\n\n历史题目：\n\n如下代码的输出结果：\n\n```\npublic class HelloB extends HelloA {\n     public HelloB() {\n         System.out.println(\"-----------HelloB 构造方法------------\");\n     }\n\n     {\n         System.out.println(\"I’m B class\");\n     }\n\n     static{\n         System.out.println(\"static B\");\n     }\n     public static void main(String[] args){\n         new HelloB();\n     }\n}\n\nclass HelloA{\n     public HelloA(){\n         System.out.println(\"-----------HelloA 构造方法------------\");\n     }\n\n     {\n         System.out.println(\"I’m A class\");\n     }\n\n     static{\n         System.out.println(\"static A\");\n     }\n}\n```\n\n输出结果：\nstatic A\nstatic B\nI’m A class\n-----------HelloA 构造方法------------\nI’m B class\n-----------HelloB 构造方法------------\n\n\n**下面程序的运行结果是什么（）**\n\n```\nclass HelloA {\n\n    public HelloA() {\n        System.out.println(\"HelloA\");\n    }\n    \n    { System.out.println(\"I'm A class\"); }\n    \n    static { System.out.println(\"static A\"); }\n\n}\n\npublic class HelloB extends HelloA {\n    public HelloB() {\n        System.out.println(\"HelloB\");\n    }\n    \n    { System.out.println(\"I'm B class\"); }\n    \n    static { System.out.println(\"static B\"); }\n    \n    public static void main(String[] args) { \n　　　　 new HelloB(); \n　　 }\n\n}\n```\n\n答案：\n\n```\nstatic A\nstatic B\nI'm A class\nHelloA\nI'm B class\nHelloB\n```\n\n\n### 2.8 面向对象\n\n1、Java面向对象的基本思想之一是封装细节并且公开接口。Java语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为四种级别：\n\n（1）public： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；\n\n（2）protected： 用protected修饰的类、类属变量及方法，包内的任何类及包外那些继承了该类的子类才能访问（此处稍后解释），protected重点突出继承；\n\n（3）default： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。default重点突出包；\n\n（4）private： 用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。　\n\n|修饰符    |当前类    |同 包    |子 类    |其他包|\n| ----- |------ |-------|-------|------|\n|public |  √    | √     | √     | √    |\n|protected | √  |    √  |     √ |     ×|\n|default|   √   | √     | ×     | ×    |\n|private|   √   | ×     | ×     | ×    |\n\n2、final修饰的类不能被继承，没有子类。\n\n3、abstract修饰的类不能被实例化，必须被子类继承。类只要有一个抽象方法就必定是抽象类，但抽象类不一定要有抽象方法。声明方式必须是：```abstract void C();``` 不能带我实现体大括号。\n\n历史题目：\n\n**1、如下代码：**\n\n```\nclass A {\n\nA() { }\n\n}\n\nclass B extends A {\n\n}\n```\n\n哪两个说明是正确的？   \n\nA. B类的构造器应该是 public.\n\nB. B类的构造器应该是没有参数\n\nC. B类的构造器应该调用this().\n\nD. B类的构造器应该调用super().\n\n**是否可以继承String类?**\n\nString类是final类故不可以继承。\n\n**以public修饰的类如：public class Car{…} 则Car( )  **\n\nA、可被其它程序包中的类使用 B、仅能被本程序包中的类使用\n\nC、不能被任意其它类使用 D、不能被其它类继承\n\n### 2.9 equals与==的区别\n\n**（1）==是一个运算符，它比较的是值**\n    \n对于基本数据类型，直接比较其数据值是否相等。如果是不同的基本数据类型之间进行比较，则遵循基本数据类型间运算的转换原则。如下：\n  \n```        \nif(12 == 12.0){  \n    System.out.println(\"-----12 == 12.0-------\");  \n} \n``` \n\n此时打印了-----12 == 12.0-------，因为低一级的int类型的12自动转换为高一级的float类型\n\n对于引用类型，==比较的还是值，只不过此时比较的是两个对象变量的内存地址。所以，用==来比较对象，实际上是判断这两个对象是否是同一个new出来的对象，或者是否是一个对象赋值给另一个对象的情况。如：\n\n```\nString s1 = new String(\"abc\");\nString s2 = s1;//将s1对的内存地址赋给了s2，此时s1==s2返回true；\n```\n\n**（2）equals**\n\nequals方法是属于Object类的一个方法，其实现源码如下：\n   \n```\npublic boolean equals(Object obj) {  \n    return (this == obj);  \n}  \n```\n\n可以看到，其实equals方法里面用的还是==运算符，所以对于那些没有重写过Object类的equals方法来说，==和equals方法是等价的！\n\n然而，很多类都自己去重写了equals方法，比如String类、所有基本数据类型的包装类等\nString类的equals源码如下：\n    \n```\npublic boolean equals(Object anObject) {  \n    if (this == anObject) {  \n        return true;  \n    }  \n    if (anObject instanceof String) {  \n        String anotherString = (String) anObject;  \n        int n = value.length;  \n        if (n == anotherString.value.length) {  \n            char v1[] = value;  \n            char v2[] = anotherString.value;  \n            int i = 0;  \n            while (n-- != 0) {  \n                if (v1[i] != v2[i])  \n                        return false;  \n                i++;  \n            }  \n            return true;  \n        }  \n    }  \n    return false;  \n}  \n```\n\n首先判断是否是同一个new出来的对象，即判断内存地址是否相同；如果不同则判断对象中的内容是否相同。\n\nInteger类的equals方法如下：\n\n```   \npublic boolean equals(Object obj) {  \n    if (obj instanceof Integer) {  \n        return value == ((Integer)obj).intValue();  \n    }  \n    return false;  \n}  \n```\n\n直接转成判断值是否相等了。\n\n因此，对于String类和所有基本数据类型的包装类来说，equals方法就是判断其内容是否相等。对于其他类来说，要具体看其是否重写了equals方法及具体业务实现。\n\n另：对于基本数据类型来说，使用equals方法，需要用该基本类型对应的包装类，因为equals是针对对象来使用的！\n\n\n**下面程序的运行结果是（）**\n\n```\nString str1 = \"hello\";\nString str2 = \"he\" + new String(\"llo\");\nSystem.err.println(str1 == str2);\n```\n\n\n##其它基础\n\n**&和&&的区别**\n\n&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）。\n\n**下面的语句会产生什么样的输出? **\n\nSystem.out.println(4&7);\n\nA.4\n\nB.5\n\nC.6\n\nD.7\n\nE.0\n\n**5、try、catch、finally执行顺序问题**\n\n**14. 如下代码：**\n\n```\npublic class Foo {\n\npublic static void main(String[] args) {\n\ntry {\n\nreturn;\n\n} finally {\n\nSystem.out.println( \"Finally\" );\n\n}\n}\n}\n```\n\n输出结果是什么?   A\n\nA. Finally\n\nB.编译失败\n\nC. 代码正常运行但没有任何输出.\n\nD. 运行时抛出异常\n\n\n下面函数将返回？\n\n```\npublicstaticintfunc (){\n    try{\n        return 1;\n    }catch(Exception e){\n        return 2;\n    }finally{\n        return 3;\n    }\n}\n```\nA、1    B、2    C、3     D、编译错误\n\n","slug":"面试基础（一）","published":1,"updated":"2017-11-08T13:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9r3xep0001e9xs6er4lssx6","content":"<h4 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h4><p>基本数据类型分为原始类型和包装类型，Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型(wrapper class)，int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>\n<table>\n<thead>\n<tr>\n<th>8种原始类型</th>\n<th>容量</th>\n<th>对应包装类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte(字节)</td>\n<td>8 位</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>shot(短整型)</td>\n<td>16位</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>int(整型)</td>\n<td>32 位</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long(长整型)</td>\n<td>64 位</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float(浮点型)</td>\n<td>32 位</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double(双精度)</td>\n<td>64 位</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>char(字符型)</td>\n<td>16 位</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>boolean(布尔型)</td>\n<td>1 位</td>\n<td>Boolean</td>\n</tr>\n</tbody>\n</table>\n<p>注意几点：</p>\n<p><strong>1、各数据类型按容量大小（表数范围大小）由小到大排列为：</strong></p>\n<p>byte &lt;—— short, char  &lt;——int &lt;——long &lt;——float &lt;——double</p>\n<p><strong>2、基本类型之间的转换原则：</strong></p>\n<p>1）运算时，容量小的类型自动转换为容量大的类型；</p>\n<p>2）容量大的类型转换为容量小的类型时，要加强制转换符，且精度可能丢失；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如：float f = 1.2f;</span><br><span class=\"line\">int ff = (int) f;</span><br><span class=\"line\">System.out.println(ff);  1</span><br><span class=\"line\">```            </span><br><span class=\"line\"></span><br><span class=\"line\">3）short，char之间不会互相转换（需要强制转换），byte、short、char并且三者在计算时首先转换为int类型；</span><br><span class=\"line\"></span><br><span class=\"line\">4）实数常量默认为double类型， 整数常量默认为int类型；</span><br><span class=\"line\"></span><br><span class=\"line\">**3、包装类及String类都是定定义为public final class的，因此这几个都不能被继承；　　**</span><br><span class=\"line\"></span><br><span class=\"line\">**4、原始类型是可以通过==直接判断是否相等的，而包装类型是类，通过==判断值是否相等是不对的，必须通过equals()函数**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**下面的程序中，temp的最终值是什么？  **</span><br></pre></td></tr></table></figure>\n<p>long temp=(int)3.9;   3</p>\n<p>temp%=2;   1<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">A .0</span><br><span class=\"line\"></span><br><span class=\"line\">B .1</span><br><span class=\"line\"></span><br><span class=\"line\">C .2</span><br><span class=\"line\"></span><br><span class=\"line\">D .3</span><br><span class=\"line\"></span><br><span class=\"line\">E .4</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**short s1 = 1; s1 = s1 + 1;有什么错（错误）? short s1 = 1; s1 += 1;有什么错（正确）?**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**下面哪个不是JAVA关键字 **</span><br><span class=\"line\"></span><br><span class=\"line\">A  integer</span><br><span class=\"line\"></span><br><span class=\"line\">B  double</span><br><span class=\"line\"></span><br><span class=\"line\">C  float</span><br><span class=\"line\"></span><br><span class=\"line\">D  default</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">###2.1.2 历年考题</span><br><span class=\"line\"></span><br><span class=\"line\">**下面哪些不是java的简单数据类型?** AC</span><br><span class=\"line\"></span><br><span class=\"line\">A. short  B. Boolean  C. Double  D. float</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**0.6332的数据类型是（）**  A</span><br><span class=\"line\"></span><br><span class=\"line\">A float     B double     C Float      D Double</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**float f=3.4;是否正确?**  错</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**下面哪些类可以被继承**</span><br><span class=\"line\"></span><br><span class=\"line\">下面哪些类可以被继承？  ABDE</span><br><span class=\"line\">Java.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader</span><br><span class=\"line\">A、Thread    B、Number    C、Double    D、Math    E、ClassLoader</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**String 是最基本的数据类型吗?**不是</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**int和Integer有什么区别?** 原始类型和封装类型，java5后自动拆箱和封箱机制</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**5、请写出下面程序的运行结果：**</span><br></pre></td></tr></table></figure></p>\n<p>class AutoUnboxingTest {<br>    public static void main(String[] args) {<br>        Integer a = new Integer(3);<br>        Integer b = 3; // 将3自动装箱成Integer类型<br>        int c = 3;<br>        System.out.println(a == b); // false 两个引用没有引用同一对象<br>        System.out.println(a == c); // true a自动拆箱成int类型再和c比较<br>        System.out.println(b == c); // true b自动装箱然后自动拆箱成int类型再和c比较</p>\n<pre><code>}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 2.2 String、StringBuilder、StringBuffer</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.2.1 String</span><br><span class=\"line\"></span><br><span class=\"line\">字符串常量，不可更改，因为其内部定义的是一个final类型的数组来保存值的，如下：</span><br></pre></td></tr></table></figure></p>\n<p>private final char value[];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">所以，当我们每次去“更改”String变量的值的时候（包括重新赋值或者使用String内部的一些方法），其实是重新新建了一个String对象（new String）来保存新的值，然后让我们的变量指向新的对象。因此，当我们需要频繁改变字符串的时候，使用String会带来较大的开销。</span><br><span class=\"line\"></span><br><span class=\"line\">定义String的方法有两种：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）String str = &quot;abc&quot;;</span><br><span class=\"line\">（2）String str2 = new String(&quot;def&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">第一种方式创建的String对象“abc”是存放在字符串常量池中，创建过程是，首先在字符串常量池中查找有没有&quot;abc&quot;对象，如果有则将str直接指向它，如果没有就在字符串常量池中创建出来“abc”，然后在将str指向它。当有另一个String变量被赋值为abc时，直接将字符串常量池中的地址给它。如下：</span><br></pre></td></tr></table></figure></p>\n<p>String a = “abc”;<br>String b = “abc”;<br>System.out.println(a == b);    //打印 true<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">也就是说通过第一种方式创建的字符串在字符串常量池中，是可共享的。同时，也是不可更改的，体现在：</span><br></pre></td></tr></table></figure></p>\n<p>String a = “abc”;<br>String b = “abc”;<br>b = b + “def”;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">此时，字符串常量池中存在了两个对象“abc”和“abcdef”。</span><br><span class=\"line\"></span><br><span class=\"line\">第二种创建方式其实分为两步：</span><br></pre></td></tr></table></figure></p>\n<p>String s = “def”;<br>String str2 = new String(s);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">第一步就是上面的第一种情况；第二步在堆内存中new出一个String对象，将str2指向该堆内存地址，新new出的String对象内容，是在字符串常量池中找到的或创建出“def”对象，相当于此时存在两份“def”对象拷贝，一份存在字符串常量池中，一份被堆内存的String对象私有化管理着。所以使用String str2 = new String(&quot;def&quot;);这种方式创建对象，实际上创建了两个对象。</span><br><span class=\"line\"></span><br><span class=\"line\">###2.2.2 StringBuffer(JDK 1.0) 和StringBuilder(JDK1.5)</span><br><span class=\"line\"></span><br><span class=\"line\">StringBuffer和StringBuilder在功能上基本完全相同，它们都继承自AbstractStringBuilder，使用方法也都一样;可以对StringBuffer和StringBuilder对象进行改变，每次改变还是再原来的对象上发生的，不会重新new出新的StringBuffer或StringBuilder对象来。所以，当我们需要频繁修改字符串内容的时候，使用StringBuffer和StringBuilder是很好地选择。</span><br><span class=\"line\"></span><br><span class=\"line\">StringBuffer和StringBuilder的最主要区别就是线程安全方面，由于在StringBuffer内大部分方法都添加了synchronized同步，所以StringBuffer是线程安全的，而StringBuilder不是线程安全的。因此，当我们处于多线程的环境下时，我们需要使用StringBuffer，如果我们的程序是线程安全的使用StringBuilder在性能上就会更优一点。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">历年面试题：</span><br><span class=\"line\"></span><br><span class=\"line\">**String与StringBuffer的区别：**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 2.3 关键字</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.3.1 switch</span><br><span class=\"line\"></span><br><span class=\"line\">**1、switch中的参数类型**</span><br><span class=\"line\"></span><br><span class=\"line\">在jdk1.7 之前switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。</span><br><span class=\"line\">在jdk1.7 及1.7以后，switch也支持了String类型，如下：</span><br></pre></td></tr></table></figure></p>\n<p>String str = “abc”;<br>switch (str) {<br>case “abc”:<br>    System.out.println(“—–abc—–”);<br>    break;<br>case “aaa”:<br>    System.out.println(“—–aaa—–”);<br>    break;<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">枚举类型</span><br></pre></td></tr></table></figure></p>\n<p>enum ColorEnum {<br>    RED,<br>    GREEN,<br>    BLUE<br>}</p>\n<p>public static void main(String[] args) {<br>    ColorEnum color = ColorEnum.BLUE;<br>    switch (color) {<br>        case RED:<br>            System.out.println(“红色”);<br>            break;<br>        case GREEN:<br>            System.out.println(“绿色”);<br>            break;<br>        case BLUE:<br>            System.out.println(“蓝色”);<br>            break;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**历年试题：**</span><br><span class=\"line\"></span><br><span class=\"line\">**swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 2.3.2 break,continue,goto</span><br><span class=\"line\"></span><br><span class=\"line\">break的作用是跳出当前循环块（for、while、do while）或程序块（switch）。在循环块中的作用是跳出当前正在循环的循环体。在程序块中的作用是中断和下一个case条件的比较。</span><br><span class=\"line\"> </span><br><span class=\"line\">continue用于结束循环体中其后语句的执行，并跳回循环程序块的开头执行下一次循环，而不是离开循环体。</span><br><span class=\"line\"></span><br><span class=\"line\">goto:goto是java中的保留字，现在没有在java中使用。 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**break,continue与标签**</span><br><span class=\"line\"></span><br><span class=\"line\">“标签”是后面跟一个冒号的标识符，就象下面这样：```label1:</span><br></pre></td></tr></table></figure></p>\n<p>对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方——在<br>标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另<br>一个循环或者一个开关。这是由于 break 和 continue 关键字通常只中断当前循环，但若随同标签使用，它们<br>就会中断到存在标签的地方。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label1:</span><br><span class=\"line\">外部循环&#123;</span><br><span class=\"line\">  内部循环 &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    break; //1</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    continue; //2</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    continue label1; //3</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    break label1; //4</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在条件 1 中，break 中断内部循环，并在外部循环结束。</p>\n<p>在条件 2 中，continue 移回内部循环的起始处。</p>\n<p>在条件 3 中，continue label1 却同时中断内部循环以及外部循环，并移至 label1 处。随后，它实际是继续<br>循环，但却从外部循环开始。</p>\n<p>在条件 4 中，break label1 也会中断所有循环，并回到 label1 处，但并不重<br>新进入循环。也就是说，它实际是完全中止了两个循环。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    outerCycle:</span><br><span class=\"line\">    for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">        for(int j = 0; j &lt; 10; j++)&#123;</span><br><span class=\"line\">            if(j == 5)&#123;</span><br><span class=\"line\">                continue outerCycle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;) &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给外层循起始处加了标签（也就是说给外层循环起了个名字）“outerCycle”，在内层循环使用“continue outerCycle”时，就相当于在outerCycle这个循环中直接使用continue语句。</p>\n<p>(0,0) (0,1) (0,2) (0,3) (0,4) (1,0) (1,1) (1,2) (1,3) (1,4) (2,0) (2,1) (2,2) (2,3) (2,4) (3,0) (3,1) (3,2) (3,3) (3,4) (4,0) (4,1) (4,2) (4,3) (4,4) (5,0) (5,1) (5,2) (5,3) (5,4) (6,0) (6,1) (6,2) (6,3) (6,4) (7,0) (7,1) (7,2) (7,3) (7,4) (8,0) (8,1) (8,2) (8,3) (8,4) (9,0) (9,1) (9,2) (9,3) (9,4)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    outerCycle:</span><br><span class=\"line\">    for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">        for(int j = 0; j &lt; 10; j++)&#123;</span><br><span class=\"line\">            if(j == 5)&#123;</span><br><span class=\"line\">                break outerCycle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;) &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<p>(0,0) (0,1) (0,2) (0,3) (0,4)</p>\n<p><strong>历年试题：</strong></p>\n<p>请写出下面程序的运行结果 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    int i = 0;</span><br><span class=\"line\">    outer:</span><br><span class=\"line\">    // 第一个标签</span><br><span class=\"line\">    for (; true; ) &#123;</span><br><span class=\"line\">        inner:</span><br><span class=\"line\">        //第二个标签</span><br><span class=\"line\">        for (; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            prt(&quot;i = &quot; + i);</span><br><span class=\"line\">            if (i == 2) &#123;</span><br><span class=\"line\">                prt(&quot;continue&quot;);</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i == 3) &#123;</span><br><span class=\"line\">                prt(&quot;break&quot;);</span><br><span class=\"line\">                i++; // 注意</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i == 7) &#123;</span><br><span class=\"line\">                prt(&quot;continue outer&quot;);</span><br><span class=\"line\">                i++; //注意</span><br><span class=\"line\">                continue outer;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i == 8) &#123;</span><br><span class=\"line\">                prt(&quot;break outer&quot;);</span><br><span class=\"line\">                break outer;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for (int k = 0; k &lt; 5; k++) &#123;</span><br><span class=\"line\">                if (k == 3) &#123;</span><br><span class=\"line\">                    prt(&quot;continue inner&quot;);</span><br><span class=\"line\">                    continue inner;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">static void prt(String s) &#123;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是输出结果：<br>i = 0<br>continue inner<br>i = 1<br>continue inner<br>i = 2<br>continue<br>i = 3<br>break<br>i = 4<br>continue inner<br>i = 5<br>continue inner<br>i = 6<br>continue inner<br>i = 7<br>continue outer<br>i = 8<br>break outer</p>\n<p><strong>需要匹配后通过break关键字跳出程序块，不然继续向下执行</strong></p>\n<p>下面的方法，当输入为2的时候返回值是多少?（）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int getValue(int i) &#123;</span><br><span class=\"line\">    int result = 0;</span><br><span class=\"line\">    switch (i) &#123;</span><br><span class=\"line\">    case 1:</span><br><span class=\"line\">        result = result + i;</span><br><span class=\"line\">    case 2:</span><br><span class=\"line\">        result = result + i * 2;</span><br><span class=\"line\">    case 3:</span><br><span class=\"line\">        result = result + i * 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A0                    B2                    C4                     D10</p>\n<p><strong>break语句的描述中，正确的是( )</strong></p>\n<p>A、只中断最内层的循环 </p>\n<p>B、只中断最外层的循环 </p>\n<p>C、借助于标号，可以实现任何外层循环中断</p>\n<p>D、只中断某一层的循环</p>\n<p>##2.4 值传递和引用传递</p>\n<p>首先要说明的是java中是没有指针的，java中只存在值传递，只存在值传递！！！  然而我们经常看到对于对象（数组，类，接口）的传递似乎有点像引用传递，可以改变对象中某个属性的值。但是不要被这个假象所蒙蔽，实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以还是按值传递。</p>\n<p>需要注意的是当传递的是数组名或对象实例的话，其实传递的都是地址拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test3 &#123;</span><br><span class=\"line\">    public static void change(int a)&#123;</span><br><span class=\"line\">        a=50;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a=10;</span><br><span class=\"line\">        System.out.println(a);  //10</span><br><span class=\"line\">        change(a);</span><br><span class=\"line\">        System.out.println(a);  //10</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test3 &#123;</span><br><span class=\"line\">    public static void change(int []a)&#123;</span><br><span class=\"line\">        a[0]=50;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int []a=&#123;10,20&#125;;</span><br><span class=\"line\">        System.out.println(a[0]);  //10</span><br><span class=\"line\">        change(a);</span><br><span class=\"line\">        System.out.println(a[0]);  //50</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Emp &#123;</span><br><span class=\"line\">    public int age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void change(Emp emp)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        emp.age = 50;</span><br><span class=\"line\">        emp = new Emp();//再创建一个对象</span><br><span class=\"line\">        emp.age=1000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Emp emp = new Emp();</span><br><span class=\"line\">        emp.age = 100;</span><br><span class=\"line\">        System.out.println(emp.age);  //100</span><br><span class=\"line\">        change(emp);</span><br><span class=\"line\">        System.out.println(emp.age);  //50</span><br><span class=\"line\">        System.out.println(emp.age);  //50</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>历史考题</strong></p>\n<p>指出下列程序运行的结果 （）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Example &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String str = new String(&quot;good&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    char[] ch = &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String args[]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Example ex = new Example();</span><br><span class=\"line\"></span><br><span class=\"line\">        ex.change(ex.str, ex.ch);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.print(ex.str + &quot; and &quot;);  //good and gbc</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.print(ex.ch);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void change(String str, char ch[]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        str = &quot;test ok&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ch[0] = &apos;g&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A、 good and abc</p>\n<p>B、 good and gbc</p>\n<p>C、 test ok and abc</p>\n<p>D、 test ok and gbc </p>\n<p>##2.5 数组</p>\n<p><strong>声明数组的两种方式：</strong></p>\n<p>int a[];<br>int []a;</p>\n<p>通过上边的定义，我们只是得到了一个数组的引用。这时已经为引用分配了存储空间，但是还没有给数组对象本身分配任何空间。想要给数组对象分配存储空间，必须使用初始化表达式。</p>\n<p><strong>初始化数组的方式：</strong></p>\n<p>int a[] = new int[8]; //分配空间，赋值默认值<br>int a[] = {0,1,2,3};<br>int a[] = new int[]{0,1,2,3};</p>\n<p><strong>默认初始化</strong></p>\n<p>如果我们利用int a[] = new int[6]，为数组元素分配了空间，但没有初始化，Java会为他们分配默认值。如下表所示：</p>\n<p>基本类型    默认值<br>boolean false<br>char       ‘/u0000’(null)<br>byte       (byte)0<br>short      (short)0<br>int         0<br>long       0L<br>float      0.0f<br>double     0.0d</p>\n<p><strong>7.下面哪些语句能够正确地生成5个空字符串？</strong></p>\n<p>A.String   a[]=new   String[5]；for(int   i=0;i&lt;5;a[i++]=””);     </p>\n<p>B.String   a[]={“”，””，””，””，””}；     </p>\n<p>C.String   a[5]；     </p>\n<p>D.String[5] a；     </p>\n<p>E.String   []a=new   String[5];for(int   i=0;i&lt;5;a[i++]=null);</p>\n<p><strong>5.下面哪个语句正确地声明一个整型的二维数组？ </strong></p>\n<p>A. int   a[][] =   new   int[][]；     </p>\n<p>B. int   a[10][10]   =   new   int[][]；     </p>\n<p>C. int   a[][]   =   new   int[10][10]；     </p>\n<p>D. int   [][]a   =   new   int[10][10]；     </p>\n<p>E. int   []a[]   =   new   int[10][10]；</p>\n<p><strong>27.哪个语句创建了一个数组实例？ </strong></p>\n<p>A. int[] ia = new int [15]; </p>\n<p>B. float fa = new float [20]; </p>\n<p>C. char[] ca = “Some String”; </p>\n<p>D. int ia [][] = {4, 5, 6} {1, 2, 3};</p>\n<p><strong>数组有没有length()这个方法? String有没有length()这个方法？</strong><br>没有，有</p>\n<p><strong>请问下面程序在初始化后，a[0]和b[0]的值是多少？</strong></p>\n<p>String []a = new String[10];  //null<br>int []b = new int[10];  //0</p>\n<p><strong>下面程序的运行结果是：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int index=1; </span><br><span class=\"line\">int foo[]=new int[3]; </span><br><span class=\"line\">int bar=foo[index]; </span><br><span class=\"line\">int baz=bar+index;</span><br></pre></td></tr></table></figure>\n<p>A. baz has a value of 0<br>B. baz has value of 1<br>C. baz has value of 2<br>D. an exception is thrown<br>E. the code will not compile </p>\n<p><strong>下面代码的运行结果为：（）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.*;</span><br><span class=\"line\">public class foo&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main (String[] args)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String s;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;s=&quot; + s);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A 代码得到编译，并输出“s=”</p>\n<p>B 代码得到编译，并输出“s=null”</p>\n<p>C 由于String s没有初始化，代码不能编译通过</p>\n<p>D 代码得到编译，但捕获到 NullPointException异常</p>\n<p>##2.6  构造函数相关</p>\n<p><strong>1、如果一个类中没有写任何的构造方法，JVM会生成一个默认的无参构造方法。</strong></p>\n<p><strong>2、如果一个基类中写了有参构造函数，没有定义无参构造函数，基类是不会默认生成无参构造函数的。而且子类的构造函数中，如果没有显示通过super.调用基类构造函数，那么默认是调用父类的无参构造方法（即默认为super()，一般这句话省略了）。</strong></p>\n<p>下面哪三个描述是正确的？  B、C、E</p>\n<p>A. 默认构造器初始化方法变量</p>\n<p>B. 默认构造器有和它所在类相同的访问修饰词.</p>\n<p>C. 默认构造器调用其父类的无参构造器.</p>\n<p>D. 如果一个类没有无参构造器,编译器会它创建一个默认构造器.</p>\n<p>E. 只有当一个类没有任何构造器时，编译器会为它创建一个默认构造器</p>\n<p>以下子类B的情形哪一个是可以通过编译的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class A &#123;  </span><br><span class=\"line\">    public A(String s)&#123;  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class B extends A &#123;   </span><br><span class=\"line\">    String name = &quot;llyB&quot;;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">public class B extends A &#123;    </span><br><span class=\"line\">    String name = &quot;llyB&quot;;  </span><br><span class=\"line\">    public B(String s)&#123;&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">public class B extends A &#123;    </span><br><span class=\"line\">    String name = &quot;llyB&quot;;  </span><br><span class=\"line\">    public B(String s)&#123;  </span><br><span class=\"line\">        super(s);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;   能</span><br></pre></td></tr></table></figure>\n<p>所以，只要记住，在子类的构造方法中，只要里面没有显示的通过super去调用父类相应的构造方法，默认都是调用super()，即无参构造方法，因此要确保父类有相应的构造方法。</p>\n<p><strong>3、Java创建对象的几种方式：</strong></p>\n<p>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p>\n<p>(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。</p>\n<p>历年考题：不通过构造函数也能创建对象吗（A）</p>\n<p>A 是     B 否</p>\n<p>下列说法正确的有（c）</p>\n<p>A． class中的constructor不可省略</p>\n<p>B． constructor必须与class同名，但方法不能与class同名</p>\n<p>C． constructor在一个对象被new时执行</p>\n<p>D．一个class只能定义一个constructor</p>\n<p><strong>4、构造函数调用顺序</strong></p>\n<p>在Java中，子类的构造过程中必须调用其父类的构造函数，是因为有继承关系存在时，子类要把父类的内容继承下来。但如果父类有多个构造函数时，该如何选择调用呢？</p>\n<p>第一个规则：子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，那么编译器会帮我们加上一个默认的构造方法（就是没有参数的构造方法），但是如果你自己写了构造方法，那么编译器就不会给你添加了，所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是如果在子类构造方法中我们并没有显示的调用基类的构造方法，如：super();  这样就会调用父类没有参数的构造方法。    </p>\n<p>第二个规则：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数，此时无参的构造函数就不会被调用。</p>\n<p>总之，一句话：子类没有显示调用父类构造函数，不管子类构造函数是否带参数都默认调用父类无参的构造函数，若父类没有则编译出错。</p>\n<p>历年考题：下面是People和Child类的定义和构造方法，每个构造方法都输出编号。在执行new Child(“mike”)的时候都有哪些构造方法被顺序调用？请选择输出结果 ( )</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class People &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public People() &#123;</span><br><span class=\"line\">        System.out.print(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public People(String name) &#123;</span><br><span class=\"line\">        System.out.print(2);</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Child extends People &#123;</span><br><span class=\"line\">    People father;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Child(String name) &#123;</span><br><span class=\"line\">        System.out.print(3);</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        father = new People(name + &quot;:F&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Child() &#123;</span><br><span class=\"line\">        System.out.print(4);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A312              B 32               C 432              D 132</p>\n<p><strong>5、override与Overloading</strong></p>\n<p>Override（重写）:<br>    在子类中定义与父类具有完全相同的名称和参数的方法，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，是子类与父类之间多态性的一种体现。特点如下：<br>  （1）子类方法的访问权限只能比父类的更大，不能更小（可以相同）；<br>  （2）如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法；</p>\n<p>Overload（重载）:<br>  同一个类中可以有多个名称相同的方法，但方法的参数个数和参数类型或者参数顺序不同；<br>    关于重载函数返回类型能否不一样，需分情况：<br>（1）如果几个Overloaded的方法的参数列表不一样（个数或类型），它们的返回者类型当然也可以不一样；<br>（2）两个方法的参数列表完全一样，则不能通过让其返回类型的不同来实现重载。<br>（3）不同的参数顺序也是可以实现重载的；<br>（4）构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载。  </p>\n<h3 id=\"2-7-静态代码块执行顺序\"><a href=\"#2-7-静态代码块执行顺序\" class=\"headerlink\" title=\"2.7 静态代码块执行顺序\"></a>2.7 静态代码块执行顺序</h3><p>执行顺序：1.静态代码块 –&gt; 2.普通代码块 –&gt; 3.构造方法</p>\n<p>需要明白的是，1是类级别的，2和3是实例级别的，所以在父子类关系中，上述的执行顺序为：</p>\n<p>父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法；</p>\n<p>也就是上到下（父类到子类）先走完 类级别的（静态的）–&gt; 再依次走完父类的所有实例级别代码 –&gt; 再走子类所有实例级别代码</p>\n<p>历史题目：</p>\n<p>如下代码的输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HelloB extends HelloA &#123;</span><br><span class=\"line\">     public HelloB() &#123;</span><br><span class=\"line\">         System.out.println(&quot;-----------HelloB 构造方法------------&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         System.out.println(&quot;I’m B class&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     static&#123;</span><br><span class=\"line\">         System.out.println(&quot;static B&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     public static void main(String[] args)&#123;</span><br><span class=\"line\">         new HelloB();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class HelloA&#123;</span><br><span class=\"line\">     public HelloA()&#123;</span><br><span class=\"line\">         System.out.println(&quot;-----------HelloA 构造方法------------&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         System.out.println(&quot;I’m A class&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     static&#123;</span><br><span class=\"line\">         System.out.println(&quot;static A&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br>static A<br>static B<br>I’m A class<br>———–HelloA 构造方法————<br>I’m B class<br>———–HelloB 构造方法————</p>\n<p><strong>下面程序的运行结果是什么（）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class HelloA &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public HelloA() &#123;</span><br><span class=\"line\">        System.out.println(&quot;HelloA&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123; System.out.println(&quot;I&apos;m A class&quot;); &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    static &#123; System.out.println(&quot;static A&quot;); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class HelloB extends HelloA &#123;</span><br><span class=\"line\">    public HelloB() &#123;</span><br><span class=\"line\">        System.out.println(&quot;HelloB&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123; System.out.println(&quot;I&apos;m B class&quot;); &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    static &#123; System.out.println(&quot;static B&quot;); &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static void main(String[] args) &#123; </span><br><span class=\"line\">　　　　 new HelloB(); </span><br><span class=\"line\">　　 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static A</span><br><span class=\"line\">static B</span><br><span class=\"line\">I&apos;m A class</span><br><span class=\"line\">HelloA</span><br><span class=\"line\">I&apos;m B class</span><br><span class=\"line\">HelloB</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-8-面向对象\"><a href=\"#2-8-面向对象\" class=\"headerlink\" title=\"2.8 面向对象\"></a>2.8 面向对象</h3><p>1、Java面向对象的基本思想之一是封装细节并且公开接口。Java语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为四种级别：</p>\n<p>（1）public： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；</p>\n<p>（2）protected： 用protected修饰的类、类属变量及方法，包内的任何类及包外那些继承了该类的子类才能访问（此处稍后解释），protected重点突出继承；</p>\n<p>（3）default： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。default重点突出包；</p>\n<p>（4）private： 用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。　</p>\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>当前类</th>\n<th>同 包</th>\n<th>子 类</th>\n<th>其他包</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>default</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>private</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n<p>2、final修饰的类不能被继承，没有子类。</p>\n<p>3、abstract修饰的类不能被实例化，必须被子类继承。类只要有一个抽象方法就必定是抽象类，但抽象类不一定要有抽象方法。声明方式必须是：<figure class=\"highlight plain\"><figcaption><span>void C();``` 不能带我实现体大括号。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">历史题目：</span><br><span class=\"line\"></span><br><span class=\"line\">**1、如下代码：**</span><br></pre></td></tr></table></figure></p>\n<p>class A {</p>\n<p>A() { }</p>\n<p>}</p>\n<p>class B extends A {</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">哪两个说明是正确的？   </span><br><span class=\"line\"></span><br><span class=\"line\">A. B类的构造器应该是 public.</span><br><span class=\"line\"></span><br><span class=\"line\">B. B类的构造器应该是没有参数</span><br><span class=\"line\"></span><br><span class=\"line\">C. B类的构造器应该调用this().</span><br><span class=\"line\"></span><br><span class=\"line\">D. B类的构造器应该调用super().</span><br><span class=\"line\"></span><br><span class=\"line\">**是否可以继承String类?**</span><br><span class=\"line\"></span><br><span class=\"line\">String类是final类故不可以继承。</span><br><span class=\"line\"></span><br><span class=\"line\">**以public修饰的类如：public class Car&#123;…&#125; 则Car( )  **</span><br><span class=\"line\"></span><br><span class=\"line\">A、可被其它程序包中的类使用 B、仅能被本程序包中的类使用</span><br><span class=\"line\"></span><br><span class=\"line\">C、不能被任意其它类使用 D、不能被其它类继承</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.9 equals与==的区别</span><br><span class=\"line\"></span><br><span class=\"line\">**（1）==是一个运算符，它比较的是值**</span><br><span class=\"line\">    </span><br><span class=\"line\">对于基本数据类型，直接比较其数据值是否相等。如果是不同的基本数据类型之间进行比较，则遵循基本数据类型间运算的转换原则。如下：</span><br><span class=\"line\">  </span><br><span class=\"line\">```        </span><br><span class=\"line\">if(12 == 12.0)&#123;  </span><br><span class=\"line\">    System.out.println(&quot;-----12 == 12.0-------&quot;);  </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">此时打印了-----12 == 12.0-------，因为低一级的int类型的12自动转换为高一级的float类型</span><br><span class=\"line\"></span><br><span class=\"line\">对于引用类型，==比较的还是值，只不过此时比较的是两个对象变量的内存地址。所以，用==来比较对象，实际上是判断这两个对象是否是同一个new出来的对象，或者是否是一个对象赋值给另一个对象的情况。如：</span><br></pre></td></tr></table></figure></p>\n<p>String s1 = new String(“abc”);<br>String s2 = s1;//将s1对的内存地址赋给了s2，此时s1==s2返回true；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**（2）equals**</span><br><span class=\"line\"></span><br><span class=\"line\">equals方法是属于Object类的一个方法，其实现源码如下：</span><br></pre></td></tr></table></figure></p>\n<p>public boolean equals(Object obj) {<br>    return (this == obj);<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">可以看到，其实equals方法里面用的还是==运算符，所以对于那些没有重写过Object类的equals方法来说，==和equals方法是等价的！</span><br><span class=\"line\"></span><br><span class=\"line\">然而，很多类都自己去重写了equals方法，比如String类、所有基本数据类型的包装类等</span><br><span class=\"line\">String类的equals源码如下：</span><br></pre></td></tr></table></figure></p>\n<p>public boolean equals(Object anObject) {<br>    if (this == anObject) {<br>        return true;<br>    }<br>    if (anObject instanceof String) {<br>        String anotherString = (String) anObject;<br>        int n = value.length;<br>        if (n == anotherString.value.length) {<br>            char v1[] = value;<br>            char v2[] = anotherString.value;<br>            int i = 0;<br>            while (n– != 0) {<br>                if (v1[i] != v2[i])<br>                        return false;<br>                i++;<br>            }<br>            return true;<br>        }<br>    }<br>    return false;<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">首先判断是否是同一个new出来的对象，即判断内存地址是否相同；如果不同则判断对象中的内容是否相同。</span><br><span class=\"line\"></span><br><span class=\"line\">Integer类的equals方法如下：</span><br><span class=\"line\"></span><br><span class=\"line\">```   </span><br><span class=\"line\">public boolean equals(Object obj) &#123;  </span><br><span class=\"line\">    if (obj instanceof Integer) &#123;  </span><br><span class=\"line\">        return value == ((Integer)obj).intValue();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>直接转成判断值是否相等了。</p>\n<p>因此，对于String类和所有基本数据类型的包装类来说，equals方法就是判断其内容是否相等。对于其他类来说，要具体看其是否重写了equals方法及具体业务实现。</p>\n<p>另：对于基本数据类型来说，使用equals方法，需要用该基本类型对应的包装类，因为equals是针对对象来使用的！</p>\n<p><strong>下面程序的运行结果是（）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = &quot;hello&quot;;</span><br><span class=\"line\">String str2 = &quot;he&quot; + new String(&quot;llo&quot;);</span><br><span class=\"line\">System.err.println(str1 == str2);</span><br></pre></td></tr></table></figure>\n<p>##其它基础</p>\n<p><strong>&amp;和&amp;&amp;的区别</strong></p>\n<p>&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。</p>\n<p><strong>下面的语句会产生什么样的输出? </strong></p>\n<p>System.out.println(4&amp;7);</p>\n<p>A.4</p>\n<p>B.5</p>\n<p>C.6</p>\n<p>D.7</p>\n<p>E.0</p>\n<p><strong>5、try、catch、finally执行顺序问题</strong></p>\n<p><strong>14. 如下代码：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Foo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">return;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println( &quot;Finally&quot; );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果是什么?   A</p>\n<p>A. Finally</p>\n<p>B.编译失败</p>\n<p>C. 代码正常运行但没有任何输出.</p>\n<p>D. 运行时抛出异常</p>\n<p>下面函数将返回？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">publicstaticintfunc ()&#123;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;catch(Exception e)&#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;finally&#123;</span><br><span class=\"line\">        return 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A、1    B、2    C、3     D、编译错误</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h4><p>基本数据类型分为原始类型和包装类型，Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型(wrapper class)，int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>\n<table>\n<thead>\n<tr>\n<th>8种原始类型</th>\n<th>容量</th>\n<th>对应包装类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte(字节)</td>\n<td>8 位</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>shot(短整型)</td>\n<td>16位</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>int(整型)</td>\n<td>32 位</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long(长整型)</td>\n<td>64 位</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float(浮点型)</td>\n<td>32 位</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double(双精度)</td>\n<td>64 位</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>char(字符型)</td>\n<td>16 位</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>boolean(布尔型)</td>\n<td>1 位</td>\n<td>Boolean</td>\n</tr>\n</tbody>\n</table>\n<p>注意几点：</p>\n<p><strong>1、各数据类型按容量大小（表数范围大小）由小到大排列为：</strong></p>\n<p>byte &lt;—— short, char  &lt;——int &lt;——long &lt;——float &lt;——double</p>\n<p><strong>2、基本类型之间的转换原则：</strong></p>\n<p>1）运算时，容量小的类型自动转换为容量大的类型；</p>\n<p>2）容量大的类型转换为容量小的类型时，要加强制转换符，且精度可能丢失；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如：float f = 1.2f;</span><br><span class=\"line\">int ff = (int) f;</span><br><span class=\"line\">System.out.println(ff);  1</span><br><span class=\"line\">```            </span><br><span class=\"line\"></span><br><span class=\"line\">3）short，char之间不会互相转换（需要强制转换），byte、short、char并且三者在计算时首先转换为int类型；</span><br><span class=\"line\"></span><br><span class=\"line\">4）实数常量默认为double类型， 整数常量默认为int类型；</span><br><span class=\"line\"></span><br><span class=\"line\">**3、包装类及String类都是定定义为public final class的，因此这几个都不能被继承；　　**</span><br><span class=\"line\"></span><br><span class=\"line\">**4、原始类型是可以通过==直接判断是否相等的，而包装类型是类，通过==判断值是否相等是不对的，必须通过equals()函数**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**下面的程序中，temp的最终值是什么？  **</span><br></pre></td></tr></table></figure>\n<p>long temp=(int)3.9;   3</p>\n<p>temp%=2;   1<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">A .0</span><br><span class=\"line\"></span><br><span class=\"line\">B .1</span><br><span class=\"line\"></span><br><span class=\"line\">C .2</span><br><span class=\"line\"></span><br><span class=\"line\">D .3</span><br><span class=\"line\"></span><br><span class=\"line\">E .4</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**short s1 = 1; s1 = s1 + 1;有什么错（错误）? short s1 = 1; s1 += 1;有什么错（正确）?**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**下面哪个不是JAVA关键字 **</span><br><span class=\"line\"></span><br><span class=\"line\">A  integer</span><br><span class=\"line\"></span><br><span class=\"line\">B  double</span><br><span class=\"line\"></span><br><span class=\"line\">C  float</span><br><span class=\"line\"></span><br><span class=\"line\">D  default</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">###2.1.2 历年考题</span><br><span class=\"line\"></span><br><span class=\"line\">**下面哪些不是java的简单数据类型?** AC</span><br><span class=\"line\"></span><br><span class=\"line\">A. short  B. Boolean  C. Double  D. float</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**0.6332的数据类型是（）**  A</span><br><span class=\"line\"></span><br><span class=\"line\">A float     B double     C Float      D Double</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**float f=3.4;是否正确?**  错</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**下面哪些类可以被继承**</span><br><span class=\"line\"></span><br><span class=\"line\">下面哪些类可以被继承？  ABDE</span><br><span class=\"line\">Java.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader</span><br><span class=\"line\">A、Thread    B、Number    C、Double    D、Math    E、ClassLoader</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**String 是最基本的数据类型吗?**不是</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**int和Integer有什么区别?** 原始类型和封装类型，java5后自动拆箱和封箱机制</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**5、请写出下面程序的运行结果：**</span><br></pre></td></tr></table></figure></p>\n<p>class AutoUnboxingTest {<br>    public static void main(String[] args) {<br>        Integer a = new Integer(3);<br>        Integer b = 3; // 将3自动装箱成Integer类型<br>        int c = 3;<br>        System.out.println(a == b); // false 两个引用没有引用同一对象<br>        System.out.println(a == c); // true a自动拆箱成int类型再和c比较<br>        System.out.println(b == c); // true b自动装箱然后自动拆箱成int类型再和c比较</p>\n<pre><code>}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 2.2 String、StringBuilder、StringBuffer</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.2.1 String</span><br><span class=\"line\"></span><br><span class=\"line\">字符串常量，不可更改，因为其内部定义的是一个final类型的数组来保存值的，如下：</span><br></pre></td></tr></table></figure></p>\n<p>private final char value[];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">所以，当我们每次去“更改”String变量的值的时候（包括重新赋值或者使用String内部的一些方法），其实是重新新建了一个String对象（new String）来保存新的值，然后让我们的变量指向新的对象。因此，当我们需要频繁改变字符串的时候，使用String会带来较大的开销。</span><br><span class=\"line\"></span><br><span class=\"line\">定义String的方法有两种：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）String str = &quot;abc&quot;;</span><br><span class=\"line\">（2）String str2 = new String(&quot;def&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">第一种方式创建的String对象“abc”是存放在字符串常量池中，创建过程是，首先在字符串常量池中查找有没有&quot;abc&quot;对象，如果有则将str直接指向它，如果没有就在字符串常量池中创建出来“abc”，然后在将str指向它。当有另一个String变量被赋值为abc时，直接将字符串常量池中的地址给它。如下：</span><br></pre></td></tr></table></figure></p>\n<p>String a = “abc”;<br>String b = “abc”;<br>System.out.println(a == b);    //打印 true<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">也就是说通过第一种方式创建的字符串在字符串常量池中，是可共享的。同时，也是不可更改的，体现在：</span><br></pre></td></tr></table></figure></p>\n<p>String a = “abc”;<br>String b = “abc”;<br>b = b + “def”;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">此时，字符串常量池中存在了两个对象“abc”和“abcdef”。</span><br><span class=\"line\"></span><br><span class=\"line\">第二种创建方式其实分为两步：</span><br></pre></td></tr></table></figure></p>\n<p>String s = “def”;<br>String str2 = new String(s);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">第一步就是上面的第一种情况；第二步在堆内存中new出一个String对象，将str2指向该堆内存地址，新new出的String对象内容，是在字符串常量池中找到的或创建出“def”对象，相当于此时存在两份“def”对象拷贝，一份存在字符串常量池中，一份被堆内存的String对象私有化管理着。所以使用String str2 = new String(&quot;def&quot;);这种方式创建对象，实际上创建了两个对象。</span><br><span class=\"line\"></span><br><span class=\"line\">###2.2.2 StringBuffer(JDK 1.0) 和StringBuilder(JDK1.5)</span><br><span class=\"line\"></span><br><span class=\"line\">StringBuffer和StringBuilder在功能上基本完全相同，它们都继承自AbstractStringBuilder，使用方法也都一样;可以对StringBuffer和StringBuilder对象进行改变，每次改变还是再原来的对象上发生的，不会重新new出新的StringBuffer或StringBuilder对象来。所以，当我们需要频繁修改字符串内容的时候，使用StringBuffer和StringBuilder是很好地选择。</span><br><span class=\"line\"></span><br><span class=\"line\">StringBuffer和StringBuilder的最主要区别就是线程安全方面，由于在StringBuffer内大部分方法都添加了synchronized同步，所以StringBuffer是线程安全的，而StringBuilder不是线程安全的。因此，当我们处于多线程的环境下时，我们需要使用StringBuffer，如果我们的程序是线程安全的使用StringBuilder在性能上就会更优一点。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">历年面试题：</span><br><span class=\"line\"></span><br><span class=\"line\">**String与StringBuffer的区别：**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 2.3 关键字</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.3.1 switch</span><br><span class=\"line\"></span><br><span class=\"line\">**1、switch中的参数类型**</span><br><span class=\"line\"></span><br><span class=\"line\">在jdk1.7 之前switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。</span><br><span class=\"line\">在jdk1.7 及1.7以后，switch也支持了String类型，如下：</span><br></pre></td></tr></table></figure></p>\n<p>String str = “abc”;<br>switch (str) {<br>case “abc”:<br>    System.out.println(“—–abc—–”);<br>    break;<br>case “aaa”:<br>    System.out.println(“—–aaa—–”);<br>    break;<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">枚举类型</span><br></pre></td></tr></table></figure></p>\n<p>enum ColorEnum {<br>    RED,<br>    GREEN,<br>    BLUE<br>}</p>\n<p>public static void main(String[] args) {<br>    ColorEnum color = ColorEnum.BLUE;<br>    switch (color) {<br>        case RED:<br>            System.out.println(“红色”);<br>            break;<br>        case GREEN:<br>            System.out.println(“绿色”);<br>            break;<br>        case BLUE:<br>            System.out.println(“蓝色”);<br>            break;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**历年试题：**</span><br><span class=\"line\"></span><br><span class=\"line\">**swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 2.3.2 break,continue,goto</span><br><span class=\"line\"></span><br><span class=\"line\">break的作用是跳出当前循环块（for、while、do while）或程序块（switch）。在循环块中的作用是跳出当前正在循环的循环体。在程序块中的作用是中断和下一个case条件的比较。</span><br><span class=\"line\"> </span><br><span class=\"line\">continue用于结束循环体中其后语句的执行，并跳回循环程序块的开头执行下一次循环，而不是离开循环体。</span><br><span class=\"line\"></span><br><span class=\"line\">goto:goto是java中的保留字，现在没有在java中使用。 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**break,continue与标签**</span><br><span class=\"line\"></span><br><span class=\"line\">“标签”是后面跟一个冒号的标识符，就象下面这样：```label1:</span><br></pre></td></tr></table></figure></p>\n<p>对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方——在<br>标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另<br>一个循环或者一个开关。这是由于 break 和 continue 关键字通常只中断当前循环，但若随同标签使用，它们<br>就会中断到存在标签的地方。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label1:</span><br><span class=\"line\">外部循环&#123;</span><br><span class=\"line\">  内部循环 &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    break; //1</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    continue; //2</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    continue label1; //3</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    break label1; //4</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在条件 1 中，break 中断内部循环，并在外部循环结束。</p>\n<p>在条件 2 中，continue 移回内部循环的起始处。</p>\n<p>在条件 3 中，continue label1 却同时中断内部循环以及外部循环，并移至 label1 处。随后，它实际是继续<br>循环，但却从外部循环开始。</p>\n<p>在条件 4 中，break label1 也会中断所有循环，并回到 label1 处，但并不重<br>新进入循环。也就是说，它实际是完全中止了两个循环。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    outerCycle:</span><br><span class=\"line\">    for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">        for(int j = 0; j &lt; 10; j++)&#123;</span><br><span class=\"line\">            if(j == 5)&#123;</span><br><span class=\"line\">                continue outerCycle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;) &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给外层循起始处加了标签（也就是说给外层循环起了个名字）“outerCycle”，在内层循环使用“continue outerCycle”时，就相当于在outerCycle这个循环中直接使用continue语句。</p>\n<p>(0,0) (0,1) (0,2) (0,3) (0,4) (1,0) (1,1) (1,2) (1,3) (1,4) (2,0) (2,1) (2,2) (2,3) (2,4) (3,0) (3,1) (3,2) (3,3) (3,4) (4,0) (4,1) (4,2) (4,3) (4,4) (5,0) (5,1) (5,2) (5,3) (5,4) (6,0) (6,1) (6,2) (6,3) (6,4) (7,0) (7,1) (7,2) (7,3) (7,4) (8,0) (8,1) (8,2) (8,3) (8,4) (9,0) (9,1) (9,2) (9,3) (9,4)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    outerCycle:</span><br><span class=\"line\">    for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">        for(int j = 0; j &lt; 10; j++)&#123;</span><br><span class=\"line\">            if(j == 5)&#123;</span><br><span class=\"line\">                break outerCycle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;) &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<p>(0,0) (0,1) (0,2) (0,3) (0,4)</p>\n<p><strong>历年试题：</strong></p>\n<p>请写出下面程序的运行结果 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    int i = 0;</span><br><span class=\"line\">    outer:</span><br><span class=\"line\">    // 第一个标签</span><br><span class=\"line\">    for (; true; ) &#123;</span><br><span class=\"line\">        inner:</span><br><span class=\"line\">        //第二个标签</span><br><span class=\"line\">        for (; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            prt(&quot;i = &quot; + i);</span><br><span class=\"line\">            if (i == 2) &#123;</span><br><span class=\"line\">                prt(&quot;continue&quot;);</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i == 3) &#123;</span><br><span class=\"line\">                prt(&quot;break&quot;);</span><br><span class=\"line\">                i++; // 注意</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i == 7) &#123;</span><br><span class=\"line\">                prt(&quot;continue outer&quot;);</span><br><span class=\"line\">                i++; //注意</span><br><span class=\"line\">                continue outer;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i == 8) &#123;</span><br><span class=\"line\">                prt(&quot;break outer&quot;);</span><br><span class=\"line\">                break outer;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for (int k = 0; k &lt; 5; k++) &#123;</span><br><span class=\"line\">                if (k == 3) &#123;</span><br><span class=\"line\">                    prt(&quot;continue inner&quot;);</span><br><span class=\"line\">                    continue inner;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">static void prt(String s) &#123;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是输出结果：<br>i = 0<br>continue inner<br>i = 1<br>continue inner<br>i = 2<br>continue<br>i = 3<br>break<br>i = 4<br>continue inner<br>i = 5<br>continue inner<br>i = 6<br>continue inner<br>i = 7<br>continue outer<br>i = 8<br>break outer</p>\n<p><strong>需要匹配后通过break关键字跳出程序块，不然继续向下执行</strong></p>\n<p>下面的方法，当输入为2的时候返回值是多少?（）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int getValue(int i) &#123;</span><br><span class=\"line\">    int result = 0;</span><br><span class=\"line\">    switch (i) &#123;</span><br><span class=\"line\">    case 1:</span><br><span class=\"line\">        result = result + i;</span><br><span class=\"line\">    case 2:</span><br><span class=\"line\">        result = result + i * 2;</span><br><span class=\"line\">    case 3:</span><br><span class=\"line\">        result = result + i * 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A0                    B2                    C4                     D10</p>\n<p><strong>break语句的描述中，正确的是( )</strong></p>\n<p>A、只中断最内层的循环 </p>\n<p>B、只中断最外层的循环 </p>\n<p>C、借助于标号，可以实现任何外层循环中断</p>\n<p>D、只中断某一层的循环</p>\n<p>##2.4 值传递和引用传递</p>\n<p>首先要说明的是java中是没有指针的，java中只存在值传递，只存在值传递！！！  然而我们经常看到对于对象（数组，类，接口）的传递似乎有点像引用传递，可以改变对象中某个属性的值。但是不要被这个假象所蒙蔽，实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以还是按值传递。</p>\n<p>需要注意的是当传递的是数组名或对象实例的话，其实传递的都是地址拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test3 &#123;</span><br><span class=\"line\">    public static void change(int a)&#123;</span><br><span class=\"line\">        a=50;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a=10;</span><br><span class=\"line\">        System.out.println(a);  //10</span><br><span class=\"line\">        change(a);</span><br><span class=\"line\">        System.out.println(a);  //10</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test3 &#123;</span><br><span class=\"line\">    public static void change(int []a)&#123;</span><br><span class=\"line\">        a[0]=50;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int []a=&#123;10,20&#125;;</span><br><span class=\"line\">        System.out.println(a[0]);  //10</span><br><span class=\"line\">        change(a);</span><br><span class=\"line\">        System.out.println(a[0]);  //50</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Emp &#123;</span><br><span class=\"line\">    public int age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void change(Emp emp)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        emp.age = 50;</span><br><span class=\"line\">        emp = new Emp();//再创建一个对象</span><br><span class=\"line\">        emp.age=1000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Emp emp = new Emp();</span><br><span class=\"line\">        emp.age = 100;</span><br><span class=\"line\">        System.out.println(emp.age);  //100</span><br><span class=\"line\">        change(emp);</span><br><span class=\"line\">        System.out.println(emp.age);  //50</span><br><span class=\"line\">        System.out.println(emp.age);  //50</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>历史考题</strong></p>\n<p>指出下列程序运行的结果 （）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Example &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String str = new String(&quot;good&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    char[] ch = &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String args[]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Example ex = new Example();</span><br><span class=\"line\"></span><br><span class=\"line\">        ex.change(ex.str, ex.ch);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.print(ex.str + &quot; and &quot;);  //good and gbc</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.print(ex.ch);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void change(String str, char ch[]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        str = &quot;test ok&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ch[0] = &apos;g&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A、 good and abc</p>\n<p>B、 good and gbc</p>\n<p>C、 test ok and abc</p>\n<p>D、 test ok and gbc </p>\n<p>##2.5 数组</p>\n<p><strong>声明数组的两种方式：</strong></p>\n<p>int a[];<br>int []a;</p>\n<p>通过上边的定义，我们只是得到了一个数组的引用。这时已经为引用分配了存储空间，但是还没有给数组对象本身分配任何空间。想要给数组对象分配存储空间，必须使用初始化表达式。</p>\n<p><strong>初始化数组的方式：</strong></p>\n<p>int a[] = new int[8]; //分配空间，赋值默认值<br>int a[] = {0,1,2,3};<br>int a[] = new int[]{0,1,2,3};</p>\n<p><strong>默认初始化</strong></p>\n<p>如果我们利用int a[] = new int[6]，为数组元素分配了空间，但没有初始化，Java会为他们分配默认值。如下表所示：</p>\n<p>基本类型    默认值<br>boolean false<br>char       ‘/u0000’(null)<br>byte       (byte)0<br>short      (short)0<br>int         0<br>long       0L<br>float      0.0f<br>double     0.0d</p>\n<p><strong>7.下面哪些语句能够正确地生成5个空字符串？</strong></p>\n<p>A.String   a[]=new   String[5]；for(int   i=0;i&lt;5;a[i++]=””);     </p>\n<p>B.String   a[]={“”，””，””，””，””}；     </p>\n<p>C.String   a[5]；     </p>\n<p>D.String[5] a；     </p>\n<p>E.String   []a=new   String[5];for(int   i=0;i&lt;5;a[i++]=null);</p>\n<p><strong>5.下面哪个语句正确地声明一个整型的二维数组？ </strong></p>\n<p>A. int   a[][] =   new   int[][]；     </p>\n<p>B. int   a[10][10]   =   new   int[][]；     </p>\n<p>C. int   a[][]   =   new   int[10][10]；     </p>\n<p>D. int   [][]a   =   new   int[10][10]；     </p>\n<p>E. int   []a[]   =   new   int[10][10]；</p>\n<p><strong>27.哪个语句创建了一个数组实例？ </strong></p>\n<p>A. int[] ia = new int [15]; </p>\n<p>B. float fa = new float [20]; </p>\n<p>C. char[] ca = “Some String”; </p>\n<p>D. int ia [][] = {4, 5, 6} {1, 2, 3};</p>\n<p><strong>数组有没有length()这个方法? String有没有length()这个方法？</strong><br>没有，有</p>\n<p><strong>请问下面程序在初始化后，a[0]和b[0]的值是多少？</strong></p>\n<p>String []a = new String[10];  //null<br>int []b = new int[10];  //0</p>\n<p><strong>下面程序的运行结果是：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int index=1; </span><br><span class=\"line\">int foo[]=new int[3]; </span><br><span class=\"line\">int bar=foo[index]; </span><br><span class=\"line\">int baz=bar+index;</span><br></pre></td></tr></table></figure>\n<p>A. baz has a value of 0<br>B. baz has value of 1<br>C. baz has value of 2<br>D. an exception is thrown<br>E. the code will not compile </p>\n<p><strong>下面代码的运行结果为：（）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.*;</span><br><span class=\"line\">public class foo&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main (String[] args)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String s;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;s=&quot; + s);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A 代码得到编译，并输出“s=”</p>\n<p>B 代码得到编译，并输出“s=null”</p>\n<p>C 由于String s没有初始化，代码不能编译通过</p>\n<p>D 代码得到编译，但捕获到 NullPointException异常</p>\n<p>##2.6  构造函数相关</p>\n<p><strong>1、如果一个类中没有写任何的构造方法，JVM会生成一个默认的无参构造方法。</strong></p>\n<p><strong>2、如果一个基类中写了有参构造函数，没有定义无参构造函数，基类是不会默认生成无参构造函数的。而且子类的构造函数中，如果没有显示通过super.调用基类构造函数，那么默认是调用父类的无参构造方法（即默认为super()，一般这句话省略了）。</strong></p>\n<p>下面哪三个描述是正确的？  B、C、E</p>\n<p>A. 默认构造器初始化方法变量</p>\n<p>B. 默认构造器有和它所在类相同的访问修饰词.</p>\n<p>C. 默认构造器调用其父类的无参构造器.</p>\n<p>D. 如果一个类没有无参构造器,编译器会它创建一个默认构造器.</p>\n<p>E. 只有当一个类没有任何构造器时，编译器会为它创建一个默认构造器</p>\n<p>以下子类B的情形哪一个是可以通过编译的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class A &#123;  </span><br><span class=\"line\">    public A(String s)&#123;  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class B extends A &#123;   </span><br><span class=\"line\">    String name = &quot;llyB&quot;;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">public class B extends A &#123;    </span><br><span class=\"line\">    String name = &quot;llyB&quot;;  </span><br><span class=\"line\">    public B(String s)&#123;&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">public class B extends A &#123;    </span><br><span class=\"line\">    String name = &quot;llyB&quot;;  </span><br><span class=\"line\">    public B(String s)&#123;  </span><br><span class=\"line\">        super(s);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;   能</span><br></pre></td></tr></table></figure>\n<p>所以，只要记住，在子类的构造方法中，只要里面没有显示的通过super去调用父类相应的构造方法，默认都是调用super()，即无参构造方法，因此要确保父类有相应的构造方法。</p>\n<p><strong>3、Java创建对象的几种方式：</strong></p>\n<p>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p>\n<p>(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。</p>\n<p>历年考题：不通过构造函数也能创建对象吗（A）</p>\n<p>A 是     B 否</p>\n<p>下列说法正确的有（c）</p>\n<p>A． class中的constructor不可省略</p>\n<p>B． constructor必须与class同名，但方法不能与class同名</p>\n<p>C． constructor在一个对象被new时执行</p>\n<p>D．一个class只能定义一个constructor</p>\n<p><strong>4、构造函数调用顺序</strong></p>\n<p>在Java中，子类的构造过程中必须调用其父类的构造函数，是因为有继承关系存在时，子类要把父类的内容继承下来。但如果父类有多个构造函数时，该如何选择调用呢？</p>\n<p>第一个规则：子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，那么编译器会帮我们加上一个默认的构造方法（就是没有参数的构造方法），但是如果你自己写了构造方法，那么编译器就不会给你添加了，所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是如果在子类构造方法中我们并没有显示的调用基类的构造方法，如：super();  这样就会调用父类没有参数的构造方法。    </p>\n<p>第二个规则：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数，此时无参的构造函数就不会被调用。</p>\n<p>总之，一句话：子类没有显示调用父类构造函数，不管子类构造函数是否带参数都默认调用父类无参的构造函数，若父类没有则编译出错。</p>\n<p>历年考题：下面是People和Child类的定义和构造方法，每个构造方法都输出编号。在执行new Child(“mike”)的时候都有哪些构造方法被顺序调用？请选择输出结果 ( )</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class People &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public People() &#123;</span><br><span class=\"line\">        System.out.print(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public People(String name) &#123;</span><br><span class=\"line\">        System.out.print(2);</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Child extends People &#123;</span><br><span class=\"line\">    People father;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Child(String name) &#123;</span><br><span class=\"line\">        System.out.print(3);</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        father = new People(name + &quot;:F&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Child() &#123;</span><br><span class=\"line\">        System.out.print(4);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A312              B 32               C 432              D 132</p>\n<p><strong>5、override与Overloading</strong></p>\n<p>Override（重写）:<br>    在子类中定义与父类具有完全相同的名称和参数的方法，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，是子类与父类之间多态性的一种体现。特点如下：<br>  （1）子类方法的访问权限只能比父类的更大，不能更小（可以相同）；<br>  （2）如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法；</p>\n<p>Overload（重载）:<br>  同一个类中可以有多个名称相同的方法，但方法的参数个数和参数类型或者参数顺序不同；<br>    关于重载函数返回类型能否不一样，需分情况：<br>（1）如果几个Overloaded的方法的参数列表不一样（个数或类型），它们的返回者类型当然也可以不一样；<br>（2）两个方法的参数列表完全一样，则不能通过让其返回类型的不同来实现重载。<br>（3）不同的参数顺序也是可以实现重载的；<br>（4）构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载。  </p>\n<h3 id=\"2-7-静态代码块执行顺序\"><a href=\"#2-7-静态代码块执行顺序\" class=\"headerlink\" title=\"2.7 静态代码块执行顺序\"></a>2.7 静态代码块执行顺序</h3><p>执行顺序：1.静态代码块 –&gt; 2.普通代码块 –&gt; 3.构造方法</p>\n<p>需要明白的是，1是类级别的，2和3是实例级别的，所以在父子类关系中，上述的执行顺序为：</p>\n<p>父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法；</p>\n<p>也就是上到下（父类到子类）先走完 类级别的（静态的）–&gt; 再依次走完父类的所有实例级别代码 –&gt; 再走子类所有实例级别代码</p>\n<p>历史题目：</p>\n<p>如下代码的输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HelloB extends HelloA &#123;</span><br><span class=\"line\">     public HelloB() &#123;</span><br><span class=\"line\">         System.out.println(&quot;-----------HelloB 构造方法------------&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         System.out.println(&quot;I’m B class&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     static&#123;</span><br><span class=\"line\">         System.out.println(&quot;static B&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     public static void main(String[] args)&#123;</span><br><span class=\"line\">         new HelloB();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class HelloA&#123;</span><br><span class=\"line\">     public HelloA()&#123;</span><br><span class=\"line\">         System.out.println(&quot;-----------HelloA 构造方法------------&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         System.out.println(&quot;I’m A class&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     static&#123;</span><br><span class=\"line\">         System.out.println(&quot;static A&quot;);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br>static A<br>static B<br>I’m A class<br>———–HelloA 构造方法————<br>I’m B class<br>———–HelloB 构造方法————</p>\n<p><strong>下面程序的运行结果是什么（）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class HelloA &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public HelloA() &#123;</span><br><span class=\"line\">        System.out.println(&quot;HelloA&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123; System.out.println(&quot;I&apos;m A class&quot;); &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    static &#123; System.out.println(&quot;static A&quot;); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class HelloB extends HelloA &#123;</span><br><span class=\"line\">    public HelloB() &#123;</span><br><span class=\"line\">        System.out.println(&quot;HelloB&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123; System.out.println(&quot;I&apos;m B class&quot;); &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    static &#123; System.out.println(&quot;static B&quot;); &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static void main(String[] args) &#123; </span><br><span class=\"line\">　　　　 new HelloB(); </span><br><span class=\"line\">　　 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static A</span><br><span class=\"line\">static B</span><br><span class=\"line\">I&apos;m A class</span><br><span class=\"line\">HelloA</span><br><span class=\"line\">I&apos;m B class</span><br><span class=\"line\">HelloB</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-8-面向对象\"><a href=\"#2-8-面向对象\" class=\"headerlink\" title=\"2.8 面向对象\"></a>2.8 面向对象</h3><p>1、Java面向对象的基本思想之一是封装细节并且公开接口。Java语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为四种级别：</p>\n<p>（1）public： 用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；</p>\n<p>（2）protected： 用protected修饰的类、类属变量及方法，包内的任何类及包外那些继承了该类的子类才能访问（此处稍后解释），protected重点突出继承；</p>\n<p>（3）default： 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。default重点突出包；</p>\n<p>（4）private： 用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。　</p>\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>当前类</th>\n<th>同 包</th>\n<th>子 类</th>\n<th>其他包</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>default</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>private</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n<p>2、final修饰的类不能被继承，没有子类。</p>\n<p>3、abstract修饰的类不能被实例化，必须被子类继承。类只要有一个抽象方法就必定是抽象类，但抽象类不一定要有抽象方法。声明方式必须是：<figure class=\"highlight plain\"><figcaption><span>void C();``` 不能带我实现体大括号。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">历史题目：</span><br><span class=\"line\"></span><br><span class=\"line\">**1、如下代码：**</span><br></pre></td></tr></table></figure></p>\n<p>class A {</p>\n<p>A() { }</p>\n<p>}</p>\n<p>class B extends A {</p>\n<p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">哪两个说明是正确的？   </span><br><span class=\"line\"></span><br><span class=\"line\">A. B类的构造器应该是 public.</span><br><span class=\"line\"></span><br><span class=\"line\">B. B类的构造器应该是没有参数</span><br><span class=\"line\"></span><br><span class=\"line\">C. B类的构造器应该调用this().</span><br><span class=\"line\"></span><br><span class=\"line\">D. B类的构造器应该调用super().</span><br><span class=\"line\"></span><br><span class=\"line\">**是否可以继承String类?**</span><br><span class=\"line\"></span><br><span class=\"line\">String类是final类故不可以继承。</span><br><span class=\"line\"></span><br><span class=\"line\">**以public修饰的类如：public class Car&#123;…&#125; 则Car( )  **</span><br><span class=\"line\"></span><br><span class=\"line\">A、可被其它程序包中的类使用 B、仅能被本程序包中的类使用</span><br><span class=\"line\"></span><br><span class=\"line\">C、不能被任意其它类使用 D、不能被其它类继承</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.9 equals与==的区别</span><br><span class=\"line\"></span><br><span class=\"line\">**（1）==是一个运算符，它比较的是值**</span><br><span class=\"line\">    </span><br><span class=\"line\">对于基本数据类型，直接比较其数据值是否相等。如果是不同的基本数据类型之间进行比较，则遵循基本数据类型间运算的转换原则。如下：</span><br><span class=\"line\">  </span><br><span class=\"line\">```        </span><br><span class=\"line\">if(12 == 12.0)&#123;  </span><br><span class=\"line\">    System.out.println(&quot;-----12 == 12.0-------&quot;);  </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">此时打印了-----12 == 12.0-------，因为低一级的int类型的12自动转换为高一级的float类型</span><br><span class=\"line\"></span><br><span class=\"line\">对于引用类型，==比较的还是值，只不过此时比较的是两个对象变量的内存地址。所以，用==来比较对象，实际上是判断这两个对象是否是同一个new出来的对象，或者是否是一个对象赋值给另一个对象的情况。如：</span><br></pre></td></tr></table></figure></p>\n<p>String s1 = new String(“abc”);<br>String s2 = s1;//将s1对的内存地址赋给了s2，此时s1==s2返回true；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**（2）equals**</span><br><span class=\"line\"></span><br><span class=\"line\">equals方法是属于Object类的一个方法，其实现源码如下：</span><br></pre></td></tr></table></figure></p>\n<p>public boolean equals(Object obj) {<br>    return (this == obj);<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">可以看到，其实equals方法里面用的还是==运算符，所以对于那些没有重写过Object类的equals方法来说，==和equals方法是等价的！</span><br><span class=\"line\"></span><br><span class=\"line\">然而，很多类都自己去重写了equals方法，比如String类、所有基本数据类型的包装类等</span><br><span class=\"line\">String类的equals源码如下：</span><br></pre></td></tr></table></figure></p>\n<p>public boolean equals(Object anObject) {<br>    if (this == anObject) {<br>        return true;<br>    }<br>    if (anObject instanceof String) {<br>        String anotherString = (String) anObject;<br>        int n = value.length;<br>        if (n == anotherString.value.length) {<br>            char v1[] = value;<br>            char v2[] = anotherString.value;<br>            int i = 0;<br>            while (n– != 0) {<br>                if (v1[i] != v2[i])<br>                        return false;<br>                i++;<br>            }<br>            return true;<br>        }<br>    }<br>    return false;<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">首先判断是否是同一个new出来的对象，即判断内存地址是否相同；如果不同则判断对象中的内容是否相同。</span><br><span class=\"line\"></span><br><span class=\"line\">Integer类的equals方法如下：</span><br><span class=\"line\"></span><br><span class=\"line\">```   </span><br><span class=\"line\">public boolean equals(Object obj) &#123;  </span><br><span class=\"line\">    if (obj instanceof Integer) &#123;  </span><br><span class=\"line\">        return value == ((Integer)obj).intValue();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>直接转成判断值是否相等了。</p>\n<p>因此，对于String类和所有基本数据类型的包装类来说，equals方法就是判断其内容是否相等。对于其他类来说，要具体看其是否重写了equals方法及具体业务实现。</p>\n<p>另：对于基本数据类型来说，使用equals方法，需要用该基本类型对应的包装类，因为equals是针对对象来使用的！</p>\n<p><strong>下面程序的运行结果是（）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = &quot;hello&quot;;</span><br><span class=\"line\">String str2 = &quot;he&quot; + new String(&quot;llo&quot;);</span><br><span class=\"line\">System.err.println(str1 == str2);</span><br></pre></td></tr></table></figure>\n<p>##其它基础</p>\n<p><strong>&amp;和&amp;&amp;的区别</strong></p>\n<p>&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。</p>\n<p><strong>下面的语句会产生什么样的输出? </strong></p>\n<p>System.out.println(4&amp;7);</p>\n<p>A.4</p>\n<p>B.5</p>\n<p>C.6</p>\n<p>D.7</p>\n<p>E.0</p>\n<p><strong>5、try、catch、finally执行顺序问题</strong></p>\n<p><strong>14. 如下代码：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Foo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">return;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println( &quot;Finally&quot; );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果是什么?   A</p>\n<p>A. Finally</p>\n<p>B.编译失败</p>\n<p>C. 代码正常运行但没有任何输出.</p>\n<p>D. 运行时抛出异常</p>\n<p>下面函数将返回？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">publicstaticintfunc ()&#123;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;catch(Exception e)&#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;finally&#123;</span><br><span class=\"line\">        return 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A、1    B、2    C、3     D、编译错误</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj9r3xeo300029xs6aduxckf8","category_id":"cj9r3xeo900069xs6u21d8mrk","_id":"cj9r3xeog000g9xs6z3a6t9pl"},{"post_id":"cj9r3xeo800059xs6nbojpzed","category_id":"cj9r3xeod000c9xs6sugo21kk","_id":"cj9r3xeoj000m9xs6a7airs48"},{"post_id":"cj9r3xeo900079xs67kp0a51m","category_id":"cj9r3xeoh000i9xs6828xma6d","_id":"cj9r3xeom000s9xs6z6n5hbie"},{"post_id":"cj9r3xeoj000o9xs6lwz2j771","category_id":"cj9r3xeo900069xs6u21d8mrk","_id":"cj9r3xeoq000y9xs66g6ptwzh"},{"post_id":"cj9r3xeoa00089xs6hz9khy9z","category_id":"cj9r3xeoj000n9xs609hdj92y","_id":"cj9r3xeos00129xs64ihwaif8"},{"post_id":"cj9r3xeog000f9xs6ewy2zkmu","category_id":"cj9r3xeom000u9xs6daepi72o","_id":"cj9r3xeow00179xs6p0mpkfjb"},{"post_id":"cj9r3xeok000r9xs6fjpvjyul","category_id":"cj9r3xeos00139xs6fnb79chp","_id":"cj9r3xeoz001c9xs6tglvvqxg"},{"post_id":"cj9r3xeox00199xs6e7q0943m","category_id":"cj9r3xeos00139xs6fnb79chp","_id":"cj9r3xep1001h9xs66esdd1z7"},{"post_id":"cj9r3xeoy001b9xs6ygyiozzd","category_id":"cj9r3xeo900069xs6u21d8mrk","_id":"cj9r3xep1001j9xs6kj8s0nly"},{"post_id":"cj9r3xeot00149xs6fh1czcxm","category_id":"cj9r3xeox00189xs60eqyeqrj","_id":"cj9r3xep1001k9xs6q0zq7z6b"}],"PostTag":[{"post_id":"cj9r3xeny00009xs62f8gqp5v","tag_id":"cj9r3xeo600049xs6xc5k5edh","_id":"cj9r3xeoc000a9xs6kd9g6ygt"},{"post_id":"cj9r3xeo300029xs6aduxckf8","tag_id":"cj9r3xeob00099xs6htjeq9ia","_id":"cj9r3xeog000h9xs6myza7pd6"},{"post_id":"cj9r3xeoi000l9xs6wo66pwbf","tag_id":"cj9r3xeo600049xs6xc5k5edh","_id":"cj9r3xeok000p9xs619n0abi5"},{"post_id":"cj9r3xeo800059xs6nbojpzed","tag_id":"cj9r3xeof000e9xs6c37fvvvf","_id":"cj9r3xeom000t9xs6efdmjo07"},{"post_id":"cj9r3xeo800059xs6nbojpzed","tag_id":"cj9r3xeoi000k9xs6zerwovb1","_id":"cj9r3xeoo000w9xs6ur6h1gfj"},{"post_id":"cj9r3xeo900079xs67kp0a51m","tag_id":"cj9r3xeok000q9xs6o7rlzlxp","_id":"cj9r3xeor00109xs6saf0zuxj"},{"post_id":"cj9r3xeoa00089xs6hz9khy9z","tag_id":"cj9r3xeoq000z9xs6uo3elisc","_id":"cj9r3xeoz001d9xs64q5hxulj"},{"post_id":"cj9r3xeoa00089xs6hz9khy9z","tag_id":"cj9r3xeov00159xs6jlke26ej","_id":"cj9r3xep0001f9xs6x1tcshpu"},{"post_id":"cj9r3xeog000f9xs6ewy2zkmu","tag_id":"cj9r3xeoy001a9xs6iaczk0qg","_id":"cj9r3xep1001i9xs6gvf4h14r"},{"post_id":"cj9r3xeoj000o9xs6lwz2j771","tag_id":"cj9r3xep1001g9xs6kllbe6sd","_id":"cj9r3xep2001m9xs6ivmvqpv4"},{"post_id":"cj9r3xeok000r9xs6fjpvjyul","tag_id":"cj9r3xep1001l9xs6snw3bjid","_id":"cj9r3xep2001o9xs6q1wnl6qw"},{"post_id":"cj9r3xeop000x9xs686nnd0dn","tag_id":"cj9r3xep2001n9xs64wai8ry7","_id":"cj9r3xep3001q9xs6nkbtgqna"},{"post_id":"cj9r3xeot00149xs6fh1czcxm","tag_id":"cj9r3xep3001p9xs6s7gxr6bl","_id":"cj9r3xep7001s9xs6al9abvyy"},{"post_id":"cj9r3xeox00199xs6e7q0943m","tag_id":"cj9r3xep1001l9xs6snw3bjid","_id":"cj9r3xep8001u9xs61p0vtayf"},{"post_id":"cj9r3xeoy001b9xs6ygyiozzd","tag_id":"cj9r3xep1001g9xs6kllbe6sd","_id":"cj9r3xepa001v9xs6ihylry93"}],"Tag":[{"name":"Java基础","_id":"cj9r3xeo600049xs6xc5k5edh"},{"name":"包名修改","_id":"cj9r3xeob00099xs6htjeq9ia"},{"name":"Netty","_id":"cj9r3xeof000e9xs6c37fvvvf"},{"name":"JAVA","_id":"cj9r3xeoi000k9xs6zerwovb1"},{"name":"模式、Android","_id":"cj9r3xeok000q9xs6o7rlzlxp"},{"name":"Subline","_id":"cj9r3xeoq000z9xs6uo3elisc"},{"name":"Markdown","_id":"cj9r3xeov00159xs6jlke26ej"},{"name":"git","_id":"cj9r3xeoy001a9xs6iaczk0qg"},{"name":"Android","_id":"cj9r3xep1001g9xs6kllbe6sd"},{"name":"算法基础","_id":"cj9r3xep1001l9xs6snw3bjid"},{"name":"数据结构","_id":"cj9r3xep2001n9xs64wai8ry7"},{"name":"安全、Android","_id":"cj9r3xep3001p9xs6s7gxr6bl"}]}}